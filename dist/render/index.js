import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toCommandProperties = exports.toCommandValue = undefined;
  function toCommandValue(input) {
    if (input === null || input === undefined) {
      return "";
    } else if (typeof input === "string" || input instanceof String) {
      return input;
    }
    return JSON.stringify(input);
  }
  exports.toCommandValue = toCommandValue;
  function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
      return {};
    }
    return {
      title: annotationProperties.title,
      file: annotationProperties.file,
      line: annotationProperties.startLine,
      endLine: annotationProperties.endLine,
      col: annotationProperties.startColumn,
      endColumn: annotationProperties.endColumn
    };
  }
  exports.toCommandProperties = toCommandProperties;
});

// node_modules/@actions/core/lib/command.js
var require_command = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.issue = exports.issueCommand = undefined;
  var os = __importStar(__require("os"));
  var utils_1 = require_utils();
  function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
  }
  exports.issueCommand = issueCommand;
  function issue(name, message = "") {
    issueCommand(name, {}, message);
  }
  exports.issue = issue;
  var CMD_STRING = "::";

  class Command {
    constructor(command, properties, message) {
      if (!command) {
        command = "missing.command";
      }
      this.command = command;
      this.properties = properties;
      this.message = message;
    }
    toString() {
      let cmdStr = CMD_STRING + this.command;
      if (this.properties && Object.keys(this.properties).length > 0) {
        cmdStr += " ";
        let first = true;
        for (const key in this.properties) {
          if (this.properties.hasOwnProperty(key)) {
            const val = this.properties[key];
            if (val) {
              if (first) {
                first = false;
              } else {
                cmdStr += ",";
              }
              cmdStr += `${key}=${escapeProperty(val)}`;
            }
          }
        }
      }
      cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
      return cmdStr;
    }
  }
  function escapeData(s) {
    return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
  }
  function escapeProperty(s) {
    return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
  }
});

// node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.prepareKeyValueMessage = exports.issueFileCommand = undefined;
  var crypto = __importStar(__require("crypto"));
  var fs = __importStar(__require("fs"));
  var os = __importStar(__require("os"));
  var utils_1 = require_utils();
  function issueFileCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
      throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
      throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os.EOL}`, {
      encoding: "utf8"
    });
  }
  exports.issueFileCommand = issueFileCommand;
  function prepareKeyValueMessage(key, value) {
    const delimiter = `ghadelimiter_${crypto.randomUUID()}`;
    const convertedValue = (0, utils_1.toCommandValue)(value);
    if (key.includes(delimiter)) {
      throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
    }
    if (convertedValue.includes(delimiter)) {
      throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
    }
    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
  }
  exports.prepareKeyValueMessage = prepareKeyValueMessage;
});

// node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkBypass = exports.getProxyUrl = undefined;
  function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === "https:";
    if (checkBypass(reqUrl)) {
      return;
    }
    const proxyVar = (() => {
      if (usingSsl) {
        return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
      } else {
        return process.env["http_proxy"] || process.env["HTTP_PROXY"];
      }
    })();
    if (proxyVar) {
      try {
        return new DecodedURL(proxyVar);
      } catch (_a) {
        if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
          return new DecodedURL(`http://${proxyVar}`);
      }
    } else {
      return;
    }
  }
  exports.getProxyUrl = getProxyUrl;
  function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
      return false;
    }
    const reqHost = reqUrl.hostname;
    if (isLoopbackAddress(reqHost)) {
      return true;
    }
    const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
    if (!noProxy) {
      return false;
    }
    let reqPort;
    if (reqUrl.port) {
      reqPort = Number(reqUrl.port);
    } else if (reqUrl.protocol === "http:") {
      reqPort = 80;
    } else if (reqUrl.protocol === "https:") {
      reqPort = 443;
    }
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === "number") {
      upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) {
      if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) {
        return true;
      }
    }
    return false;
  }
  exports.checkBypass = checkBypass;
  function isLoopbackAddress(host) {
    const hostLower = host.toLowerCase();
    return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
  }

  class DecodedURL extends URL {
    constructor(url, base) {
      super(url, base);
      this._decodedUsername = decodeURIComponent(super.username);
      this._decodedPassword = decodeURIComponent(super.password);
    }
    get username() {
      return this._decodedUsername;
    }
    get password() {
      return this._decodedPassword;
    }
  }
});

// node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS((exports) => {
  var net = __require("net");
  var tls = __require("tls");
  var http = __require("http");
  var https = __require("https");
  var events = __require("events");
  var assert = __require("assert");
  var util = __require("util");
  exports.httpOverHttp = httpOverHttp;
  exports.httpsOverHttp = httpsOverHttp;
  exports.httpOverHttps = httpOverHttps;
  exports.httpsOverHttps = httpsOverHttps;
  function httpOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    return agent;
  }
  function httpsOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function httpOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    return agent;
  }
  function httpsOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function TunnelingAgent(options) {
    var self2 = this;
    self2.options = options || {};
    self2.proxyOptions = self2.options.proxy || {};
    self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
    self2.requests = [];
    self2.sockets = [];
    self2.on("free", function onFree(socket, host, port, localAddress) {
      var options2 = toOptions(host, port, localAddress);
      for (var i = 0, len = self2.requests.length;i < len; ++i) {
        var pending = self2.requests[i];
        if (pending.host === options2.host && pending.port === options2.port) {
          self2.requests.splice(i, 1);
          pending.request.onSocket(socket);
          return;
        }
      }
      socket.destroy();
      self2.removeSocket(socket);
    });
  }
  util.inherits(TunnelingAgent, events.EventEmitter);
  TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
    var self2 = this;
    var options = mergeOptions({ request: req }, self2.options, toOptions(host, port, localAddress));
    if (self2.sockets.length >= this.maxSockets) {
      self2.requests.push(options);
      return;
    }
    self2.createSocket(options, function(socket) {
      socket.on("free", onFree);
      socket.on("close", onCloseOrRemove);
      socket.on("agentRemove", onCloseOrRemove);
      req.onSocket(socket);
      function onFree() {
        self2.emit("free", socket, options);
      }
      function onCloseOrRemove(err) {
        self2.removeSocket(socket);
        socket.removeListener("free", onFree);
        socket.removeListener("close", onCloseOrRemove);
        socket.removeListener("agentRemove", onCloseOrRemove);
      }
    });
  };
  TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
    var self2 = this;
    var placeholder = {};
    self2.sockets.push(placeholder);
    var connectOptions = mergeOptions({}, self2.proxyOptions, {
      method: "CONNECT",
      path: options.host + ":" + options.port,
      agent: false,
      headers: {
        host: options.host + ":" + options.port
      }
    });
    if (options.localAddress) {
      connectOptions.localAddress = options.localAddress;
    }
    if (connectOptions.proxyAuth) {
      connectOptions.headers = connectOptions.headers || {};
      connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
    }
    debug("making CONNECT request");
    var connectReq = self2.request(connectOptions);
    connectReq.useChunkedEncodingByDefault = false;
    connectReq.once("response", onResponse);
    connectReq.once("upgrade", onUpgrade);
    connectReq.once("connect", onConnect);
    connectReq.once("error", onError);
    connectReq.end();
    function onResponse(res) {
      res.upgrade = true;
    }
    function onUpgrade(res, socket, head) {
      process.nextTick(function() {
        onConnect(res, socket, head);
      });
    }
    function onConnect(res, socket, head) {
      connectReq.removeAllListeners();
      socket.removeAllListeners();
      if (res.statusCode !== 200) {
        debug("tunneling socket could not be established, statusCode=%d", res.statusCode);
        socket.destroy();
        var error = new Error("tunneling socket could not be established, " + "statusCode=" + res.statusCode);
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self2.removeSocket(placeholder);
        return;
      }
      if (head.length > 0) {
        debug("got illegal response body from proxy");
        socket.destroy();
        var error = new Error("got illegal response body from proxy");
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self2.removeSocket(placeholder);
        return;
      }
      debug("tunneling connection has established");
      self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
      return cb(socket);
    }
    function onError(cause) {
      connectReq.removeAllListeners();
      debug(`tunneling socket could not be established, cause=%s
`, cause.message, cause.stack);
      var error = new Error("tunneling socket could not be established, " + "cause=" + cause.message);
      error.code = "ECONNRESET";
      options.request.emit("error", error);
      self2.removeSocket(placeholder);
    }
  };
  TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
    var pos = this.sockets.indexOf(socket);
    if (pos === -1) {
      return;
    }
    this.sockets.splice(pos, 1);
    var pending = this.requests.shift();
    if (pending) {
      this.createSocket(pending, function(socket2) {
        pending.request.onSocket(socket2);
      });
    }
  };
  function createSecureSocket(options, cb) {
    var self2 = this;
    TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
      var hostHeader = options.request.getHeader("host");
      var tlsOptions = mergeOptions({}, self2.options, {
        socket,
        servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
      });
      var secureSocket = tls.connect(0, tlsOptions);
      self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
      cb(secureSocket);
    });
  }
  function toOptions(host, port, localAddress) {
    if (typeof host === "string") {
      return {
        host,
        port,
        localAddress
      };
    }
    return host;
  }
  function mergeOptions(target) {
    for (var i = 1, len = arguments.length;i < len; ++i) {
      var overrides = arguments[i];
      if (typeof overrides === "object") {
        var keys = Object.keys(overrides);
        for (var j = 0, keyLen = keys.length;j < keyLen; ++j) {
          var k = keys[j];
          if (overrides[k] !== undefined) {
            target[k] = overrides[k];
          }
        }
      }
    }
    return target;
  }
  var debug;
  if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments);
      if (typeof args[0] === "string") {
        args[0] = "TUNNEL: " + args[0];
      } else {
        args.unshift("TUNNEL:");
      }
      console.error.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports.debug = debug;
});

// node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS((exports, module) => {
  module.exports = {
    kClose: Symbol("close"),
    kDestroy: Symbol("destroy"),
    kDispatch: Symbol("dispatch"),
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kConnecting: Symbol("connecting"),
    kHeadersList: Symbol("headers list"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kServerName: Symbol("server name"),
    kLocalAddress: Symbol("local address"),
    kHost: Symbol("host"),
    kNoRef: Symbol("no ref"),
    kBodyUsed: Symbol("used"),
    kRunning: Symbol("running"),
    kBlocking: Symbol("blocking"),
    kPending: Symbol("pending"),
    kSize: Symbol("size"),
    kBusy: Symbol("busy"),
    kQueued: Symbol("queued"),
    kFree: Symbol("free"),
    kConnected: Symbol("connected"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol.for("nodejs.stream.destroyed"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClients: Symbol("clients"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelining"),
    kSocket: Symbol("socket"),
    kHostHeader: Symbol("host header"),
    kConnector: Symbol("connector"),
    kStrictContentLength: Symbol("strict content length"),
    kMaxRedirections: Symbol("maxRedirections"),
    kMaxRequests: Symbol("maxRequestsPerClient"),
    kProxy: Symbol("proxy agent options"),
    kCounter: Symbol("socket request counter"),
    kInterceptors: Symbol("dispatch interceptors"),
    kMaxResponseSize: Symbol("max response size"),
    kHTTP2Session: Symbol("http2Session"),
    kHTTP2SessionState: Symbol("http2Session state"),
    kHTTP2BuildRequest: Symbol("http2 build request"),
    kHTTP1BuildRequest: Symbol("http1 build request"),
    kHTTP2CopyHeaders: Symbol("http2 copy headers"),
    kHTTPConnVersion: Symbol("http connection version"),
    kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
    kConstruct: Symbol("constructable")
  };
});

// node_modules/undici/lib/core/errors.js
var require_errors = __commonJS((exports, module) => {
  class UndiciError extends Error {
    constructor(message) {
      super(message);
      this.name = "UndiciError";
      this.code = "UND_ERR";
    }
  }

  class ConnectTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ConnectTimeoutError);
      this.name = "ConnectTimeoutError";
      this.message = message || "Connect Timeout Error";
      this.code = "UND_ERR_CONNECT_TIMEOUT";
    }
  }

  class HeadersTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, HeadersTimeoutError);
      this.name = "HeadersTimeoutError";
      this.message = message || "Headers Timeout Error";
      this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
  }

  class HeadersOverflowError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, HeadersOverflowError);
      this.name = "HeadersOverflowError";
      this.message = message || "Headers Overflow Error";
      this.code = "UND_ERR_HEADERS_OVERFLOW";
    }
  }

  class BodyTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, BodyTimeoutError);
      this.name = "BodyTimeoutError";
      this.message = message || "Body Timeout Error";
      this.code = "UND_ERR_BODY_TIMEOUT";
    }
  }

  class ResponseStatusCodeError extends UndiciError {
    constructor(message, statusCode, headers, body) {
      super(message);
      Error.captureStackTrace(this, ResponseStatusCodeError);
      this.name = "ResponseStatusCodeError";
      this.message = message || "Response Status Code Error";
      this.code = "UND_ERR_RESPONSE_STATUS_CODE";
      this.body = body;
      this.status = statusCode;
      this.statusCode = statusCode;
      this.headers = headers;
    }
  }

  class InvalidArgumentError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidArgumentError);
      this.name = "InvalidArgumentError";
      this.message = message || "Invalid Argument Error";
      this.code = "UND_ERR_INVALID_ARG";
    }
  }

  class InvalidReturnValueError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidReturnValueError);
      this.name = "InvalidReturnValueError";
      this.message = message || "Invalid Return Value Error";
      this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
  }

  class RequestAbortedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, RequestAbortedError);
      this.name = "AbortError";
      this.message = message || "Request aborted";
      this.code = "UND_ERR_ABORTED";
    }
  }

  class InformationalError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InformationalError);
      this.name = "InformationalError";
      this.message = message || "Request information";
      this.code = "UND_ERR_INFO";
    }
  }

  class RequestContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, RequestContentLengthMismatchError);
      this.name = "RequestContentLengthMismatchError";
      this.message = message || "Request body length does not match content-length header";
      this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
    }
  }

  class ResponseContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ResponseContentLengthMismatchError);
      this.name = "ResponseContentLengthMismatchError";
      this.message = message || "Response body length does not match content-length header";
      this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
    }
  }

  class ClientDestroyedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientDestroyedError);
      this.name = "ClientDestroyedError";
      this.message = message || "The client is destroyed";
      this.code = "UND_ERR_DESTROYED";
    }
  }

  class ClientClosedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientClosedError);
      this.name = "ClientClosedError";
      this.message = message || "The client is closed";
      this.code = "UND_ERR_CLOSED";
    }
  }

  class SocketError extends UndiciError {
    constructor(message, socket) {
      super(message);
      Error.captureStackTrace(this, SocketError);
      this.name = "SocketError";
      this.message = message || "Socket error";
      this.code = "UND_ERR_SOCKET";
      this.socket = socket;
    }
  }

  class NotSupportedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, NotSupportedError);
      this.name = "NotSupportedError";
      this.message = message || "Not supported error";
      this.code = "UND_ERR_NOT_SUPPORTED";
    }
  }

  class BalancedPoolMissingUpstreamError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, NotSupportedError);
      this.name = "MissingUpstreamError";
      this.message = message || "No upstream has been added to the BalancedPool";
      this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
    }
  }

  class HTTPParserError extends Error {
    constructor(message, code, data) {
      super(message);
      Error.captureStackTrace(this, HTTPParserError);
      this.name = "HTTPParserError";
      this.code = code ? `HPE_${code}` : undefined;
      this.data = data ? data.toString() : undefined;
    }
  }

  class ResponseExceededMaxSizeError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ResponseExceededMaxSizeError);
      this.name = "ResponseExceededMaxSizeError";
      this.message = message || "Response content exceeded max size";
      this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
    }
  }

  class RequestRetryError extends UndiciError {
    constructor(message, code, { headers, data }) {
      super(message);
      Error.captureStackTrace(this, RequestRetryError);
      this.name = "RequestRetryError";
      this.message = message || "Request retry error";
      this.code = "UND_ERR_REQ_RETRY";
      this.statusCode = code;
      this.data = data;
      this.headers = headers;
    }
  }
  module.exports = {
    HTTPParserError,
    UndiciError,
    HeadersTimeoutError,
    HeadersOverflowError,
    BodyTimeoutError,
    RequestContentLengthMismatchError,
    ConnectTimeoutError,
    ResponseStatusCodeError,
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError,
    ClientDestroyedError,
    ClientClosedError,
    InformationalError,
    SocketError,
    NotSupportedError,
    ResponseContentLengthMismatchError,
    BalancedPoolMissingUpstreamError,
    ResponseExceededMaxSizeError,
    RequestRetryError
  };
});

// node_modules/undici/lib/core/constants.js
var require_constants = __commonJS((exports, module) => {
  var headerNameLowerCasedRecord = {};
  var wellknownHeaderNames = [
    "Accept",
    "Accept-Encoding",
    "Accept-Language",
    "Accept-Ranges",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Age",
    "Allow",
    "Alt-Svc",
    "Alt-Used",
    "Authorization",
    "Cache-Control",
    "Clear-Site-Data",
    "Connection",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-Length",
    "Content-Location",
    "Content-Range",
    "Content-Security-Policy",
    "Content-Security-Policy-Report-Only",
    "Content-Type",
    "Cookie",
    "Cross-Origin-Embedder-Policy",
    "Cross-Origin-Opener-Policy",
    "Cross-Origin-Resource-Policy",
    "Date",
    "Device-Memory",
    "Downlink",
    "ECT",
    "ETag",
    "Expect",
    "Expect-CT",
    "Expires",
    "Forwarded",
    "From",
    "Host",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Range",
    "If-Unmodified-Since",
    "Keep-Alive",
    "Last-Modified",
    "Link",
    "Location",
    "Max-Forwards",
    "Origin",
    "Permissions-Policy",
    "Pragma",
    "Proxy-Authenticate",
    "Proxy-Authorization",
    "RTT",
    "Range",
    "Referer",
    "Referrer-Policy",
    "Refresh",
    "Retry-After",
    "Sec-WebSocket-Accept",
    "Sec-WebSocket-Extensions",
    "Sec-WebSocket-Key",
    "Sec-WebSocket-Protocol",
    "Sec-WebSocket-Version",
    "Server",
    "Server-Timing",
    "Service-Worker-Allowed",
    "Service-Worker-Navigation-Preload",
    "Set-Cookie",
    "SourceMap",
    "Strict-Transport-Security",
    "Supports-Loading-Mode",
    "TE",
    "Timing-Allow-Origin",
    "Trailer",
    "Transfer-Encoding",
    "Upgrade",
    "Upgrade-Insecure-Requests",
    "User-Agent",
    "Vary",
    "Via",
    "WWW-Authenticate",
    "X-Content-Type-Options",
    "X-DNS-Prefetch-Control",
    "X-Frame-Options",
    "X-Permitted-Cross-Domain-Policies",
    "X-Powered-By",
    "X-Requested-With",
    "X-XSS-Protection"
  ];
  for (let i = 0;i < wellknownHeaderNames.length; ++i) {
    const key = wellknownHeaderNames[i];
    const lowerCasedKey = key.toLowerCase();
    headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
  }
  Object.setPrototypeOf(headerNameLowerCasedRecord, null);
  module.exports = {
    wellknownHeaderNames,
    headerNameLowerCasedRecord
  };
});

// node_modules/undici/lib/core/util.js
var require_util = __commonJS((exports, module) => {
  var assert = __require("assert");
  var { kDestroyed, kBodyUsed } = require_symbols();
  var { IncomingMessage } = __require("http");
  var stream = __require("stream");
  var net = __require("net");
  var { InvalidArgumentError } = require_errors();
  var { Blob: Blob2 } = __require("buffer");
  var nodeUtil = __require("util");
  var { stringify } = __require("querystring");
  var { headerNameLowerCasedRecord } = require_constants();
  var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
  function nop() {
  }
  function isStream(obj) {
    return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
  }
  function isBlobLike(object) {
    return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
  }
  function buildURL(url, queryParams) {
    if (url.includes("?") || url.includes("#")) {
      throw new Error('Query params cannot be passed when url already contains "?" or "#".');
    }
    const stringified = stringify(queryParams);
    if (stringified) {
      url += "?" + stringified;
    }
    return url;
  }
  function parseURL(url) {
    if (typeof url === "string") {
      url = new URL(url);
      if (!/^https?:/.test(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      return url;
    }
    if (!url || typeof url !== "object") {
      throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
    }
    if (!/^https?:/.test(url.origin || url.protocol)) {
      throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    }
    if (!(url instanceof URL)) {
      if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
        throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
      }
      if (url.path != null && typeof url.path !== "string") {
        throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
      }
      if (url.pathname != null && typeof url.pathname !== "string") {
        throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
      }
      if (url.hostname != null && typeof url.hostname !== "string") {
        throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
      }
      if (url.origin != null && typeof url.origin !== "string") {
        throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
      }
      const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
      let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
      let path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
      if (origin.endsWith("/")) {
        origin = origin.substring(0, origin.length - 1);
      }
      if (path && !path.startsWith("/")) {
        path = `/${path}`;
      }
      url = new URL(origin + path);
    }
    return url;
  }
  function parseOrigin(url) {
    url = parseURL(url);
    if (url.pathname !== "/" || url.search || url.hash) {
      throw new InvalidArgumentError("invalid url");
    }
    return url;
  }
  function getHostname(host) {
    if (host[0] === "[") {
      const idx2 = host.indexOf("]");
      assert(idx2 !== -1);
      return host.substring(1, idx2);
    }
    const idx = host.indexOf(":");
    if (idx === -1)
      return host;
    return host.substring(0, idx);
  }
  function getServerName(host) {
    if (!host) {
      return null;
    }
    assert.strictEqual(typeof host, "string");
    const servername = getHostname(host);
    if (net.isIP(servername)) {
      return "";
    }
    return servername;
  }
  function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  function isAsyncIterable(obj) {
    return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
  }
  function isIterable(obj) {
    return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
  }
  function bodyLength(body) {
    if (body == null) {
      return 0;
    } else if (isStream(body)) {
      const state = body._readableState;
      return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
    } else if (isBlobLike(body)) {
      return body.size != null ? body.size : null;
    } else if (isBuffer(body)) {
      return body.byteLength;
    }
    return null;
  }
  function isDestroyed(stream2) {
    return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
  }
  function isReadableAborted(stream2) {
    const state = stream2 && stream2._readableState;
    return isDestroyed(stream2) && state && !state.endEmitted;
  }
  function destroy(stream2, err) {
    if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
      return;
    }
    if (typeof stream2.destroy === "function") {
      if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
        stream2.socket = null;
      }
      stream2.destroy(err);
    } else if (err) {
      process.nextTick((stream3, err2) => {
        stream3.emit("error", err2);
      }, stream2, err);
    }
    if (stream2.destroyed !== true) {
      stream2[kDestroyed] = true;
    }
  }
  var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  function parseKeepAliveTimeout(val) {
    const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
    return m ? parseInt(m[1], 10) * 1000 : null;
  }
  function headerNameToString(value) {
    return headerNameLowerCasedRecord[value] || value.toLowerCase();
  }
  function parseHeaders(headers, obj = {}) {
    if (!Array.isArray(headers))
      return headers;
    for (let i = 0;i < headers.length; i += 2) {
      const key = headers[i].toString().toLowerCase();
      let val = obj[key];
      if (!val) {
        if (Array.isArray(headers[i + 1])) {
          obj[key] = headers[i + 1].map((x) => x.toString("utf8"));
        } else {
          obj[key] = headers[i + 1].toString("utf8");
        }
      } else {
        if (!Array.isArray(val)) {
          val = [val];
          obj[key] = val;
        }
        val.push(headers[i + 1].toString("utf8"));
      }
    }
    if ("content-length" in obj && "content-disposition" in obj) {
      obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
    }
    return obj;
  }
  function parseRawHeaders(headers) {
    const ret = [];
    let hasContentLength = false;
    let contentDispositionIdx = -1;
    for (let n = 0;n < headers.length; n += 2) {
      const key = headers[n + 0].toString();
      const val = headers[n + 1].toString("utf8");
      if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
        ret.push(key, val);
        hasContentLength = true;
      } else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
        contentDispositionIdx = ret.push(key, val) - 1;
      } else {
        ret.push(key, val);
      }
    }
    if (hasContentLength && contentDispositionIdx !== -1) {
      ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
    }
    return ret;
  }
  function isBuffer(buffer) {
    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
  }
  function validateHandler(handler, method, upgrade) {
    if (!handler || typeof handler !== "object") {
      throw new InvalidArgumentError("handler must be an object");
    }
    if (typeof handler.onConnect !== "function") {
      throw new InvalidArgumentError("invalid onConnect method");
    }
    if (typeof handler.onError !== "function") {
      throw new InvalidArgumentError("invalid onError method");
    }
    if (typeof handler.onBodySent !== "function" && handler.onBodySent !== undefined) {
      throw new InvalidArgumentError("invalid onBodySent method");
    }
    if (upgrade || method === "CONNECT") {
      if (typeof handler.onUpgrade !== "function") {
        throw new InvalidArgumentError("invalid onUpgrade method");
      }
    } else {
      if (typeof handler.onHeaders !== "function") {
        throw new InvalidArgumentError("invalid onHeaders method");
      }
      if (typeof handler.onData !== "function") {
        throw new InvalidArgumentError("invalid onData method");
      }
      if (typeof handler.onComplete !== "function") {
        throw new InvalidArgumentError("invalid onComplete method");
      }
    }
  }
  function isDisturbed(body) {
    return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
  }
  function isErrored(body) {
    return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));
  }
  function isReadable(body) {
    return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));
  }
  function getSocketInfo(socket) {
    return {
      localAddress: socket.localAddress,
      localPort: socket.localPort,
      remoteAddress: socket.remoteAddress,
      remotePort: socket.remotePort,
      remoteFamily: socket.remoteFamily,
      timeout: socket.timeout,
      bytesWritten: socket.bytesWritten,
      bytesRead: socket.bytesRead
    };
  }
  async function* convertIterableToBuffer(iterable) {
    for await (const chunk of iterable) {
      yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
    }
  }
  var ReadableStream2;
  function ReadableStreamFrom(iterable) {
    if (!ReadableStream2) {
      ReadableStream2 = __require("stream/web").ReadableStream;
    }
    if (ReadableStream2.from) {
      return ReadableStream2.from(convertIterableToBuffer(iterable));
    }
    let iterator;
    return new ReadableStream2({
      async start() {
        iterator = iterable[Symbol.asyncIterator]();
      },
      async pull(controller) {
        const { done, value } = await iterator.next();
        if (done) {
          queueMicrotask(() => {
            controller.close();
          });
        } else {
          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
          controller.enqueue(new Uint8Array(buf));
        }
        return controller.desiredSize > 0;
      },
      async cancel(reason) {
        await iterator.return();
      }
    }, 0);
  }
  function isFormDataLike(object) {
    return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
  }
  function throwIfAborted(signal) {
    if (!signal) {
      return;
    }
    if (typeof signal.throwIfAborted === "function") {
      signal.throwIfAborted();
    } else {
      if (signal.aborted) {
        const err = new Error("The operation was aborted");
        err.name = "AbortError";
        throw err;
      }
    }
  }
  function addAbortListener(signal, listener) {
    if ("addEventListener" in signal) {
      signal.addEventListener("abort", listener, { once: true });
      return () => signal.removeEventListener("abort", listener);
    }
    signal.addListener("abort", listener);
    return () => signal.removeListener("abort", listener);
  }
  var hasToWellFormed = !!String.prototype.toWellFormed;
  function toUSVString(val) {
    if (hasToWellFormed) {
      return `${val}`.toWellFormed();
    } else if (nodeUtil.toUSVString) {
      return nodeUtil.toUSVString(val);
    }
    return `${val}`;
  }
  function parseRangeHeader(range) {
    if (range == null || range === "")
      return { start: 0, end: null, size: null };
    const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
    return m ? {
      start: parseInt(m[1]),
      end: m[2] ? parseInt(m[2]) : null,
      size: m[3] ? parseInt(m[3]) : null
    } : null;
  }
  var kEnumerableProperty = Object.create(null);
  kEnumerableProperty.enumerable = true;
  module.exports = {
    kEnumerableProperty,
    nop,
    isDisturbed,
    isErrored,
    isReadable,
    toUSVString,
    isReadableAborted,
    isBlobLike,
    parseOrigin,
    parseURL,
    getServerName,
    isStream,
    isIterable,
    isAsyncIterable,
    isDestroyed,
    headerNameToString,
    parseRawHeaders,
    parseHeaders,
    parseKeepAliveTimeout,
    destroy,
    bodyLength,
    deepClone,
    ReadableStreamFrom,
    isBuffer,
    validateHandler,
    getSocketInfo,
    isFormDataLike,
    buildURL,
    throwIfAborted,
    addAbortListener,
    parseRangeHeader,
    nodeMajor,
    nodeMinor,
    nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,
    safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
  };
});

// node_modules/undici/lib/timers.js
var require_timers = __commonJS((exports, module) => {
  var fastNow = Date.now();
  var fastNowTimeout;
  var fastTimers = [];
  function onTimeout() {
    fastNow = Date.now();
    let len = fastTimers.length;
    let idx = 0;
    while (idx < len) {
      const timer = fastTimers[idx];
      if (timer.state === 0) {
        timer.state = fastNow + timer.delay;
      } else if (timer.state > 0 && fastNow >= timer.state) {
        timer.state = -1;
        timer.callback(timer.opaque);
      }
      if (timer.state === -1) {
        timer.state = -2;
        if (idx !== len - 1) {
          fastTimers[idx] = fastTimers.pop();
        } else {
          fastTimers.pop();
        }
        len -= 1;
      } else {
        idx += 1;
      }
    }
    if (fastTimers.length > 0) {
      refreshTimeout();
    }
  }
  function refreshTimeout() {
    if (fastNowTimeout && fastNowTimeout.refresh) {
      fastNowTimeout.refresh();
    } else {
      clearTimeout(fastNowTimeout);
      fastNowTimeout = setTimeout(onTimeout, 1000);
      if (fastNowTimeout.unref) {
        fastNowTimeout.unref();
      }
    }
  }

  class Timeout {
    constructor(callback, delay, opaque) {
      this.callback = callback;
      this.delay = delay;
      this.opaque = opaque;
      this.state = -2;
      this.refresh();
    }
    refresh() {
      if (this.state === -2) {
        fastTimers.push(this);
        if (!fastNowTimeout || fastTimers.length === 1) {
          refreshTimeout();
        }
      }
      this.state = 0;
    }
    clear() {
      this.state = -1;
    }
  }
  module.exports = {
    setTimeout(callback, delay, opaque) {
      return delay < 1000 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
    },
    clearTimeout(timeout) {
      if (timeout instanceof Timeout) {
        timeout.clear();
      } else {
        clearTimeout(timeout);
      }
    }
  };
});

// node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events").EventEmitter;
  var inherits = __require("node:util").inherits;
  function SBMH(needle) {
    if (typeof needle === "string") {
      needle = Buffer.from(needle);
    }
    if (!Buffer.isBuffer(needle)) {
      throw new TypeError("The needle has to be a String or a Buffer.");
    }
    const needleLength = needle.length;
    if (needleLength === 0) {
      throw new Error("The needle cannot be an empty String/Buffer.");
    }
    if (needleLength > 256) {
      throw new Error("The needle cannot have a length bigger than 256.");
    }
    this.maxMatches = Infinity;
    this.matches = 0;
    this._occ = new Array(256).fill(needleLength);
    this._lookbehind_size = 0;
    this._needle = needle;
    this._bufpos = 0;
    this._lookbehind = Buffer.alloc(needleLength);
    for (var i = 0;i < needleLength - 1; ++i) {
      this._occ[needle[i]] = needleLength - 1 - i;
    }
  }
  inherits(SBMH, EventEmitter);
  SBMH.prototype.reset = function() {
    this._lookbehind_size = 0;
    this.matches = 0;
    this._bufpos = 0;
  };
  SBMH.prototype.push = function(chunk, pos) {
    if (!Buffer.isBuffer(chunk)) {
      chunk = Buffer.from(chunk, "binary");
    }
    const chlen = chunk.length;
    this._bufpos = pos || 0;
    let r;
    while (r !== chlen && this.matches < this.maxMatches) {
      r = this._sbmh_feed(chunk);
    }
    return r;
  };
  SBMH.prototype._sbmh_feed = function(data) {
    const len = data.length;
    const needle = this._needle;
    const needleLength = needle.length;
    const lastNeedleChar = needle[needleLength - 1];
    let pos = -this._lookbehind_size;
    let ch;
    if (pos < 0) {
      while (pos < 0 && pos <= len - needleLength) {
        ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
        if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
          this._lookbehind_size = 0;
          ++this.matches;
          this.emit("info", true);
          return this._bufpos = pos + needleLength;
        }
        pos += this._occ[ch];
      }
      if (pos < 0) {
        while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
          ++pos;
        }
      }
      if (pos >= 0) {
        this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
        this._lookbehind_size = 0;
      } else {
        const bytesToCutOff = this._lookbehind_size + pos;
        if (bytesToCutOff > 0) {
          this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
        }
        this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size - bytesToCutOff);
        this._lookbehind_size -= bytesToCutOff;
        data.copy(this._lookbehind, this._lookbehind_size);
        this._lookbehind_size += len;
        this._bufpos = len;
        return len;
      }
    }
    pos += (pos >= 0) * this._bufpos;
    if (data.indexOf(needle, pos) !== -1) {
      pos = data.indexOf(needle, pos);
      ++this.matches;
      if (pos > 0) {
        this.emit("info", true, data, this._bufpos, pos);
      } else {
        this.emit("info", true);
      }
      return this._bufpos = pos + needleLength;
    } else {
      pos = len - needleLength;
    }
    while (pos < len && (data[pos] !== needle[0] || Buffer.compare(data.subarray(pos, pos + len - pos), needle.subarray(0, len - pos)) !== 0)) {
      ++pos;
    }
    if (pos < len) {
      data.copy(this._lookbehind, 0, pos, pos + (len - pos));
      this._lookbehind_size = len - pos;
    }
    if (pos > 0) {
      this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
    }
    this._bufpos = len;
    return len;
  };
  SBMH.prototype._sbmh_lookup_char = function(data, pos) {
    return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
  };
  SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
    for (var i = 0;i < len; ++i) {
      if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {
        return false;
      }
    }
    return true;
  };
  module.exports = SBMH;
});

// node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS((exports, module) => {
  var inherits = __require("node:util").inherits;
  var ReadableStream2 = __require("node:stream").Readable;
  function PartStream(opts) {
    ReadableStream2.call(this, opts);
  }
  inherits(PartStream, ReadableStream2);
  PartStream.prototype._read = function(n) {
  };
  module.exports = PartStream;
});

// node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS((exports, module) => {
  module.exports = function getLimit(limits, name, defaultLimit) {
    if (!limits || limits[name] === undefined || limits[name] === null) {
      return defaultLimit;
    }
    if (typeof limits[name] !== "number" || isNaN(limits[name])) {
      throw new TypeError("Limit " + name + " is not a valid number");
    }
    return limits[name];
  };
});

// node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events").EventEmitter;
  var inherits = __require("node:util").inherits;
  var getLimit = require_getLimit();
  var StreamSearch = require_sbmh();
  var B_DCRLF = Buffer.from(`\r
\r
`);
  var RE_CRLF = /\r\n/g;
  var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
  function HeaderParser(cfg) {
    EventEmitter.call(this);
    cfg = cfg || {};
    const self2 = this;
    this.nread = 0;
    this.maxed = false;
    this.npairs = 0;
    this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2000);
    this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
    this.buffer = "";
    this.header = {};
    this.finished = false;
    this.ss = new StreamSearch(B_DCRLF);
    this.ss.on("info", function(isMatch, data, start, end) {
      if (data && !self2.maxed) {
        if (self2.nread + end - start >= self2.maxHeaderSize) {
          end = self2.maxHeaderSize - self2.nread + start;
          self2.nread = self2.maxHeaderSize;
          self2.maxed = true;
        } else {
          self2.nread += end - start;
        }
        self2.buffer += data.toString("binary", start, end);
      }
      if (isMatch) {
        self2._finish();
      }
    });
  }
  inherits(HeaderParser, EventEmitter);
  HeaderParser.prototype.push = function(data) {
    const r = this.ss.push(data);
    if (this.finished) {
      return r;
    }
  };
  HeaderParser.prototype.reset = function() {
    this.finished = false;
    this.buffer = "";
    this.header = {};
    this.ss.reset();
  };
  HeaderParser.prototype._finish = function() {
    if (this.buffer) {
      this._parseHeader();
    }
    this.ss.matches = this.ss.maxMatches;
    const header = this.header;
    this.header = {};
    this.buffer = "";
    this.finished = true;
    this.nread = this.npairs = 0;
    this.maxed = false;
    this.emit("header", header);
  };
  HeaderParser.prototype._parseHeader = function() {
    if (this.npairs === this.maxHeaderPairs) {
      return;
    }
    const lines = this.buffer.split(RE_CRLF);
    const len = lines.length;
    let m, h;
    for (var i = 0;i < len; ++i) {
      if (lines[i].length === 0) {
        continue;
      }
      if (lines[i][0] === "\t" || lines[i][0] === " ") {
        if (h) {
          this.header[h][this.header[h].length - 1] += lines[i];
          continue;
        }
      }
      const posColon = lines[i].indexOf(":");
      if (posColon === -1 || posColon === 0) {
        return;
      }
      m = RE_HDR.exec(lines[i]);
      h = m[1].toLowerCase();
      this.header[h] = this.header[h] || [];
      this.header[h].push(m[2] || "");
      if (++this.npairs === this.maxHeaderPairs) {
        break;
      }
    }
  };
  module.exports = HeaderParser;
});

// node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS((exports, module) => {
  var WritableStream = __require("node:stream").Writable;
  var inherits = __require("node:util").inherits;
  var StreamSearch = require_sbmh();
  var PartStream = require_PartStream();
  var HeaderParser = require_HeaderParser();
  var DASH = 45;
  var B_ONEDASH = Buffer.from("-");
  var B_CRLF = Buffer.from(`\r
`);
  var EMPTY_FN = function() {
  };
  function Dicer(cfg) {
    if (!(this instanceof Dicer)) {
      return new Dicer(cfg);
    }
    WritableStream.call(this, cfg);
    if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {
      throw new TypeError("Boundary required");
    }
    if (typeof cfg.boundary === "string") {
      this.setBoundary(cfg.boundary);
    } else {
      this._bparser = undefined;
    }
    this._headerFirst = cfg.headerFirst;
    this._dashes = 0;
    this._parts = 0;
    this._finished = false;
    this._realFinish = false;
    this._isPreamble = true;
    this._justMatched = false;
    this._firstWrite = true;
    this._inHeader = true;
    this._part = undefined;
    this._cb = undefined;
    this._ignoreData = false;
    this._partOpts = { highWaterMark: cfg.partHwm };
    this._pause = false;
    const self2 = this;
    this._hparser = new HeaderParser(cfg);
    this._hparser.on("header", function(header) {
      self2._inHeader = false;
      self2._part.emit("header", header);
    });
  }
  inherits(Dicer, WritableStream);
  Dicer.prototype.emit = function(ev) {
    if (ev === "finish" && !this._realFinish) {
      if (!this._finished) {
        const self2 = this;
        process.nextTick(function() {
          self2.emit("error", new Error("Unexpected end of multipart data"));
          if (self2._part && !self2._ignoreData) {
            const type = self2._isPreamble ? "Preamble" : "Part";
            self2._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data"));
            self2._part.push(null);
            process.nextTick(function() {
              self2._realFinish = true;
              self2.emit("finish");
              self2._realFinish = false;
            });
            return;
          }
          self2._realFinish = true;
          self2.emit("finish");
          self2._realFinish = false;
        });
      }
    } else {
      WritableStream.prototype.emit.apply(this, arguments);
    }
  };
  Dicer.prototype._write = function(data, encoding, cb) {
    if (!this._hparser && !this._bparser) {
      return cb();
    }
    if (this._headerFirst && this._isPreamble) {
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        if (this.listenerCount("preamble") !== 0) {
          this.emit("preamble", this._part);
        } else {
          this._ignore();
        }
      }
      const r = this._hparser.push(data);
      if (!this._inHeader && r !== undefined && r < data.length) {
        data = data.slice(r);
      } else {
        return cb();
      }
    }
    if (this._firstWrite) {
      this._bparser.push(B_CRLF);
      this._firstWrite = false;
    }
    this._bparser.push(data);
    if (this._pause) {
      this._cb = cb;
    } else {
      cb();
    }
  };
  Dicer.prototype.reset = function() {
    this._part = undefined;
    this._bparser = undefined;
    this._hparser = undefined;
  };
  Dicer.prototype.setBoundary = function(boundary) {
    const self2 = this;
    this._bparser = new StreamSearch(`\r
--` + boundary);
    this._bparser.on("info", function(isMatch, data, start, end) {
      self2._oninfo(isMatch, data, start, end);
    });
  };
  Dicer.prototype._ignore = function() {
    if (this._part && !this._ignoreData) {
      this._ignoreData = true;
      this._part.on("error", EMPTY_FN);
      this._part.resume();
    }
  };
  Dicer.prototype._oninfo = function(isMatch, data, start, end) {
    let buf;
    const self2 = this;
    let i = 0;
    let r;
    let shouldWriteMore = true;
    if (!this._part && this._justMatched && data) {
      while (this._dashes < 2 && start + i < end) {
        if (data[start + i] === DASH) {
          ++i;
          ++this._dashes;
        } else {
          if (this._dashes) {
            buf = B_ONEDASH;
          }
          this._dashes = 0;
          break;
        }
      }
      if (this._dashes === 2) {
        if (start + i < end && this.listenerCount("trailer") !== 0) {
          this.emit("trailer", data.slice(start + i, end));
        }
        this.reset();
        this._finished = true;
        if (self2._parts === 0) {
          self2._realFinish = true;
          self2.emit("finish");
          self2._realFinish = false;
        }
      }
      if (this._dashes) {
        return;
      }
    }
    if (this._justMatched) {
      this._justMatched = false;
    }
    if (!this._part) {
      this._part = new PartStream(this._partOpts);
      this._part._read = function(n) {
        self2._unpause();
      };
      if (this._isPreamble && this.listenerCount("preamble") !== 0) {
        this.emit("preamble", this._part);
      } else if (this._isPreamble !== true && this.listenerCount("part") !== 0) {
        this.emit("part", this._part);
      } else {
        this._ignore();
      }
      if (!this._isPreamble) {
        this._inHeader = true;
      }
    }
    if (data && start < end && !this._ignoreData) {
      if (this._isPreamble || !this._inHeader) {
        if (buf) {
          shouldWriteMore = this._part.push(buf);
        }
        shouldWriteMore = this._part.push(data.slice(start, end));
        if (!shouldWriteMore) {
          this._pause = true;
        }
      } else if (!this._isPreamble && this._inHeader) {
        if (buf) {
          this._hparser.push(buf);
        }
        r = this._hparser.push(data.slice(start, end));
        if (!this._inHeader && r !== undefined && r < end) {
          this._oninfo(false, data, start + r, end);
        }
      }
    }
    if (isMatch) {
      this._hparser.reset();
      if (this._isPreamble) {
        this._isPreamble = false;
      } else {
        if (start !== end) {
          ++this._parts;
          this._part.on("end", function() {
            if (--self2._parts === 0) {
              if (self2._finished) {
                self2._realFinish = true;
                self2.emit("finish");
                self2._realFinish = false;
              } else {
                self2._unpause();
              }
            }
          });
        }
      }
      this._part.push(null);
      this._part = undefined;
      this._ignoreData = false;
      this._justMatched = true;
      this._dashes = 0;
    }
  };
  Dicer.prototype._unpause = function() {
    if (!this._pause) {
      return;
    }
    this._pause = false;
    if (this._cb) {
      const cb = this._cb;
      this._cb = undefined;
      cb();
    }
  };
  module.exports = Dicer;
});

// node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS((exports, module) => {
  var utf8Decoder = new TextDecoder("utf-8");
  var textDecoders = new Map([
    ["utf-8", utf8Decoder],
    ["utf8", utf8Decoder]
  ]);
  function getDecoder(charset) {
    let lc;
    while (true) {
      switch (charset) {
        case "utf-8":
        case "utf8":
          return decoders.utf8;
        case "latin1":
        case "ascii":
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return decoders.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return decoders.utf16le;
        case "base64":
          return decoders.base64;
        default:
          if (lc === undefined) {
            lc = true;
            charset = charset.toLowerCase();
            continue;
          }
          return decoders.other.bind(charset);
      }
    }
  }
  var decoders = {
    utf8: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        data = Buffer.from(data, sourceEncoding);
      }
      return data.utf8Slice(0, data.length);
    },
    latin1: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        return data;
      }
      return data.latin1Slice(0, data.length);
    },
    utf16le: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        data = Buffer.from(data, sourceEncoding);
      }
      return data.ucs2Slice(0, data.length);
    },
    base64: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        data = Buffer.from(data, sourceEncoding);
      }
      return data.base64Slice(0, data.length);
    },
    other: (data, sourceEncoding) => {
      if (data.length === 0) {
        return "";
      }
      if (typeof data === "string") {
        data = Buffer.from(data, sourceEncoding);
      }
      if (textDecoders.has(exports.toString())) {
        try {
          return textDecoders.get(exports).decode(data);
        } catch {
        }
      }
      return typeof data === "string" ? data : data.toString();
    }
  };
  function decodeText(text, sourceEncoding, destEncoding) {
    if (text) {
      return getDecoder(destEncoding)(text, sourceEncoding);
    }
    return text;
  }
  module.exports = decodeText;
});

// node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS((exports, module) => {
  var decodeText = require_decodeText();
  var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
  var EncodedLookup = {
    "%00": "\x00",
    "%01": "\x01",
    "%02": "\x02",
    "%03": "\x03",
    "%04": "\x04",
    "%05": "\x05",
    "%06": "\x06",
    "%07": "\x07",
    "%08": "\b",
    "%09": "\t",
    "%0a": `
`,
    "%0A": `
`,
    "%0b": "\v",
    "%0B": "\v",
    "%0c": "\f",
    "%0C": "\f",
    "%0d": "\r",
    "%0D": "\r",
    "%0e": "\x0E",
    "%0E": "\x0E",
    "%0f": "\x0F",
    "%0F": "\x0F",
    "%10": "\x10",
    "%11": "\x11",
    "%12": "\x12",
    "%13": "\x13",
    "%14": "\x14",
    "%15": "\x15",
    "%16": "\x16",
    "%17": "\x17",
    "%18": "\x18",
    "%19": "\x19",
    "%1a": "\x1A",
    "%1A": "\x1A",
    "%1b": "\x1B",
    "%1B": "\x1B",
    "%1c": "\x1C",
    "%1C": "\x1C",
    "%1d": "\x1D",
    "%1D": "\x1D",
    "%1e": "\x1E",
    "%1E": "\x1E",
    "%1f": "\x1F",
    "%1F": "\x1F",
    "%20": " ",
    "%21": "!",
    "%22": '"',
    "%23": "#",
    "%24": "$",
    "%25": "%",
    "%26": "&",
    "%27": "'",
    "%28": "(",
    "%29": ")",
    "%2a": "*",
    "%2A": "*",
    "%2b": "+",
    "%2B": "+",
    "%2c": ",",
    "%2C": ",",
    "%2d": "-",
    "%2D": "-",
    "%2e": ".",
    "%2E": ".",
    "%2f": "/",
    "%2F": "/",
    "%30": "0",
    "%31": "1",
    "%32": "2",
    "%33": "3",
    "%34": "4",
    "%35": "5",
    "%36": "6",
    "%37": "7",
    "%38": "8",
    "%39": "9",
    "%3a": ":",
    "%3A": ":",
    "%3b": ";",
    "%3B": ";",
    "%3c": "<",
    "%3C": "<",
    "%3d": "=",
    "%3D": "=",
    "%3e": ">",
    "%3E": ">",
    "%3f": "?",
    "%3F": "?",
    "%40": "@",
    "%41": "A",
    "%42": "B",
    "%43": "C",
    "%44": "D",
    "%45": "E",
    "%46": "F",
    "%47": "G",
    "%48": "H",
    "%49": "I",
    "%4a": "J",
    "%4A": "J",
    "%4b": "K",
    "%4B": "K",
    "%4c": "L",
    "%4C": "L",
    "%4d": "M",
    "%4D": "M",
    "%4e": "N",
    "%4E": "N",
    "%4f": "O",
    "%4F": "O",
    "%50": "P",
    "%51": "Q",
    "%52": "R",
    "%53": "S",
    "%54": "T",
    "%55": "U",
    "%56": "V",
    "%57": "W",
    "%58": "X",
    "%59": "Y",
    "%5a": "Z",
    "%5A": "Z",
    "%5b": "[",
    "%5B": "[",
    "%5c": "\\",
    "%5C": "\\",
    "%5d": "]",
    "%5D": "]",
    "%5e": "^",
    "%5E": "^",
    "%5f": "_",
    "%5F": "_",
    "%60": "`",
    "%61": "a",
    "%62": "b",
    "%63": "c",
    "%64": "d",
    "%65": "e",
    "%66": "f",
    "%67": "g",
    "%68": "h",
    "%69": "i",
    "%6a": "j",
    "%6A": "j",
    "%6b": "k",
    "%6B": "k",
    "%6c": "l",
    "%6C": "l",
    "%6d": "m",
    "%6D": "m",
    "%6e": "n",
    "%6E": "n",
    "%6f": "o",
    "%6F": "o",
    "%70": "p",
    "%71": "q",
    "%72": "r",
    "%73": "s",
    "%74": "t",
    "%75": "u",
    "%76": "v",
    "%77": "w",
    "%78": "x",
    "%79": "y",
    "%7a": "z",
    "%7A": "z",
    "%7b": "{",
    "%7B": "{",
    "%7c": "|",
    "%7C": "|",
    "%7d": "}",
    "%7D": "}",
    "%7e": "~",
    "%7E": "~",
    "%7f": "",
    "%7F": "",
    "%80": "",
    "%81": "",
    "%82": "",
    "%83": "",
    "%84": "",
    "%85": "",
    "%86": "",
    "%87": "",
    "%88": "",
    "%89": "",
    "%8a": "",
    "%8A": "",
    "%8b": "",
    "%8B": "",
    "%8c": "",
    "%8C": "",
    "%8d": "",
    "%8D": "",
    "%8e": "",
    "%8E": "",
    "%8f": "",
    "%8F": "",
    "%90": "",
    "%91": "",
    "%92": "",
    "%93": "",
    "%94": "",
    "%95": "",
    "%96": "",
    "%97": "",
    "%98": "",
    "%99": "",
    "%9a": "",
    "%9A": "",
    "%9b": "",
    "%9B": "",
    "%9c": "",
    "%9C": "",
    "%9d": "",
    "%9D": "",
    "%9e": "",
    "%9E": "",
    "%9f": "",
    "%9F": "",
    "%a0": "",
    "%A0": "",
    "%a1": "",
    "%A1": "",
    "%a2": "",
    "%A2": "",
    "%a3": "",
    "%A3": "",
    "%a4": "",
    "%A4": "",
    "%a5": "",
    "%A5": "",
    "%a6": "",
    "%A6": "",
    "%a7": "",
    "%A7": "",
    "%a8": "",
    "%A8": "",
    "%a9": "",
    "%A9": "",
    "%aa": "",
    "%Aa": "",
    "%aA": "",
    "%AA": "",
    "%ab": "",
    "%Ab": "",
    "%aB": "",
    "%AB": "",
    "%ac": "",
    "%Ac": "",
    "%aC": "",
    "%AC": "",
    "%ad": "",
    "%Ad": "",
    "%aD": "",
    "%AD": "",
    "%ae": "",
    "%Ae": "",
    "%aE": "",
    "%AE": "",
    "%af": "",
    "%Af": "",
    "%aF": "",
    "%AF": "",
    "%b0": "",
    "%B0": "",
    "%b1": "",
    "%B1": "",
    "%b2": "",
    "%B2": "",
    "%b3": "",
    "%B3": "",
    "%b4": "",
    "%B4": "",
    "%b5": "",
    "%B5": "",
    "%b6": "",
    "%B6": "",
    "%b7": "",
    "%B7": "",
    "%b8": "",
    "%B8": "",
    "%b9": "",
    "%B9": "",
    "%ba": "",
    "%Ba": "",
    "%bA": "",
    "%BA": "",
    "%bb": "",
    "%Bb": "",
    "%bB": "",
    "%BB": "",
    "%bc": "",
    "%Bc": "",
    "%bC": "",
    "%BC": "",
    "%bd": "",
    "%Bd": "",
    "%bD": "",
    "%BD": "",
    "%be": "",
    "%Be": "",
    "%bE": "",
    "%BE": "",
    "%bf": "",
    "%Bf": "",
    "%bF": "",
    "%BF": "",
    "%c0": "",
    "%C0": "",
    "%c1": "",
    "%C1": "",
    "%c2": "",
    "%C2": "",
    "%c3": "",
    "%C3": "",
    "%c4": "",
    "%C4": "",
    "%c5": "",
    "%C5": "",
    "%c6": "",
    "%C6": "",
    "%c7": "",
    "%C7": "",
    "%c8": "",
    "%C8": "",
    "%c9": "",
    "%C9": "",
    "%ca": "",
    "%Ca": "",
    "%cA": "",
    "%CA": "",
    "%cb": "",
    "%Cb": "",
    "%cB": "",
    "%CB": "",
    "%cc": "",
    "%Cc": "",
    "%cC": "",
    "%CC": "",
    "%cd": "",
    "%Cd": "",
    "%cD": "",
    "%CD": "",
    "%ce": "",
    "%Ce": "",
    "%cE": "",
    "%CE": "",
    "%cf": "",
    "%Cf": "",
    "%cF": "",
    "%CF": "",
    "%d0": "",
    "%D0": "",
    "%d1": "",
    "%D1": "",
    "%d2": "",
    "%D2": "",
    "%d3": "",
    "%D3": "",
    "%d4": "",
    "%D4": "",
    "%d5": "",
    "%D5": "",
    "%d6": "",
    "%D6": "",
    "%d7": "",
    "%D7": "",
    "%d8": "",
    "%D8": "",
    "%d9": "",
    "%D9": "",
    "%da": "",
    "%Da": "",
    "%dA": "",
    "%DA": "",
    "%db": "",
    "%Db": "",
    "%dB": "",
    "%DB": "",
    "%dc": "",
    "%Dc": "",
    "%dC": "",
    "%DC": "",
    "%dd": "",
    "%Dd": "",
    "%dD": "",
    "%DD": "",
    "%de": "",
    "%De": "",
    "%dE": "",
    "%DE": "",
    "%df": "",
    "%Df": "",
    "%dF": "",
    "%DF": "",
    "%e0": "",
    "%E0": "",
    "%e1": "",
    "%E1": "",
    "%e2": "",
    "%E2": "",
    "%e3": "",
    "%E3": "",
    "%e4": "",
    "%E4": "",
    "%e5": "",
    "%E5": "",
    "%e6": "",
    "%E6": "",
    "%e7": "",
    "%E7": "",
    "%e8": "",
    "%E8": "",
    "%e9": "",
    "%E9": "",
    "%ea": "",
    "%Ea": "",
    "%eA": "",
    "%EA": "",
    "%eb": "",
    "%Eb": "",
    "%eB": "",
    "%EB": "",
    "%ec": "",
    "%Ec": "",
    "%eC": "",
    "%EC": "",
    "%ed": "",
    "%Ed": "",
    "%eD": "",
    "%ED": "",
    "%ee": "",
    "%Ee": "",
    "%eE": "",
    "%EE": "",
    "%ef": "",
    "%Ef": "",
    "%eF": "",
    "%EF": "",
    "%f0": "",
    "%F0": "",
    "%f1": "",
    "%F1": "",
    "%f2": "",
    "%F2": "",
    "%f3": "",
    "%F3": "",
    "%f4": "",
    "%F4": "",
    "%f5": "",
    "%F5": "",
    "%f6": "",
    "%F6": "",
    "%f7": "",
    "%F7": "",
    "%f8": "",
    "%F8": "",
    "%f9": "",
    "%F9": "",
    "%fa": "",
    "%Fa": "",
    "%fA": "",
    "%FA": "",
    "%fb": "",
    "%Fb": "",
    "%fB": "",
    "%FB": "",
    "%fc": "",
    "%Fc": "",
    "%fC": "",
    "%FC": "",
    "%fd": "",
    "%Fd": "",
    "%fD": "",
    "%FD": "",
    "%fe": "",
    "%Fe": "",
    "%fE": "",
    "%FE": "",
    "%ff": "",
    "%Ff": "",
    "%fF": "",
    "%FF": ""
  };
  function encodedReplacer(match) {
    return EncodedLookup[match];
  }
  var STATE_KEY = 0;
  var STATE_VALUE = 1;
  var STATE_CHARSET = 2;
  var STATE_LANG = 3;
  function parseParams(str) {
    const res = [];
    let state = STATE_KEY;
    let charset = "";
    let inquote = false;
    let escaping = false;
    let p = 0;
    let tmp = "";
    const len = str.length;
    for (var i = 0;i < len; ++i) {
      const char = str[i];
      if (char === "\\" && inquote) {
        if (escaping) {
          escaping = false;
        } else {
          escaping = true;
          continue;
        }
      } else if (char === '"') {
        if (!escaping) {
          if (inquote) {
            inquote = false;
            state = STATE_KEY;
          } else {
            inquote = true;
          }
          continue;
        } else {
          escaping = false;
        }
      } else {
        if (escaping && inquote) {
          tmp += "\\";
        }
        escaping = false;
        if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
          if (state === STATE_CHARSET) {
            state = STATE_LANG;
            charset = tmp.substring(1);
          } else {
            state = STATE_VALUE;
          }
          tmp = "";
          continue;
        } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
          state = char === "*" ? STATE_CHARSET : STATE_VALUE;
          res[p] = [tmp, undefined];
          tmp = "";
          continue;
        } else if (!inquote && char === ";") {
          state = STATE_KEY;
          if (charset) {
            if (tmp.length) {
              tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
            }
            charset = "";
          } else if (tmp.length) {
            tmp = decodeText(tmp, "binary", "utf8");
          }
          if (res[p] === undefined) {
            res[p] = tmp;
          } else {
            res[p][1] = tmp;
          }
          tmp = "";
          ++p;
          continue;
        } else if (!inquote && (char === " " || char === "\t")) {
          continue;
        }
      }
      tmp += char;
    }
    if (charset && tmp.length) {
      tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
    } else if (tmp) {
      tmp = decodeText(tmp, "binary", "utf8");
    }
    if (res[p] === undefined) {
      if (tmp) {
        res[p] = tmp;
      }
    } else {
      res[p][1] = tmp;
    }
    return res;
  }
  module.exports = parseParams;
});

// node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS((exports, module) => {
  module.exports = function basename(path) {
    if (typeof path !== "string") {
      return "";
    }
    for (var i = path.length - 1;i >= 0; --i) {
      switch (path.charCodeAt(i)) {
        case 47:
        case 92:
          path = path.slice(i + 1);
          return path === ".." || path === "." ? "" : path;
      }
    }
    return path === ".." || path === "." ? "" : path;
  };
});

// node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS((exports, module) => {
  var { Readable } = __require("node:stream");
  var { inherits } = __require("node:util");
  var Dicer = require_Dicer();
  var parseParams = require_parseParams();
  var decodeText = require_decodeText();
  var basename = require_basename();
  var getLimit = require_getLimit();
  var RE_BOUNDARY = /^boundary$/i;
  var RE_FIELD = /^form-data$/i;
  var RE_CHARSET = /^charset$/i;
  var RE_FILENAME = /^filename$/i;
  var RE_NAME = /^name$/i;
  Multipart.detect = /^multipart\/form-data/i;
  function Multipart(boy, cfg) {
    let i;
    let len;
    const self2 = this;
    let boundary;
    const limits = cfg.limits;
    const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== undefined);
    const parsedConType = cfg.parsedConType || [];
    const defCharset = cfg.defCharset || "utf8";
    const preservePath = cfg.preservePath;
    const fileOpts = { highWaterMark: cfg.fileHwm };
    for (i = 0, len = parsedConType.length;i < len; ++i) {
      if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
        boundary = parsedConType[i][1];
        break;
      }
    }
    function checkFinished() {
      if (nends === 0 && finished && !boy._done) {
        finished = false;
        self2.end();
      }
    }
    if (typeof boundary !== "string") {
      throw new Error("Multipart: Boundary not found");
    }
    const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
    const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
    const filesLimit = getLimit(limits, "files", Infinity);
    const fieldsLimit = getLimit(limits, "fields", Infinity);
    const partsLimit = getLimit(limits, "parts", Infinity);
    const headerPairsLimit = getLimit(limits, "headerPairs", 2000);
    const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
    let nfiles = 0;
    let nfields = 0;
    let nends = 0;
    let curFile;
    let curField;
    let finished = false;
    this._needDrain = false;
    this._pause = false;
    this._cb = undefined;
    this._nparts = 0;
    this._boy = boy;
    const parserCfg = {
      boundary,
      maxHeaderPairs: headerPairsLimit,
      maxHeaderSize: headerSizeLimit,
      partHwm: fileOpts.highWaterMark,
      highWaterMark: cfg.highWaterMark
    };
    this.parser = new Dicer(parserCfg);
    this.parser.on("drain", function() {
      self2._needDrain = false;
      if (self2._cb && !self2._pause) {
        const cb = self2._cb;
        self2._cb = undefined;
        cb();
      }
    }).on("part", function onPart(part) {
      if (++self2._nparts > partsLimit) {
        self2.parser.removeListener("part", onPart);
        self2.parser.on("part", skipPart);
        boy.hitPartsLimit = true;
        boy.emit("partsLimit");
        return skipPart(part);
      }
      if (curField) {
        const field = curField;
        field.emit("end");
        field.removeAllListeners("end");
      }
      part.on("header", function(header) {
        let contype;
        let fieldname;
        let parsed;
        let charset;
        let encoding;
        let filename;
        let nsize = 0;
        if (header["content-type"]) {
          parsed = parseParams(header["content-type"][0]);
          if (parsed[0]) {
            contype = parsed[0].toLowerCase();
            for (i = 0, len = parsed.length;i < len; ++i) {
              if (RE_CHARSET.test(parsed[i][0])) {
                charset = parsed[i][1].toLowerCase();
                break;
              }
            }
          }
        }
        if (contype === undefined) {
          contype = "text/plain";
        }
        if (charset === undefined) {
          charset = defCharset;
        }
        if (header["content-disposition"]) {
          parsed = parseParams(header["content-disposition"][0]);
          if (!RE_FIELD.test(parsed[0])) {
            return skipPart(part);
          }
          for (i = 0, len = parsed.length;i < len; ++i) {
            if (RE_NAME.test(parsed[i][0])) {
              fieldname = parsed[i][1];
            } else if (RE_FILENAME.test(parsed[i][0])) {
              filename = parsed[i][1];
              if (!preservePath) {
                filename = basename(filename);
              }
            }
          }
        } else {
          return skipPart(part);
        }
        if (header["content-transfer-encoding"]) {
          encoding = header["content-transfer-encoding"][0].toLowerCase();
        } else {
          encoding = "7bit";
        }
        let onData, onEnd;
        if (isPartAFile(fieldname, contype, filename)) {
          if (nfiles === filesLimit) {
            if (!boy.hitFilesLimit) {
              boy.hitFilesLimit = true;
              boy.emit("filesLimit");
            }
            return skipPart(part);
          }
          ++nfiles;
          if (boy.listenerCount("file") === 0) {
            self2.parser._ignore();
            return;
          }
          ++nends;
          const file = new FileStream(fileOpts);
          curFile = file;
          file.on("end", function() {
            --nends;
            self2._pause = false;
            checkFinished();
            if (self2._cb && !self2._needDrain) {
              const cb = self2._cb;
              self2._cb = undefined;
              cb();
            }
          });
          file._read = function(n) {
            if (!self2._pause) {
              return;
            }
            self2._pause = false;
            if (self2._cb && !self2._needDrain) {
              const cb = self2._cb;
              self2._cb = undefined;
              cb();
            }
          };
          boy.emit("file", fieldname, file, filename, encoding, contype);
          onData = function(data) {
            if ((nsize += data.length) > fileSizeLimit) {
              const extralen = fileSizeLimit - nsize + data.length;
              if (extralen > 0) {
                file.push(data.slice(0, extralen));
              }
              file.truncated = true;
              file.bytesRead = fileSizeLimit;
              part.removeAllListeners("data");
              file.emit("limit");
              return;
            } else if (!file.push(data)) {
              self2._pause = true;
            }
            file.bytesRead = nsize;
          };
          onEnd = function() {
            curFile = undefined;
            file.push(null);
          };
        } else {
          if (nfields === fieldsLimit) {
            if (!boy.hitFieldsLimit) {
              boy.hitFieldsLimit = true;
              boy.emit("fieldsLimit");
            }
            return skipPart(part);
          }
          ++nfields;
          ++nends;
          let buffer = "";
          let truncated = false;
          curField = part;
          onData = function(data) {
            if ((nsize += data.length) > fieldSizeLimit) {
              const extralen = fieldSizeLimit - (nsize - data.length);
              buffer += data.toString("binary", 0, extralen);
              truncated = true;
              part.removeAllListeners("data");
            } else {
              buffer += data.toString("binary");
            }
          };
          onEnd = function() {
            curField = undefined;
            if (buffer.length) {
              buffer = decodeText(buffer, "binary", charset);
            }
            boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
            --nends;
            checkFinished();
          };
        }
        part._readableState.sync = false;
        part.on("data", onData);
        part.on("end", onEnd);
      }).on("error", function(err) {
        if (curFile) {
          curFile.emit("error", err);
        }
      });
    }).on("error", function(err) {
      boy.emit("error", err);
    }).on("finish", function() {
      finished = true;
      checkFinished();
    });
  }
  Multipart.prototype.write = function(chunk, cb) {
    const r = this.parser.write(chunk);
    if (r && !this._pause) {
      cb();
    } else {
      this._needDrain = !r;
      this._cb = cb;
    }
  };
  Multipart.prototype.end = function() {
    const self2 = this;
    if (self2.parser.writable) {
      self2.parser.end();
    } else if (!self2._boy._done) {
      process.nextTick(function() {
        self2._boy._done = true;
        self2._boy.emit("finish");
      });
    }
  };
  function skipPart(part) {
    part.resume();
  }
  function FileStream(opts) {
    Readable.call(this, opts);
    this.bytesRead = 0;
    this.truncated = false;
  }
  inherits(FileStream, Readable);
  FileStream.prototype._read = function(n) {
  };
  module.exports = Multipart;
});

// node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS((exports, module) => {
  var RE_PLUS = /\+/g;
  var HEX = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  function Decoder() {
    this.buffer = undefined;
  }
  Decoder.prototype.write = function(str) {
    str = str.replace(RE_PLUS, " ");
    let res = "";
    let i = 0;
    let p = 0;
    const len = str.length;
    for (;i < len; ++i) {
      if (this.buffer !== undefined) {
        if (!HEX[str.charCodeAt(i)]) {
          res += "%" + this.buffer;
          this.buffer = undefined;
          --i;
        } else {
          this.buffer += str[i];
          ++p;
          if (this.buffer.length === 2) {
            res += String.fromCharCode(parseInt(this.buffer, 16));
            this.buffer = undefined;
          }
        }
      } else if (str[i] === "%") {
        if (i > p) {
          res += str.substring(p, i);
          p = i;
        }
        this.buffer = "";
        ++p;
      }
    }
    if (p < len && this.buffer === undefined) {
      res += str.substring(p);
    }
    return res;
  };
  Decoder.prototype.reset = function() {
    this.buffer = undefined;
  };
  module.exports = Decoder;
});

// node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  var Decoder = require_Decoder();
  var decodeText = require_decodeText();
  var getLimit = require_getLimit();
  var RE_CHARSET = /^charset$/i;
  UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
  function UrlEncoded(boy, cfg) {
    const limits = cfg.limits;
    const parsedConType = cfg.parsedConType;
    this.boy = boy;
    this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
    this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
    this.fieldsLimit = getLimit(limits, "fields", Infinity);
    let charset;
    for (var i = 0, len = parsedConType.length;i < len; ++i) {
      if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
        charset = parsedConType[i][1].toLowerCase();
        break;
      }
    }
    if (charset === undefined) {
      charset = cfg.defCharset || "utf8";
    }
    this.decoder = new Decoder;
    this.charset = charset;
    this._fields = 0;
    this._state = "key";
    this._checkingBytes = true;
    this._bytesKey = 0;
    this._bytesVal = 0;
    this._key = "";
    this._val = "";
    this._keyTrunc = false;
    this._valTrunc = false;
    this._hitLimit = false;
  }
  UrlEncoded.prototype.write = function(data, cb) {
    if (this._fields === this.fieldsLimit) {
      if (!this.boy.hitFieldsLimit) {
        this.boy.hitFieldsLimit = true;
        this.boy.emit("fieldsLimit");
      }
      return cb();
    }
    let idxeq;
    let idxamp;
    let i;
    let p = 0;
    const len = data.length;
    while (p < len) {
      if (this._state === "key") {
        idxeq = idxamp = undefined;
        for (i = p;i < len; ++i) {
          if (!this._checkingBytes) {
            ++p;
          }
          if (data[i] === 61) {
            idxeq = i;
            break;
          } else if (data[i] === 38) {
            idxamp = i;
            break;
          }
          if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
            this._hitLimit = true;
            break;
          } else if (this._checkingBytes) {
            ++this._bytesKey;
          }
        }
        if (idxeq !== undefined) {
          if (idxeq > p) {
            this._key += this.decoder.write(data.toString("binary", p, idxeq));
          }
          this._state = "val";
          this._hitLimit = false;
          this._checkingBytes = true;
          this._val = "";
          this._bytesVal = 0;
          this._valTrunc = false;
          this.decoder.reset();
          p = idxeq + 1;
        } else if (idxamp !== undefined) {
          ++this._fields;
          let key;
          const keyTrunc = this._keyTrunc;
          if (idxamp > p) {
            key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
          } else {
            key = this._key;
          }
          this._hitLimit = false;
          this._checkingBytes = true;
          this._key = "";
          this._bytesKey = 0;
          this._keyTrunc = false;
          this.decoder.reset();
          if (key.length) {
            this.boy.emit("field", decodeText(key, "binary", this.charset), "", keyTrunc, false);
          }
          p = idxamp + 1;
          if (this._fields === this.fieldsLimit) {
            return cb();
          }
        } else if (this._hitLimit) {
          if (i > p) {
            this._key += this.decoder.write(data.toString("binary", p, i));
          }
          p = i;
          if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
            this._checkingBytes = false;
            this._keyTrunc = true;
          }
        } else {
          if (p < len) {
            this._key += this.decoder.write(data.toString("binary", p));
          }
          p = len;
        }
      } else {
        idxamp = undefined;
        for (i = p;i < len; ++i) {
          if (!this._checkingBytes) {
            ++p;
          }
          if (data[i] === 38) {
            idxamp = i;
            break;
          }
          if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
            this._hitLimit = true;
            break;
          } else if (this._checkingBytes) {
            ++this._bytesVal;
          }
        }
        if (idxamp !== undefined) {
          ++this._fields;
          if (idxamp > p) {
            this._val += this.decoder.write(data.toString("binary", p, idxamp));
          }
          this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
          this._state = "key";
          this._hitLimit = false;
          this._checkingBytes = true;
          this._key = "";
          this._bytesKey = 0;
          this._keyTrunc = false;
          this.decoder.reset();
          p = idxamp + 1;
          if (this._fields === this.fieldsLimit) {
            return cb();
          }
        } else if (this._hitLimit) {
          if (i > p) {
            this._val += this.decoder.write(data.toString("binary", p, i));
          }
          p = i;
          if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
            this._checkingBytes = false;
            this._valTrunc = true;
          }
        } else {
          if (p < len) {
            this._val += this.decoder.write(data.toString("binary", p));
          }
          p = len;
        }
      }
    }
    cb();
  };
  UrlEncoded.prototype.end = function() {
    if (this.boy._done) {
      return;
    }
    if (this._state === "key" && this._key.length > 0) {
      this.boy.emit("field", decodeText(this._key, "binary", this.charset), "", this._keyTrunc, false);
    } else if (this._state === "val") {
      this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
    }
    this.boy._done = true;
    this.boy.emit("finish");
  };
  module.exports = UrlEncoded;
});

// node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS((exports, module) => {
  var WritableStream = __require("node:stream").Writable;
  var { inherits } = __require("node:util");
  var Dicer = require_Dicer();
  var MultipartParser = require_multipart();
  var UrlencodedParser = require_urlencoded();
  var parseParams = require_parseParams();
  function Busboy(opts) {
    if (!(this instanceof Busboy)) {
      return new Busboy(opts);
    }
    if (typeof opts !== "object") {
      throw new TypeError("Busboy expected an options-Object.");
    }
    if (typeof opts.headers !== "object") {
      throw new TypeError("Busboy expected an options-Object with headers-attribute.");
    }
    if (typeof opts.headers["content-type"] !== "string") {
      throw new TypeError("Missing Content-Type-header.");
    }
    const {
      headers,
      ...streamOptions
    } = opts;
    this.opts = {
      autoDestroy: false,
      ...streamOptions
    };
    WritableStream.call(this, this.opts);
    this._done = false;
    this._parser = this.getParserByHeaders(headers);
    this._finished = false;
  }
  inherits(Busboy, WritableStream);
  Busboy.prototype.emit = function(ev) {
    if (ev === "finish") {
      if (!this._done) {
        this._parser?.end();
        return;
      } else if (this._finished) {
        return;
      }
      this._finished = true;
    }
    WritableStream.prototype.emit.apply(this, arguments);
  };
  Busboy.prototype.getParserByHeaders = function(headers) {
    const parsed = parseParams(headers["content-type"]);
    const cfg = {
      defCharset: this.opts.defCharset,
      fileHwm: this.opts.fileHwm,
      headers,
      highWaterMark: this.opts.highWaterMark,
      isPartAFile: this.opts.isPartAFile,
      limits: this.opts.limits,
      parsedConType: parsed,
      preservePath: this.opts.preservePath
    };
    if (MultipartParser.detect.test(parsed[0])) {
      return new MultipartParser(this, cfg);
    }
    if (UrlencodedParser.detect.test(parsed[0])) {
      return new UrlencodedParser(this, cfg);
    }
    throw new Error("Unsupported Content-Type.");
  };
  Busboy.prototype._write = function(chunk, encoding, cb) {
    this._parser.write(chunk, cb);
  };
  module.exports = Busboy;
  module.exports.default = Busboy;
  module.exports.Busboy = Busboy;
  module.exports.Dicer = Dicer;
});

// node_modules/undici/lib/fetch/constants.js
var require_constants2 = __commonJS((exports, module) => {
  var { MessageChannel, receiveMessageOnPort } = __require("worker_threads");
  var corsSafeListedMethods = ["GET", "HEAD", "POST"];
  var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
  var nullBodyStatus = [101, 204, 205, 304];
  var redirectStatus = [301, 302, 303, 307, 308];
  var redirectStatusSet = new Set(redirectStatus);
  var badPorts = [
    "1",
    "7",
    "9",
    "11",
    "13",
    "15",
    "17",
    "19",
    "20",
    "21",
    "22",
    "23",
    "25",
    "37",
    "42",
    "43",
    "53",
    "69",
    "77",
    "79",
    "87",
    "95",
    "101",
    "102",
    "103",
    "104",
    "109",
    "110",
    "111",
    "113",
    "115",
    "117",
    "119",
    "123",
    "135",
    "137",
    "139",
    "143",
    "161",
    "179",
    "389",
    "427",
    "465",
    "512",
    "513",
    "514",
    "515",
    "526",
    "530",
    "531",
    "532",
    "540",
    "548",
    "554",
    "556",
    "563",
    "587",
    "601",
    "636",
    "989",
    "990",
    "993",
    "995",
    "1719",
    "1720",
    "1723",
    "2049",
    "3659",
    "4045",
    "5060",
    "5061",
    "6000",
    "6566",
    "6665",
    "6666",
    "6667",
    "6668",
    "6669",
    "6697",
    "10080"
  ];
  var badPortsSet = new Set(badPorts);
  var referrerPolicy = [
    "",
    "no-referrer",
    "no-referrer-when-downgrade",
    "same-origin",
    "origin",
    "strict-origin",
    "origin-when-cross-origin",
    "strict-origin-when-cross-origin",
    "unsafe-url"
  ];
  var referrerPolicySet = new Set(referrerPolicy);
  var requestRedirect = ["follow", "manual", "error"];
  var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
  var safeMethodsSet = new Set(safeMethods);
  var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
  var requestCredentials = ["omit", "same-origin", "include"];
  var requestCache = [
    "default",
    "no-store",
    "reload",
    "no-cache",
    "force-cache",
    "only-if-cached"
  ];
  var requestBodyHeader = [
    "content-encoding",
    "content-language",
    "content-location",
    "content-type",
    "content-length"
  ];
  var requestDuplex = [
    "half"
  ];
  var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
  var forbiddenMethodsSet = new Set(forbiddenMethods);
  var subresource = [
    "audio",
    "audioworklet",
    "font",
    "image",
    "manifest",
    "paintworklet",
    "script",
    "style",
    "track",
    "video",
    "xslt",
    ""
  ];
  var subresourceSet = new Set(subresource);
  var DOMException2 = globalThis.DOMException ?? (() => {
    try {
      atob("~");
    } catch (err) {
      return Object.getPrototypeOf(err).constructor;
    }
  })();
  var channel;
  var structuredClone = globalThis.structuredClone ?? function structuredClone(value, options = undefined) {
    if (arguments.length === 0) {
      throw new TypeError("missing argument");
    }
    if (!channel) {
      channel = new MessageChannel;
    }
    channel.port1.unref();
    channel.port2.unref();
    channel.port1.postMessage(value, options?.transfer);
    return receiveMessageOnPort(channel.port2).message;
  };
  module.exports = {
    DOMException: DOMException2,
    structuredClone,
    subresource,
    forbiddenMethods,
    requestBodyHeader,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    redirectStatus,
    corsSafeListedMethods,
    nullBodyStatus,
    safeMethods,
    badPorts,
    requestDuplex,
    subresourceSet,
    badPortsSet,
    redirectStatusSet,
    corsSafeListedMethodsSet,
    safeMethodsSet,
    forbiddenMethodsSet,
    referrerPolicySet
  };
});

// node_modules/undici/lib/fetch/global.js
var require_global = __commonJS((exports, module) => {
  var globalOrigin = Symbol.for("undici.globalOrigin.1");
  function getGlobalOrigin() {
    return globalThis[globalOrigin];
  }
  function setGlobalOrigin(newOrigin) {
    if (newOrigin === undefined) {
      Object.defineProperty(globalThis, globalOrigin, {
        value: undefined,
        writable: true,
        enumerable: false,
        configurable: false
      });
      return;
    }
    const parsedURL = new URL(newOrigin);
    if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
      throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
    }
    Object.defineProperty(globalThis, globalOrigin, {
      value: parsedURL,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  module.exports = {
    getGlobalOrigin,
    setGlobalOrigin
  };
});

// node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS((exports, module) => {
  var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants2();
  var { getGlobalOrigin } = require_global();
  var { performance: performance2 } = __require("perf_hooks");
  var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();
  var assert = __require("assert");
  var { isUint8Array } = __require("util/types");
  var supportedHashes = [];
  var crypto;
  try {
    crypto = __require("crypto");
    const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
    supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
  } catch {
  }
  function responseURL(response) {
    const urlList = response.urlList;
    const length = urlList.length;
    return length === 0 ? null : urlList[length - 1].toString();
  }
  function responseLocationURL(response, requestFragment) {
    if (!redirectStatusSet.has(response.status)) {
      return null;
    }
    let location = response.headersList.get("location");
    if (location !== null && isValidHeaderValue(location)) {
      location = new URL(location, responseURL(response));
    }
    if (location && !location.hash) {
      location.hash = requestFragment;
    }
    return location;
  }
  function requestCurrentURL(request) {
    return request.urlList[request.urlList.length - 1];
  }
  function requestBadPort(request) {
    const url = requestCurrentURL(request);
    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
      return "blocked";
    }
    return "allowed";
  }
  function isErrorLike(object) {
    return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
  }
  function isValidReasonPhrase(statusText) {
    for (let i = 0;i < statusText.length; ++i) {
      const c = statusText.charCodeAt(i);
      if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) {
        return false;
      }
    }
    return true;
  }
  function isTokenCharCode(c) {
    switch (c) {
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 123:
      case 125:
        return false;
      default:
        return c >= 33 && c <= 126;
    }
  }
  function isValidHTTPToken(characters) {
    if (characters.length === 0) {
      return false;
    }
    for (let i = 0;i < characters.length; ++i) {
      if (!isTokenCharCode(characters.charCodeAt(i))) {
        return false;
      }
    }
    return true;
  }
  function isValidHeaderName(potentialValue) {
    return isValidHTTPToken(potentialValue);
  }
  function isValidHeaderValue(potentialValue) {
    if (potentialValue.startsWith("\t") || potentialValue.startsWith(" ") || potentialValue.endsWith("\t") || potentialValue.endsWith(" ")) {
      return false;
    }
    if (potentialValue.includes("\x00") || potentialValue.includes("\r") || potentialValue.includes(`
`)) {
      return false;
    }
    return true;
  }
  function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
    const { headersList } = actualResponse;
    const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
    let policy = "";
    if (policyHeader.length > 0) {
      for (let i = policyHeader.length;i !== 0; i--) {
        const token = policyHeader[i - 1].trim();
        if (referrerPolicyTokens.has(token)) {
          policy = token;
          break;
        }
      }
    }
    if (policy !== "") {
      request.referrerPolicy = policy;
    }
  }
  function crossOriginResourcePolicyCheck() {
    return "allowed";
  }
  function corsCheck() {
    return "success";
  }
  function TAOCheck() {
    return "success";
  }
  function appendFetchMetadata(httpRequest) {
    let header = null;
    header = httpRequest.mode;
    httpRequest.headersList.set("sec-fetch-mode", header);
  }
  function appendRequestOriginHeader(request) {
    let serializedOrigin = request.origin;
    if (request.responseTainting === "cors" || request.mode === "websocket") {
      if (serializedOrigin) {
        request.headersList.append("origin", serializedOrigin);
      }
    } else if (request.method !== "GET" && request.method !== "HEAD") {
      switch (request.referrerPolicy) {
        case "no-referrer":
          serializedOrigin = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
            serializedOrigin = null;
          }
          break;
        case "same-origin":
          if (!sameOrigin(request, requestCurrentURL(request))) {
            serializedOrigin = null;
          }
          break;
        default:
      }
      if (serializedOrigin) {
        request.headersList.append("origin", serializedOrigin);
      }
    }
  }
  function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
    return performance2.now();
  }
  function createOpaqueTimingInfo(timingInfo) {
    return {
      startTime: timingInfo.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: timingInfo.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  }
  function makePolicyContainer() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  }
  function clonePolicyContainer(policyContainer) {
    return {
      referrerPolicy: policyContainer.referrerPolicy
    };
  }
  function determineRequestsReferrer(request) {
    const policy = request.referrerPolicy;
    assert(policy);
    let referrerSource = null;
    if (request.referrer === "client") {
      const globalOrigin = getGlobalOrigin();
      if (!globalOrigin || globalOrigin.origin === "null") {
        return "no-referrer";
      }
      referrerSource = new URL(globalOrigin);
    } else if (request.referrer instanceof URL) {
      referrerSource = request.referrer;
    }
    let referrerURL = stripURLForReferrer(referrerSource);
    const referrerOrigin = stripURLForReferrer(referrerSource, true);
    if (referrerURL.toString().length > 4096) {
      referrerURL = referrerOrigin;
    }
    const areSameOrigin = sameOrigin(request, referrerURL);
    const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
    switch (policy) {
      case "origin":
        return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
      case "unsafe-url":
        return referrerURL;
      case "same-origin":
        return areSameOrigin ? referrerOrigin : "no-referrer";
      case "origin-when-cross-origin":
        return areSameOrigin ? referrerURL : referrerOrigin;
      case "strict-origin-when-cross-origin": {
        const currentURL = requestCurrentURL(request);
        if (sameOrigin(referrerURL, currentURL)) {
          return referrerURL;
        }
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerOrigin;
      }
      case "strict-origin":
      case "no-referrer-when-downgrade":
      default:
        return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
    }
  }
  function stripURLForReferrer(url, originOnly) {
    assert(url instanceof URL);
    if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
      return "no-referrer";
    }
    url.username = "";
    url.password = "";
    url.hash = "";
    if (originOnly) {
      url.pathname = "";
      url.search = "";
    }
    return url;
  }
  function isURLPotentiallyTrustworthy(url) {
    if (!(url instanceof URL)) {
      return false;
    }
    if (url.href === "about:blank" || url.href === "about:srcdoc") {
      return true;
    }
    if (url.protocol === "data:")
      return true;
    if (url.protocol === "file:")
      return true;
    return isOriginPotentiallyTrustworthy(url.origin);
    function isOriginPotentiallyTrustworthy(origin) {
      if (origin == null || origin === "null")
        return false;
      const originAsURL = new URL(origin);
      if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
        return true;
      }
      if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
        return true;
      }
      return false;
    }
  }
  function bytesMatch(bytes, metadataList) {
    if (crypto === undefined) {
      return true;
    }
    const parsedMetadata = parseMetadata(metadataList);
    if (parsedMetadata === "no metadata") {
      return true;
    }
    if (parsedMetadata.length === 0) {
      return true;
    }
    const strongest = getStrongestMetadata(parsedMetadata);
    const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
    for (const item of metadata) {
      const algorithm = item.algo;
      const expectedValue = item.hash;
      let actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
      if (actualValue[actualValue.length - 1] === "=") {
        if (actualValue[actualValue.length - 2] === "=") {
          actualValue = actualValue.slice(0, -2);
        } else {
          actualValue = actualValue.slice(0, -1);
        }
      }
      if (compareBase64Mixed(actualValue, expectedValue)) {
        return true;
      }
    }
    return false;
  }
  var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
  function parseMetadata(metadata) {
    const result = [];
    let empty = true;
    for (const token of metadata.split(" ")) {
      empty = false;
      const parsedToken = parseHashWithOptions.exec(token);
      if (parsedToken === null || parsedToken.groups === undefined || parsedToken.groups.algo === undefined) {
        continue;
      }
      const algorithm = parsedToken.groups.algo.toLowerCase();
      if (supportedHashes.includes(algorithm)) {
        result.push(parsedToken.groups);
      }
    }
    if (empty === true) {
      return "no metadata";
    }
    return result;
  }
  function getStrongestMetadata(metadataList) {
    let algorithm = metadataList[0].algo;
    if (algorithm[3] === "5") {
      return algorithm;
    }
    for (let i = 1;i < metadataList.length; ++i) {
      const metadata = metadataList[i];
      if (metadata.algo[3] === "5") {
        algorithm = "sha512";
        break;
      } else if (algorithm[3] === "3") {
        continue;
      } else if (metadata.algo[3] === "3") {
        algorithm = "sha384";
      }
    }
    return algorithm;
  }
  function filterMetadataListByAlgorithm(metadataList, algorithm) {
    if (metadataList.length === 1) {
      return metadataList;
    }
    let pos = 0;
    for (let i = 0;i < metadataList.length; ++i) {
      if (metadataList[i].algo === algorithm) {
        metadataList[pos++] = metadataList[i];
      }
    }
    metadataList.length = pos;
    return metadataList;
  }
  function compareBase64Mixed(actualValue, expectedValue) {
    if (actualValue.length !== expectedValue.length) {
      return false;
    }
    for (let i = 0;i < actualValue.length; ++i) {
      if (actualValue[i] !== expectedValue[i]) {
        if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
          continue;
        }
        return false;
      }
    }
    return true;
  }
  function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
  }
  function sameOrigin(A, B) {
    if (A.origin === B.origin && A.origin === "null") {
      return true;
    }
    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
      return true;
    }
    return false;
  }
  function createDeferredPromise() {
    let res;
    let rej;
    const promise = new Promise((resolve, reject) => {
      res = resolve;
      rej = reject;
    });
    return { promise, resolve: res, reject: rej };
  }
  function isAborted(fetchParams) {
    return fetchParams.controller.state === "aborted";
  }
  function isCancelled(fetchParams) {
    return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
  }
  var normalizeMethodRecord = {
    delete: "DELETE",
    DELETE: "DELETE",
    get: "GET",
    GET: "GET",
    head: "HEAD",
    HEAD: "HEAD",
    options: "OPTIONS",
    OPTIONS: "OPTIONS",
    post: "POST",
    POST: "POST",
    put: "PUT",
    PUT: "PUT"
  };
  Object.setPrototypeOf(normalizeMethodRecord, null);
  function normalizeMethod(method) {
    return normalizeMethodRecord[method.toLowerCase()] ?? method;
  }
  function serializeJavascriptValueToJSONString(value) {
    const result = JSON.stringify(value);
    if (result === undefined) {
      throw new TypeError("Value is not JSON serializable");
    }
    assert(typeof result === "string");
    return result;
  }
  var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  function makeIterator(iterator, name, kind) {
    const object = {
      index: 0,
      kind,
      target: iterator
    };
    const i = {
      next() {
        if (Object.getPrototypeOf(this) !== i) {
          throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
        }
        const { index, kind: kind2, target } = object;
        const values = target();
        const len = values.length;
        if (index >= len) {
          return { value: undefined, done: true };
        }
        const pair = values[index];
        object.index = index + 1;
        return iteratorResult(pair, kind2);
      },
      [Symbol.toStringTag]: `${name} Iterator`
    };
    Object.setPrototypeOf(i, esIteratorPrototype);
    return Object.setPrototypeOf({}, i);
  }
  function iteratorResult(pair, kind) {
    let result;
    switch (kind) {
      case "key": {
        result = pair[0];
        break;
      }
      case "value": {
        result = pair[1];
        break;
      }
      case "key+value": {
        result = pair;
        break;
      }
    }
    return { value: result, done: false };
  }
  async function fullyReadBody(body, processBody, processBodyError) {
    const successSteps = processBody;
    const errorSteps = processBodyError;
    let reader;
    try {
      reader = body.stream.getReader();
    } catch (e) {
      errorSteps(e);
      return;
    }
    try {
      const result = await readAllBytes(reader);
      successSteps(result);
    } catch (e) {
      errorSteps(e);
    }
  }
  var ReadableStream2 = globalThis.ReadableStream;
  function isReadableStreamLike(stream) {
    if (!ReadableStream2) {
      ReadableStream2 = __require("stream/web").ReadableStream;
    }
    return stream instanceof ReadableStream2 || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
  }
  var MAXIMUM_ARGUMENT_LENGTH = 65535;
  function isomorphicDecode(input) {
    if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
      return String.fromCharCode(...input);
    }
    return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
  }
  function readableStreamClose(controller) {
    try {
      controller.close();
    } catch (err) {
      if (!err.message.includes("Controller is already closed")) {
        throw err;
      }
    }
  }
  function isomorphicEncode(input) {
    for (let i = 0;i < input.length; i++) {
      assert(input.charCodeAt(i) <= 255);
    }
    return input;
  }
  async function readAllBytes(reader) {
    const bytes = [];
    let byteLength = 0;
    while (true) {
      const { done, value: chunk } = await reader.read();
      if (done) {
        return Buffer.concat(bytes, byteLength);
      }
      if (!isUint8Array(chunk)) {
        throw new TypeError("Received non-Uint8Array chunk");
      }
      bytes.push(chunk);
      byteLength += chunk.length;
    }
  }
  function urlIsLocal(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "about:" || protocol === "blob:" || protocol === "data:";
  }
  function urlHasHttpsScheme(url) {
    if (typeof url === "string") {
      return url.startsWith("https:");
    }
    return url.protocol === "https:";
  }
  function urlIsHttpHttpsScheme(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "http:" || protocol === "https:";
  }
  var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
  module.exports = {
    isAborted,
    isCancelled,
    createDeferredPromise,
    ReadableStreamFrom,
    toUSVString,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    coarsenedSharedCurrentTime,
    determineRequestsReferrer,
    makePolicyContainer,
    clonePolicyContainer,
    appendFetchMetadata,
    appendRequestOriginHeader,
    TAOCheck,
    corsCheck,
    crossOriginResourcePolicyCheck,
    createOpaqueTimingInfo,
    setRequestReferrerPolicyOnRedirect,
    isValidHTTPToken,
    requestBadPort,
    requestCurrentURL,
    responseURL,
    responseLocationURL,
    isBlobLike,
    isURLPotentiallyTrustworthy,
    isValidReasonPhrase,
    sameOrigin,
    normalizeMethod,
    serializeJavascriptValueToJSONString,
    makeIterator,
    isValidHeaderName,
    isValidHeaderValue,
    hasOwn,
    isErrorLike,
    fullyReadBody,
    bytesMatch,
    isReadableStreamLike,
    readableStreamClose,
    isomorphicEncode,
    isomorphicDecode,
    urlIsLocal,
    urlHasHttpsScheme,
    urlIsHttpHttpsScheme,
    readAllBytes,
    normalizeMethodRecord,
    parseMetadata
  };
});

// node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS((exports, module) => {
  module.exports = {
    kUrl: Symbol("url"),
    kHeaders: Symbol("headers"),
    kSignal: Symbol("signal"),
    kState: Symbol("state"),
    kGuard: Symbol("guard"),
    kRealm: Symbol("realm")
  };
});

// node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS((exports, module) => {
  var { types } = __require("util");
  var { hasOwn, toUSVString } = require_util2();
  var webidl = {};
  webidl.converters = {};
  webidl.util = {};
  webidl.errors = {};
  webidl.errors.exception = function(message) {
    return new TypeError(`${message.header}: ${message.message}`);
  };
  webidl.errors.conversionFailed = function(context) {
    const plural = context.types.length === 1 ? "" : " one of";
    const message = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(", ")}.`;
    return webidl.errors.exception({
      header: context.prefix,
      message
    });
  };
  webidl.errors.invalidArgument = function(context) {
    return webidl.errors.exception({
      header: context.prefix,
      message: `"${context.value}" is an invalid ${context.type}.`
    });
  };
  webidl.brandCheck = function(V, I, opts = undefined) {
    if (opts?.strict !== false && !(V instanceof I)) {
      throw new TypeError("Illegal invocation");
    } else {
      return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
    }
  };
  webidl.argumentLengthCheck = function({ length }, min, ctx) {
    if (length < min) {
      throw webidl.errors.exception({
        message: `${min} argument${min !== 1 ? "s" : ""} required, ` + `but${length ? " only" : ""} ${length} found.`,
        ...ctx
      });
    }
  };
  webidl.illegalConstructor = function() {
    throw webidl.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  };
  webidl.util.Type = function(V) {
    switch (typeof V) {
      case "undefined":
        return "Undefined";
      case "boolean":
        return "Boolean";
      case "string":
        return "String";
      case "symbol":
        return "Symbol";
      case "number":
        return "Number";
      case "bigint":
        return "BigInt";
      case "function":
      case "object": {
        if (V === null) {
          return "Null";
        }
        return "Object";
      }
    }
  };
  webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
    let upperBound;
    let lowerBound;
    if (bitLength === 64) {
      upperBound = Math.pow(2, 53) - 1;
      if (signedness === "unsigned") {
        lowerBound = 0;
      } else {
        lowerBound = Math.pow(-2, 53) + 1;
      }
    } else if (signedness === "unsigned") {
      lowerBound = 0;
      upperBound = Math.pow(2, bitLength) - 1;
    } else {
      lowerBound = Math.pow(-2, bitLength) - 1;
      upperBound = Math.pow(2, bitLength - 1) - 1;
    }
    let x = Number(V);
    if (x === 0) {
      x = 0;
    }
    if (opts.enforceRange === true) {
      if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${V} to an integer.`
        });
      }
      x = webidl.util.IntegerPart(x);
      if (x < lowerBound || x > upperBound) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
        });
      }
      return x;
    }
    if (!Number.isNaN(x) && opts.clamp === true) {
      x = Math.min(Math.max(x, lowerBound), upperBound);
      if (Math.floor(x) % 2 === 0) {
        x = Math.floor(x);
      } else {
        x = Math.ceil(x);
      }
      return x;
    }
    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
      return 0;
    }
    x = webidl.util.IntegerPart(x);
    x = x % Math.pow(2, bitLength);
    if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
      return x - Math.pow(2, bitLength);
    }
    return x;
  };
  webidl.util.IntegerPart = function(n) {
    const r = Math.floor(Math.abs(n));
    if (n < 0) {
      return -1 * r;
    }
    return r;
  };
  webidl.sequenceConverter = function(converter) {
    return (V) => {
      if (webidl.util.Type(V) !== "Object") {
        throw webidl.errors.exception({
          header: "Sequence",
          message: `Value of type ${webidl.util.Type(V)} is not an Object.`
        });
      }
      const method = V?.[Symbol.iterator]?.();
      const seq = [];
      if (method === undefined || typeof method.next !== "function") {
        throw webidl.errors.exception({
          header: "Sequence",
          message: "Object is not an iterator."
        });
      }
      while (true) {
        const { done, value } = method.next();
        if (done) {
          break;
        }
        seq.push(converter(value));
      }
      return seq;
    };
  };
  webidl.recordConverter = function(keyConverter, valueConverter) {
    return (O) => {
      if (webidl.util.Type(O) !== "Object") {
        throw webidl.errors.exception({
          header: "Record",
          message: `Value of type ${webidl.util.Type(O)} is not an Object.`
        });
      }
      const result = {};
      if (!types.isProxy(O)) {
        const keys2 = Object.keys(O);
        for (const key of keys2) {
          const typedKey = keyConverter(key);
          const typedValue = valueConverter(O[key]);
          result[typedKey] = typedValue;
        }
        return result;
      }
      const keys = Reflect.ownKeys(O);
      for (const key of keys) {
        const desc = Reflect.getOwnPropertyDescriptor(O, key);
        if (desc?.enumerable) {
          const typedKey = keyConverter(key);
          const typedValue = valueConverter(O[key]);
          result[typedKey] = typedValue;
        }
      }
      return result;
    };
  };
  webidl.interfaceConverter = function(i) {
    return (V, opts = {}) => {
      if (opts.strict !== false && !(V instanceof i)) {
        throw webidl.errors.exception({
          header: i.name,
          message: `Expected ${V} to be an instance of ${i.name}.`
        });
      }
      return V;
    };
  };
  webidl.dictionaryConverter = function(converters) {
    return (dictionary) => {
      const type = webidl.util.Type(dictionary);
      const dict = {};
      if (type === "Null" || type === "Undefined") {
        return dict;
      } else if (type !== "Object") {
        throw webidl.errors.exception({
          header: "Dictionary",
          message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
        });
      }
      for (const options of converters) {
        const { key, defaultValue, required, converter } = options;
        if (required === true) {
          if (!hasOwn(dictionary, key)) {
            throw webidl.errors.exception({
              header: "Dictionary",
              message: `Missing required key "${key}".`
            });
          }
        }
        let value = dictionary[key];
        const hasDefault = hasOwn(options, "defaultValue");
        if (hasDefault && value !== null) {
          value = value ?? defaultValue;
        }
        if (required || hasDefault || value !== undefined) {
          value = converter(value);
          if (options.allowedValues && !options.allowedValues.includes(value)) {
            throw webidl.errors.exception({
              header: "Dictionary",
              message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
            });
          }
          dict[key] = value;
        }
      }
      return dict;
    };
  };
  webidl.nullableConverter = function(converter) {
    return (V) => {
      if (V === null) {
        return V;
      }
      return converter(V);
    };
  };
  webidl.converters.DOMString = function(V, opts = {}) {
    if (V === null && opts.legacyNullToEmptyString) {
      return "";
    }
    if (typeof V === "symbol") {
      throw new TypeError("Could not convert argument of type symbol to string.");
    }
    return String(V);
  };
  webidl.converters.ByteString = function(V) {
    const x = webidl.converters.DOMString(V);
    for (let index = 0;index < x.length; index++) {
      if (x.charCodeAt(index) > 255) {
        throw new TypeError("Cannot convert argument to a ByteString because the character at " + `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);
      }
    }
    return x;
  };
  webidl.converters.USVString = toUSVString;
  webidl.converters.boolean = function(V) {
    const x = Boolean(V);
    return x;
  };
  webidl.converters.any = function(V) {
    return V;
  };
  webidl.converters["long long"] = function(V) {
    const x = webidl.util.ConvertToInt(V, 64, "signed");
    return x;
  };
  webidl.converters["unsigned long long"] = function(V) {
    const x = webidl.util.ConvertToInt(V, 64, "unsigned");
    return x;
  };
  webidl.converters["unsigned long"] = function(V) {
    const x = webidl.util.ConvertToInt(V, 32, "unsigned");
    return x;
  };
  webidl.converters["unsigned short"] = function(V, opts) {
    const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts);
    return x;
  };
  webidl.converters.ArrayBuffer = function(V, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
      throw webidl.errors.conversionFailed({
        prefix: `${V}`,
        argument: `${V}`,
        types: ["ArrayBuffer"]
      });
    }
    if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    return V;
  };
  webidl.converters.TypedArray = function(V, T, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
      throw webidl.errors.conversionFailed({
        prefix: `${T.name}`,
        argument: `${V}`,
        types: [T.name]
      });
    }
    if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    return V;
  };
  webidl.converters.DataView = function(V, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
      throw webidl.errors.exception({
        header: "DataView",
        message: "Object is not a DataView."
      });
    }
    if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    return V;
  };
  webidl.converters.BufferSource = function(V, opts = {}) {
    if (types.isAnyArrayBuffer(V)) {
      return webidl.converters.ArrayBuffer(V, opts);
    }
    if (types.isTypedArray(V)) {
      return webidl.converters.TypedArray(V, V.constructor);
    }
    if (types.isDataView(V)) {
      return webidl.converters.DataView(V, opts);
    }
    throw new TypeError(`Could not convert ${V} to a BufferSource.`);
  };
  webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(webidl.converters.ByteString);
  webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(webidl.converters["sequence<ByteString>"]);
  webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);
  module.exports = {
    webidl
  };
});

// node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS((exports, module) => {
  var assert = __require("assert");
  var { atob: atob2 } = __require("buffer");
  var { isomorphicDecode } = require_util2();
  var encoder = new TextEncoder;
  var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
  var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
  var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
  function dataURLProcessor(dataURL) {
    assert(dataURL.protocol === "data:");
    let input = URLSerializer(dataURL, true);
    input = input.slice(5);
    const position = { position: 0 };
    let mimeType = collectASequenceOfCodePointsFast(",", input, position);
    const mimeTypeLength = mimeType.length;
    mimeType = removeASCIIWhitespace(mimeType, true, true);
    if (position.position >= input.length) {
      return "failure";
    }
    position.position++;
    const encodedBody = input.slice(mimeTypeLength + 1);
    let body = stringPercentDecode(encodedBody);
    if (/;(\u0020){0,}base64$/i.test(mimeType)) {
      const stringBody = isomorphicDecode(body);
      body = forgivingBase64(stringBody);
      if (body === "failure") {
        return "failure";
      }
      mimeType = mimeType.slice(0, -6);
      mimeType = mimeType.replace(/(\u0020)+$/, "");
      mimeType = mimeType.slice(0, -1);
    }
    if (mimeType.startsWith(";")) {
      mimeType = "text/plain" + mimeType;
    }
    let mimeTypeRecord = parseMIMEType(mimeType);
    if (mimeTypeRecord === "failure") {
      mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
    }
    return { mimeType: mimeTypeRecord, body };
  }
  function URLSerializer(url, excludeFragment = false) {
    if (!excludeFragment) {
      return url.href;
    }
    const href = url.href;
    const hashLength = url.hash.length;
    return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
  }
  function collectASequenceOfCodePoints(condition, input, position) {
    let result = "";
    while (position.position < input.length && condition(input[position.position])) {
      result += input[position.position];
      position.position++;
    }
    return result;
  }
  function collectASequenceOfCodePointsFast(char, input, position) {
    const idx = input.indexOf(char, position.position);
    const start = position.position;
    if (idx === -1) {
      position.position = input.length;
      return input.slice(start);
    }
    position.position = idx;
    return input.slice(start, position.position);
  }
  function stringPercentDecode(input) {
    const bytes = encoder.encode(input);
    return percentDecode(bytes);
  }
  function percentDecode(input) {
    const output = [];
    for (let i = 0;i < input.length; i++) {
      const byte = input[i];
      if (byte !== 37) {
        output.push(byte);
      } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
        output.push(37);
      } else {
        const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
        const bytePoint = Number.parseInt(nextTwoBytes, 16);
        output.push(bytePoint);
        i += 2;
      }
    }
    return Uint8Array.from(output);
  }
  function parseMIMEType(input) {
    input = removeHTTPWhitespace(input, true, true);
    const position = { position: 0 };
    const type = collectASequenceOfCodePointsFast("/", input, position);
    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
      return "failure";
    }
    if (position.position > input.length) {
      return "failure";
    }
    position.position++;
    let subtype = collectASequenceOfCodePointsFast(";", input, position);
    subtype = removeHTTPWhitespace(subtype, false, true);
    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
      return "failure";
    }
    const typeLowercase = type.toLowerCase();
    const subtypeLowercase = subtype.toLowerCase();
    const mimeType = {
      type: typeLowercase,
      subtype: subtypeLowercase,
      parameters: new Map,
      essence: `${typeLowercase}/${subtypeLowercase}`
    };
    while (position.position < input.length) {
      position.position++;
      collectASequenceOfCodePoints((char) => HTTP_WHITESPACE_REGEX.test(char), input, position);
      let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
      parameterName = parameterName.toLowerCase();
      if (position.position < input.length) {
        if (input[position.position] === ";") {
          continue;
        }
        position.position++;
      }
      if (position.position > input.length) {
        break;
      }
      let parameterValue = null;
      if (input[position.position] === '"') {
        parameterValue = collectAnHTTPQuotedString(input, position, true);
        collectASequenceOfCodePointsFast(";", input, position);
      } else {
        parameterValue = collectASequenceOfCodePointsFast(";", input, position);
        parameterValue = removeHTTPWhitespace(parameterValue, false, true);
        if (parameterValue.length === 0) {
          continue;
        }
      }
      if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
        mimeType.parameters.set(parameterName, parameterValue);
      }
    }
    return mimeType;
  }
  function forgivingBase64(data) {
    data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
    if (data.length % 4 === 0) {
      data = data.replace(/=?=$/, "");
    }
    if (data.length % 4 === 1) {
      return "failure";
    }
    if (/[^+/0-9A-Za-z]/.test(data)) {
      return "failure";
    }
    const binary = atob2(data);
    const bytes = new Uint8Array(binary.length);
    for (let byte = 0;byte < binary.length; byte++) {
      bytes[byte] = binary.charCodeAt(byte);
    }
    return bytes;
  }
  function collectAnHTTPQuotedString(input, position, extractValue) {
    const positionStart = position.position;
    let value = "";
    assert(input[position.position] === '"');
    position.position++;
    while (true) {
      value += collectASequenceOfCodePoints((char) => char !== '"' && char !== "\\", input, position);
      if (position.position >= input.length) {
        break;
      }
      const quoteOrBackslash = input[position.position];
      position.position++;
      if (quoteOrBackslash === "\\") {
        if (position.position >= input.length) {
          value += "\\";
          break;
        }
        value += input[position.position];
        position.position++;
      } else {
        assert(quoteOrBackslash === '"');
        break;
      }
    }
    if (extractValue) {
      return value;
    }
    return input.slice(positionStart, position.position);
  }
  function serializeAMimeType(mimeType) {
    assert(mimeType !== "failure");
    const { parameters, essence } = mimeType;
    let serialization = essence;
    for (let [name, value] of parameters.entries()) {
      serialization += ";";
      serialization += name;
      serialization += "=";
      if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
        value = value.replace(/(\\|")/g, "\\$1");
        value = '"' + value;
        value += '"';
      }
      serialization += value;
    }
    return serialization;
  }
  function isHTTPWhiteSpace(char) {
    return char === "\r" || char === `
` || char === "\t" || char === " ";
  }
  function removeHTTPWhitespace(str, leading = true, trailing = true) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      for (;lead < str.length && isHTTPWhiteSpace(str[lead]); lead++)
        ;
    }
    if (trailing) {
      for (;trail > 0 && isHTTPWhiteSpace(str[trail]); trail--)
        ;
    }
    return str.slice(lead, trail + 1);
  }
  function isASCIIWhitespace(char) {
    return char === "\r" || char === `
` || char === "\t" || char === "\f" || char === " ";
  }
  function removeASCIIWhitespace(str, leading = true, trailing = true) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      for (;lead < str.length && isASCIIWhitespace(str[lead]); lead++)
        ;
    }
    if (trailing) {
      for (;trail > 0 && isASCIIWhitespace(str[trail]); trail--)
        ;
    }
    return str.slice(lead, trail + 1);
  }
  module.exports = {
    dataURLProcessor,
    URLSerializer,
    collectASequenceOfCodePoints,
    collectASequenceOfCodePointsFast,
    stringPercentDecode,
    parseMIMEType,
    collectAnHTTPQuotedString,
    serializeAMimeType
  };
});

// node_modules/undici/lib/fetch/file.js
var require_file = __commonJS((exports, module) => {
  var { Blob: Blob2, File: NativeFile } = __require("buffer");
  var { types } = __require("util");
  var { kState } = require_symbols2();
  var { isBlobLike } = require_util2();
  var { webidl } = require_webidl();
  var { parseMIMEType, serializeAMimeType } = require_dataURL();
  var { kEnumerableProperty } = require_util();
  var encoder = new TextEncoder;

  class File2 extends Blob2 {
    constructor(fileBits, fileName, options = {}) {
      webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
      fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
      fileName = webidl.converters.USVString(fileName);
      options = webidl.converters.FilePropertyBag(options);
      const n = fileName;
      let t = options.type;
      let d;
      substep: {
        if (t) {
          t = parseMIMEType(t);
          if (t === "failure") {
            t = "";
            break substep;
          }
          t = serializeAMimeType(t).toLowerCase();
        }
        d = options.lastModified;
      }
      super(processBlobParts(fileBits, options), { type: t });
      this[kState] = {
        name: n,
        lastModified: d,
        type: t
      };
    }
    get name() {
      webidl.brandCheck(this, File2);
      return this[kState].name;
    }
    get lastModified() {
      webidl.brandCheck(this, File2);
      return this[kState].lastModified;
    }
    get type() {
      webidl.brandCheck(this, File2);
      return this[kState].type;
    }
  }

  class FileLike {
    constructor(blobLike, fileName, options = {}) {
      const n = fileName;
      const t = options.type;
      const d = options.lastModified ?? Date.now();
      this[kState] = {
        blobLike,
        name: n,
        type: t,
        lastModified: d
      };
    }
    stream(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.stream(...args);
    }
    arrayBuffer(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.arrayBuffer(...args);
    }
    slice(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.slice(...args);
    }
    text(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.text(...args);
    }
    get size() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.size;
    }
    get type() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.type;
    }
    get name() {
      webidl.brandCheck(this, FileLike);
      return this[kState].name;
    }
    get lastModified() {
      webidl.brandCheck(this, FileLike);
      return this[kState].lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
  }
  Object.defineProperties(File2.prototype, {
    [Symbol.toStringTag]: {
      value: "File",
      configurable: true
    },
    name: kEnumerableProperty,
    lastModified: kEnumerableProperty
  });
  webidl.converters.Blob = webidl.interfaceConverter(Blob2);
  webidl.converters.BlobPart = function(V, opts) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
        return webidl.converters.BufferSource(V, opts);
      }
    }
    return webidl.converters.USVString(V, opts);
  };
  webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(webidl.converters.BlobPart);
  webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
    {
      key: "lastModified",
      converter: webidl.converters["long long"],
      get defaultValue() {
        return Date.now();
      }
    },
    {
      key: "type",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "endings",
      converter: (value) => {
        value = webidl.converters.DOMString(value);
        value = value.toLowerCase();
        if (value !== "native") {
          value = "transparent";
        }
        return value;
      },
      defaultValue: "transparent"
    }
  ]);
  function processBlobParts(parts, options) {
    const bytes = [];
    for (const element of parts) {
      if (typeof element === "string") {
        let s = element;
        if (options.endings === "native") {
          s = convertLineEndingsNative(s);
        }
        bytes.push(encoder.encode(s));
      } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
        if (!element.buffer) {
          bytes.push(new Uint8Array(element));
        } else {
          bytes.push(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));
        }
      } else if (isBlobLike(element)) {
        bytes.push(element);
      }
    }
    return bytes;
  }
  function convertLineEndingsNative(s) {
    let nativeLineEnding = `
`;
    if (process.platform === "win32") {
      nativeLineEnding = `\r
`;
    }
    return s.replace(/\r?\n/g, nativeLineEnding);
  }
  function isFileLike(object) {
    return NativeFile && object instanceof NativeFile || object instanceof File2 || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
  }
  module.exports = { File: File2, FileLike, isFileLike };
});

// node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS((exports, module) => {
  var { isBlobLike, toUSVString, makeIterator } = require_util2();
  var { kState } = require_symbols2();
  var { File: UndiciFile, FileLike, isFileLike } = require_file();
  var { webidl } = require_webidl();
  var { Blob: Blob2, File: NativeFile } = __require("buffer");
  var File2 = NativeFile ?? UndiciFile;

  class FormData2 {
    constructor(form) {
      if (form !== undefined) {
        throw webidl.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      }
      this[kState] = [];
    }
    append(name, value, filename = undefined) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
      if (arguments.length === 3 && !isBlobLike(value)) {
        throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
      }
      name = webidl.converters.USVString(name);
      value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
      filename = arguments.length === 3 ? webidl.converters.USVString(filename) : undefined;
      const entry = makeEntry(name, value, filename);
      this[kState].push(entry);
    }
    delete(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
      name = webidl.converters.USVString(name);
      this[kState] = this[kState].filter((entry) => entry.name !== name);
    }
    get(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
      name = webidl.converters.USVString(name);
      const idx = this[kState].findIndex((entry) => entry.name === name);
      if (idx === -1) {
        return null;
      }
      return this[kState][idx].value;
    }
    getAll(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
      name = webidl.converters.USVString(name);
      return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
    }
    has(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
      name = webidl.converters.USVString(name);
      return this[kState].findIndex((entry) => entry.name === name) !== -1;
    }
    set(name, value, filename = undefined) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
      if (arguments.length === 3 && !isBlobLike(value)) {
        throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
      }
      name = webidl.converters.USVString(name);
      value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
      filename = arguments.length === 3 ? toUSVString(filename) : undefined;
      const entry = makeEntry(name, value, filename);
      const idx = this[kState].findIndex((entry2) => entry2.name === name);
      if (idx !== -1) {
        this[kState] = [
          ...this[kState].slice(0, idx),
          entry,
          ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
        ];
      } else {
        this[kState].push(entry);
      }
    }
    entries() {
      webidl.brandCheck(this, FormData2);
      return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "key+value");
    }
    keys() {
      webidl.brandCheck(this, FormData2);
      return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "key");
    }
    values() {
      webidl.brandCheck(this, FormData2);
      return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "value");
    }
    forEach(callbackFn, thisArg = globalThis) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
      if (typeof callbackFn !== "function") {
        throw new TypeError("Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.");
      }
      for (const [key, value] of this) {
        callbackFn.apply(thisArg, [value, key, this]);
      }
    }
  }
  FormData2.prototype[Symbol.iterator] = FormData2.prototype.entries;
  Object.defineProperties(FormData2.prototype, {
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: true
    }
  });
  function makeEntry(name, value, filename) {
    name = Buffer.from(name).toString("utf8");
    if (typeof value === "string") {
      value = Buffer.from(value).toString("utf8");
    } else {
      if (!isFileLike(value)) {
        value = value instanceof Blob2 ? new File2([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
      }
      if (filename !== undefined) {
        const options = {
          type: value.type,
          lastModified: value.lastModified
        };
        value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File2([value], filename, options) : new FileLike(value, filename, options);
      }
    }
    return { name, value };
  }
  module.exports = { FormData: FormData2 };
});

// node_modules/undici/lib/fetch/body.js
var require_body = __commonJS((exports, module) => {
  var Busboy = require_main();
  var util = require_util();
  var {
    ReadableStreamFrom,
    isBlobLike,
    isReadableStreamLike,
    readableStreamClose,
    createDeferredPromise,
    fullyReadBody
  } = require_util2();
  var { FormData: FormData2 } = require_formdata();
  var { kState } = require_symbols2();
  var { webidl } = require_webidl();
  var { DOMException: DOMException2, structuredClone } = require_constants2();
  var { Blob: Blob2, File: NativeFile } = __require("buffer");
  var { kBodyUsed } = require_symbols();
  var assert = __require("assert");
  var { isErrored } = require_util();
  var { isUint8Array, isArrayBuffer } = __require("util/types");
  var { File: UndiciFile } = require_file();
  var { parseMIMEType, serializeAMimeType } = require_dataURL();
  var random;
  try {
    const crypto = __require("node:crypto");
    random = (max) => crypto.randomInt(0, max);
  } catch {
    random = (max) => Math.floor(Math.random(max));
  }
  var ReadableStream2 = globalThis.ReadableStream;
  var File2 = NativeFile ?? UndiciFile;
  var textEncoder = new TextEncoder;
  var textDecoder = new TextDecoder;
  function extractBody(object, keepalive = false) {
    if (!ReadableStream2) {
      ReadableStream2 = __require("stream/web").ReadableStream;
    }
    let stream = null;
    if (object instanceof ReadableStream2) {
      stream = object;
    } else if (isBlobLike(object)) {
      stream = object.stream();
    } else {
      stream = new ReadableStream2({
        async pull(controller) {
          controller.enqueue(typeof source === "string" ? textEncoder.encode(source) : source);
          queueMicrotask(() => readableStreamClose(controller));
        },
        start() {
        },
        type: undefined
      });
    }
    assert(isReadableStreamLike(stream));
    let action = null;
    let source = null;
    let length = null;
    let type = null;
    if (typeof object === "string") {
      source = object;
      type = "text/plain;charset=UTF-8";
    } else if (object instanceof URLSearchParams) {
      source = object.toString();
      type = "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isArrayBuffer(object)) {
      source = new Uint8Array(object.slice());
    } else if (ArrayBuffer.isView(object)) {
      source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
    } else if (util.isFormDataLike(object)) {
      const boundary = `----formdata-undici-0${`${random(100000000000)}`.padStart(11, "0")}`;
      const prefix = `--${boundary}\r
Content-Disposition: form-data`;
      /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
      const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
      const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, `\r
`);
      const blobParts = [];
      const rn = new Uint8Array([13, 10]);
      length = 0;
      let hasUnknownSizeValue = false;
      for (const [name, value] of object) {
        if (typeof value === "string") {
          const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"` + `\r
\r
${normalizeLinefeeds(value)}\r
`);
          blobParts.push(chunk2);
          length += chunk2.byteLength;
        } else {
          const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
` + `Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
          blobParts.push(chunk2, value, rn);
          if (typeof value.size === "number") {
            length += chunk2.byteLength + value.size + rn.byteLength;
          } else {
            hasUnknownSizeValue = true;
          }
        }
      }
      const chunk = textEncoder.encode(`--${boundary}--`);
      blobParts.push(chunk);
      length += chunk.byteLength;
      if (hasUnknownSizeValue) {
        length = null;
      }
      source = object;
      action = async function* () {
        for (const part of blobParts) {
          if (part.stream) {
            yield* part.stream();
          } else {
            yield part;
          }
        }
      };
      type = "multipart/form-data; boundary=" + boundary;
    } else if (isBlobLike(object)) {
      source = object;
      length = object.size;
      if (object.type) {
        type = object.type;
      }
    } else if (typeof object[Symbol.asyncIterator] === "function") {
      if (keepalive) {
        throw new TypeError("keepalive");
      }
      if (util.isDisturbed(object) || object.locked) {
        throw new TypeError("Response body object should not be disturbed or locked");
      }
      stream = object instanceof ReadableStream2 ? object : ReadableStreamFrom(object);
    }
    if (typeof source === "string" || util.isBuffer(source)) {
      length = Buffer.byteLength(source);
    }
    if (action != null) {
      let iterator;
      stream = new ReadableStream2({
        async start() {
          iterator = action(object)[Symbol.asyncIterator]();
        },
        async pull(controller) {
          const { value, done } = await iterator.next();
          if (done) {
            queueMicrotask(() => {
              controller.close();
            });
          } else {
            if (!isErrored(stream)) {
              controller.enqueue(new Uint8Array(value));
            }
          }
          return controller.desiredSize > 0;
        },
        async cancel(reason) {
          await iterator.return();
        },
        type: undefined
      });
    }
    const body = { stream, source, length };
    return [body, type];
  }
  function safelyExtractBody(object, keepalive = false) {
    if (!ReadableStream2) {
      ReadableStream2 = __require("stream/web").ReadableStream;
    }
    if (object instanceof ReadableStream2) {
      assert(!util.isDisturbed(object), "The body has already been consumed.");
      assert(!object.locked, "The stream is locked.");
    }
    return extractBody(object, keepalive);
  }
  function cloneBody(body) {
    const [out1, out2] = body.stream.tee();
    const out2Clone = structuredClone(out2, { transfer: [out2] });
    const [, finalClone] = out2Clone.tee();
    body.stream = out1;
    return {
      stream: finalClone,
      length: body.length,
      source: body.source
    };
  }
  async function* consumeBody(body) {
    if (body) {
      if (isUint8Array(body)) {
        yield body;
      } else {
        const stream = body.stream;
        if (util.isDisturbed(stream)) {
          throw new TypeError("The body has already been consumed.");
        }
        if (stream.locked) {
          throw new TypeError("The stream is locked.");
        }
        stream[kBodyUsed] = true;
        yield* stream;
      }
    }
  }
  function throwIfAborted(state) {
    if (state.aborted) {
      throw new DOMException2("The operation was aborted.", "AbortError");
    }
  }
  function bodyMixinMethods(instance) {
    const methods = {
      blob() {
        return specConsumeBody(this, (bytes) => {
          let mimeType = bodyMimeType(this);
          if (mimeType === "failure") {
            mimeType = "";
          } else if (mimeType) {
            mimeType = serializeAMimeType(mimeType);
          }
          return new Blob2([bytes], { type: mimeType });
        }, instance);
      },
      arrayBuffer() {
        return specConsumeBody(this, (bytes) => {
          return new Uint8Array(bytes).buffer;
        }, instance);
      },
      text() {
        return specConsumeBody(this, utf8DecodeBytes, instance);
      },
      json() {
        return specConsumeBody(this, parseJSONFromBytes, instance);
      },
      async formData() {
        webidl.brandCheck(this, instance);
        throwIfAborted(this[kState]);
        const contentType = this.headers.get("Content-Type");
        if (/multipart\/form-data/.test(contentType)) {
          const headers = {};
          for (const [key, value] of this.headers)
            headers[key.toLowerCase()] = value;
          const responseFormData = new FormData2;
          let busboy;
          try {
            busboy = new Busboy({
              headers,
              preservePath: true
            });
          } catch (err) {
            throw new DOMException2(`${err}`, "AbortError");
          }
          busboy.on("field", (name, value) => {
            responseFormData.append(name, value);
          });
          busboy.on("file", (name, value, filename, encoding, mimeType) => {
            const chunks = [];
            if (encoding === "base64" || encoding.toLowerCase() === "base64") {
              let base64chunk = "";
              value.on("data", (chunk) => {
                base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                const end = base64chunk.length - base64chunk.length % 4;
                chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                base64chunk = base64chunk.slice(end);
              });
              value.on("end", () => {
                chunks.push(Buffer.from(base64chunk, "base64"));
                responseFormData.append(name, new File2(chunks, filename, { type: mimeType }));
              });
            } else {
              value.on("data", (chunk) => {
                chunks.push(chunk);
              });
              value.on("end", () => {
                responseFormData.append(name, new File2(chunks, filename, { type: mimeType }));
              });
            }
          });
          const busboyResolve = new Promise((resolve, reject) => {
            busboy.on("finish", resolve);
            busboy.on("error", (err) => reject(new TypeError(err)));
          });
          if (this.body !== null)
            for await (const chunk of consumeBody(this[kState].body))
              busboy.write(chunk);
          busboy.end();
          await busboyResolve;
          return responseFormData;
        } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
          let entries;
          try {
            let text = "";
            const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
            for await (const chunk of consumeBody(this[kState].body)) {
              if (!isUint8Array(chunk)) {
                throw new TypeError("Expected Uint8Array chunk");
              }
              text += streamingDecoder.decode(chunk, { stream: true });
            }
            text += streamingDecoder.decode();
            entries = new URLSearchParams(text);
          } catch (err) {
            throw Object.assign(new TypeError, { cause: err });
          }
          const formData = new FormData2;
          for (const [name, value] of entries) {
            formData.append(name, value);
          }
          return formData;
        } else {
          await Promise.resolve();
          throwIfAborted(this[kState]);
          throw webidl.errors.exception({
            header: `${instance.name}.formData`,
            message: "Could not parse content as FormData."
          });
        }
      }
    };
    return methods;
  }
  function mixinBody(prototype) {
    Object.assign(prototype.prototype, bodyMixinMethods(prototype));
  }
  async function specConsumeBody(object, convertBytesToJSValue, instance) {
    webidl.brandCheck(object, instance);
    throwIfAborted(object[kState]);
    if (bodyUnusable(object[kState].body)) {
      throw new TypeError("Body is unusable");
    }
    const promise = createDeferredPromise();
    const errorSteps = (error) => promise.reject(error);
    const successSteps = (data) => {
      try {
        promise.resolve(convertBytesToJSValue(data));
      } catch (e) {
        errorSteps(e);
      }
    };
    if (object[kState].body == null) {
      successSteps(new Uint8Array);
      return promise.promise;
    }
    await fullyReadBody(object[kState].body, successSteps, errorSteps);
    return promise.promise;
  }
  function bodyUnusable(body) {
    return body != null && (body.stream.locked || util.isDisturbed(body.stream));
  }
  function utf8DecodeBytes(buffer) {
    if (buffer.length === 0) {
      return "";
    }
    if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
      buffer = buffer.subarray(3);
    }
    const output = textDecoder.decode(buffer);
    return output;
  }
  function parseJSONFromBytes(bytes) {
    return JSON.parse(utf8DecodeBytes(bytes));
  }
  function bodyMimeType(object) {
    const { headersList } = object[kState];
    const contentType = headersList.get("content-type");
    if (contentType === null) {
      return "failure";
    }
    return parseMIMEType(contentType);
  }
  module.exports = {
    extractBody,
    safelyExtractBody,
    cloneBody,
    mixinBody
  };
});

// node_modules/undici/lib/core/request.js
var require_request = __commonJS((exports, module) => {
  var {
    InvalidArgumentError,
    NotSupportedError
  } = require_errors();
  var assert = __require("assert");
  var { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols();
  var util = require_util();
  var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
  var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  var invalidPathRegex = /[^\u0021-\u00ff]/;
  var kHandler = Symbol("handler");
  var channels = {};
  var extractBody;
  try {
    const diagnosticsChannel = __require("diagnostics_channel");
    channels.create = diagnosticsChannel.channel("undici:request:create");
    channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
    channels.headers = diagnosticsChannel.channel("undici:request:headers");
    channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
    channels.error = diagnosticsChannel.channel("undici:request:error");
  } catch {
    channels.create = { hasSubscribers: false };
    channels.bodySent = { hasSubscribers: false };
    channels.headers = { hasSubscribers: false };
    channels.trailers = { hasSubscribers: false };
    channels.error = { hasSubscribers: false };
  }

  class Request {
    constructor(origin, {
      path,
      method,
      body,
      headers,
      query,
      idempotent,
      blocking,
      upgrade,
      headersTimeout,
      bodyTimeout,
      reset,
      throwOnError,
      expectContinue
    }, handler) {
      if (typeof path !== "string") {
        throw new InvalidArgumentError("path must be a string");
      } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") {
        throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
      } else if (invalidPathRegex.exec(path) !== null) {
        throw new InvalidArgumentError("invalid request path");
      }
      if (typeof method !== "string") {
        throw new InvalidArgumentError("method must be a string");
      } else if (tokenRegExp.exec(method) === null) {
        throw new InvalidArgumentError("invalid request method");
      }
      if (upgrade && typeof upgrade !== "string") {
        throw new InvalidArgumentError("upgrade must be a string");
      }
      if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("invalid headersTimeout");
      }
      if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("invalid bodyTimeout");
      }
      if (reset != null && typeof reset !== "boolean") {
        throw new InvalidArgumentError("invalid reset");
      }
      if (expectContinue != null && typeof expectContinue !== "boolean") {
        throw new InvalidArgumentError("invalid expectContinue");
      }
      this.headersTimeout = headersTimeout;
      this.bodyTimeout = bodyTimeout;
      this.throwOnError = throwOnError === true;
      this.method = method;
      this.abort = null;
      if (body == null) {
        this.body = null;
      } else if (util.isStream(body)) {
        this.body = body;
        const rState = this.body._readableState;
        if (!rState || !rState.autoDestroy) {
          this.endHandler = function autoDestroy() {
            util.destroy(this);
          };
          this.body.on("end", this.endHandler);
        }
        this.errorHandler = (err) => {
          if (this.abort) {
            this.abort(err);
          } else {
            this.error = err;
          }
        };
        this.body.on("error", this.errorHandler);
      } else if (util.isBuffer(body)) {
        this.body = body.byteLength ? body : null;
      } else if (ArrayBuffer.isView(body)) {
        this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
      } else if (body instanceof ArrayBuffer) {
        this.body = body.byteLength ? Buffer.from(body) : null;
      } else if (typeof body === "string") {
        this.body = body.length ? Buffer.from(body) : null;
      } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
        this.body = body;
      } else {
        throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
      }
      this.completed = false;
      this.aborted = false;
      this.upgrade = upgrade || null;
      this.path = query ? util.buildURL(path, query) : path;
      this.origin = origin;
      this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
      this.blocking = blocking == null ? false : blocking;
      this.reset = reset == null ? null : reset;
      this.host = null;
      this.contentLength = null;
      this.contentType = null;
      this.headers = "";
      this.expectContinue = expectContinue != null ? expectContinue : false;
      if (Array.isArray(headers)) {
        if (headers.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i = 0;i < headers.length; i += 2) {
          processHeader(this, headers[i], headers[i + 1]);
        }
      } else if (headers && typeof headers === "object") {
        const keys = Object.keys(headers);
        for (let i = 0;i < keys.length; i++) {
          const key = keys[i];
          processHeader(this, key, headers[key]);
        }
      } else if (headers != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      if (util.isFormDataLike(this.body)) {
        if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {
          throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
        }
        if (!extractBody) {
          extractBody = require_body().extractBody;
        }
        const [bodyStream, contentType] = extractBody(body);
        if (this.contentType == null) {
          this.contentType = contentType;
          this.headers += `content-type: ${contentType}\r
`;
        }
        this.body = bodyStream.stream;
        this.contentLength = bodyStream.length;
      } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
        this.contentType = body.type;
        this.headers += `content-type: ${body.type}\r
`;
      }
      util.validateHandler(handler, method, upgrade);
      this.servername = util.getServerName(this.host);
      this[kHandler] = handler;
      if (channels.create.hasSubscribers) {
        channels.create.publish({ request: this });
      }
    }
    onBodySent(chunk) {
      if (this[kHandler].onBodySent) {
        try {
          return this[kHandler].onBodySent(chunk);
        } catch (err) {
          this.abort(err);
        }
      }
    }
    onRequestSent() {
      if (channels.bodySent.hasSubscribers) {
        channels.bodySent.publish({ request: this });
      }
      if (this[kHandler].onRequestSent) {
        try {
          return this[kHandler].onRequestSent();
        } catch (err) {
          this.abort(err);
        }
      }
    }
    onConnect(abort) {
      assert(!this.aborted);
      assert(!this.completed);
      if (this.error) {
        abort(this.error);
      } else {
        this.abort = abort;
        return this[kHandler].onConnect(abort);
      }
    }
    onHeaders(statusCode, headers, resume, statusText) {
      assert(!this.aborted);
      assert(!this.completed);
      if (channels.headers.hasSubscribers) {
        channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
      }
      try {
        return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
      } catch (err) {
        this.abort(err);
      }
    }
    onData(chunk) {
      assert(!this.aborted);
      assert(!this.completed);
      try {
        return this[kHandler].onData(chunk);
      } catch (err) {
        this.abort(err);
        return false;
      }
    }
    onUpgrade(statusCode, headers, socket) {
      assert(!this.aborted);
      assert(!this.completed);
      return this[kHandler].onUpgrade(statusCode, headers, socket);
    }
    onComplete(trailers) {
      this.onFinally();
      assert(!this.aborted);
      this.completed = true;
      if (channels.trailers.hasSubscribers) {
        channels.trailers.publish({ request: this, trailers });
      }
      try {
        return this[kHandler].onComplete(trailers);
      } catch (err) {
        this.onError(err);
      }
    }
    onError(error) {
      this.onFinally();
      if (channels.error.hasSubscribers) {
        channels.error.publish({ request: this, error });
      }
      if (this.aborted) {
        return;
      }
      this.aborted = true;
      return this[kHandler].onError(error);
    }
    onFinally() {
      if (this.errorHandler) {
        this.body.off("error", this.errorHandler);
        this.errorHandler = null;
      }
      if (this.endHandler) {
        this.body.off("end", this.endHandler);
        this.endHandler = null;
      }
    }
    addHeader(key, value) {
      processHeader(this, key, value);
      return this;
    }
    static [kHTTP1BuildRequest](origin, opts, handler) {
      return new Request(origin, opts, handler);
    }
    static [kHTTP2BuildRequest](origin, opts, handler) {
      const headers = opts.headers;
      opts = { ...opts, headers: null };
      const request = new Request(origin, opts, handler);
      request.headers = {};
      if (Array.isArray(headers)) {
        if (headers.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i = 0;i < headers.length; i += 2) {
          processHeader(request, headers[i], headers[i + 1], true);
        }
      } else if (headers && typeof headers === "object") {
        const keys = Object.keys(headers);
        for (let i = 0;i < keys.length; i++) {
          const key = keys[i];
          processHeader(request, key, headers[key], true);
        }
      } else if (headers != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      return request;
    }
    static [kHTTP2CopyHeaders](raw) {
      const rawHeaders = raw.split(`\r
`);
      const headers = {};
      for (const header of rawHeaders) {
        const [key, value] = header.split(": ");
        if (value == null || value.length === 0)
          continue;
        if (headers[key])
          headers[key] += `,${value}`;
        else
          headers[key] = value;
      }
      return headers;
    }
  }
  function processHeaderValue(key, val, skipAppend) {
    if (val && typeof val === "object") {
      throw new InvalidArgumentError(`invalid ${key} header`);
    }
    val = val != null ? `${val}` : "";
    if (headerCharRegex.exec(val) !== null) {
      throw new InvalidArgumentError(`invalid ${key} header`);
    }
    return skipAppend ? val : `${key}: ${val}\r
`;
  }
  function processHeader(request, key, val, skipAppend = false) {
    if (val && (typeof val === "object" && !Array.isArray(val))) {
      throw new InvalidArgumentError(`invalid ${key} header`);
    } else if (val === undefined) {
      return;
    }
    if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
      if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      request.host = val;
    } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
      request.contentLength = parseInt(val, 10);
      if (!Number.isFinite(request.contentLength)) {
        throw new InvalidArgumentError("invalid content-length header");
      }
    } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
      request.contentType = val;
      if (skipAppend)
        request.headers[key] = processHeaderValue(key, val, skipAppend);
      else
        request.headers += processHeaderValue(key, val);
    } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
      throw new InvalidArgumentError("invalid transfer-encoding header");
    } else if (key.length === 10 && key.toLowerCase() === "connection") {
      const value = typeof val === "string" ? val.toLowerCase() : null;
      if (value !== "close" && value !== "keep-alive") {
        throw new InvalidArgumentError("invalid connection header");
      } else if (value === "close") {
        request.reset = true;
      }
    } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
      throw new InvalidArgumentError("invalid keep-alive header");
    } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
      throw new InvalidArgumentError("invalid upgrade header");
    } else if (key.length === 6 && key.toLowerCase() === "expect") {
      throw new NotSupportedError("expect header not supported");
    } else if (tokenRegExp.exec(key) === null) {
      throw new InvalidArgumentError("invalid header key");
    } else {
      if (Array.isArray(val)) {
        for (let i = 0;i < val.length; i++) {
          if (skipAppend) {
            if (request.headers[key])
              request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
            else
              request.headers[key] = processHeaderValue(key, val[i], skipAppend);
          } else {
            request.headers += processHeaderValue(key, val[i]);
          }
        }
      } else {
        if (skipAppend)
          request.headers[key] = processHeaderValue(key, val, skipAppend);
        else
          request.headers += processHeaderValue(key, val);
      }
    }
  }
  module.exports = Request;
});

// node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS((exports, module) => {
  var EventEmitter = __require("events");

  class Dispatcher extends EventEmitter {
    dispatch() {
      throw new Error("not implemented");
    }
    close() {
      throw new Error("not implemented");
    }
    destroy() {
      throw new Error("not implemented");
    }
  }
  module.exports = Dispatcher;
});

// node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS((exports, module) => {
  var Dispatcher = require_dispatcher();
  var {
    ClientDestroyedError,
    ClientClosedError,
    InvalidArgumentError
  } = require_errors();
  var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
  var kDestroyed = Symbol("destroyed");
  var kClosed = Symbol("closed");
  var kOnDestroyed = Symbol("onDestroyed");
  var kOnClosed = Symbol("onClosed");
  var kInterceptedDispatch = Symbol("Intercepted Dispatch");

  class DispatcherBase extends Dispatcher {
    constructor() {
      super();
      this[kDestroyed] = false;
      this[kOnDestroyed] = null;
      this[kClosed] = false;
      this[kOnClosed] = [];
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosed];
    }
    get interceptors() {
      return this[kInterceptors];
    }
    set interceptors(newInterceptors) {
      if (newInterceptors) {
        for (let i = newInterceptors.length - 1;i >= 0; i--) {
          const interceptor = this[kInterceptors][i];
          if (typeof interceptor !== "function") {
            throw new InvalidArgumentError("interceptor must be an function");
          }
        }
      }
      this[kInterceptors] = newInterceptors;
    }
    close(callback) {
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          this.close((err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        queueMicrotask(() => callback(new ClientDestroyedError, null));
        return;
      }
      if (this[kClosed]) {
        if (this[kOnClosed]) {
          this[kOnClosed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      this[kClosed] = true;
      this[kOnClosed].push(callback);
      const onClosed = () => {
        const callbacks = this[kOnClosed];
        this[kOnClosed] = null;
        for (let i = 0;i < callbacks.length; i++) {
          callbacks[i](null, null);
        }
      };
      this[kClose]().then(() => this.destroy()).then(() => {
        queueMicrotask(onClosed);
      });
    }
    destroy(err, callback) {
      if (typeof err === "function") {
        callback = err;
        err = null;
      }
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          this.destroy(err, (err2, data) => {
            return err2 ? reject(err2) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        if (this[kOnDestroyed]) {
          this[kOnDestroyed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      if (!err) {
        err = new ClientDestroyedError;
      }
      this[kDestroyed] = true;
      this[kOnDestroyed] = this[kOnDestroyed] || [];
      this[kOnDestroyed].push(callback);
      const onDestroyed = () => {
        const callbacks = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (let i = 0;i < callbacks.length; i++) {
          callbacks[i](null, null);
        }
      };
      this[kDestroy](err).then(() => {
        queueMicrotask(onDestroyed);
      });
    }
    [kInterceptedDispatch](opts, handler) {
      if (!this[kInterceptors] || this[kInterceptors].length === 0) {
        this[kInterceptedDispatch] = this[kDispatch];
        return this[kDispatch](opts, handler);
      }
      let dispatch = this[kDispatch].bind(this);
      for (let i = this[kInterceptors].length - 1;i >= 0; i--) {
        dispatch = this[kInterceptors][i](dispatch);
      }
      this[kInterceptedDispatch] = dispatch;
      return dispatch(opts, handler);
    }
    dispatch(opts, handler) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      try {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object.");
        }
        if (this[kDestroyed] || this[kOnDestroyed]) {
          throw new ClientDestroyedError;
        }
        if (this[kClosed]) {
          throw new ClientClosedError;
        }
        return this[kInterceptedDispatch](opts, handler);
      } catch (err) {
        if (typeof handler.onError !== "function") {
          throw new InvalidArgumentError("invalid onError method");
        }
        handler.onError(err);
        return false;
      }
    }
  }
  module.exports = DispatcherBase;
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS((exports, module) => {
  var net = __require("net");
  var assert = __require("assert");
  var util = require_util();
  var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
  var tls;
  var SessionCache;
  if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
    SessionCache = class WeakSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = new Map;
        this._sessionRegistry = new global.FinalizationRegistry((key) => {
          if (this._sessionCache.size < this._maxCachedSessions) {
            return;
          }
          const ref = this._sessionCache.get(key);
          if (ref !== undefined && ref.deref() === undefined) {
            this._sessionCache.delete(key);
          }
        });
      }
      get(sessionKey) {
        const ref = this._sessionCache.get(sessionKey);
        return ref ? ref.deref() : null;
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        this._sessionCache.set(sessionKey, new WeakRef(session));
        this._sessionRegistry.register(session, sessionKey);
      }
    };
  } else {
    SessionCache = class SimpleSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = new Map;
      }
      get(sessionKey) {
        return this._sessionCache.get(sessionKey);
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        if (this._sessionCache.size >= this._maxCachedSessions) {
          const { value: oldestKey } = this._sessionCache.keys().next();
          this._sessionCache.delete(oldestKey);
        }
        this._sessionCache.set(sessionKey, session);
      }
    };
  }
  function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
      throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
    }
    const options = { path: socketPath, ...opts };
    const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
    timeout = timeout == null ? 1e4 : timeout;
    allowH2 = allowH2 != null ? allowH2 : false;
    return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
      let socket;
      if (protocol === "https:") {
        if (!tls) {
          tls = __require("tls");
        }
        servername = servername || options.servername || util.getServerName(host) || null;
        const sessionKey = servername || hostname;
        const session = sessionCache.get(sessionKey) || null;
        assert(sessionKey);
        socket = tls.connect({
          highWaterMark: 16384,
          ...options,
          servername,
          session,
          localAddress,
          ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
          socket: httpSocket,
          port: port || 443,
          host: hostname
        });
        socket.on("session", function(session2) {
          sessionCache.set(sessionKey, session2);
        });
      } else {
        assert(!httpSocket, "httpSocket can only be sent on TLS update");
        socket = net.connect({
          highWaterMark: 64 * 1024,
          ...options,
          localAddress,
          port: port || 80,
          host: hostname
        });
      }
      if (options.keepAlive == null || options.keepAlive) {
        const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60000 : options.keepAliveInitialDelay;
        socket.setKeepAlive(true, keepAliveInitialDelay);
      }
      const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
      socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
        cancelTimeout();
        if (callback) {
          const cb = callback;
          callback = null;
          cb(null, this);
        }
      }).on("error", function(err) {
        cancelTimeout();
        if (callback) {
          const cb = callback;
          callback = null;
          cb(err);
        }
      });
      return socket;
    };
  }
  function setupTimeout(onConnectTimeout2, timeout) {
    if (!timeout) {
      return () => {
      };
    }
    let s1 = null;
    let s2 = null;
    const timeoutId = setTimeout(() => {
      s1 = setImmediate(() => {
        if (process.platform === "win32") {
          s2 = setImmediate(() => onConnectTimeout2());
        } else {
          onConnectTimeout2();
        }
      });
    }, timeout);
    return () => {
      clearTimeout(timeoutId);
      clearImmediate(s1);
      clearImmediate(s2);
    };
  }
  function onConnectTimeout(socket) {
    util.destroy(socket, new ConnectTimeoutError);
  }
  module.exports = buildConnector;
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.enumToMap = undefined;
  function enumToMap(obj) {
    const res = {};
    Object.keys(obj).forEach((key) => {
      const value = obj[key];
      if (typeof value === "number") {
        res[key] = value;
      }
    });
    return res;
  }
  exports.enumToMap = enumToMap;
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = undefined;
  var utils_1 = require_utils2();
  var ERROR;
  (function(ERROR2) {
    ERROR2[ERROR2["OK"] = 0] = "OK";
    ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
    ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
    ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
    ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
    ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
    ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
    ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
    ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
    ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
    ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
    ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
    ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
    ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
    ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
    ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
    ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
    ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
    ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
    ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
    ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
    ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
    ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
    ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
    ERROR2[ERROR2["USER"] = 24] = "USER";
  })(ERROR = exports.ERROR || (exports.ERROR = {}));
  var TYPE;
  (function(TYPE2) {
    TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
    TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
    TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
  })(TYPE = exports.TYPE || (exports.TYPE = {}));
  var FLAGS;
  (function(FLAGS2) {
    FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
    FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
    FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
    FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
    FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
    FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
    FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
    FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
    FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
  })(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
  var LENIENT_FLAGS;
  (function(LENIENT_FLAGS2) {
    LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
    LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
    LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
  })(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
  var METHODS;
  (function(METHODS2) {
    METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
    METHODS2[METHODS2["GET"] = 1] = "GET";
    METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
    METHODS2[METHODS2["POST"] = 3] = "POST";
    METHODS2[METHODS2["PUT"] = 4] = "PUT";
    METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
    METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
    METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
    METHODS2[METHODS2["COPY"] = 8] = "COPY";
    METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
    METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
    METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
    METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
    METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
    METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
    METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
    METHODS2[METHODS2["BIND"] = 16] = "BIND";
    METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
    METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
    METHODS2[METHODS2["ACL"] = 19] = "ACL";
    METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
    METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
    METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
    METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
    METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
    METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
    METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
    METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
    METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
    METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
    METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
    METHODS2[METHODS2["LINK"] = 31] = "LINK";
    METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
    METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
    METHODS2[METHODS2["PRI"] = 34] = "PRI";
    METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
    METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
    METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
    METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
    METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
    METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
    METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
    METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
    METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
    METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
    METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
  })(METHODS = exports.METHODS || (exports.METHODS = {}));
  exports.METHODS_HTTP = [
    METHODS.DELETE,
    METHODS.GET,
    METHODS.HEAD,
    METHODS.POST,
    METHODS.PUT,
    METHODS.CONNECT,
    METHODS.OPTIONS,
    METHODS.TRACE,
    METHODS.COPY,
    METHODS.LOCK,
    METHODS.MKCOL,
    METHODS.MOVE,
    METHODS.PROPFIND,
    METHODS.PROPPATCH,
    METHODS.SEARCH,
    METHODS.UNLOCK,
    METHODS.BIND,
    METHODS.REBIND,
    METHODS.UNBIND,
    METHODS.ACL,
    METHODS.REPORT,
    METHODS.MKACTIVITY,
    METHODS.CHECKOUT,
    METHODS.MERGE,
    METHODS["M-SEARCH"],
    METHODS.NOTIFY,
    METHODS.SUBSCRIBE,
    METHODS.UNSUBSCRIBE,
    METHODS.PATCH,
    METHODS.PURGE,
    METHODS.MKCALENDAR,
    METHODS.LINK,
    METHODS.UNLINK,
    METHODS.PRI,
    METHODS.SOURCE
  ];
  exports.METHODS_ICE = [
    METHODS.SOURCE
  ];
  exports.METHODS_RTSP = [
    METHODS.OPTIONS,
    METHODS.DESCRIBE,
    METHODS.ANNOUNCE,
    METHODS.SETUP,
    METHODS.PLAY,
    METHODS.PAUSE,
    METHODS.TEARDOWN,
    METHODS.GET_PARAMETER,
    METHODS.SET_PARAMETER,
    METHODS.REDIRECT,
    METHODS.RECORD,
    METHODS.FLUSH,
    METHODS.GET,
    METHODS.POST
  ];
  exports.METHOD_MAP = utils_1.enumToMap(METHODS);
  exports.H_METHOD_MAP = {};
  Object.keys(exports.METHOD_MAP).forEach((key) => {
    if (/^H/.test(key)) {
      exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
    }
  });
  var FINISH;
  (function(FINISH2) {
    FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
    FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
    FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
  })(FINISH = exports.FINISH || (exports.FINISH = {}));
  exports.ALPHA = [];
  for (let i = 65;i <= 90; i++) {
    exports.ALPHA.push(String.fromCharCode(i));
    exports.ALPHA.push(String.fromCharCode(i + 32));
  }
  exports.NUM_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9
  };
  exports.HEX_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
  };
  exports.NUM = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9"
  ];
  exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
  exports.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
  exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
  exports.STRICT_URL_CHAR = [
    "!",
    '"',
    "$",
    "%",
    "&",
    "'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "@",
    "[",
    "\\",
    "]",
    "^",
    "_",
    "`",
    "{",
    "|",
    "}",
    "~"
  ].concat(exports.ALPHANUM);
  exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["\t", "\f"]);
  for (let i = 128;i <= 255; i++) {
    exports.URL_CHAR.push(i);
  }
  exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
  exports.STRICT_TOKEN = [
    "!",
    "#",
    "$",
    "%",
    "&",
    "'",
    "*",
    "+",
    "-",
    ".",
    "^",
    "_",
    "`",
    "|",
    "~"
  ].concat(exports.ALPHANUM);
  exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
  exports.HEADER_CHARS = ["\t"];
  for (let i = 32;i <= 255; i++) {
    if (i !== 127) {
      exports.HEADER_CHARS.push(i);
    }
  }
  exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
  exports.MAJOR = exports.NUM_MAP;
  exports.MINOR = exports.MAJOR;
  var HEADER_STATE;
  (function(HEADER_STATE2) {
    HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
    HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
    HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
    HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
    HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
    HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
  })(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
  exports.SPECIAL_HEADERS = {
    connection: HEADER_STATE.CONNECTION,
    "content-length": HEADER_STATE.CONTENT_LENGTH,
    "proxy-connection": HEADER_STATE.CONNECTION,
    "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
    upgrade: HEADER_STATE.UPGRADE
  };
});

// node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS((exports, module) => {
  var util = require_util();
  var { kBodyUsed } = require_symbols();
  var assert = __require("assert");
  var { InvalidArgumentError } = require_errors();
  var EE = __require("events");
  var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
  var kBody = Symbol("body");

  class BodyAsyncIterable {
    constructor(body) {
      this[kBody] = body;
      this[kBodyUsed] = false;
    }
    async* [Symbol.asyncIterator]() {
      assert(!this[kBodyUsed], "disturbed");
      this[kBodyUsed] = true;
      yield* this[kBody];
    }
  }

  class RedirectHandler {
    constructor(dispatch, maxRedirections, opts, handler) {
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      util.validateHandler(handler, opts.method, opts.upgrade);
      this.dispatch = dispatch;
      this.location = null;
      this.abort = null;
      this.opts = { ...opts, maxRedirections: 0 };
      this.maxRedirections = maxRedirections;
      this.handler = handler;
      this.history = [];
      if (util.isStream(this.opts.body)) {
        if (util.bodyLength(this.opts.body) === 0) {
          this.opts.body.on("data", function() {
            assert(false);
          });
        }
        if (typeof this.opts.body.readableDidRead !== "boolean") {
          this.opts.body[kBodyUsed] = false;
          EE.prototype.on.call(this.opts.body, "data", function() {
            this[kBodyUsed] = true;
          });
        }
      } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      }
    }
    onConnect(abort) {
      this.abort = abort;
      this.handler.onConnect(abort, { history: this.history });
    }
    onUpgrade(statusCode, headers, socket) {
      this.handler.onUpgrade(statusCode, headers, socket);
    }
    onError(error) {
      this.handler.onError(error);
    }
    onHeaders(statusCode, headers, resume, statusText) {
      this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
      if (this.opts.origin) {
        this.history.push(new URL(this.opts.path, this.opts.origin));
      }
      if (!this.location) {
        return this.handler.onHeaders(statusCode, headers, resume, statusText);
      }
      const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
      const path = search ? `${pathname}${search}` : pathname;
      this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
      this.opts.path = path;
      this.opts.origin = origin;
      this.opts.maxRedirections = 0;
      this.opts.query = null;
      if (statusCode === 303 && this.opts.method !== "HEAD") {
        this.opts.method = "GET";
        this.opts.body = null;
      }
    }
    onData(chunk) {
      if (this.location) {
      } else {
        return this.handler.onData(chunk);
      }
    }
    onComplete(trailers) {
      if (this.location) {
        this.location = null;
        this.abort = null;
        this.dispatch(this.opts, this);
      } else {
        this.handler.onComplete(trailers);
      }
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent) {
        this.handler.onBodySent(chunk);
      }
    }
  }
  function parseLocation(statusCode, headers) {
    if (redirectableStatusCodes.indexOf(statusCode) === -1) {
      return null;
    }
    for (let i = 0;i < headers.length; i += 2) {
      if (headers[i].toString().toLowerCase() === "location") {
        return headers[i + 1];
      }
    }
  }
  function shouldRemoveHeader(header, removeContent, unknownOrigin) {
    if (header.length === 4) {
      return util.headerNameToString(header) === "host";
    }
    if (removeContent && util.headerNameToString(header).startsWith("content-")) {
      return true;
    }
    if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
      const name = util.headerNameToString(header);
      return name === "authorization" || name === "cookie" || name === "proxy-authorization";
    }
    return false;
  }
  function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
    const ret = [];
    if (Array.isArray(headers)) {
      for (let i = 0;i < headers.length; i += 2) {
        if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
          ret.push(headers[i], headers[i + 1]);
        }
      }
    } else if (headers && typeof headers === "object") {
      for (const key of Object.keys(headers)) {
        if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
          ret.push(key, headers[key]);
        }
      }
    } else {
      assert(headers == null, "headers must be an object or an array");
    }
    return ret;
  }
  module.exports = RedirectHandler;
});

// node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS((exports, module) => {
  var RedirectHandler = require_RedirectHandler();
  function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
    return (dispatch) => {
      return function Intercept(opts, handler) {
        const { maxRedirections = defaultMaxRedirections } = opts;
        if (!maxRedirections) {
          return dispatch(opts, handler);
        }
        const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
        opts = { ...opts, maxRedirections: 0 };
        return dispatch(opts, redirectHandler);
      };
    };
  }
  module.exports = createRedirectInterceptor;
});

// node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS((exports, module) => {
  module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCsLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC1kAIABBGGpCADcDACAAQgA3AwAgAEE4akIANwMAIABBMGpCADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwHLAcoBuAHJAbkByAG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAQDcAQtBACEQDMYBC0EOIRAMxQELQQ0hEAzEAQtBDyEQDMMBC0EQIRAMwgELQRMhEAzBAQtBFCEQDMABC0EVIRAMvwELQRYhEAy+AQtBFyEQDL0BC0EYIRAMvAELQRkhEAy7AQtBGiEQDLoBC0EbIRAMuQELQRwhEAy4AQtBCCEQDLcBC0EdIRAMtgELQSAhEAy1AQtBHyEQDLQBC0EHIRAMswELQSEhEAyyAQtBIiEQDLEBC0EeIRAMsAELQSMhEAyvAQtBEiEQDK4BC0ERIRAMrQELQSQhEAysAQtBJSEQDKsBC0EmIRAMqgELQSchEAypAQtBwwEhEAyoAQtBKSEQDKcBC0ErIRAMpgELQSwhEAylAQtBLSEQDKQBC0EuIRAMowELQS8hEAyiAQtBxAEhEAyhAQtBMCEQDKABC0E0IRAMnwELQQwhEAyeAQtBMSEQDJ0BC0EyIRAMnAELQTMhEAybAQtBOSEQDJoBC0E1IRAMmQELQcUBIRAMmAELQQshEAyXAQtBOiEQDJYBC0E2IRAMlQELQQohEAyUAQtBNyEQDJMBC0E4IRAMkgELQTwhEAyRAQtBOyEQDJABC0E9IRAMjwELQQkhEAyOAQtBKCEQDI0BC0E+IRAMjAELQT8hEAyLAQtBwAAhEAyKAQtBwQAhEAyJAQtBwgAhEAyIAQtBwwAhEAyHAQtBxAAhEAyGAQtBxQAhEAyFAQtBxgAhEAyEAQtBKiEQDIMBC0HHACEQDIIBC0HIACEQDIEBC0HJACEQDIABC0HKACEQDH8LQcsAIRAMfgtBzQAhEAx9C0HMACEQDHwLQc4AIRAMewtBzwAhEAx6C0HQACEQDHkLQdEAIRAMeAtB0gAhEAx3C0HTACEQDHYLQdQAIRAMdQtB1gAhEAx0C0HVACEQDHMLQQYhEAxyC0HXACEQDHELQQUhEAxwC0HYACEQDG8LQQQhEAxuC0HZACEQDG0LQdoAIRAMbAtB2wAhEAxrC0HcACEQDGoLQQMhEAxpC0HdACEQDGgLQd4AIRAMZwtB3wAhEAxmC0HhACEQDGULQeAAIRAMZAtB4gAhEAxjC0HjACEQDGILQQIhEAxhC0HkACEQDGALQeUAIRAMXwtB5gAhEAxeC0HnACEQDF0LQegAIRAMXAtB6QAhEAxbC0HqACEQDFoLQesAIRAMWQtB7AAhEAxYC0HtACEQDFcLQe4AIRAMVgtB7wAhEAxVC0HwACEQDFQLQfEAIRAMUwtB8gAhEAxSC0HzACEQDFELQfQAIRAMUAtB9QAhEAxPC0H2ACEQDE4LQfcAIRAMTQtB+AAhEAxMC0H5ACEQDEsLQfoAIRAMSgtB+wAhEAxJC0H8ACEQDEgLQf0AIRAMRwtB/gAhEAxGC0H/ACEQDEULQYABIRAMRAtBgQEhEAxDC0GCASEQDEILQYMBIRAMQQtBhAEhEAxAC0GFASEQDD8LQYYBIRAMPgtBhwEhEAw9C0GIASEQDDwLQYkBIRAMOwtBigEhEAw6C0GLASEQDDkLQYwBIRAMOAtBjQEhEAw3C0GOASEQDDYLQY8BIRAMNQtBkAEhEAw0C0GRASEQDDMLQZIBIRAMMgtBkwEhEAwxC0GUASEQDDALQZUBIRAMLwtBlgEhEAwuC0GXASEQDC0LQZgBIRAMLAtBmQEhEAwrC0GaASEQDCoLQZsBIRAMKQtBnAEhEAwoC0GdASEQDCcLQZ4BIRAMJgtBnwEhEAwlC0GgASEQDCQLQaEBIRAMIwtBogEhEAwiC0GjASEQDCELQaQBIRAMIAtBpQEhEAwfC0GmASEQDB4LQacBIRAMHQtBqAEhEAwcC0GpASEQDBsLQaoBIRAMGgtBqwEhEAwZC0GsASEQDBgLQa0BIRAMFwtBrgEhEAwWC0EBIRAMFQtBrwEhEAwUC0GwASEQDBMLQbEBIRAMEgtBswEhEAwRC0GyASEQDBALQbQBIRAMDwtBtQEhEAwOC0G2ASEQDA0LQbcBIRAMDAtBuAEhEAwLC0G5ASEQDAoLQboBIRAMCQtBuwEhEAwIC0HGASEQDAcLQbwBIRAMBgtBvQEhEAwFC0G+ASEQDAQLQb8BIRAMAwtBwAEhEAwCC0HCASEQDAELQcEBIRALA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQDscBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxweHyAhIyUoP0BBREVGR0hJSktMTU9QUVJT3gNXWVtcXWBiZWZnaGlqa2xtb3BxcnN0dXZ3eHl6e3x9foABggGFAYYBhwGJAYsBjAGNAY4BjwGQAZEBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAZkCpAKwAv4C/gILIAEiBCACRw3zAUHdASEQDP8DCyABIhAgAkcN3QFBwwEhEAz+AwsgASIBIAJHDZABQfcAIRAM/QMLIAEiASACRw2GAUHvACEQDPwDCyABIgEgAkcNf0HqACEQDPsDCyABIgEgAkcNe0HoACEQDPoDCyABIgEgAkcNeEHmACEQDPkDCyABIgEgAkcNGkEYIRAM+AMLIAEiASACRw0UQRIhEAz3AwsgASIBIAJHDVlBxQAhEAz2AwsgASIBIAJHDUpBPyEQDPUDCyABIgEgAkcNSEE8IRAM9AMLIAEiASACRw1BQTEhEAzzAwsgAC0ALkEBRg3rAwyHAgsgACABIgEgAhDAgICAAEEBRw3mASAAQgA3AyAM5wELIAAgASIBIAIQtICAgAAiEA3nASABIQEM9QILAkAgASIBIAJHDQBBBiEQDPADCyAAIAFBAWoiASACELuAgIAAIhAN6AEgASEBDDELIABCADcDIEESIRAM1QMLIAEiECACRw0rQR0hEAztAwsCQCABIgEgAkYNACABQQFqIQFBECEQDNQDC0EHIRAM7AMLIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN5QFBCCEQDOsDCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEUIRAM0gMLQQkhEAzqAwsgASEBIAApAyBQDeQBIAEhAQzyAgsCQCABIgEgAkcNAEELIRAM6QMLIAAgAUEBaiIBIAIQtoCAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3mASABIQEMDQsgACABIgEgAhC6gICAACIQDecBIAEhAQzwAgsCQCABIgEgAkcNAEEPIRAM5QMLIAEtAAAiEEE7Rg0IIBBBDUcN6AEgAUEBaiEBDO8CCyAAIAEiASACELqAgIAAIhAN6AEgASEBDPICCwNAAkAgAS0AAEHwtYCAAGotAAAiEEEBRg0AIBBBAkcN6wEgACgCBCEQIABBADYCBCAAIBAgAUEBaiIBELmAgIAAIhAN6gEgASEBDPQCCyABQQFqIgEgAkcNAAtBEiEQDOIDCyAAIAEiASACELqAgIAAIhAN6QEgASEBDAoLIAEiASACRw0GQRshEAzgAwsCQCABIgEgAkcNAEEWIRAM4AMLIABBioCAgAA2AgggACABNgIEIAAgASACELiAgIAAIhAN6gEgASEBQSAhEAzGAwsCQCABIgEgAkYNAANAAkAgAS0AAEHwt4CAAGotAAAiEEECRg0AAkAgEEF/ag4E5QHsAQDrAewBCyABQQFqIQFBCCEQDMgDCyABQQFqIgEgAkcNAAtBFSEQDN8DC0EVIRAM3gMLA0ACQCABLQAAQfC5gIAAai0AACIQQQJGDQAgEEF/ag4E3gHsAeAB6wHsAQsgAUEBaiIBIAJHDQALQRghEAzdAwsCQCABIgEgAkYNACAAQYuAgIAANgIIIAAgATYCBCABIQFBByEQDMQDC0EZIRAM3AMLIAFBAWohAQwCCwJAIAEiFCACRw0AQRohEAzbAwsgFCEBAkAgFC0AAEFzag4U3QLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gIA7gILQQAhECAAQQA2AhwgAEGvi4CAADYCECAAQQI2AgwgACAUQQFqNgIUDNoDCwJAIAEtAAAiEEE7Rg0AIBBBDUcN6AEgAUEBaiEBDOUCCyABQQFqIQELQSIhEAy/AwsCQCABIhAgAkcNAEEcIRAM2AMLQgAhESAQIQEgEC0AAEFQag435wHmAQECAwQFBgcIAAAAAAAAAAkKCwwNDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADxAREhMUAAtBHiEQDL0DC0ICIREM5QELQgMhEQzkAQtCBCERDOMBC0IFIREM4gELQgYhEQzhAQtCByERDOABC0IIIREM3wELQgkhEQzeAQtCCiERDN0BC0ILIREM3AELQgwhEQzbAQtCDSERDNoBC0IOIREM2QELQg8hEQzYAQtCCiERDNcBC0ILIREM1gELQgwhEQzVAQtCDSERDNQBC0IOIREM0wELQg8hEQzSAQtCACERAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQLQAAQVBqDjflAeQBAAECAwQFBgfmAeYB5gHmAeYB5gHmAQgJCgsMDeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gEODxAREhPmAQtCAiERDOQBC0IDIREM4wELQgQhEQziAQtCBSERDOEBC0IGIREM4AELQgchEQzfAQtCCCERDN4BC0IJIREM3QELQgohEQzcAQtCCyERDNsBC0IMIREM2gELQg0hEQzZAQtCDiERDNgBC0IPIREM1wELQgohEQzWAQtCCyERDNUBC0IMIREM1AELQg0hEQzTAQtCDiERDNIBC0IPIREM0QELIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN0gFBHyEQDMADCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEkIRAMpwMLQSAhEAy/AwsgACABIhAgAhC+gICAAEF/ag4FtgEAxQIB0QHSAQtBESEQDKQDCyAAQQE6AC8gECEBDLsDCyABIgEgAkcN0gFBJCEQDLsDCyABIg0gAkcNHkHGACEQDLoDCyAAIAEiASACELKAgIAAIhAN1AEgASEBDLUBCyABIhAgAkcNJkHQACEQDLgDCwJAIAEiASACRw0AQSghEAy4AwsgAEEANgIEIABBjICAgAA2AgggACABIAEQsYCAgAAiEA3TASABIQEM2AELAkAgASIQIAJHDQBBKSEQDLcDCyAQLQAAIgFBIEYNFCABQQlHDdMBIBBBAWohAQwVCwJAIAEiASACRg0AIAFBAWohAQwXC0EqIRAMtQMLAkAgASIQIAJHDQBBKyEQDLUDCwJAIBAtAAAiAUEJRg0AIAFBIEcN1QELIAAtACxBCEYN0wEgECEBDJEDCwJAIAEiASACRw0AQSwhEAy0AwsgAS0AAEEKRw3VASABQQFqIQEMyQILIAEiDiACRw3VAUEvIRAMsgMLA0ACQCABLQAAIhBBIEYNAAJAIBBBdmoOBADcAdwBANoBCyABIQEM4AELIAFBAWoiASACRw0AC0ExIRAMsQMLQTIhECABIhQgAkYNsAMgAiAUayAAKAIAIgFqIRUgFCABa0EDaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfC7gIAAai0AAEcNAQJAIAFBA0cNAEEGIQEMlgMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLEDCyAAQQA2AgAgFCEBDNkBC0EzIRAgASIUIAJGDa8DIAIgFGsgACgCACIBaiEVIBQgAWtBCGohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUH0u4CAAGotAABHDQECQCABQQhHDQBBBSEBDJUDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAywAwsgAEEANgIAIBQhAQzYAQtBNCEQIAEiFCACRg2uAyACIBRrIAAoAgAiAWohFSAUIAFrQQVqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw0BAkAgAUEFRw0AQQchAQyUAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMrwMLIABBADYCACAUIQEM1wELAkAgASIBIAJGDQADQAJAIAEtAABBgL6AgABqLQAAIhBBAUYNACAQQQJGDQogASEBDN0BCyABQQFqIgEgAkcNAAtBMCEQDK4DC0EwIRAMrQMLAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AIBBBdmoOBNkB2gHaAdkB2gELIAFBAWoiASACRw0AC0E4IRAMrQMLQTghEAysAwsDQAJAIAEtAAAiEEEgRg0AIBBBCUcNAwsgAUEBaiIBIAJHDQALQTwhEAyrAwsDQAJAIAEtAAAiEEEgRg0AAkACQCAQQXZqDgTaAQEB2gEACyAQQSxGDdsBCyABIQEMBAsgAUEBaiIBIAJHDQALQT8hEAyqAwsgASEBDNsBC0HAACEQIAEiFCACRg2oAyACIBRrIAAoAgAiAWohFiAUIAFrQQZqIRcCQANAIBQtAABBIHIgAUGAwICAAGotAABHDQEgAUEGRg2OAyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAypAwsgAEEANgIAIBQhAQtBNiEQDI4DCwJAIAEiDyACRw0AQcEAIRAMpwMLIABBjICAgAA2AgggACAPNgIEIA8hASAALQAsQX9qDgTNAdUB1wHZAYcDCyABQQFqIQEMzAELAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgciAQIBBBv39qQf8BcUEaSRtB/wFxIhBBCUYNACAQQSBGDQACQAJAAkACQCAQQZ1/ag4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIRAMkQMLIAFBAWohAUEyIRAMkAMLIAFBAWohAUEzIRAMjwMLIAEhAQzQAQsgAUEBaiIBIAJHDQALQTUhEAylAwtBNSEQDKQDCwJAIAEiASACRg0AA0ACQCABLQAAQYC8gIAAai0AAEEBRg0AIAEhAQzTAQsgAUEBaiIBIAJHDQALQT0hEAykAwtBPSEQDKMDCyAAIAEiASACELCAgIAAIhAN1gEgASEBDAELIBBBAWohAQtBPCEQDIcDCwJAIAEiASACRw0AQcIAIRAMoAMLAkADQAJAIAEtAABBd2oOGAAC/gL+AoQD/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4CAP4CCyABQQFqIgEgAkcNAAtBwgAhEAygAwsgAUEBaiEBIAAtAC1BAXFFDb0BIAEhAQtBLCEQDIUDCyABIgEgAkcN0wFBxAAhEAydAwsDQAJAIAEtAABBkMCAgABqLQAAQQFGDQAgASEBDLcCCyABQQFqIgEgAkcNAAtBxQAhEAycAwsgDS0AACIQQSBGDbMBIBBBOkcNgQMgACgCBCEBIABBADYCBCAAIAEgDRCvgICAACIBDdABIA1BAWohAQyzAgtBxwAhECABIg0gAkYNmgMgAiANayAAKAIAIgFqIRYgDSABa0EFaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGQwoCAAGotAABHDYADIAFBBUYN9AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmgMLQcgAIRAgASINIAJGDZkDIAIgDWsgACgCACIBaiEWIA0gAWtBCWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBlsKAgABqLQAARw3/AgJAIAFBCUcNAEECIQEM9QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJkDCwJAIAEiDSACRw0AQckAIRAMmQMLAkACQCANLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGSf2oOBwCAA4ADgAOAA4ADAYADCyANQQFqIQFBPiEQDIADCyANQQFqIQFBPyEQDP8CC0HKACEQIAEiDSACRg2XAyACIA1rIAAoAgAiAWohFiANIAFrQQFqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaDCgIAAai0AAEcN/QIgAUEBRg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyXAwtBywAhECABIg0gAkYNlgMgAiANayAAKAIAIgFqIRYgDSABa0EOaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGiwoCAAGotAABHDfwCIAFBDkYN8AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlgMLQcwAIRAgASINIAJGDZUDIAIgDWsgACgCACIBaiEWIA0gAWtBD2ohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBwMKAgABqLQAARw37AgJAIAFBD0cNAEEDIQEM8QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJUDC0HNACEQIAEiDSACRg2UAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQdDCgIAAai0AAEcN+gICQCABQQVHDQBBBCEBDPACCyABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyUAwsCQCABIg0gAkcNAEHOACEQDJQDCwJAAkACQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZ1/ag4TAP0C/QL9Av0C/QL9Av0C/QL9Av0C/QL9AgH9Av0C/QICA/0CCyANQQFqIQFBwQAhEAz9AgsgDUEBaiEBQcIAIRAM/AILIA1BAWohAUHDACEQDPsCCyANQQFqIQFBxAAhEAz6AgsCQCABIgEgAkYNACAAQY2AgIAANgIIIAAgATYCBCABIQFBxQAhEAz6AgtBzwAhEAySAwsgECEBAkACQCAQLQAAQXZqDgQBqAKoAgCoAgsgEEEBaiEBC0EnIRAM+AILAkAgASIBIAJHDQBB0QAhEAyRAwsCQCABLQAAQSBGDQAgASEBDI0BCyABQQFqIQEgAC0ALUEBcUUNxwEgASEBDIwBCyABIhcgAkcNyAFB0gAhEAyPAwtB0wAhECABIhQgAkYNjgMgAiAUayAAKAIAIgFqIRYgFCABa0EBaiEXA0AgFC0AACABQdbCgIAAai0AAEcNzAEgAUEBRg3HASABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAyOAwsCQCABIgEgAkcNAEHVACEQDI4DCyABLQAAQQpHDcwBIAFBAWohAQzHAQsCQCABIgEgAkcNAEHWACEQDI0DCwJAAkAgAS0AAEF2ag4EAM0BzQEBzQELIAFBAWohAQzHAQsgAUEBaiEBQcoAIRAM8wILIAAgASIBIAIQroCAgAAiEA3LASABIQFBzQAhEAzyAgsgAC0AKUEiRg2FAwymAgsCQCABIgEgAkcNAEHbACEQDIoDC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4K1AHTAQABAgMEBQYI1QELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMzAELQQkhEEEBIRRBACEXQQAhFgzLAQsCQCABIgEgAkcNAEHdACEQDIkDCyABLQAAQS5HDcwBIAFBAWohAQymAgsgASIBIAJHDcwBQd8AIRAMhwMLAkAgASIBIAJGDQAgAEGOgICAADYCCCAAIAE2AgQgASEBQdAAIRAM7gILQeAAIRAMhgMLQeEAIRAgASIBIAJGDYUDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHiwoCAAGotAABHDc0BIBRBA0YNzAEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhQMLQeIAIRAgASIBIAJGDYQDIAIgAWsgACgCACIUaiEWIAEgFGtBAmohFwNAIAEtAAAgFEHmwoCAAGotAABHDcwBIBRBAkYNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhAMLQeMAIRAgASIBIAJGDYMDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHpwoCAAGotAABHDcsBIBRBA0YNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMgwMLAkAgASIBIAJHDQBB5QAhEAyDAwsgACABQQFqIgEgAhCogICAACIQDc0BIAEhAUHWACEQDOkCCwJAIAEiASACRg0AA0ACQCABLQAAIhBBIEYNAAJAAkACQCAQQbh/ag4LAAHPAc8BzwHPAc8BzwHPAc8BAs8BCyABQQFqIQFB0gAhEAztAgsgAUEBaiEBQdMAIRAM7AILIAFBAWohAUHUACEQDOsCCyABQQFqIgEgAkcNAAtB5AAhEAyCAwtB5AAhEAyBAwsDQAJAIAEtAABB8MKAgABqLQAAIhBBAUYNACAQQX5qDgPPAdAB0QHSAQsgAUEBaiIBIAJHDQALQeYAIRAMgAMLAkAgASIBIAJGDQAgAUEBaiEBDAMLQecAIRAM/wILA0ACQCABLQAAQfDEgIAAai0AACIQQQFGDQACQCAQQX5qDgTSAdMB1AEA1QELIAEhAUHXACEQDOcCCyABQQFqIgEgAkcNAAtB6AAhEAz+AgsCQCABIgEgAkcNAEHpACEQDP4CCwJAIAEtAAAiEEF2ag4augHVAdUBvAHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHKAdUB1QEA0wELIAFBAWohAQtBBiEQDOMCCwNAAkAgAS0AAEHwxoCAAGotAABBAUYNACABIQEMngILIAFBAWoiASACRw0AC0HqACEQDPsCCwJAIAEiASACRg0AIAFBAWohAQwDC0HrACEQDPoCCwJAIAEiASACRw0AQewAIRAM+gILIAFBAWohAQwBCwJAIAEiASACRw0AQe0AIRAM+QILIAFBAWohAQtBBCEQDN4CCwJAIAEiFCACRw0AQe4AIRAM9wILIBQhAQJAAkACQCAULQAAQfDIgIAAai0AAEF/ag4H1AHVAdYBAJwCAQLXAQsgFEEBaiEBDAoLIBRBAWohAQzNAQtBACEQIABBADYCHCAAQZuSgIAANgIQIABBBzYCDCAAIBRBAWo2AhQM9gILAkADQAJAIAEtAABB8MiAgABqLQAAIhBBBEYNAAJAAkAgEEF/ag4H0gHTAdQB2QEABAHZAQsgASEBQdoAIRAM4AILIAFBAWohAUHcACEQDN8CCyABQQFqIgEgAkcNAAtB7wAhEAz2AgsgAUEBaiEBDMsBCwJAIAEiFCACRw0AQfAAIRAM9QILIBQtAABBL0cN1AEgFEEBaiEBDAYLAkAgASIUIAJHDQBB8QAhEAz0AgsCQCAULQAAIgFBL0cNACAUQQFqIQFB3QAhEAzbAgsgAUF2aiIEQRZLDdMBQQEgBHRBiYCAAnFFDdMBDMoCCwJAIAEiASACRg0AIAFBAWohAUHeACEQDNoCC0HyACEQDPICCwJAIAEiFCACRw0AQfQAIRAM8gILIBQhAQJAIBQtAABB8MyAgABqLQAAQX9qDgPJApQCANQBC0HhACEQDNgCCwJAIAEiFCACRg0AA0ACQCAULQAAQfDKgIAAai0AACIBQQNGDQACQCABQX9qDgLLAgDVAQsgFCEBQd8AIRAM2gILIBRBAWoiFCACRw0AC0HzACEQDPECC0HzACEQDPACCwJAIAEiASACRg0AIABBj4CAgAA2AgggACABNgIEIAEhAUHgACEQDNcCC0H1ACEQDO8CCwJAIAEiASACRw0AQfYAIRAM7wILIABBj4CAgAA2AgggACABNgIEIAEhAQtBAyEQDNQCCwNAIAEtAABBIEcNwwIgAUEBaiIBIAJHDQALQfcAIRAM7AILAkAgASIBIAJHDQBB+AAhEAzsAgsgAS0AAEEgRw3OASABQQFqIQEM7wELIAAgASIBIAIQrICAgAAiEA3OASABIQEMjgILAkAgASIEIAJHDQBB+gAhEAzqAgsgBC0AAEHMAEcN0QEgBEEBaiEBQRMhEAzPAQsCQCABIgQgAkcNAEH7ACEQDOkCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRADQCAELQAAIAFB8M6AgABqLQAARw3QASABQQVGDc4BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQfsAIRAM6AILAkAgASIEIAJHDQBB/AAhEAzoAgsCQAJAIAQtAABBvX9qDgwA0QHRAdEB0QHRAdEB0QHRAdEB0QEB0QELIARBAWohAUHmACEQDM8CCyAEQQFqIQFB5wAhEAzOAgsCQCABIgQgAkcNAEH9ACEQDOcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDc8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH9ACEQDOcCCyAAQQA2AgAgEEEBaiEBQRAhEAzMAQsCQCABIgQgAkcNAEH+ACEQDOYCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUH2zoCAAGotAABHDc4BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH+ACEQDOYCCyAAQQA2AgAgEEEBaiEBQRYhEAzLAQsCQCABIgQgAkcNAEH/ACEQDOUCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUH8zoCAAGotAABHDc0BIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH/ACEQDOUCCyAAQQA2AgAgEEEBaiEBQQUhEAzKAQsCQCABIgQgAkcNAEGAASEQDOQCCyAELQAAQdkARw3LASAEQQFqIQFBCCEQDMkBCwJAIAEiBCACRw0AQYEBIRAM4wILAkACQCAELQAAQbJ/ag4DAMwBAcwBCyAEQQFqIQFB6wAhEAzKAgsgBEEBaiEBQewAIRAMyQILAkAgASIEIAJHDQBBggEhEAziAgsCQAJAIAQtAABBuH9qDggAywHLAcsBywHLAcsBAcsBCyAEQQFqIQFB6gAhEAzJAgsgBEEBaiEBQe0AIRAMyAILAkAgASIEIAJHDQBBgwEhEAzhAgsgAiAEayAAKAIAIgFqIRAgBCABa0ECaiEUAkADQCAELQAAIAFBgM+AgABqLQAARw3JASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBA2AgBBgwEhEAzhAgtBACEQIABBADYCACAUQQFqIQEMxgELAkAgASIEIAJHDQBBhAEhEAzgAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBg8+AgABqLQAARw3IASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhAEhEAzgAgsgAEEANgIAIBBBAWohAUEjIRAMxQELAkAgASIEIAJHDQBBhQEhEAzfAgsCQAJAIAQtAABBtH9qDggAyAHIAcgByAHIAcgBAcgBCyAEQQFqIQFB7wAhEAzGAgsgBEEBaiEBQfAAIRAMxQILAkAgASIEIAJHDQBBhgEhEAzeAgsgBC0AAEHFAEcNxQEgBEEBaiEBDIMCCwJAIAEiBCACRw0AQYcBIRAM3QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQYjPgIAAai0AAEcNxQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYcBIRAM3QILIABBADYCACAQQQFqIQFBLSEQDMIBCwJAIAEiBCACRw0AQYgBIRAM3AILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNxAEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYgBIRAM3AILIABBADYCACAQQQFqIQFBKSEQDMEBCwJAIAEiASACRw0AQYkBIRAM2wILQQEhECABLQAAQd8ARw3AASABQQFqIQEMgQILAkAgASIEIAJHDQBBigEhEAzaAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQA0AgBC0AACABQYzPgIAAai0AAEcNwQEgAUEBRg2vAiABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGKASEQDNkCCwJAIAEiBCACRw0AQYsBIRAM2QILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQY7PgIAAai0AAEcNwQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYsBIRAM2QILIABBADYCACAQQQFqIQFBAiEQDL4BCwJAIAEiBCACRw0AQYwBIRAM2AILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNwAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYwBIRAM2AILIABBADYCACAQQQFqIQFBHyEQDL0BCwJAIAEiBCACRw0AQY0BIRAM1wILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNvwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY0BIRAM1wILIABBADYCACAQQQFqIQFBCSEQDLwBCwJAIAEiBCACRw0AQY4BIRAM1gILAkACQCAELQAAQbd/ag4HAL8BvwG/Ab8BvwEBvwELIARBAWohAUH4ACEQDL0CCyAEQQFqIQFB+QAhEAy8AgsCQCABIgQgAkcNAEGPASEQDNUCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGRz4CAAGotAABHDb0BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGPASEQDNUCCyAAQQA2AgAgEEEBaiEBQRghEAy6AQsCQCABIgQgAkcNAEGQASEQDNQCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUGXz4CAAGotAABHDbwBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGQASEQDNQCCyAAQQA2AgAgEEEBaiEBQRchEAy5AQsCQCABIgQgAkcNAEGRASEQDNMCCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUGaz4CAAGotAABHDbsBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGRASEQDNMCCyAAQQA2AgAgEEEBaiEBQRUhEAy4AQsCQCABIgQgAkcNAEGSASEQDNICCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGhz4CAAGotAABHDboBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGSASEQDNICCyAAQQA2AgAgEEEBaiEBQR4hEAy3AQsCQCABIgQgAkcNAEGTASEQDNECCyAELQAAQcwARw24ASAEQQFqIQFBCiEQDLYBCwJAIAQgAkcNAEGUASEQDNACCwJAAkAgBC0AAEG/f2oODwC5AbkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AQG5AQsgBEEBaiEBQf4AIRAMtwILIARBAWohAUH/ACEQDLYCCwJAIAQgAkcNAEGVASEQDM8CCwJAAkAgBC0AAEG/f2oOAwC4AQG4AQsgBEEBaiEBQf0AIRAMtgILIARBAWohBEGAASEQDLUCCwJAIAQgAkcNAEGWASEQDM4CCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUGnz4CAAGotAABHDbYBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGWASEQDM4CCyAAQQA2AgAgEEEBaiEBQQshEAyzAQsCQCAEIAJHDQBBlwEhEAzNAgsCQAJAAkACQCAELQAAQVNqDiMAuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AQG4AbgBuAG4AbgBArgBuAG4AQO4AQsgBEEBaiEBQfsAIRAMtgILIARBAWohAUH8ACEQDLUCCyAEQQFqIQRBgQEhEAy0AgsgBEEBaiEEQYIBIRAMswILAkAgBCACRw0AQZgBIRAMzAILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQanPgIAAai0AAEcNtAEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZgBIRAMzAILIABBADYCACAQQQFqIQFBGSEQDLEBCwJAIAQgAkcNAEGZASEQDMsCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGuz4CAAGotAABHDbMBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGZASEQDMsCCyAAQQA2AgAgEEEBaiEBQQYhEAywAQsCQCAEIAJHDQBBmgEhEAzKAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBtM+AgABqLQAARw2yASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmgEhEAzKAgsgAEEANgIAIBBBAWohAUEcIRAMrwELAkAgBCACRw0AQZsBIRAMyQILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbbPgIAAai0AAEcNsQEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZsBIRAMyQILIABBADYCACAQQQFqIQFBJyEQDK4BCwJAIAQgAkcNAEGcASEQDMgCCwJAAkAgBC0AAEGsf2oOAgABsQELIARBAWohBEGGASEQDK8CCyAEQQFqIQRBhwEhEAyuAgsCQCAEIAJHDQBBnQEhEAzHAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBuM+AgABqLQAARw2vASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBnQEhEAzHAgsgAEEANgIAIBBBAWohAUEmIRAMrAELAkAgBCACRw0AQZ4BIRAMxgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbrPgIAAai0AAEcNrgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ4BIRAMxgILIABBADYCACAQQQFqIQFBAyEQDKsBCwJAIAQgAkcNAEGfASEQDMUCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDa0BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGfASEQDMUCCyAAQQA2AgAgEEEBaiEBQQwhEAyqAQsCQCAEIAJHDQBBoAEhEAzEAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBvM+AgABqLQAARw2sASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBoAEhEAzEAgsgAEEANgIAIBBBAWohAUENIRAMqQELAkAgBCACRw0AQaEBIRAMwwILAkACQCAELQAAQbp/ag4LAKwBrAGsAawBrAGsAawBrAGsAQGsAQsgBEEBaiEEQYsBIRAMqgILIARBAWohBEGMASEQDKkCCwJAIAQgAkcNAEGiASEQDMICCyAELQAAQdAARw2pASAEQQFqIQQM6QELAkAgBCACRw0AQaMBIRAMwQILAkACQCAELQAAQbd/ag4HAaoBqgGqAaoBqgEAqgELIARBAWohBEGOASEQDKgCCyAEQQFqIQFBIiEQDKYBCwJAIAQgAkcNAEGkASEQDMACCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHAz4CAAGotAABHDagBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGkASEQDMACCyAAQQA2AgAgEEEBaiEBQR0hEAylAQsCQCAEIAJHDQBBpQEhEAy/AgsCQAJAIAQtAABBrn9qDgMAqAEBqAELIARBAWohBEGQASEQDKYCCyAEQQFqIQFBBCEQDKQBCwJAIAQgAkcNAEGmASEQDL4CCwJAAkACQAJAAkAgBC0AAEG/f2oOFQCqAaoBqgGqAaoBqgGqAaoBqgGqAQGqAaoBAqoBqgEDqgGqAQSqAQsgBEEBaiEEQYgBIRAMqAILIARBAWohBEGJASEQDKcCCyAEQQFqIQRBigEhEAymAgsgBEEBaiEEQY8BIRAMpQILIARBAWohBEGRASEQDKQCCwJAIAQgAkcNAEGnASEQDL0CCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDaUBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGnASEQDL0CCyAAQQA2AgAgEEEBaiEBQREhEAyiAQsCQCAEIAJHDQBBqAEhEAy8AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBws+AgABqLQAARw2kASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqAEhEAy8AgsgAEEANgIAIBBBAWohAUEsIRAMoQELAkAgBCACRw0AQakBIRAMuwILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQcXPgIAAai0AAEcNowEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQakBIRAMuwILIABBADYCACAQQQFqIQFBKyEQDKABCwJAIAQgAkcNAEGqASEQDLoCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHKz4CAAGotAABHDaIBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGqASEQDLoCCyAAQQA2AgAgEEEBaiEBQRQhEAyfAQsCQCAEIAJHDQBBqwEhEAy5AgsCQAJAAkACQCAELQAAQb5/ag4PAAECpAGkAaQBpAGkAaQBpAGkAaQBpAGkAQOkAQsgBEEBaiEEQZMBIRAMogILIARBAWohBEGUASEQDKECCyAEQQFqIQRBlQEhEAygAgsgBEEBaiEEQZYBIRAMnwILAkAgBCACRw0AQawBIRAMuAILIAQtAABBxQBHDZ8BIARBAWohBAzgAQsCQCAEIAJHDQBBrQEhEAy3AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBzc+AgABqLQAARw2fASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrQEhEAy3AgsgAEEANgIAIBBBAWohAUEOIRAMnAELAkAgBCACRw0AQa4BIRAMtgILIAQtAABB0ABHDZ0BIARBAWohAUElIRAMmwELAkAgBCACRw0AQa8BIRAMtQILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNnQEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQa8BIRAMtQILIABBADYCACAQQQFqIQFBKiEQDJoBCwJAIAQgAkcNAEGwASEQDLQCCwJAAkAgBC0AAEGrf2oOCwCdAZ0BnQGdAZ0BnQGdAZ0BnQEBnQELIARBAWohBEGaASEQDJsCCyAEQQFqIQRBmwEhEAyaAgsCQCAEIAJHDQBBsQEhEAyzAgsCQAJAIAQtAABBv39qDhQAnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBAZwBCyAEQQFqIQRBmQEhEAyaAgsgBEEBaiEEQZwBIRAMmQILAkAgBCACRw0AQbIBIRAMsgILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQdnPgIAAai0AAEcNmgEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbIBIRAMsgILIABBADYCACAQQQFqIQFBISEQDJcBCwJAIAQgAkcNAEGzASEQDLECCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUHdz4CAAGotAABHDZkBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGzASEQDLECCyAAQQA2AgAgEEEBaiEBQRohEAyWAQsCQCAEIAJHDQBBtAEhEAywAgsCQAJAAkAgBC0AAEG7f2oOEQCaAZoBmgGaAZoBmgGaAZoBmgEBmgGaAZoBmgGaAQKaAQsgBEEBaiEEQZ0BIRAMmAILIARBAWohBEGeASEQDJcCCyAEQQFqIQRBnwEhEAyWAgsCQCAEIAJHDQBBtQEhEAyvAgsgAiAEayAAKAIAIgFqIRQgBCABa0EFaiEQAkADQCAELQAAIAFB5M+AgABqLQAARw2XASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtQEhEAyvAgsgAEEANgIAIBBBAWohAUEoIRAMlAELAkAgBCACRw0AQbYBIRAMrgILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQerPgIAAai0AAEcNlgEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbYBIRAMrgILIABBADYCACAQQQFqIQFBByEQDJMBCwJAIAQgAkcNAEG3ASEQDK0CCwJAAkAgBC0AAEG7f2oODgCWAZYBlgGWAZYBlgGWAZYBlgGWAZYBlgEBlgELIARBAWohBEGhASEQDJQCCyAEQQFqIQRBogEhEAyTAgsCQCAEIAJHDQBBuAEhEAysAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB7c+AgABqLQAARw2UASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuAEhEAysAgsgAEEANgIAIBBBAWohAUESIRAMkQELAkAgBCACRw0AQbkBIRAMqwILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNkwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbkBIRAMqwILIABBADYCACAQQQFqIQFBICEQDJABCwJAIAQgAkcNAEG6ASEQDKoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHyz4CAAGotAABHDZIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG6ASEQDKoCCyAAQQA2AgAgEEEBaiEBQQ8hEAyPAQsCQCAEIAJHDQBBuwEhEAypAgsCQAJAIAQtAABBt39qDgcAkgGSAZIBkgGSAQGSAQsgBEEBaiEEQaUBIRAMkAILIARBAWohBEGmASEQDI8CCwJAIAQgAkcNAEG8ASEQDKgCCyACIARrIAAoAgAiAWohFCAEIAFrQQdqIRACQANAIAQtAAAgAUH0z4CAAGotAABHDZABIAFBB0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG8ASEQDKgCCyAAQQA2AgAgEEEBaiEBQRshEAyNAQsCQCAEIAJHDQBBvQEhEAynAgsCQAJAAkAgBC0AAEG+f2oOEgCRAZEBkQGRAZEBkQGRAZEBkQEBkQGRAZEBkQGRAZEBApEBCyAEQQFqIQRBpAEhEAyPAgsgBEEBaiEEQacBIRAMjgILIARBAWohBEGoASEQDI0CCwJAIAQgAkcNAEG+ASEQDKYCCyAELQAAQc4ARw2NASAEQQFqIQQMzwELAkAgBCACRw0AQb8BIRAMpQILAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBC0AAEG/f2oOFQABAgOcAQQFBpwBnAGcAQcICQoLnAEMDQ4PnAELIARBAWohAUHoACEQDJoCCyAEQQFqIQFB6QAhEAyZAgsgBEEBaiEBQe4AIRAMmAILIARBAWohAUHyACEQDJcCCyAEQQFqIQFB8wAhEAyWAgsgBEEBaiEBQfYAIRAMlQILIARBAWohAUH3ACEQDJQCCyAEQQFqIQFB+gAhEAyTAgsgBEEBaiEEQYMBIRAMkgILIARBAWohBEGEASEQDJECCyAEQQFqIQRBhQEhEAyQAgsgBEEBaiEEQZIBIRAMjwILIARBAWohBEGYASEQDI4CCyAEQQFqIQRBoAEhEAyNAgsgBEEBaiEEQaMBIRAMjAILIARBAWohBEGqASEQDIsCCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEGrASEQDIsCC0HAASEQDKMCCyAAIAUgAhCqgICAACIBDYsBIAUhAQxcCwJAIAYgAkYNACAGQQFqIQUMjQELQcIBIRAMoQILA0ACQCAQLQAAQXZqDgSMAQAAjwEACyAQQQFqIhAgAkcNAAtBwwEhEAygAgsCQCAHIAJGDQAgAEGRgICAADYCCCAAIAc2AgQgByEBQQEhEAyHAgtBxAEhEAyfAgsCQCAHIAJHDQBBxQEhEAyfAgsCQAJAIActAABBdmoOBAHOAc4BAM4BCyAHQQFqIQYMjQELIAdBAWohBQyJAQsCQCAHIAJHDQBBxgEhEAyeAgsCQAJAIActAABBdmoOFwGPAY8BAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAQCPAQsgB0EBaiEHC0GwASEQDIQCCwJAIAggAkcNAEHIASEQDJ0CCyAILQAAQSBHDY0BIABBADsBMiAIQQFqIQFBswEhEAyDAgsgASEXAkADQCAXIgcgAkYNASAHLQAAQVBqQf8BcSIQQQpPDcwBAkAgAC8BMiIUQZkzSw0AIAAgFEEKbCIUOwEyIBBB//8DcyAUQf7/A3FJDQAgB0EBaiEXIAAgFCAQaiIQOwEyIBBB//8DcUHoB0kNAQsLQQAhECAAQQA2AhwgAEHBiYCAADYCECAAQQ02AgwgACAHQQFqNgIUDJwCC0HHASEQDJsCCyAAIAggAhCugICAACIQRQ3KASAQQRVHDYwBIABByAE2AhwgACAINgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAyaAgsCQCAJIAJHDQBBzAEhEAyaAgtBACEUQQEhF0EBIRZBACEQAkACQAJAAkACQAJAAkACQAJAIAktAABBUGoOCpYBlQEAAQIDBAUGCJcBC0ECIRAMBgtBAyEQDAULQQQhEAwEC0EFIRAMAwtBBiEQDAILQQchEAwBC0EIIRALQQAhF0EAIRZBACEUDI4BC0EJIRBBASEUQQAhF0EAIRYMjQELAkAgCiACRw0AQc4BIRAMmQILIAotAABBLkcNjgEgCkEBaiEJDMoBCyALIAJHDY4BQdABIRAMlwILAkAgCyACRg0AIABBjoCAgAA2AgggACALNgIEQbcBIRAM/gELQdEBIRAMlgILAkAgBCACRw0AQdIBIRAMlgILIAIgBGsgACgCACIQaiEUIAQgEGtBBGohCwNAIAQtAAAgEEH8z4CAAGotAABHDY4BIBBBBEYN6QEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB0gEhEAyVAgsgACAMIAIQrICAgAAiAQ2NASAMIQEMuAELAkAgBCACRw0AQdQBIRAMlAILIAIgBGsgACgCACIQaiEUIAQgEGtBAWohDANAIAQtAAAgEEGB0ICAAGotAABHDY8BIBBBAUYNjgEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB1AEhEAyTAgsCQCAEIAJHDQBB1gEhEAyTAgsgAiAEayAAKAIAIhBqIRQgBCAQa0ECaiELA0AgBC0AACAQQYPQgIAAai0AAEcNjgEgEEECRg2QASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHWASEQDJICCwJAIAQgAkcNAEHXASEQDJICCwJAAkAgBC0AAEG7f2oOEACPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAY8BCyAEQQFqIQRBuwEhEAz5AQsgBEEBaiEEQbwBIRAM+AELAkAgBCACRw0AQdgBIRAMkQILIAQtAABByABHDYwBIARBAWohBAzEAQsCQCAEIAJGDQAgAEGQgICAADYCCCAAIAQ2AgRBvgEhEAz3AQtB2QEhEAyPAgsCQCAEIAJHDQBB2gEhEAyPAgsgBC0AAEHIAEYNwwEgAEEBOgAoDLkBCyAAQQI6AC8gACAEIAIQpoCAgAAiEA2NAUHCASEQDPQBCyAALQAoQX9qDgK3AbkBuAELA0ACQCAELQAAQXZqDgQAjgGOAQCOAQsgBEEBaiIEIAJHDQALQd0BIRAMiwILIABBADoALyAALQAtQQRxRQ2EAgsgAEEAOgAvIABBAToANCABIQEMjAELIBBBFUYN2gEgAEEANgIcIAAgATYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMiAILAkAgACAQIAIQtICAgAAiBA0AIBAhAQyBAgsCQCAEQRVHDQAgAEEDNgIcIAAgEDYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMiAILIABBADYCHCAAIBA2AhQgAEGnjoCAADYCECAAQRI2AgxBACEQDIcCCyAQQRVGDdYBIABBADYCHCAAIAE2AhQgAEHajYCAADYCECAAQRQ2AgxBACEQDIYCCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNjQEgAEEHNgIcIAAgEDYCFCAAIBQ2AgxBACEQDIUCCyAAIAAvATBBgAFyOwEwIAEhAQtBKiEQDOoBCyAQQRVGDdEBIABBADYCHCAAIAE2AhQgAEGDjICAADYCECAAQRM2AgxBACEQDIICCyAQQRVGDc8BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDIECCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyNAQsgAEEMNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDIACCyAQQRVGDcwBIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDP8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyMAQsgAEENNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDP4BCyAQQRVGDckBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDP0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyLAQsgAEEONgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPwBCyAAQQA2AhwgACABNgIUIABBwJWAgAA2AhAgAEECNgIMQQAhEAz7AQsgEEEVRg3FASAAQQA2AhwgACABNgIUIABBxoyAgAA2AhAgAEEjNgIMQQAhEAz6AQsgAEEQNgIcIAAgATYCFCAAIBA2AgxBACEQDPkBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQzxAQsgAEERNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPgBCyAQQRVGDcEBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPcBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyIAQsgAEETNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPYBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQztAQsgAEEUNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPUBCyAQQRVGDb0BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDPQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyGAQsgAEEWNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPMBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQt4CAgAAiBA0AIAFBAWohAQzpAQsgAEEXNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPIBCyAAQQA2AhwgACABNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzxAQtCASERCyAQQQFqIQECQCAAKQMgIhJC//////////8PVg0AIAAgEkIEhiARhDcDICABIQEMhAELIABBADYCHCAAIAE2AhQgAEGtiYCAADYCECAAQQw2AgxBACEQDO8BCyAAQQA2AhwgACAQNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzuAQsgACgCBCEXIABBADYCBCAQIBGnaiIWIQEgACAXIBAgFiAUGyIQELWAgIAAIhRFDXMgAEEFNgIcIAAgEDYCFCAAIBQ2AgxBACEQDO0BCyAAQQA2AhwgACAQNgIUIABBqpyAgAA2AhAgAEEPNgIMQQAhEAzsAQsgACAQIAIQtICAgAAiAQ0BIBAhAQtBDiEQDNEBCwJAIAFBFUcNACAAQQI2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAzqAQsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAM6QELIAFBAWohEAJAIAAvATAiAUGAAXFFDQACQCAAIBAgAhC7gICAACIBDQAgECEBDHALIAFBFUcNugEgAEEFNgIcIAAgEDYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAM6QELAkAgAUGgBHFBoARHDQAgAC0ALUECcQ0AIABBADYCHCAAIBA2AhQgAEGWk4CAADYCECAAQQQ2AgxBACEQDOkBCyAAIBAgAhC9gICAABogECEBAkACQAJAAkACQCAAIBAgAhCzgICAAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIABBAToALgsgACAALwEwQcAAcjsBMCAQIQELQSYhEAzRAQsgAEEjNgIcIAAgEDYCFCAAQaWWgIAANgIQIABBFTYCDEEAIRAM6QELIABBADYCHCAAIBA2AhQgAEHVi4CAADYCECAAQRE2AgxBACEQDOgBCyAALQAtQQFxRQ0BQcMBIRAMzgELAkAgDSACRg0AA0ACQCANLQAAQSBGDQAgDSEBDMQBCyANQQFqIg0gAkcNAAtBJSEQDOcBC0ElIRAM5gELIAAoAgQhBCAAQQA2AgQgACAEIA0Qr4CAgAAiBEUNrQEgAEEmNgIcIAAgBDYCDCAAIA1BAWo2AhRBACEQDOUBCyAQQRVGDasBIABBADYCHCAAIAE2AhQgAEH9jYCAADYCECAAQR02AgxBACEQDOQBCyAAQSc2AhwgACABNgIUIAAgEDYCDEEAIRAM4wELIBAhAUEBIRQCQAJAAkACQAJAAkACQCAALQAsQX5qDgcGBQUDAQIABQsgACAALwEwQQhyOwEwDAMLQQIhFAwBC0EEIRQLIABBAToALCAAIAAvATAgFHI7ATALIBAhAQtBKyEQDMoBCyAAQQA2AhwgACAQNgIUIABBq5KAgAA2AhAgAEELNgIMQQAhEAziAQsgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDEEAIRAM4QELIABBADoALCAQIQEMvQELIBAhAUEBIRQCQAJAAkACQAJAIAAtACxBe2oOBAMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0EpIRAMxQELIABBADYCHCAAIAE2AhQgAEHwlICAADYCECAAQQM2AgxBACEQDN0BCwJAIA4tAABBDUcNACAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA5BAWohAQx1CyAAQSw2AhwgACABNgIMIAAgDkEBajYCFEEAIRAM3QELIAAtAC1BAXFFDQFBxAEhEAzDAQsCQCAOIAJHDQBBLSEQDNwBCwJAAkADQAJAIA4tAABBdmoOBAIAAAMACyAOQQFqIg4gAkcNAAtBLSEQDN0BCyAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA4hAQx0CyAAQSw2AhwgACAONgIUIAAgATYCDEEAIRAM3AELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHMLIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzbAQsgACgCBCEEIABBADYCBCAAIAQgDhCxgICAACIEDaABIA4hAQzOAQsgEEEsRw0BIAFBAWohEEEBIQECQAJAAkACQAJAIAAtACxBe2oOBAMBAgQACyAQIQEMBAtBAiEBDAELQQQhAQsgAEEBOgAsIAAgAC8BMCABcjsBMCAQIQEMAQsgACAALwEwQQhyOwEwIBAhAQtBOSEQDL8BCyAAQQA6ACwgASEBC0E0IRAMvQELIAAgAC8BMEEgcjsBMCABIQEMAgsgACgCBCEEIABBADYCBAJAIAAgBCABELGAgIAAIgQNACABIQEMxwELIABBNzYCHCAAIAE2AhQgACAENgIMQQAhEAzUAQsgAEEIOgAsIAEhAQtBMCEQDLkBCwJAIAAtAChBAUYNACABIQEMBAsgAC0ALUEIcUUNkwEgASEBDAMLIAAtADBBIHENlAFBxQEhEAy3AQsCQCAPIAJGDQACQANAAkAgDy0AAEFQaiIBQf8BcUEKSQ0AIA8hAUE1IRAMugELIAApAyAiEUKZs+bMmbPmzBlWDQEgACARQgp+IhE3AyAgESABrUL/AYMiEkJ/hVYNASAAIBEgEnw3AyAgD0EBaiIPIAJHDQALQTkhEAzRAQsgACgCBCECIABBADYCBCAAIAIgD0EBaiIEELGAgIAAIgINlQEgBCEBDMMBC0E5IRAMzwELAkAgAC8BMCIBQQhxRQ0AIAAtAChBAUcNACAALQAtQQhxRQ2QAQsgACABQff7A3FBgARyOwEwIA8hAQtBNyEQDLQBCyAAIAAvATBBEHI7ATAMqwELIBBBFUYNiwEgAEEANgIcIAAgATYCFCAAQfCOgIAANgIQIABBHDYCDEEAIRAMywELIABBwwA2AhwgACABNgIMIAAgDUEBajYCFEEAIRAMygELAkAgAS0AAEE6Rw0AIAAoAgQhECAAQQA2AgQCQCAAIBAgARCvgICAACIQDQAgAUEBaiEBDGMLIABBwwA2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMygELIABBADYCHCAAIAE2AhQgAEGxkYCAADYCECAAQQo2AgxBACEQDMkBCyAAQQA2AhwgACABNgIUIABBoJmAgAA2AhAgAEEeNgIMQQAhEAzIAQsgAEEANgIACyAAQYASOwEqIAAgF0EBaiIBIAIQqICAgAAiEA0BIAEhAQtBxwAhEAysAQsgEEEVRw2DASAAQdEANgIcIAAgATYCFCAAQeOXgIAANgIQIABBFTYCDEEAIRAMxAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDF4LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMwwELIABBADYCHCAAIBQ2AhQgAEHBqICAADYCECAAQQc2AgwgAEEANgIAQQAhEAzCAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAzBAQtBACEQIABBADYCHCAAIAE2AhQgAEGAkYCAADYCECAAQQk2AgwMwAELIBBBFUYNfSAAQQA2AhwgACABNgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAy/AQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgAUEBaiEBAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBAJAIAAgECABEK2AgIAAIhANACABIQEMXAsgAEHYADYCHCAAIAE2AhQgACAQNgIMQQAhEAy+AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMrQELIABB2QA2AhwgACABNgIUIAAgBDYCDEEAIRAMvQELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKsBCyAAQdoANgIcIAAgATYCFCAAIAQ2AgxBACEQDLwBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQypAQsgAEHcADYCHCAAIAE2AhQgACAENgIMQQAhEAy7AQsCQCABLQAAQVBqIhBB/wFxQQpPDQAgACAQOgAqIAFBAWohAUHPACEQDKIBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQynAQsgAEHeADYCHCAAIAE2AhQgACAENgIMQQAhEAy6AQsgAEEANgIAIBdBAWohAQJAIAAtAClBI08NACABIQEMWQsgAEEANgIcIAAgATYCFCAAQdOJgIAANgIQIABBCDYCDEEAIRAMuQELIABBADYCAAtBACEQIABBADYCHCAAIAE2AhQgAEGQs4CAADYCECAAQQg2AgwMtwELIABBADYCACAXQQFqIQECQCAALQApQSFHDQAgASEBDFYLIABBADYCHCAAIAE2AhQgAEGbioCAADYCECAAQQg2AgxBACEQDLYBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKSIQQV1qQQtPDQAgASEBDFULAkAgEEEGSw0AQQEgEHRBygBxRQ0AIAEhAQxVC0EAIRAgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDAy1AQsgEEEVRg1xIABBADYCHCAAIAE2AhQgAEG5jYCAADYCECAAQRo2AgxBACEQDLQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxUCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLMBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAUNgIUIAAgATYCDEEAIRAMogELIABBADYCHCAAIBQ2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKEBCyAAQQA2AhwgACABNgIUIABBw4+AgAA2AhAgAEEHNgIMQQAhEAygAQtBACEQIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgwMnwELIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgxBACEQDJ4BCyAAQQA2AhwgACAUNgIUIABB/pGAgAA2AhAgAEEHNgIMQQAhEAydAQsgAEEANgIcIAAgATYCFCAAQY6bgIAANgIQIABBBjYCDEEAIRAMnAELIBBBFUYNVyAAQQA2AhwgACABNgIUIABBzI6AgAA2AhAgAEEgNgIMQQAhEAybAQsgAEEANgIAIBBBAWohAUEkIRALIAAgEDoAKSAAKAIEIRAgAEEANgIEIAAgECABEKuAgIAAIhANVCABIQEMPgsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQfGbgIAANgIQIABBBjYCDAyXAQsgAUEVRg1QIABBADYCHCAAIAU2AhQgAEHwjICAADYCECAAQRs2AgxBACEQDJYBCyAAKAIEIQUgAEEANgIEIAAgBSAQEKmAgIAAIgUNASAQQQFqIQULQa0BIRAMewsgAEHBATYCHCAAIAU2AgwgACAQQQFqNgIUQQAhEAyTAQsgACgCBCEGIABBADYCBCAAIAYgEBCpgICAACIGDQEgEEEBaiEGC0GuASEQDHgLIABBwgE2AhwgACAGNgIMIAAgEEEBajYCFEEAIRAMkAELIABBADYCHCAAIAc2AhQgAEGXi4CAADYCECAAQQ02AgxBACEQDI8BCyAAQQA2AhwgACAINgIUIABB45CAgAA2AhAgAEEJNgIMQQAhEAyOAQsgAEEANgIcIAAgCDYCFCAAQZSNgIAANgIQIABBITYCDEEAIRAMjQELQQEhFkEAIRdBACEUQQEhEAsgACAQOgArIAlBAWohCAJAAkAgAC0ALUEQcQ0AAkACQAJAIAAtACoOAwEAAgQLIBZFDQMMAgsgFA0BDAILIBdFDQELIAAoAgQhECAAQQA2AgQgACAQIAgQrYCAgAAiEEUNPSAAQckBNgIcIAAgCDYCFCAAIBA2AgxBACEQDIwBCyAAKAIEIQQgAEEANgIEIAAgBCAIEK2AgIAAIgRFDXYgAEHKATYCHCAAIAg2AhQgACAENgIMQQAhEAyLAQsgACgCBCEEIABBADYCBCAAIAQgCRCtgICAACIERQ10IABBywE2AhwgACAJNgIUIAAgBDYCDEEAIRAMigELIAAoAgQhBCAAQQA2AgQgACAEIAoQrYCAgAAiBEUNciAAQc0BNgIcIAAgCjYCFCAAIAQ2AgxBACEQDIkBCwJAIAstAABBUGoiEEH/AXFBCk8NACAAIBA6ACogC0EBaiEKQbYBIRAMcAsgACgCBCEEIABBADYCBCAAIAQgCxCtgICAACIERQ1wIABBzwE2AhwgACALNgIUIAAgBDYCDEEAIRAMiAELIABBADYCHCAAIAQ2AhQgAEGQs4CAADYCECAAQQg2AgwgAEEANgIAQQAhEAyHAQsgAUEVRg0/IABBADYCHCAAIAw2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDIYBCyAAQYEEOwEoIAAoAgQhECAAQgA3AwAgACAQIAxBAWoiDBCrgICAACIQRQ04IABB0wE2AhwgACAMNgIUIAAgEDYCDEEAIRAMhQELIABBADYCAAtBACEQIABBADYCHCAAIAQ2AhQgAEHYm4CAADYCECAAQQg2AgwMgwELIAAoAgQhECAAQgA3AwAgACAQIAtBAWoiCxCrgICAACIQDQFBxgEhEAxpCyAAQQI6ACgMVQsgAEHVATYCHCAAIAs2AhQgACAQNgIMQQAhEAyAAQsgEEEVRg03IABBADYCHCAAIAQ2AhQgAEGkjICAADYCECAAQRA2AgxBACEQDH8LIAAtADRBAUcNNCAAIAQgAhC8gICAACIQRQ00IBBBFUcNNSAAQdwBNgIcIAAgBDYCFCAAQdWWgIAANgIQIABBFTYCDEEAIRAMfgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQMfQtBACEQDGMLQQIhEAxiC0ENIRAMYQtBDyEQDGALQSUhEAxfC0ETIRAMXgtBFSEQDF0LQRYhEAxcC0EXIRAMWwtBGCEQDFoLQRkhEAxZC0EaIRAMWAtBGyEQDFcLQRwhEAxWC0EdIRAMVQtBHyEQDFQLQSEhEAxTC0EjIRAMUgtBxgAhEAxRC0EuIRAMUAtBLyEQDE8LQTshEAxOC0E9IRAMTQtByAAhEAxMC0HJACEQDEsLQcsAIRAMSgtBzAAhEAxJC0HOACEQDEgLQdEAIRAMRwtB1QAhEAxGC0HYACEQDEULQdkAIRAMRAtB2wAhEAxDC0HkACEQDEILQeUAIRAMQQtB8QAhEAxAC0H0ACEQDD8LQY0BIRAMPgtBlwEhEAw9C0GpASEQDDwLQawBIRAMOwtBwAEhEAw6C0G5ASEQDDkLQa8BIRAMOAtBsQEhEAw3C0GyASEQDDYLQbQBIRAMNQtBtQEhEAw0C0G6ASEQDDMLQb0BIRAMMgtBvwEhEAwxC0HBASEQDDALIABBADYCHCAAIAQ2AhQgAEHpi4CAADYCECAAQR82AgxBACEQDEgLIABB2wE2AhwgACAENgIUIABB+paAgAA2AhAgAEEVNgIMQQAhEAxHCyAAQfgANgIcIAAgDDYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMRgsgAEHRADYCHCAAIAU2AhQgAEGwl4CAADYCECAAQRU2AgxBACEQDEULIABB+QA2AhwgACABNgIUIAAgEDYCDEEAIRAMRAsgAEH4ADYCHCAAIAE2AhQgAEHKmICAADYCECAAQRU2AgxBACEQDEMLIABB5AA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAxCCyAAQdcANgIcIAAgATYCFCAAQcmXgIAANgIQIABBFTYCDEEAIRAMQQsgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMQAsgAEHCADYCHCAAIAE2AhQgAEHjmICAADYCECAAQRU2AgxBACEQDD8LIABBADYCBCAAIA8gDxCxgICAACIERQ0BIABBOjYCHCAAIAQ2AgwgACAPQQFqNgIUQQAhEAw+CyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBEUNACAAQTs2AhwgACAENgIMIAAgAUEBajYCFEEAIRAMPgsgAUEBaiEBDC0LIA9BAWohAQwtCyAAQQA2AhwgACAPNgIUIABB5JKAgAA2AhAgAEEENgIMQQAhEAw7CyAAQTY2AhwgACAENgIUIAAgAjYCDEEAIRAMOgsgAEEuNgIcIAAgDjYCFCAAIAQ2AgxBACEQDDkLIABB0AA2AhwgACABNgIUIABBkZiAgAA2AhAgAEEVNgIMQQAhEAw4CyANQQFqIQEMLAsgAEEVNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMNgsgAEEbNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNQsgAEEPNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNAsgAEELNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMMwsgAEEaNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMgsgAEELNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMQsgAEEKNgIcIAAgATYCFCAAQeSWgIAANgIQIABBFTYCDEEAIRAMMAsgAEEeNgIcIAAgATYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAMLwsgAEEANgIcIAAgEDYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMLgsgAEEENgIcIAAgATYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMLQsgAEEANgIAIAtBAWohCwtBuAEhEAwSCyAAQQA2AgAgEEEBaiEBQfUAIRAMEQsgASEBAkAgAC0AKUEFRw0AQeMAIRAMEQtB4gAhEAwQC0EAIRAgAEEANgIcIABB5JGAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAwoCyAAQQA2AgAgF0EBaiEBQcAAIRAMDgtBASEBCyAAIAE6ACwgAEEANgIAIBdBAWohAQtBKCEQDAsLIAEhAQtBOCEQDAkLAkAgASIPIAJGDQADQAJAIA8tAABBgL6AgABqLQAAIgFBAUYNACABQQJHDQMgD0EBaiEBDAQLIA9BAWoiDyACRw0AC0E+IRAMIgtBPiEQDCELIABBADoALCAPIQEMAQtBCyEQDAYLQTohEAwFCyABQQFqIQFBLSEQDAQLIAAgAToALCAAQQA2AgAgFkEBaiEBQQwhEAwDCyAAQQA2AgAgF0EBaiEBQQohEAwCCyAAQQA2AgALIABBADoALCANIQFBCSEQDAALC0EAIRAgAEEANgIcIAAgCzYCFCAAQc2QgIAANgIQIABBCTYCDAwXC0EAIRAgAEEANgIcIAAgCjYCFCAAQemKgIAANgIQIABBCTYCDAwWC0EAIRAgAEEANgIcIAAgCTYCFCAAQbeQgIAANgIQIABBCTYCDAwVC0EAIRAgAEEANgIcIAAgCDYCFCAAQZyRgIAANgIQIABBCTYCDAwUC0EAIRAgAEEANgIcIAAgATYCFCAAQc2QgIAANgIQIABBCTYCDAwTC0EAIRAgAEEANgIcIAAgATYCFCAAQemKgIAANgIQIABBCTYCDAwSC0EAIRAgAEEANgIcIAAgATYCFCAAQbeQgIAANgIQIABBCTYCDAwRC0EAIRAgAEEANgIcIAAgATYCFCAAQZyRgIAANgIQIABBCTYCDAwQC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwPC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwOC0EAIRAgAEEANgIcIAAgATYCFCAAQcCSgIAANgIQIABBCzYCDAwNC0EAIRAgAEEANgIcIAAgATYCFCAAQZWJgIAANgIQIABBCzYCDAwMC0EAIRAgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDAwLC0EAIRAgAEEANgIcIAAgATYCFCAAQfuPgIAANgIQIABBCjYCDAwKC0EAIRAgAEEANgIcIAAgATYCFCAAQfGZgIAANgIQIABBAjYCDAwJC0EAIRAgAEEANgIcIAAgATYCFCAAQcSUgIAANgIQIABBAjYCDAwIC0EAIRAgAEEANgIcIAAgATYCFCAAQfKVgIAANgIQIABBAjYCDAwHCyAAQQI2AhwgACABNgIUIABBnJqAgAA2AhAgAEEWNgIMQQAhEAwGC0EBIRAMBQtB1AAhECABIgQgAkYNBCADQQhqIAAgBCACQdjCgIAAQQoQxYCAgAAgAygCDCEEIAMoAggOAwEEAgALEMqAgIAAAAsgAEEANgIcIABBtZqAgAA2AhAgAEEXNgIMIAAgBEEBajYCFEEAIRAMAgsgAEEANgIcIAAgBDYCFCAAQcqagIAANgIQIABBCTYCDEEAIRAMAQsCQCABIgQgAkcNAEEiIRAMAQsgAEGJgICAADYCCCAAIAQ2AgRBISEQCyADQRBqJICAgIAAIBALrwEBAn8gASgCACEGAkACQCACIANGDQAgBCAGaiEEIAYgA2ogAmshByACIAZBf3MgBWoiBmohBQNAAkAgAi0AACAELQAARg0AQQIhBAwDCwJAIAYNAEEAIQQgBSECDAMLIAZBf2ohBiAEQQFqIQQgAkEBaiICIANHDQALIAchBiADIQILIABBATYCACABIAY2AgAgACACNgIEDwsgAUEANgIAIAAgBDYCACAAIAI2AgQLCgAgABDHgICAAAvyNgELfyOAgICAAEEQayIBJICAgIAAAkBBACgCoNCAgAANAEEAEMuAgIAAQYDUhIAAayICQdkASQ0AQQAhAwJAQQAoAuDTgIAAIgQNAEEAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEIakFwcUHYqtWqBXMiBDYC4NOAgABBAEEANgL004CAAEEAQQA2AsTTgIAAC0EAIAI2AszTgIAAQQBBgNSEgAA2AsjTgIAAQQBBgNSEgAA2ApjQgIAAQQAgBDYCrNCAgABBAEF/NgKo0ICAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALQYDUhIAAQXhBgNSEgABrQQ9xQQBBgNSEgABBCGpBD3EbIgNqIgRBBGogAkFIaiIFIANrIgNBAXI2AgBBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAQYDUhIAAIAVqQTg2AgQLAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKI0ICAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQACQAJAIANBAXEgBHJBAXMiBUEDdCIEQbDQgIAAaiIDIARBuNCAgABqKAIAIgQoAggiAkcNAEEAIAZBfiAFd3E2AojQgIAADAELIAMgAjYCCCACIAM2AgwLIARBCGohAyAEIAVBA3QiBUEDcjYCBCAEIAVqIgQgBCgCBEEBcjYCBAwMCyACQQAoApDQgIAAIgdNDQECQCADRQ0AAkACQCADIAR0QQIgBHQiA0EAIANrcnEiA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqIgRBA3QiA0Gw0ICAAGoiBSADQbjQgIAAaigCACIDKAIIIgBHDQBBACAGQX4gBHdxIgY2AojQgIAADAELIAUgADYCCCAAIAU2AgwLIAMgAkEDcjYCBCADIARBA3QiBGogBCACayIFNgIAIAMgAmoiACAFQQFyNgIEAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQQCQAJAIAZBASAHQQN2dCIIcQ0AQQAgBiAIcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCAENgIMIAIgBDYCCCAEIAI2AgwgBCAINgIICyADQQhqIQNBACAANgKc0ICAAEEAIAU2ApDQgIAADAwLQQAoAozQgIAAIglFDQEgCUEAIAlrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqQQJ0QbjSgIAAaigCACIAKAIEQXhxIAJrIQQgACEFAkADQAJAIAUoAhAiAw0AIAVBFGooAgAiA0UNAgsgAygCBEF4cSACayIFIAQgBSAESSIFGyEEIAMgACAFGyEAIAMhBQwACwsgACgCGCEKAkAgACgCDCIIIABGDQAgACgCCCIDQQAoApjQgIAASRogCCADNgIIIAMgCDYCDAwLCwJAIABBFGoiBSgCACIDDQAgACgCECIDRQ0DIABBEGohBQsDQCAFIQsgAyIIQRRqIgUoAgAiAw0AIAhBEGohBSAIKAIQIgMNAAsgC0EANgIADAoLQX8hAiAAQb9/Sw0AIABBE2oiA0FwcSECQQAoAozQgIAAIgdFDQBBACELAkAgAkGAAkkNAEEfIQsgAkH///8HSw0AIANBCHYiAyADQYD+P2pBEHZBCHEiA3QiBCAEQYDgH2pBEHZBBHEiBHQiBSAFQYCAD2pBEHZBAnEiBXRBD3YgAyAEciAFcmsiA0EBdCACIANBFWp2QQFxckEcaiELC0EAIAJrIQQCQAJAAkACQCALQQJ0QbjSgIAAaigCACIFDQBBACEDQQAhCAwBC0EAIQMgAkEAQRkgC0EBdmsgC0EfRht0IQBBACEIA0ACQCAFKAIEQXhxIAJrIgYgBE8NACAGIQQgBSEIIAYNAEEAIQQgBSEIIAUhAwwDCyADIAVBFGooAgAiBiAGIAUgAEEddkEEcWpBEGooAgAiBUYbIAMgBhshAyAAQQF0IQAgBQ0ACwsCQCADIAhyDQBBACEIQQIgC3QiA0EAIANrciAHcSIDRQ0DIANBACADa3FBf2oiAyADQQx2QRBxIgN2IgVBBXZBCHEiACADciAFIAB2IgNBAnZBBHEiBXIgAyAFdiIDQQF2QQJxIgVyIAMgBXYiA0EBdkEBcSIFciADIAV2akECdEG40oCAAGooAgAhAwsgA0UNAQsDQCADKAIEQXhxIAJrIgYgBEkhAAJAIAMoAhAiBQ0AIANBFGooAgAhBQsgBiAEIAAbIQQgAyAIIAAbIQggBSEDIAUNAAsLIAhFDQAgBEEAKAKQ0ICAACACa08NACAIKAIYIQsCQCAIKAIMIgAgCEYNACAIKAIIIgNBACgCmNCAgABJGiAAIAM2AgggAyAANgIMDAkLAkAgCEEUaiIFKAIAIgMNACAIKAIQIgNFDQMgCEEQaiEFCwNAIAUhBiADIgBBFGoiBSgCACIDDQAgAEEQaiEFIAAoAhAiAw0ACyAGQQA2AgAMCAsCQEEAKAKQ0ICAACIDIAJJDQBBACgCnNCAgAAhBAJAAkAgAyACayIFQRBJDQAgBCACaiIAIAVBAXI2AgRBACAFNgKQ0ICAAEEAIAA2ApzQgIAAIAQgA2ogBTYCACAEIAJBA3I2AgQMAQsgBCADQQNyNgIEIAQgA2oiAyADKAIEQQFyNgIEQQBBADYCnNCAgABBAEEANgKQ0ICAAAsgBEEIaiEDDAoLAkBBACgClNCAgAAiACACTQ0AQQAoAqDQgIAAIgMgAmoiBCAAIAJrIgVBAXI2AgRBACAFNgKU0ICAAEEAIAQ2AqDQgIAAIAMgAkEDcjYCBCADQQhqIQMMCgsCQAJAQQAoAuDTgIAARQ0AQQAoAujTgIAAIQQMAQtBAEJ/NwLs04CAAEEAQoCAhICAgMAANwLk04CAAEEAIAFBDGpBcHFB2KrVqgVzNgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgABBgIAEIQQLQQAhAwJAIAQgAkHHAGoiB2oiBkEAIARrIgtxIgggAksNAEEAQTA2AvjTgIAADAoLAkBBACgCwNOAgAAiA0UNAAJAQQAoArjTgIAAIgQgCGoiBSAETQ0AIAUgA00NAQtBACEDQQBBMDYC+NOAgAAMCgtBAC0AxNOAgABBBHENBAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQAJAIAMoAgAiBSAESw0AIAUgAygCBGogBEsNAwsgAygCCCIDDQALC0EAEMuAgIAAIgBBf0YNBSAIIQYCQEEAKALk04CAACIDQX9qIgQgAHFFDQAgCCAAayAEIABqQQAgA2txaiEGCyAGIAJNDQUgBkH+////B0sNBQJAQQAoAsDTgIAAIgNFDQBBACgCuNOAgAAiBCAGaiIFIARNDQYgBSADSw0GCyAGEMuAgIAAIgMgAEcNAQwHCyAGIABrIAtxIgZB/v///wdLDQQgBhDLgICAACIAIAMoAgAgAygCBGpGDQMgACEDCwJAIANBf0YNACACQcgAaiAGTQ0AAkAgByAGa0EAKALo04CAACIEakEAIARrcSIEQf7///8HTQ0AIAMhAAwHCwJAIAQQy4CAgABBf0YNACAEIAZqIQYgAyEADAcLQQAgBmsQy4CAgAAaDAQLIAMhACADQX9HDQUMAwtBACEIDAcLQQAhAAwFCyAAQX9HDQILQQBBACgCxNOAgABBBHI2AsTTgIAACyAIQf7///8HSw0BIAgQy4CAgAAhAEEAEMuAgIAAIQMgAEF/Rg0BIANBf0YNASAAIANPDQEgAyAAayIGIAJBOGpNDQELQQBBACgCuNOAgAAgBmoiAzYCuNOAgAACQCADQQAoArzTgIAATQ0AQQAgAzYCvNOAgAALAkACQAJAAkBBACgCoNCAgAAiBEUNAEHI04CAACEDA0AgACADKAIAIgUgAygCBCIIakYNAiADKAIIIgMNAAwDCwsCQAJAQQAoApjQgIAAIgNFDQAgACADTw0BC0EAIAA2ApjQgIAAC0EAIQNBACAGNgLM04CAAEEAIAA2AsjTgIAAQQBBfzYCqNCAgABBAEEAKALg04CAADYCrNCAgABBAEEANgLU04CAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgQgBkFIaiIFIANrIgNBAXI2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAIAAgBWpBODYCBAwCCyADLQAMQQhxDQAgBCAFSQ0AIAQgAE8NACAEQXggBGtBD3FBACAEQQhqQQ9xGyIFaiIAQQAoApTQgIAAIAZqIgsgBWsiBUEBcjYCBCADIAggBmo2AgRBAEEAKALw04CAADYCpNCAgABBACAFNgKU0ICAAEEAIAA2AqDQgIAAIAQgC2pBODYCBAwBCwJAIABBACgCmNCAgAAiCE8NAEEAIAA2ApjQgIAAIAAhCAsgACAGaiEFQcjTgIAAIQMCQAJAAkACQAJAAkACQANAIAMoAgAgBUYNASADKAIIIgMNAAwCCwsgAy0ADEEIcUUNAQtByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiIFIARLDQMLIAMoAgghAwwACwsgAyAANgIAIAMgAygCBCAGajYCBCAAQXggAGtBD3FBACAAQQhqQQ9xG2oiCyACQQNyNgIEIAVBeCAFa0EPcUEAIAVBCGpBD3EbaiIGIAsgAmoiAmshAwJAIAYgBEcNAEEAIAI2AqDQgIAAQQBBACgClNCAgAAgA2oiAzYClNCAgAAgAiADQQFyNgIEDAMLAkAgBkEAKAKc0ICAAEcNAEEAIAI2ApzQgIAAQQBBACgCkNCAgAAgA2oiAzYCkNCAgAAgAiADQQFyNgIEIAIgA2ogAzYCAAwDCwJAIAYoAgQiBEEDcUEBRw0AIARBeHEhBwJAAkAgBEH/AUsNACAGKAIIIgUgBEEDdiIIQQN0QbDQgIAAaiIARhoCQCAGKAIMIgQgBUcNAEEAQQAoAojQgIAAQX4gCHdxNgKI0ICAAAwCCyAEIABGGiAEIAU2AgggBSAENgIMDAELIAYoAhghCQJAAkAgBigCDCIAIAZGDQAgBigCCCIEIAhJGiAAIAQ2AgggBCAANgIMDAELAkAgBkEUaiIEKAIAIgUNACAGQRBqIgQoAgAiBQ0AQQAhAAwBCwNAIAQhCCAFIgBBFGoiBCgCACIFDQAgAEEQaiEEIAAoAhAiBQ0ACyAIQQA2AgALIAlFDQACQAJAIAYgBigCHCIFQQJ0QbjSgIAAaiIEKAIARw0AIAQgADYCACAADQFBAEEAKAKM0ICAAEF+IAV3cTYCjNCAgAAMAgsgCUEQQRQgCSgCECAGRhtqIAA2AgAgAEUNAQsgACAJNgIYAkAgBigCECIERQ0AIAAgBDYCECAEIAA2AhgLIAYoAhQiBEUNACAAQRRqIAQ2AgAgBCAANgIYCyAHIANqIQMgBiAHaiIGKAIEIQQLIAYgBEF+cTYCBCACIANqIAM2AgAgAiADQQFyNgIEAkAgA0H/AUsNACADQXhxQbDQgIAAaiEEAkACQEEAKAKI0ICAACIFQQEgA0EDdnQiA3ENAEEAIAUgA3I2AojQgIAAIAQhAwwBCyAEKAIIIQMLIAMgAjYCDCAEIAI2AgggAiAENgIMIAIgAzYCCAwDC0EfIQQCQCADQf///wdLDQAgA0EIdiIEIARBgP4/akEQdkEIcSIEdCIFIAVBgOAfakEQdkEEcSIFdCIAIABBgIAPakEQdkECcSIAdEEPdiAEIAVyIAByayIEQQF0IAMgBEEVanZBAXFyQRxqIQQLIAIgBDYCHCACQgA3AhAgBEECdEG40oCAAGohBQJAQQAoAozQgIAAIgBBASAEdCIIcQ0AIAUgAjYCAEEAIAAgCHI2AozQgIAAIAIgBTYCGCACIAI2AgggAiACNgIMDAMLIANBAEEZIARBAXZrIARBH0YbdCEEIAUoAgAhAANAIAAiBSgCBEF4cSADRg0CIARBHXYhACAEQQF0IQQgBSAAQQRxakEQaiIIKAIAIgANAAsgCCACNgIAIAIgBTYCGCACIAI2AgwgAiACNgIIDAILIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgsgBkFIaiIIIANrIgNBAXI2AgQgACAIakE4NgIEIAQgBUE3IAVrQQ9xQQAgBUFJakEPcRtqQUFqIgggCCAEQRBqSRsiCEEjNgIEQQBBACgC8NOAgAA2AqTQgIAAQQAgAzYClNCAgABBACALNgKg0ICAACAIQRBqQQApAtDTgIAANwIAIAhBACkCyNOAgAA3AghBACAIQQhqNgLQ04CAAEEAIAY2AszTgIAAQQAgADYCyNOAgABBAEEANgLU04CAACAIQSRqIQMDQCADQQc2AgAgA0EEaiIDIAVJDQALIAggBEYNAyAIIAgoAgRBfnE2AgQgCCAIIARrIgA2AgAgBCAAQQFyNgIEAkAgAEH/AUsNACAAQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgAEEDdnQiAHENAEEAIAUgAHI2AojQgIAAIAMhBQwBCyADKAIIIQULIAUgBDYCDCADIAQ2AgggBCADNgIMIAQgBTYCCAwEC0EfIQMCQCAAQf///wdLDQAgAEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCIIIAhBgIAPakEQdkECcSIIdEEPdiADIAVyIAhyayIDQQF0IAAgA0EVanZBAXFyQRxqIQMLIAQgAzYCHCAEQgA3AhAgA0ECdEG40oCAAGohBQJAQQAoAozQgIAAIghBASADdCIGcQ0AIAUgBDYCAEEAIAggBnI2AozQgIAAIAQgBTYCGCAEIAQ2AgggBCAENgIMDAQLIABBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhCANAIAgiBSgCBEF4cSAARg0DIANBHXYhCCADQQF0IQMgBSAIQQRxakEQaiIGKAIAIggNAAsgBiAENgIAIAQgBTYCGCAEIAQ2AgwgBCAENgIIDAMLIAUoAggiAyACNgIMIAUgAjYCCCACQQA2AhggAiAFNgIMIAIgAzYCCAsgC0EIaiEDDAULIAUoAggiAyAENgIMIAUgBDYCCCAEQQA2AhggBCAFNgIMIAQgAzYCCAtBACgClNCAgAAiAyACTQ0AQQAoAqDQgIAAIgQgAmoiBSADIAJrIgNBAXI2AgRBACADNgKU0ICAAEEAIAU2AqDQgIAAIAQgAkEDcjYCBCAEQQhqIQMMAwtBACEDQQBBMDYC+NOAgAAMAgsCQCALRQ0AAkACQCAIIAgoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAA2AgAgAA0BQQAgB0F+IAV3cSIHNgKM0ICAAAwCCyALQRBBFCALKAIQIAhGG2ogADYCACAARQ0BCyAAIAs2AhgCQCAIKAIQIgNFDQAgACADNgIQIAMgADYCGAsgCEEUaigCACIDRQ0AIABBFGogAzYCACADIAA2AhgLAkACQCAEQQ9LDQAgCCAEIAJqIgNBA3I2AgQgCCADaiIDIAMoAgRBAXI2AgQMAQsgCCACaiIAIARBAXI2AgQgCCACQQNyNgIEIAAgBGogBDYCAAJAIARB/wFLDQAgBEF4cUGw0ICAAGohAwJAAkBBACgCiNCAgAAiBUEBIARBA3Z0IgRxDQBBACAFIARyNgKI0ICAACADIQQMAQsgAygCCCEECyAEIAA2AgwgAyAANgIIIAAgAzYCDCAAIAQ2AggMAQtBHyEDAkAgBEH///8HSw0AIARBCHYiAyADQYD+P2pBEHZBCHEiA3QiBSAFQYDgH2pBEHZBBHEiBXQiAiACQYCAD2pBEHZBAnEiAnRBD3YgAyAFciACcmsiA0EBdCAEIANBFWp2QQFxckEcaiEDCyAAIAM2AhwgAEIANwIQIANBAnRBuNKAgABqIQUCQCAHQQEgA3QiAnENACAFIAA2AgBBACAHIAJyNgKM0ICAACAAIAU2AhggACAANgIIIAAgADYCDAwBCyAEQQBBGSADQQF2ayADQR9GG3QhAyAFKAIAIQICQANAIAIiBSgCBEF4cSAERg0BIANBHXYhAiADQQF0IQMgBSACQQRxakEQaiIGKAIAIgINAAsgBiAANgIAIAAgBTYCGCAAIAA2AgwgACAANgIIDAELIAUoAggiAyAANgIMIAUgADYCCCAAQQA2AhggACAFNgIMIAAgAzYCCAsgCEEIaiEDDAELAkAgCkUNAAJAAkAgACAAKAIcIgVBAnRBuNKAgABqIgMoAgBHDQAgAyAINgIAIAgNAUEAIAlBfiAFd3E2AozQgIAADAILIApBEEEUIAooAhAgAEYbaiAINgIAIAhFDQELIAggCjYCGAJAIAAoAhAiA0UNACAIIAM2AhAgAyAINgIYCyAAQRRqKAIAIgNFDQAgCEEUaiADNgIAIAMgCDYCGAsCQAJAIARBD0sNACAAIAQgAmoiA0EDcjYCBCAAIANqIgMgAygCBEEBcjYCBAwBCyAAIAJqIgUgBEEBcjYCBCAAIAJBA3I2AgQgBSAEaiAENgIAAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQMCQAJAQQEgB0EDdnQiCCAGcQ0AQQAgCCAGcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCADNgIMIAIgAzYCCCADIAI2AgwgAyAINgIIC0EAIAU2ApzQgIAAQQAgBDYCkNCAgAALIABBCGohAwsgAUEQaiSAgICAACADCwoAIAAQyYCAgAAL4g0BB38CQCAARQ0AIABBeGoiASAAQXxqKAIAIgJBeHEiAGohAwJAIAJBAXENACACQQNxRQ0BIAEgASgCACICayIBQQAoApjQgIAAIgRJDQEgAiAAaiEAAkAgAUEAKAKc0ICAAEYNAAJAIAJB/wFLDQAgASgCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgASgCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAwsgAiAGRhogAiAENgIIIAQgAjYCDAwCCyABKAIYIQcCQAJAIAEoAgwiBiABRg0AIAEoAggiAiAESRogBiACNgIIIAIgBjYCDAwBCwJAIAFBFGoiAigCACIEDQAgAUEQaiICKAIAIgQNAEEAIQYMAQsDQCACIQUgBCIGQRRqIgIoAgAiBA0AIAZBEGohAiAGKAIQIgQNAAsgBUEANgIACyAHRQ0BAkACQCABIAEoAhwiBEECdEG40oCAAGoiAigCAEcNACACIAY2AgAgBg0BQQBBACgCjNCAgABBfiAEd3E2AozQgIAADAMLIAdBEEEUIAcoAhAgAUYbaiAGNgIAIAZFDQILIAYgBzYCGAJAIAEoAhAiAkUNACAGIAI2AhAgAiAGNgIYCyABKAIUIgJFDQEgBkEUaiACNgIAIAIgBjYCGAwBCyADKAIEIgJBA3FBA0cNACADIAJBfnE2AgRBACAANgKQ0ICAACABIABqIAA2AgAgASAAQQFyNgIEDwsgASADTw0AIAMoAgQiAkEBcUUNAAJAAkAgAkECcQ0AAkAgA0EAKAKg0ICAAEcNAEEAIAE2AqDQgIAAQQBBACgClNCAgAAgAGoiADYClNCAgAAgASAAQQFyNgIEIAFBACgCnNCAgABHDQNBAEEANgKQ0ICAAEEAQQA2ApzQgIAADwsCQCADQQAoApzQgIAARw0AQQAgATYCnNCAgABBAEEAKAKQ0ICAACAAaiIANgKQ0ICAACABIABBAXI2AgQgASAAaiAANgIADwsgAkF4cSAAaiEAAkACQCACQf8BSw0AIAMoAggiBCACQQN2IgVBA3RBsNCAgABqIgZGGgJAIAMoAgwiAiAERw0AQQBBACgCiNCAgABBfiAFd3E2AojQgIAADAILIAIgBkYaIAIgBDYCCCAEIAI2AgwMAQsgAygCGCEHAkACQCADKAIMIgYgA0YNACADKAIIIgJBACgCmNCAgABJGiAGIAI2AgggAiAGNgIMDAELAkAgA0EUaiICKAIAIgQNACADQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQACQAJAIAMgAygCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAgsgB0EQQRQgBygCECADRhtqIAY2AgAgBkUNAQsgBiAHNgIYAkAgAygCECICRQ0AIAYgAjYCECACIAY2AhgLIAMoAhQiAkUNACAGQRRqIAI2AgAgAiAGNgIYCyABIABqIAA2AgAgASAAQQFyNgIEIAFBACgCnNCAgABHDQFBACAANgKQ0ICAAA8LIAMgAkF+cTYCBCABIABqIAA2AgAgASAAQQFyNgIECwJAIABB/wFLDQAgAEF4cUGw0ICAAGohAgJAAkBBACgCiNCAgAAiBEEBIABBA3Z0IgBxDQBBACAEIAByNgKI0ICAACACIQAMAQsgAigCCCEACyAAIAE2AgwgAiABNgIIIAEgAjYCDCABIAA2AggPC0EfIQICQCAAQf///wdLDQAgAEEIdiICIAJBgP4/akEQdkEIcSICdCIEIARBgOAfakEQdkEEcSIEdCIGIAZBgIAPakEQdkECcSIGdEEPdiACIARyIAZyayICQQF0IAAgAkEVanZBAXFyQRxqIQILIAEgAjYCHCABQgA3AhAgAkECdEG40oCAAGohBAJAAkBBACgCjNCAgAAiBkEBIAJ0IgNxDQAgBCABNgIAQQAgBiADcjYCjNCAgAAgASAENgIYIAEgATYCCCABIAE2AgwMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgBCgCACEGAkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABIAQ2AhggASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEANgIYIAEgBDYCDCABIAA2AggLQQBBACgCqNCAgABBf2oiAUF/IAEbNgKo0ICAAAsLBAAAAAtOAAJAIAANAD8AQRB0DwsCQCAAQf//A3ENACAAQX9MDQACQCAAQRB2QAAiAEF/Rw0AQQBBMDYC+NOAgABBfw8LIABBEHQPCxDKgICAAAAL8gICA38BfgJAIAJFDQAgACABOgAAIAIgAGoiA0F/aiABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBfWogAToAACADQX5qIAE6AAAgAkEHSQ0AIAAgAToAAyADQXxqIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIFayICQSBJDQAgAa1CgYCAgBB+IQYgAyAFaiEBA0AgASAGNwMYIAEgBjcDECABIAY3AwggASAGNwMAIAFBIGohASACQWBqIgJBH0sNAAsLIAALC45IAQBBgAgLhkgBAAAAAgAAAAMAAAAAAAAAAAAAAAQAAAAFAAAAAAAAAAAAAAAGAAAABwAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
});

// node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS((exports, module) => {
  module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCrLgAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQyoCAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDKgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMqAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMqAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL/gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARB//8DcSIDQQhxDQACQCADQYAEcUUNAAJAIAAtAChBAUcNACAALQAtQQpxDQBBBQ8LQQQPCwJAIANBIHENAAJAIAAtAChBAUYNACAALwEyQf//A3EiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQShxRQ0CIANBiARxQYAERg0CC0EADwtBAEEDIAApAyBQGyEFCyAFC2IBAn9BACEBAkAgAC0AKEEBRg0AIAAvATJB//8DcSICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6cBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMkH//wNxIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuZAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATJB//8DcSIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC0kBAXsgAEEQav0MAAAAAAAAAAAAAAAAAAAAACIB/QsDACAAIAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AcsBygG4AckBuQHIAboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBANwBC0EAIRAMxgELQQ4hEAzFAQtBDSEQDMQBC0EPIRAMwwELQRAhEAzCAQtBEyEQDMEBC0EUIRAMwAELQRUhEAy/AQtBFiEQDL4BC0EXIRAMvQELQRghEAy8AQtBGSEQDLsBC0EaIRAMugELQRshEAy5AQtBHCEQDLgBC0EIIRAMtwELQR0hEAy2AQtBICEQDLUBC0EfIRAMtAELQQchEAyzAQtBISEQDLIBC0EiIRAMsQELQR4hEAywAQtBIyEQDK8BC0ESIRAMrgELQREhEAytAQtBJCEQDKwBC0ElIRAMqwELQSYhEAyqAQtBJyEQDKkBC0HDASEQDKgBC0EpIRAMpwELQSshEAymAQtBLCEQDKUBC0EtIRAMpAELQS4hEAyjAQtBLyEQDKIBC0HEASEQDKEBC0EwIRAMoAELQTQhEAyfAQtBDCEQDJ4BC0ExIRAMnQELQTIhEAycAQtBMyEQDJsBC0E5IRAMmgELQTUhEAyZAQtBxQEhEAyYAQtBCyEQDJcBC0E6IRAMlgELQTYhEAyVAQtBCiEQDJQBC0E3IRAMkwELQTghEAySAQtBPCEQDJEBC0E7IRAMkAELQT0hEAyPAQtBCSEQDI4BC0EoIRAMjQELQT4hEAyMAQtBPyEQDIsBC0HAACEQDIoBC0HBACEQDIkBC0HCACEQDIgBC0HDACEQDIcBC0HEACEQDIYBC0HFACEQDIUBC0HGACEQDIQBC0EqIRAMgwELQccAIRAMggELQcgAIRAMgQELQckAIRAMgAELQcoAIRAMfwtBywAhEAx+C0HNACEQDH0LQcwAIRAMfAtBzgAhEAx7C0HPACEQDHoLQdAAIRAMeQtB0QAhEAx4C0HSACEQDHcLQdMAIRAMdgtB1AAhEAx1C0HWACEQDHQLQdUAIRAMcwtBBiEQDHILQdcAIRAMcQtBBSEQDHALQdgAIRAMbwtBBCEQDG4LQdkAIRAMbQtB2gAhEAxsC0HbACEQDGsLQdwAIRAMagtBAyEQDGkLQd0AIRAMaAtB3gAhEAxnC0HfACEQDGYLQeEAIRAMZQtB4AAhEAxkC0HiACEQDGMLQeMAIRAMYgtBAiEQDGELQeQAIRAMYAtB5QAhEAxfC0HmACEQDF4LQecAIRAMXQtB6AAhEAxcC0HpACEQDFsLQeoAIRAMWgtB6wAhEAxZC0HsACEQDFgLQe0AIRAMVwtB7gAhEAxWC0HvACEQDFULQfAAIRAMVAtB8QAhEAxTC0HyACEQDFILQfMAIRAMUQtB9AAhEAxQC0H1ACEQDE8LQfYAIRAMTgtB9wAhEAxNC0H4ACEQDEwLQfkAIRAMSwtB+gAhEAxKC0H7ACEQDEkLQfwAIRAMSAtB/QAhEAxHC0H+ACEQDEYLQf8AIRAMRQtBgAEhEAxEC0GBASEQDEMLQYIBIRAMQgtBgwEhEAxBC0GEASEQDEALQYUBIRAMPwtBhgEhEAw+C0GHASEQDD0LQYgBIRAMPAtBiQEhEAw7C0GKASEQDDoLQYsBIRAMOQtBjAEhEAw4C0GNASEQDDcLQY4BIRAMNgtBjwEhEAw1C0GQASEQDDQLQZEBIRAMMwtBkgEhEAwyC0GTASEQDDELQZQBIRAMMAtBlQEhEAwvC0GWASEQDC4LQZcBIRAMLQtBmAEhEAwsC0GZASEQDCsLQZoBIRAMKgtBmwEhEAwpC0GcASEQDCgLQZ0BIRAMJwtBngEhEAwmC0GfASEQDCULQaABIRAMJAtBoQEhEAwjC0GiASEQDCILQaMBIRAMIQtBpAEhEAwgC0GlASEQDB8LQaYBIRAMHgtBpwEhEAwdC0GoASEQDBwLQakBIRAMGwtBqgEhEAwaC0GrASEQDBkLQawBIRAMGAtBrQEhEAwXC0GuASEQDBYLQQEhEAwVC0GvASEQDBQLQbABIRAMEwtBsQEhEAwSC0GzASEQDBELQbIBIRAMEAtBtAEhEAwPC0G1ASEQDA4LQbYBIRAMDQtBtwEhEAwMC0G4ASEQDAsLQbkBIRAMCgtBugEhEAwJC0G7ASEQDAgLQcYBIRAMBwtBvAEhEAwGC0G9ASEQDAULQb4BIRAMBAtBvwEhEAwDC0HAASEQDAILQcIBIRAMAQtBwQEhEAsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB4fICEjJSg/QEFERUZHSElKS0xNT1BRUlPeA1dZW1xdYGJlZmdoaWprbG1vcHFyc3R1dnd4eXp7fH1+gAGCAYUBhgGHAYkBiwGMAY0BjgGPAZABkQGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHgAeEB4gHjAeQB5QHmAecB6AHpAeoB6wHsAe0B7gHvAfAB8QHyAfMBmQKkArAC/gL+AgsgASIEIAJHDfMBQd0BIRAM/wMLIAEiECACRw3dAUHDASEQDP4DCyABIgEgAkcNkAFB9wAhEAz9AwsgASIBIAJHDYYBQe8AIRAM/AMLIAEiASACRw1/QeoAIRAM+wMLIAEiASACRw17QegAIRAM+gMLIAEiASACRw14QeYAIRAM+QMLIAEiASACRw0aQRghEAz4AwsgASIBIAJHDRRBEiEQDPcDCyABIgEgAkcNWUHFACEQDPYDCyABIgEgAkcNSkE/IRAM9QMLIAEiASACRw1IQTwhEAz0AwsgASIBIAJHDUFBMSEQDPMDCyAALQAuQQFGDesDDIcCCyAAIAEiASACEMCAgIAAQQFHDeYBIABCADcDIAznAQsgACABIgEgAhC0gICAACIQDecBIAEhAQz1AgsCQCABIgEgAkcNAEEGIRAM8AMLIAAgAUEBaiIBIAIQu4CAgAAiEA3oASABIQEMMQsgAEIANwMgQRIhEAzVAwsgASIQIAJHDStBHSEQDO0DCwJAIAEiASACRg0AIAFBAWohAUEQIRAM1AMLQQchEAzsAwsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3lAUEIIRAM6wMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQRQhEAzSAwtBCSEQDOoDCyABIQEgACkDIFAN5AEgASEBDPICCwJAIAEiASACRw0AQQshEAzpAwsgACABQQFqIgEgAhC2gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeUBIAEhAQzyAgsgACABIgEgAhC4gICAACIQDeYBIAEhAQwNCyAAIAEiASACELqAgIAAIhAN5wEgASEBDPACCwJAIAEiASACRw0AQQ8hEAzlAwsgAS0AACIQQTtGDQggEEENRw3oASABQQFqIQEM7wILIAAgASIBIAIQuoCAgAAiEA3oASABIQEM8gILA0ACQCABLQAAQfC1gIAAai0AACIQQQFGDQAgEEECRw3rASAAKAIEIRAgAEEANgIEIAAgECABQQFqIgEQuYCAgAAiEA3qASABIQEM9AILIAFBAWoiASACRw0AC0ESIRAM4gMLIAAgASIBIAIQuoCAgAAiEA3pASABIQEMCgsgASIBIAJHDQZBGyEQDOADCwJAIAEiASACRw0AQRYhEAzgAwsgAEGKgICAADYCCCAAIAE2AgQgACABIAIQuICAgAAiEA3qASABIQFBICEQDMYDCwJAIAEiASACRg0AA0ACQCABLQAAQfC3gIAAai0AACIQQQJGDQACQCAQQX9qDgTlAewBAOsB7AELIAFBAWohAUEIIRAMyAMLIAFBAWoiASACRw0AC0EVIRAM3wMLQRUhEAzeAwsDQAJAIAEtAABB8LmAgABqLQAAIhBBAkYNACAQQX9qDgTeAewB4AHrAewBCyABQQFqIgEgAkcNAAtBGCEQDN0DCwJAIAEiASACRg0AIABBi4CAgAA2AgggACABNgIEIAEhAUEHIRAMxAMLQRkhEAzcAwsgAUEBaiEBDAILAkAgASIUIAJHDQBBGiEQDNsDCyAUIQECQCAULQAAQXNqDhTdAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAgDuAgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQM2gMLAkAgAS0AACIQQTtGDQAgEEENRw3oASABQQFqIQEM5QILIAFBAWohAQtBIiEQDL8DCwJAIAEiECACRw0AQRwhEAzYAwtCACERIBAhASAQLQAAQVBqDjfnAeYBAQIDBAUGBwgAAAAAAAAACQoLDA0OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPEBESExQAC0EeIRAMvQMLQgIhEQzlAQtCAyERDOQBC0IEIREM4wELQgUhEQziAQtCBiERDOEBC0IHIREM4AELQgghEQzfAQtCCSERDN4BC0IKIREM3QELQgshEQzcAQtCDCERDNsBC0INIREM2gELQg4hEQzZAQtCDyERDNgBC0IKIREM1wELQgshEQzWAQtCDCERDNUBC0INIREM1AELQg4hEQzTAQtCDyERDNIBC0IAIRECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAtAABBUGoON+UB5AEAAQIDBAUGB+YB5gHmAeYB5gHmAeYBCAkKCwwN5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAQ4PEBESE+YBC0ICIREM5AELQgMhEQzjAQtCBCERDOIBC0IFIREM4QELQgYhEQzgAQtCByERDN8BC0IIIREM3gELQgkhEQzdAQtCCiERDNwBC0ILIREM2wELQgwhEQzaAQtCDSERDNkBC0IOIREM2AELQg8hEQzXAQtCCiERDNYBC0ILIREM1QELQgwhEQzUAQtCDSERDNMBC0IOIREM0gELQg8hEQzRAQsgAEIAIAApAyAiESACIAEiEGutIhJ9IhMgEyARVhs3AyAgESASViIURQ3SAUEfIRAMwAMLAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQSQhEAynAwtBICEQDL8DCyAAIAEiECACEL6AgIAAQX9qDgW2AQDFAgHRAdIBC0ERIRAMpAMLIABBAToALyAQIQEMuwMLIAEiASACRw3SAUEkIRAMuwMLIAEiDSACRw0eQcYAIRAMugMLIAAgASIBIAIQsoCAgAAiEA3UASABIQEMtQELIAEiECACRw0mQdAAIRAMuAMLAkAgASIBIAJHDQBBKCEQDLgDCyAAQQA2AgQgAEGMgICAADYCCCAAIAEgARCxgICAACIQDdMBIAEhAQzYAQsCQCABIhAgAkcNAEEpIRAMtwMLIBAtAAAiAUEgRg0UIAFBCUcN0wEgEEEBaiEBDBULAkAgASIBIAJGDQAgAUEBaiEBDBcLQSohEAy1AwsCQCABIhAgAkcNAEErIRAMtQMLAkAgEC0AACIBQQlGDQAgAUEgRw3VAQsgAC0ALEEIRg3TASAQIQEMkQMLAkAgASIBIAJHDQBBLCEQDLQDCyABLQAAQQpHDdUBIAFBAWohAQzJAgsgASIOIAJHDdUBQS8hEAyyAwsDQAJAIAEtAAAiEEEgRg0AAkAgEEF2ag4EANwB3AEA2gELIAEhAQzgAQsgAUEBaiIBIAJHDQALQTEhEAyxAwtBMiEQIAEiFCACRg2wAyACIBRrIAAoAgAiAWohFSAUIAFrQQNqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB8LuAgABqLQAARw0BAkAgAUEDRw0AQQYhAQyWAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMsQMLIABBADYCACAUIQEM2QELQTMhECABIhQgAkYNrwMgAiAUayAAKAIAIgFqIRUgFCABa0EIaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfS7gIAAai0AAEcNAQJAIAFBCEcNAEEFIQEMlQMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLADCyAAQQA2AgAgFCEBDNgBC0E0IRAgASIUIAJGDa4DIAIgFGsgACgCACIBaiEVIBQgAWtBBWohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUHQwoCAAGotAABHDQECQCABQQVHDQBBByEBDJQDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAyvAwsgAEEANgIAIBQhAQzXAQsCQCABIgEgAkYNAANAAkAgAS0AAEGAvoCAAGotAAAiEEEBRg0AIBBBAkYNCiABIQEM3QELIAFBAWoiASACRw0AC0EwIRAMrgMLQTAhEAytAwsCQCABIgEgAkYNAANAAkAgAS0AACIQQSBGDQAgEEF2ag4E2QHaAdoB2QHaAQsgAUEBaiIBIAJHDQALQTghEAytAwtBOCEQDKwDCwNAAkAgAS0AACIQQSBGDQAgEEEJRw0DCyABQQFqIgEgAkcNAAtBPCEQDKsDCwNAAkAgAS0AACIQQSBGDQACQAJAIBBBdmoOBNoBAQHaAQALIBBBLEYN2wELIAEhAQwECyABQQFqIgEgAkcNAAtBPyEQDKoDCyABIQEM2wELQcAAIRAgASIUIAJGDagDIAIgFGsgACgCACIBaiEWIBQgAWtBBmohFwJAA0AgFC0AAEEgciABQYDAgIAAai0AAEcNASABQQZGDY4DIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADKkDCyAAQQA2AgAgFCEBC0E2IRAMjgMLAkAgASIPIAJHDQBBwQAhEAynAwsgAEGMgICAADYCCCAAIA82AgQgDyEBIAAtACxBf2oOBM0B1QHXAdkBhwMLIAFBAWohAQzMAQsCQCABIgEgAkYNAANAAkAgAS0AACIQQSByIBAgEEG/f2pB/wFxQRpJG0H/AXEiEEEJRg0AIBBBIEYNAAJAAkACQAJAIBBBnX9qDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQTEhEAyRAwsgAUEBaiEBQTIhEAyQAwsgAUEBaiEBQTMhEAyPAwsgASEBDNABCyABQQFqIgEgAkcNAAtBNSEQDKUDC0E1IRAMpAMLAkAgASIBIAJGDQADQAJAIAEtAABBgLyAgABqLQAAQQFGDQAgASEBDNMBCyABQQFqIgEgAkcNAAtBPSEQDKQDC0E9IRAMowMLIAAgASIBIAIQsICAgAAiEA3WASABIQEMAQsgEEEBaiEBC0E8IRAMhwMLAkAgASIBIAJHDQBBwgAhEAygAwsCQANAAkAgAS0AAEF3ag4YAAL+Av4ChAP+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gIA/gILIAFBAWoiASACRw0AC0HCACEQDKADCyABQQFqIQEgAC0ALUEBcUUNvQEgASEBC0EsIRAMhQMLIAEiASACRw3TAUHEACEQDJ0DCwNAAkAgAS0AAEGQwICAAGotAABBAUYNACABIQEMtwILIAFBAWoiASACRw0AC0HFACEQDJwDCyANLQAAIhBBIEYNswEgEEE6Rw2BAyAAKAIEIQEgAEEANgIEIAAgASANEK+AgIAAIgEN0AEgDUEBaiEBDLMCC0HHACEQIAEiDSACRg2aAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQZDCgIAAai0AAEcNgAMgAUEFRg30AiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyaAwtByAAhECABIg0gAkYNmQMgAiANayAAKAIAIgFqIRYgDSABa0EJaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGWwoCAAGotAABHDf8CAkAgAUEJRw0AQQIhAQz1AgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmQMLAkAgASINIAJHDQBByQAhEAyZAwsCQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZJ/ag4HAIADgAOAA4ADgAMBgAMLIA1BAWohAUE+IRAMgAMLIA1BAWohAUE/IRAM/wILQcoAIRAgASINIAJGDZcDIAIgDWsgACgCACIBaiEWIA0gAWtBAWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBoMKAgABqLQAARw39AiABQQFGDfACIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJcDC0HLACEQIAEiDSACRg2WAyACIA1rIAAoAgAiAWohFiANIAFrQQ5qIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaLCgIAAai0AAEcN/AIgAUEORg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyWAwtBzAAhECABIg0gAkYNlQMgAiANayAAKAIAIgFqIRYgDSABa0EPaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUHAwoCAAGotAABHDfsCAkAgAUEPRw0AQQMhAQzxAgsgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlQMLQc0AIRAgASINIAJGDZQDIAIgDWsgACgCACIBaiEWIA0gAWtBBWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw36AgJAIAFBBUcNAEEEIQEM8AILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJQDCwJAIAEiDSACRw0AQc4AIRAMlAMLAkACQAJAAkAgDS0AACIBQSByIAEgAUG/f2pB/wFxQRpJG0H/AXFBnX9qDhMA/QL9Av0C/QL9Av0C/QL9Av0C/QL9Av0CAf0C/QL9AgID/QILIA1BAWohAUHBACEQDP0CCyANQQFqIQFBwgAhEAz8AgsgDUEBaiEBQcMAIRAM+wILIA1BAWohAUHEACEQDPoCCwJAIAEiASACRg0AIABBjYCAgAA2AgggACABNgIEIAEhAUHFACEQDPoCC0HPACEQDJIDCyAQIQECQAJAIBAtAABBdmoOBAGoAqgCAKgCCyAQQQFqIQELQSchEAz4AgsCQCABIgEgAkcNAEHRACEQDJEDCwJAIAEtAABBIEYNACABIQEMjQELIAFBAWohASAALQAtQQFxRQ3HASABIQEMjAELIAEiFyACRw3IAUHSACEQDI8DC0HTACEQIAEiFCACRg2OAyACIBRrIAAoAgAiAWohFiAUIAFrQQFqIRcDQCAULQAAIAFB1sKAgABqLQAARw3MASABQQFGDccBIAFBAWohASAUQQFqIhQgAkcNAAsgACAWNgIADI4DCwJAIAEiASACRw0AQdUAIRAMjgMLIAEtAABBCkcNzAEgAUEBaiEBDMcBCwJAIAEiASACRw0AQdYAIRAMjQMLAkACQCABLQAAQXZqDgQAzQHNAQHNAQsgAUEBaiEBDMcBCyABQQFqIQFBygAhEAzzAgsgACABIgEgAhCugICAACIQDcsBIAEhAUHNACEQDPICCyAALQApQSJGDYUDDKYCCwJAIAEiASACRw0AQdsAIRAMigMLQQAhFEEBIRdBASEWQQAhEAJAAkACQAJAAkACQAJAAkACQCABLQAAQVBqDgrUAdMBAAECAwQFBgjVAQtBAiEQDAYLQQMhEAwFC0EEIRAMBAtBBSEQDAMLQQYhEAwCC0EHIRAMAQtBCCEQC0EAIRdBACEWQQAhFAzMAQtBCSEQQQEhFEEAIRdBACEWDMsBCwJAIAEiASACRw0AQd0AIRAMiQMLIAEtAABBLkcNzAEgAUEBaiEBDKYCCyABIgEgAkcNzAFB3wAhEAyHAwsCQCABIgEgAkYNACAAQY6AgIAANgIIIAAgATYCBCABIQFB0AAhEAzuAgtB4AAhEAyGAwtB4QAhECABIgEgAkYNhQMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQeLCgIAAai0AAEcNzQEgFEEDRg3MASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyFAwtB4gAhECABIgEgAkYNhAMgAiABayAAKAIAIhRqIRYgASAUa0ECaiEXA0AgAS0AACAUQebCgIAAai0AAEcNzAEgFEECRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyEAwtB4wAhECABIgEgAkYNgwMgAiABayAAKAIAIhRqIRYgASAUa0EDaiEXA0AgAS0AACAUQenCgIAAai0AAEcNywEgFEEDRg3OASAUQQFqIRQgAUEBaiIBIAJHDQALIAAgFjYCAAyDAwsCQCABIgEgAkcNAEHlACEQDIMDCyAAIAFBAWoiASACEKiAgIAAIhANzQEgASEBQdYAIRAM6QILAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AAkACQAJAIBBBuH9qDgsAAc8BzwHPAc8BzwHPAc8BzwECzwELIAFBAWohAUHSACEQDO0CCyABQQFqIQFB0wAhEAzsAgsgAUEBaiEBQdQAIRAM6wILIAFBAWoiASACRw0AC0HkACEQDIIDC0HkACEQDIEDCwNAAkAgAS0AAEHwwoCAAGotAAAiEEEBRg0AIBBBfmoOA88B0AHRAdIBCyABQQFqIgEgAkcNAAtB5gAhEAyAAwsCQCABIgEgAkYNACABQQFqIQEMAwtB5wAhEAz/AgsDQAJAIAEtAABB8MSAgABqLQAAIhBBAUYNAAJAIBBBfmoOBNIB0wHUAQDVAQsgASEBQdcAIRAM5wILIAFBAWoiASACRw0AC0HoACEQDP4CCwJAIAEiASACRw0AQekAIRAM/gILAkAgAS0AACIQQXZqDhq6AdUB1QG8AdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAcoB1QHVAQDTAQsgAUEBaiEBC0EGIRAM4wILA0ACQCABLQAAQfDGgIAAai0AAEEBRg0AIAEhAQyeAgsgAUEBaiIBIAJHDQALQeoAIRAM+wILAkAgASIBIAJGDQAgAUEBaiEBDAMLQesAIRAM+gILAkAgASIBIAJHDQBB7AAhEAz6AgsgAUEBaiEBDAELAkAgASIBIAJHDQBB7QAhEAz5AgsgAUEBaiEBC0EEIRAM3gILAkAgASIUIAJHDQBB7gAhEAz3AgsgFCEBAkACQAJAIBQtAABB8MiAgABqLQAAQX9qDgfUAdUB1gEAnAIBAtcBCyAUQQFqIQEMCgsgFEEBaiEBDM0BC0EAIRAgAEEANgIcIABBm5KAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAz2AgsCQANAAkAgAS0AAEHwyICAAGotAAAiEEEERg0AAkACQCAQQX9qDgfSAdMB1AHZAQAEAdkBCyABIQFB2gAhEAzgAgsgAUEBaiEBQdwAIRAM3wILIAFBAWoiASACRw0AC0HvACEQDPYCCyABQQFqIQEMywELAkAgASIUIAJHDQBB8AAhEAz1AgsgFC0AAEEvRw3UASAUQQFqIQEMBgsCQCABIhQgAkcNAEHxACEQDPQCCwJAIBQtAAAiAUEvRw0AIBRBAWohAUHdACEQDNsCCyABQXZqIgRBFksN0wFBASAEdEGJgIACcUUN0wEMygILAkAgASIBIAJGDQAgAUEBaiEBQd4AIRAM2gILQfIAIRAM8gILAkAgASIUIAJHDQBB9AAhEAzyAgsgFCEBAkAgFC0AAEHwzICAAGotAABBf2oOA8kClAIA1AELQeEAIRAM2AILAkAgASIUIAJGDQADQAJAIBQtAABB8MqAgABqLQAAIgFBA0YNAAJAIAFBf2oOAssCANUBCyAUIQFB3wAhEAzaAgsgFEEBaiIUIAJHDQALQfMAIRAM8QILQfMAIRAM8AILAkAgASIBIAJGDQAgAEGPgICAADYCCCAAIAE2AgQgASEBQeAAIRAM1wILQfUAIRAM7wILAkAgASIBIAJHDQBB9gAhEAzvAgsgAEGPgICAADYCCCAAIAE2AgQgASEBC0EDIRAM1AILA0AgAS0AAEEgRw3DAiABQQFqIgEgAkcNAAtB9wAhEAzsAgsCQCABIgEgAkcNAEH4ACEQDOwCCyABLQAAQSBHDc4BIAFBAWohAQzvAQsgACABIgEgAhCsgICAACIQDc4BIAEhAQyOAgsCQCABIgQgAkcNAEH6ACEQDOoCCyAELQAAQcwARw3RASAEQQFqIQFBEyEQDM8BCwJAIAEiBCACRw0AQfsAIRAM6QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEANAIAQtAAAgAUHwzoCAAGotAABHDdABIAFBBUYNzgEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBB+wAhEAzoAgsCQCABIgQgAkcNAEH8ACEQDOgCCwJAAkAgBC0AAEG9f2oODADRAdEB0QHRAdEB0QHRAdEB0QHRAQHRAQsgBEEBaiEBQeYAIRAMzwILIARBAWohAUHnACEQDM4CCwJAIAEiBCACRw0AQf0AIRAM5wILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNzwEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf0AIRAM5wILIABBADYCACAQQQFqIQFBECEQDMwBCwJAIAEiBCACRw0AQf4AIRAM5gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQfbOgIAAai0AAEcNzgEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf4AIRAM5gILIABBADYCACAQQQFqIQFBFiEQDMsBCwJAIAEiBCACRw0AQf8AIRAM5QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQfzOgIAAai0AAEcNzQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQf8AIRAM5QILIABBADYCACAQQQFqIQFBBSEQDMoBCwJAIAEiBCACRw0AQYABIRAM5AILIAQtAABB2QBHDcsBIARBAWohAUEIIRAMyQELAkAgASIEIAJHDQBBgQEhEAzjAgsCQAJAIAQtAABBsn9qDgMAzAEBzAELIARBAWohAUHrACEQDMoCCyAEQQFqIQFB7AAhEAzJAgsCQCABIgQgAkcNAEGCASEQDOICCwJAAkAgBC0AAEG4f2oOCADLAcsBywHLAcsBywEBywELIARBAWohAUHqACEQDMkCCyAEQQFqIQFB7QAhEAzIAgsCQCABIgQgAkcNAEGDASEQDOECCyACIARrIAAoAgAiAWohECAEIAFrQQJqIRQCQANAIAQtAAAgAUGAz4CAAGotAABHDckBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgEDYCAEGDASEQDOECC0EAIRAgAEEANgIAIBRBAWohAQzGAQsCQCABIgQgAkcNAEGEASEQDOACCyACIARrIAAoAgAiAWohFCAEIAFrQQRqIRACQANAIAQtAAAgAUGDz4CAAGotAABHDcgBIAFBBEYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGEASEQDOACCyAAQQA2AgAgEEEBaiEBQSMhEAzFAQsCQCABIgQgAkcNAEGFASEQDN8CCwJAAkAgBC0AAEG0f2oOCADIAcgByAHIAcgByAEByAELIARBAWohAUHvACEQDMYCCyAEQQFqIQFB8AAhEAzFAgsCQCABIgQgAkcNAEGGASEQDN4CCyAELQAAQcUARw3FASAEQQFqIQEMgwILAkAgASIEIAJHDQBBhwEhEAzdAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBiM+AgABqLQAARw3FASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhwEhEAzdAgsgAEEANgIAIBBBAWohAUEtIRAMwgELAkAgASIEIAJHDQBBiAEhEAzcAgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw3EASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiAEhEAzcAgsgAEEANgIAIBBBAWohAUEpIRAMwQELAkAgASIBIAJHDQBBiQEhEAzbAgtBASEQIAEtAABB3wBHDcABIAFBAWohAQyBAgsCQCABIgQgAkcNAEGKASEQDNoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRADQCAELQAAIAFBjM+AgABqLQAARw3BASABQQFGDa8CIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYoBIRAM2QILAkAgASIEIAJHDQBBiwEhEAzZAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBjs+AgABqLQAARw3BASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBiwEhEAzZAgsgAEEANgIAIBBBAWohAUECIRAMvgELAkAgASIEIAJHDQBBjAEhEAzYAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw3AASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjAEhEAzYAgsgAEEANgIAIBBBAWohAUEfIRAMvQELAkAgASIEIAJHDQBBjQEhEAzXAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8s+AgABqLQAARw2/ASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBjQEhEAzXAgsgAEEANgIAIBBBAWohAUEJIRAMvAELAkAgASIEIAJHDQBBjgEhEAzWAgsCQAJAIAQtAABBt39qDgcAvwG/Ab8BvwG/AQG/AQsgBEEBaiEBQfgAIRAMvQILIARBAWohAUH5ACEQDLwCCwJAIAEiBCACRw0AQY8BIRAM1QILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQZHPgIAAai0AAEcNvQEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY8BIRAM1QILIABBADYCACAQQQFqIQFBGCEQDLoBCwJAIAEiBCACRw0AQZABIRAM1AILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQZfPgIAAai0AAEcNvAEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZABIRAM1AILIABBADYCACAQQQFqIQFBFyEQDLkBCwJAIAEiBCACRw0AQZEBIRAM0wILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQZrPgIAAai0AAEcNuwEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZEBIRAM0wILIABBADYCACAQQQFqIQFBFSEQDLgBCwJAIAEiBCACRw0AQZIBIRAM0gILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQaHPgIAAai0AAEcNugEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZIBIRAM0gILIABBADYCACAQQQFqIQFBHiEQDLcBCwJAIAEiBCACRw0AQZMBIRAM0QILIAQtAABBzABHDbgBIARBAWohAUEKIRAMtgELAkAgBCACRw0AQZQBIRAM0AILAkACQCAELQAAQb9/ag4PALkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AbkBAbkBCyAEQQFqIQFB/gAhEAy3AgsgBEEBaiEBQf8AIRAMtgILAkAgBCACRw0AQZUBIRAMzwILAkACQCAELQAAQb9/ag4DALgBAbgBCyAEQQFqIQFB/QAhEAy2AgsgBEEBaiEEQYABIRAMtQILAkAgBCACRw0AQZYBIRAMzgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQafPgIAAai0AAEcNtgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZYBIRAMzgILIABBADYCACAQQQFqIQFBCyEQDLMBCwJAIAQgAkcNAEGXASEQDM0CCwJAAkACQAJAIAQtAABBU2oOIwC4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBAbgBuAG4AbgBuAECuAG4AbgBA7gBCyAEQQFqIQFB+wAhEAy2AgsgBEEBaiEBQfwAIRAMtQILIARBAWohBEGBASEQDLQCCyAEQQFqIQRBggEhEAyzAgsCQCAEIAJHDQBBmAEhEAzMAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBqc+AgABqLQAARw20ASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmAEhEAzMAgsgAEEANgIAIBBBAWohAUEZIRAMsQELAkAgBCACRw0AQZkBIRAMywILIAIgBGsgACgCACIBaiEUIAQgAWtBBWohEAJAA0AgBC0AACABQa7PgIAAai0AAEcNswEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZkBIRAMywILIABBADYCACAQQQFqIQFBBiEQDLABCwJAIAQgAkcNAEGaASEQDMoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG0z4CAAGotAABHDbIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGaASEQDMoCCyAAQQA2AgAgEEEBaiEBQRwhEAyvAQsCQCAEIAJHDQBBmwEhEAzJAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBts+AgABqLQAARw2xASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmwEhEAzJAgsgAEEANgIAIBBBAWohAUEnIRAMrgELAkAgBCACRw0AQZwBIRAMyAILAkACQCAELQAAQax/ag4CAAGxAQsgBEEBaiEEQYYBIRAMrwILIARBAWohBEGHASEQDK4CCwJAIAQgAkcNAEGdASEQDMcCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUG4z4CAAGotAABHDa8BIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGdASEQDMcCCyAAQQA2AgAgEEEBaiEBQSYhEAysAQsCQCAEIAJHDQBBngEhEAzGAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBus+AgABqLQAARw2uASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBngEhEAzGAgsgAEEANgIAIBBBAWohAUEDIRAMqwELAkAgBCACRw0AQZ8BIRAMxQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNrQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ8BIRAMxQILIABBADYCACAQQQFqIQFBDCEQDKoBCwJAIAQgAkcNAEGgASEQDMQCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUG8z4CAAGotAABHDawBIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGgASEQDMQCCyAAQQA2AgAgEEEBaiEBQQ0hEAypAQsCQCAEIAJHDQBBoQEhEAzDAgsCQAJAIAQtAABBun9qDgsArAGsAawBrAGsAawBrAGsAawBAawBCyAEQQFqIQRBiwEhEAyqAgsgBEEBaiEEQYwBIRAMqQILAkAgBCACRw0AQaIBIRAMwgILIAQtAABB0ABHDakBIARBAWohBAzpAQsCQCAEIAJHDQBBowEhEAzBAgsCQAJAIAQtAABBt39qDgcBqgGqAaoBqgGqAQCqAQsgBEEBaiEEQY4BIRAMqAILIARBAWohAUEiIRAMpgELAkAgBCACRw0AQaQBIRAMwAILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQcDPgIAAai0AAEcNqAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaQBIRAMwAILIABBADYCACAQQQFqIQFBHSEQDKUBCwJAIAQgAkcNAEGlASEQDL8CCwJAAkAgBC0AAEGuf2oOAwCoAQGoAQsgBEEBaiEEQZABIRAMpgILIARBAWohAUEEIRAMpAELAkAgBCACRw0AQaYBIRAMvgILAkACQAJAAkACQCAELQAAQb9/ag4VAKoBqgGqAaoBqgGqAaoBqgGqAaoBAaoBqgECqgGqAQOqAaoBBKoBCyAEQQFqIQRBiAEhEAyoAgsgBEEBaiEEQYkBIRAMpwILIARBAWohBEGKASEQDKYCCyAEQQFqIQRBjwEhEAylAgsgBEEBaiEEQZEBIRAMpAILAkAgBCACRw0AQacBIRAMvQILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQe3PgIAAai0AAEcNpQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQacBIRAMvQILIABBADYCACAQQQFqIQFBESEQDKIBCwJAIAQgAkcNAEGoASEQDLwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHCz4CAAGotAABHDaQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGoASEQDLwCCyAAQQA2AgAgEEEBaiEBQSwhEAyhAQsCQCAEIAJHDQBBqQEhEAy7AgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBxc+AgABqLQAARw2jASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqQEhEAy7AgsgAEEANgIAIBBBAWohAUErIRAMoAELAkAgBCACRw0AQaoBIRAMugILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQcrPgIAAai0AAEcNogEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQaoBIRAMugILIABBADYCACAQQQFqIQFBFCEQDJ8BCwJAIAQgAkcNAEGrASEQDLkCCwJAAkACQAJAIAQtAABBvn9qDg8AAQKkAaQBpAGkAaQBpAGkAaQBpAGkAaQBA6QBCyAEQQFqIQRBkwEhEAyiAgsgBEEBaiEEQZQBIRAMoQILIARBAWohBEGVASEQDKACCyAEQQFqIQRBlgEhEAyfAgsCQCAEIAJHDQBBrAEhEAy4AgsgBC0AAEHFAEcNnwEgBEEBaiEEDOABCwJAIAQgAkcNAEGtASEQDLcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHNz4CAAGotAABHDZ8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGtASEQDLcCCyAAQQA2AgAgEEEBaiEBQQ4hEAycAQsCQCAEIAJHDQBBrgEhEAy2AgsgBC0AAEHQAEcNnQEgBEEBaiEBQSUhEAybAQsCQCAEIAJHDQBBrwEhEAy1AgsgAiAEayAAKAIAIgFqIRQgBCABa0EIaiEQAkADQCAELQAAIAFB0M+AgABqLQAARw2dASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrwEhEAy1AgsgAEEANgIAIBBBAWohAUEqIRAMmgELAkAgBCACRw0AQbABIRAMtAILAkACQCAELQAAQat/ag4LAJ0BnQGdAZ0BnQGdAZ0BnQGdAQGdAQsgBEEBaiEEQZoBIRAMmwILIARBAWohBEGbASEQDJoCCwJAIAQgAkcNAEGxASEQDLMCCwJAAkAgBC0AAEG/f2oOFACcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAEBnAELIARBAWohBEGZASEQDJoCCyAEQQFqIQRBnAEhEAyZAgsCQCAEIAJHDQBBsgEhEAyyAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFB2c+AgABqLQAARw2aASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBsgEhEAyyAgsgAEEANgIAIBBBAWohAUEhIRAMlwELAkAgBCACRw0AQbMBIRAMsQILIAIgBGsgACgCACIBaiEUIAQgAWtBBmohEAJAA0AgBC0AACABQd3PgIAAai0AAEcNmQEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbMBIRAMsQILIABBADYCACAQQQFqIQFBGiEQDJYBCwJAIAQgAkcNAEG0ASEQDLACCwJAAkACQCAELQAAQbt/ag4RAJoBmgGaAZoBmgGaAZoBmgGaAQGaAZoBmgGaAZoBApoBCyAEQQFqIQRBnQEhEAyYAgsgBEEBaiEEQZ4BIRAMlwILIARBAWohBEGfASEQDJYCCwJAIAQgAkcNAEG1ASEQDK8CCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUHkz4CAAGotAABHDZcBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG1ASEQDK8CCyAAQQA2AgAgEEEBaiEBQSghEAyUAQsCQCAEIAJHDQBBtgEhEAyuAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB6s+AgABqLQAARw2WASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtgEhEAyuAgsgAEEANgIAIBBBAWohAUEHIRAMkwELAkAgBCACRw0AQbcBIRAMrQILAkACQCAELQAAQbt/ag4OAJYBlgGWAZYBlgGWAZYBlgGWAZYBlgGWAQGWAQsgBEEBaiEEQaEBIRAMlAILIARBAWohBEGiASEQDJMCCwJAIAQgAkcNAEG4ASEQDKwCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDZQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG4ASEQDKwCCyAAQQA2AgAgEEEBaiEBQRIhEAyRAQsCQCAEIAJHDQBBuQEhEAyrAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFB8M+AgABqLQAARw2TASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuQEhEAyrAgsgAEEANgIAIBBBAWohAUEgIRAMkAELAkAgBCACRw0AQboBIRAMqgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNkgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQboBIRAMqgILIABBADYCACAQQQFqIQFBDyEQDI8BCwJAIAQgAkcNAEG7ASEQDKkCCwJAAkAgBC0AAEG3f2oOBwCSAZIBkgGSAZIBAZIBCyAEQQFqIQRBpQEhEAyQAgsgBEEBaiEEQaYBIRAMjwILAkAgBCACRw0AQbwBIRAMqAILIAIgBGsgACgCACIBaiEUIAQgAWtBB2ohEAJAA0AgBC0AACABQfTPgIAAai0AAEcNkAEgAUEHRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbwBIRAMqAILIABBADYCACAQQQFqIQFBGyEQDI0BCwJAIAQgAkcNAEG9ASEQDKcCCwJAAkACQCAELQAAQb5/ag4SAJEBkQGRAZEBkQGRAZEBkQGRAQGRAZEBkQGRAZEBkQECkQELIARBAWohBEGkASEQDI8CCyAEQQFqIQRBpwEhEAyOAgsgBEEBaiEEQagBIRAMjQILAkAgBCACRw0AQb4BIRAMpgILIAQtAABBzgBHDY0BIARBAWohBAzPAQsCQCAEIAJHDQBBvwEhEAylAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAELQAAQb9/ag4VAAECA5wBBAUGnAGcAZwBBwgJCgucAQwNDg+cAQsgBEEBaiEBQegAIRAMmgILIARBAWohAUHpACEQDJkCCyAEQQFqIQFB7gAhEAyYAgsgBEEBaiEBQfIAIRAMlwILIARBAWohAUHzACEQDJYCCyAEQQFqIQFB9gAhEAyVAgsgBEEBaiEBQfcAIRAMlAILIARBAWohAUH6ACEQDJMCCyAEQQFqIQRBgwEhEAySAgsgBEEBaiEEQYQBIRAMkQILIARBAWohBEGFASEQDJACCyAEQQFqIQRBkgEhEAyPAgsgBEEBaiEEQZgBIRAMjgILIARBAWohBEGgASEQDI0CCyAEQQFqIQRBowEhEAyMAgsgBEEBaiEEQaoBIRAMiwILAkAgBCACRg0AIABBkICAgAA2AgggACAENgIEQasBIRAMiwILQcABIRAMowILIAAgBSACEKqAgIAAIgENiwEgBSEBDFwLAkAgBiACRg0AIAZBAWohBQyNAQtBwgEhEAyhAgsDQAJAIBAtAABBdmoOBIwBAACPAQALIBBBAWoiECACRw0AC0HDASEQDKACCwJAIAcgAkYNACAAQZGAgIAANgIIIAAgBzYCBCAHIQFBASEQDIcCC0HEASEQDJ8CCwJAIAcgAkcNAEHFASEQDJ8CCwJAAkAgBy0AAEF2ag4EAc4BzgEAzgELIAdBAWohBgyNAQsgB0EBaiEFDIkBCwJAIAcgAkcNAEHGASEQDJ4CCwJAAkAgBy0AAEF2ag4XAY8BjwEBjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAI8BCyAHQQFqIQcLQbABIRAMhAILAkAgCCACRw0AQcgBIRAMnQILIAgtAABBIEcNjQEgAEEAOwEyIAhBAWohAUGzASEQDIMCCyABIRcCQANAIBciByACRg0BIActAABBUGpB/wFxIhBBCk8NzAECQCAALwEyIhRBmTNLDQAgACAUQQpsIhQ7ATIgEEH//wNzIBRB/v8DcUkNACAHQQFqIRcgACAUIBBqIhA7ATIgEEH//wNxQegHSQ0BCwtBACEQIABBADYCHCAAQcGJgIAANgIQIABBDTYCDCAAIAdBAWo2AhQMnAILQccBIRAMmwILIAAgCCACEK6AgIAAIhBFDcoBIBBBFUcNjAEgAEHIATYCHCAAIAg2AhQgAEHJl4CAADYCECAAQRU2AgxBACEQDJoCCwJAIAkgAkcNAEHMASEQDJoCC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgCS0AAEFQag4KlgGVAQABAgMEBQYIlwELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMjgELQQkhEEEBIRRBACEXQQAhFgyNAQsCQCAKIAJHDQBBzgEhEAyZAgsgCi0AAEEuRw2OASAKQQFqIQkMygELIAsgAkcNjgFB0AEhEAyXAgsCQCALIAJGDQAgAEGOgICAADYCCCAAIAs2AgRBtwEhEAz+AQtB0QEhEAyWAgsCQCAEIAJHDQBB0gEhEAyWAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EEaiELA0AgBC0AACAQQfzPgIAAai0AAEcNjgEgEEEERg3pASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHSASEQDJUCCyAAIAwgAhCsgICAACIBDY0BIAwhAQy4AQsCQCAEIAJHDQBB1AEhEAyUAgsgAiAEayAAKAIAIhBqIRQgBCAQa0EBaiEMA0AgBC0AACAQQYHQgIAAai0AAEcNjwEgEEEBRg2OASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHUASEQDJMCCwJAIAQgAkcNAEHWASEQDJMCCyACIARrIAAoAgAiEGohFCAEIBBrQQJqIQsDQCAELQAAIBBBg9CAgABqLQAARw2OASAQQQJGDZABIBBBAWohECAEQQFqIgQgAkcNAAsgACAUNgIAQdYBIRAMkgILAkAgBCACRw0AQdcBIRAMkgILAkACQCAELQAAQbt/ag4QAI8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwEBjwELIARBAWohBEG7ASEQDPkBCyAEQQFqIQRBvAEhEAz4AQsCQCAEIAJHDQBB2AEhEAyRAgsgBC0AAEHIAEcNjAEgBEEBaiEEDMQBCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEG+ASEQDPcBC0HZASEQDI8CCwJAIAQgAkcNAEHaASEQDI8CCyAELQAAQcgARg3DASAAQQE6ACgMuQELIABBAjoALyAAIAQgAhCmgICAACIQDY0BQcIBIRAM9AELIAAtAChBf2oOArcBuQG4AQsDQAJAIAQtAABBdmoOBACOAY4BAI4BCyAEQQFqIgQgAkcNAAtB3QEhEAyLAgsgAEEAOgAvIAAtAC1BBHFFDYQCCyAAQQA6AC8gAEEBOgA0IAEhAQyMAQsgEEEVRg3aASAAQQA2AhwgACABNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAyIAgsCQCAAIBAgAhC0gICAACIEDQAgECEBDIECCwJAIARBFUcNACAAQQM2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAyIAgsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMhwILIBBBFUYN1gEgAEEANgIcIAAgATYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMhgILIAAoAgQhFyAAQQA2AgQgECARp2oiFiEBIAAgFyAQIBYgFBsiEBC1gICAACIURQ2NASAAQQc2AhwgACAQNgIUIAAgFDYCDEEAIRAMhQILIAAgAC8BMEGAAXI7ATAgASEBC0EqIRAM6gELIBBBFUYN0QEgAEEANgIcIAAgATYCFCAAQYOMgIAANgIQIABBEzYCDEEAIRAMggILIBBBFUYNzwEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAMgQILIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDI0BCyAAQQw2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMgAILIBBBFUYNzAEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM/wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIwBCyAAQQ02AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/gELIBBBFUYNyQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM/QELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIsBCyAAQQ42AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM/AELIABBADYCHCAAIAE2AhQgAEHAlYCAADYCECAAQQI2AgxBACEQDPsBCyAQQRVGDcUBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPoBCyAAQRA2AhwgACABNgIUIAAgEDYCDEEAIRAM+QELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDPEBCyAAQRE2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM+AELIBBBFUYNwQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAIRAM9wELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC5gICAACIQDQAgAUEBaiEBDIgBCyAAQRM2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM9gELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC5gICAACIEDQAgAUEBaiEBDO0BCyAAQRQ2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM9QELIBBBFUYNvQEgAEEANgIcIAAgATYCFCAAQZqPgIAANgIQIABBIjYCDEEAIRAM9AELIAAoAgQhECAAQQA2AgQCQCAAIBAgARC3gICAACIQDQAgAUEBaiEBDIYBCyAAQRY2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAM8wELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARC3gICAACIEDQAgAUEBaiEBDOkBCyAAQRc2AhwgACAENgIMIAAgAUEBajYCFEEAIRAM8gELIABBADYCHCAAIAE2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDPEBC0IBIRELIBBBAWohAQJAIAApAyAiEkL//////////w9WDQAgACASQgSGIBGENwMgIAEhAQyEAQsgAEEANgIcIAAgATYCFCAAQa2JgIAANgIQIABBDDYCDEEAIRAM7wELIABBADYCHCAAIBA2AhQgAEHNk4CAADYCECAAQQw2AgxBACEQDO4BCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNcyAAQQU2AhwgACAQNgIUIAAgFDYCDEEAIRAM7QELIABBADYCHCAAIBA2AhQgAEGqnICAADYCECAAQQ82AgxBACEQDOwBCyAAIBAgAhC0gICAACIBDQEgECEBC0EOIRAM0QELAkAgAUEVRw0AIABBAjYCHCAAIBA2AhQgAEGwmICAADYCECAAQRU2AgxBACEQDOoBCyAAQQA2AhwgACAQNgIUIABBp46AgAA2AhAgAEESNgIMQQAhEAzpAQsgAUEBaiEQAkAgAC8BMCIBQYABcUUNAAJAIAAgECACELuAgIAAIgENACAQIQEMcAsgAUEVRw26ASAAQQU2AhwgACAQNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAzpAQsCQCABQaAEcUGgBEcNACAALQAtQQJxDQAgAEEANgIcIAAgEDYCFCAAQZaTgIAANgIQIABBBDYCDEEAIRAM6QELIAAgECACEL2AgIAAGiAQIQECQAJAAkACQAJAIAAgECACELOAgIAADhYCAQAEBAQEBAQEBAQEBAQEBAQEBAQDBAsgAEEBOgAuCyAAIAAvATBBwAByOwEwIBAhAQtBJiEQDNEBCyAAQSM2AhwgACAQNgIUIABBpZaAgAA2AhAgAEEVNgIMQQAhEAzpAQsgAEEANgIcIAAgEDYCFCAAQdWLgIAANgIQIABBETYCDEEAIRAM6AELIAAtAC1BAXFFDQFBwwEhEAzOAQsCQCANIAJGDQADQAJAIA0tAABBIEYNACANIQEMxAELIA1BAWoiDSACRw0AC0ElIRAM5wELQSUhEAzmAQsgACgCBCEEIABBADYCBCAAIAQgDRCvgICAACIERQ2tASAAQSY2AhwgACAENgIMIAAgDUEBajYCFEEAIRAM5QELIBBBFUYNqwEgAEEANgIcIAAgATYCFCAAQf2NgIAANgIQIABBHTYCDEEAIRAM5AELIABBJzYCHCAAIAE2AhQgACAQNgIMQQAhEAzjAQsgECEBQQEhFAJAAkACQAJAAkACQAJAIAAtACxBfmoOBwYFBQMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0ErIRAMygELIABBADYCHCAAIBA2AhQgAEGrkoCAADYCECAAQQs2AgxBACEQDOIBCyAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMQQAhEAzhAQsgAEEAOgAsIBAhAQy9AQsgECEBQQEhFAJAAkACQAJAAkAgAC0ALEF7ag4EAwECAAULIAAgAC8BMEEIcjsBMAwDC0ECIRQMAQtBBCEUCyAAQQE6ACwgACAALwEwIBRyOwEwCyAQIQELQSkhEAzFAQsgAEEANgIcIAAgATYCFCAAQfCUgIAANgIQIABBAzYCDEEAIRAM3QELAkAgDi0AAEENRw0AIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHULIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzdAQsgAC0ALUEBcUUNAUHEASEQDMMBCwJAIA4gAkcNAEEtIRAM3AELAkACQANAAkAgDi0AAEF2ag4EAgAAAwALIA5BAWoiDiACRw0AC0EtIRAM3QELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDiEBDHQLIABBLDYCHCAAIA42AhQgACABNgIMQQAhEAzcAQsgACgCBCEBIABBADYCBAJAIAAgASAOELGAgIAAIgENACAOQQFqIQEMcwsgAEEsNgIcIAAgATYCDCAAIA5BAWo2AhRBACEQDNsBCyAAKAIEIQQgAEEANgIEIAAgBCAOELGAgIAAIgQNoAEgDiEBDM4BCyAQQSxHDQEgAUEBaiEQQQEhAQJAAkACQAJAAkAgAC0ALEF7ag4EAwECBAALIBAhAQwEC0ECIQEMAQtBBCEBCyAAQQE6ACwgACAALwEwIAFyOwEwIBAhAQwBCyAAIAAvATBBCHI7ATAgECEBC0E5IRAMvwELIABBADoALCABIQELQTQhEAy9AQsgACAALwEwQSByOwEwIAEhAQwCCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBA0AIAEhAQzHAQsgAEE3NgIcIAAgATYCFCAAIAQ2AgxBACEQDNQBCyAAQQg6ACwgASEBC0EwIRAMuQELAkAgAC0AKEEBRg0AIAEhAQwECyAALQAtQQhxRQ2TASABIQEMAwsgAC0AMEEgcQ2UAUHFASEQDLcBCwJAIA8gAkYNAAJAA0ACQCAPLQAAQVBqIgFB/wFxQQpJDQAgDyEBQTUhEAy6AQsgACkDICIRQpmz5syZs+bMGVYNASAAIBFCCn4iETcDICARIAGtQv8BgyISQn+FVg0BIAAgESASfDcDICAPQQFqIg8gAkcNAAtBOSEQDNEBCyAAKAIEIQIgAEEANgIEIAAgAiAPQQFqIgQQsYCAgAAiAg2VASAEIQEMwwELQTkhEAzPAQsCQCAALwEwIgFBCHFFDQAgAC0AKEEBRw0AIAAtAC1BCHFFDZABCyAAIAFB9/sDcUGABHI7ATAgDyEBC0E3IRAMtAELIAAgAC8BMEEQcjsBMAyrAQsgEEEVRg2LASAAQQA2AhwgACABNgIUIABB8I6AgAA2AhAgAEEcNgIMQQAhEAzLAQsgAEHDADYCHCAAIAE2AgwgACANQQFqNgIUQQAhEAzKAQsCQCABLQAAQTpHDQAgACgCBCEQIABBADYCBAJAIAAgECABEK+AgIAAIhANACABQQFqIQEMYwsgAEHDADYCHCAAIBA2AgwgACABQQFqNgIUQQAhEAzKAQsgAEEANgIcIAAgATYCFCAAQbGRgIAANgIQIABBCjYCDEEAIRAMyQELIABBADYCHCAAIAE2AhQgAEGgmYCAADYCECAAQR42AgxBACEQDMgBCyAAQQA2AgALIABBgBI7ASogACAXQQFqIgEgAhCogICAACIQDQEgASEBC0HHACEQDKwBCyAQQRVHDYMBIABB0QA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAzEAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAzDAQsgAEEANgIcIAAgFDYCFCAAQcGogIAANgIQIABBBzYCDCAAQQA2AgBBACEQDMIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxdCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDMEBC0EAIRAgAEEANgIcIAAgATYCFCAAQYCRgIAANgIQIABBCTYCDAzAAQsgEEEVRg19IABBADYCHCAAIAE2AhQgAEGUjYCAADYCECAAQSE2AgxBACEQDL8BC0EBIRZBACEXQQAhFEEBIRALIAAgEDoAKyABQQFqIQECQAJAIAAtAC1BEHENAAJAAkACQCAALQAqDgMBAAIECyAWRQ0DDAILIBQNAQwCCyAXRQ0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQrYCAgAAiEA0AIAEhAQxcCyAAQdgANgIcIAAgATYCFCAAIBA2AgxBACEQDL4BCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQytAQsgAEHZADYCHCAAIAE2AhQgACAENgIMQQAhEAy9AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMqwELIABB2gA2AhwgACABNgIUIAAgBDYCDEEAIRAMvAELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKkBCyAAQdwANgIcIAAgATYCFCAAIAQ2AgxBACEQDLsBCwJAIAEtAABBUGoiEEH/AXFBCk8NACAAIBA6ACogAUEBaiEBQc8AIRAMogELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKcBCyAAQd4ANgIcIAAgATYCFCAAIAQ2AgxBACEQDLoBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKUEjTw0AIAEhAQxZCyAAQQA2AhwgACABNgIUIABB04mAgAA2AhAgAEEINgIMQQAhEAy5AQsgAEEANgIAC0EAIRAgAEEANgIcIAAgATYCFCAAQZCzgIAANgIQIABBCDYCDAy3AQsgAEEANgIAIBdBAWohAQJAIAAtAClBIUcNACABIQEMVgsgAEEANgIcIAAgATYCFCAAQZuKgIAANgIQIABBCDYCDEEAIRAMtgELIABBADYCACAXQQFqIQECQCAALQApIhBBXWpBC08NACABIQEMVQsCQCAQQQZLDQBBASAQdEHKAHFFDQAgASEBDFULQQAhECAAQQA2AhwgACABNgIUIABB94mAgAA2AhAgAEEINgIMDLUBCyAQQRVGDXEgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMtAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFQLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMswELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMsgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDE0LIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMsQELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDFELIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMsAELIABBADYCHCAAIAE2AhQgAEHGioCAADYCECAAQQc2AgxBACEQDK8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDK4BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxJCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDK0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDKwBCyAAQQA2AhwgACABNgIUIABB3IiAgAA2AhAgAEEHNgIMQQAhEAyrAQsgEEE/Rw0BIAFBAWohAQtBBSEQDJABC0EAIRAgAEEANgIcIAAgATYCFCAAQf2SgIAANgIQIABBBzYCDAyoAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAynAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMQgsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAymAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMRgsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAylAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHSADYCHCAAIBQ2AhQgACABNgIMQQAhEAykAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMPwsgAEHTADYCHCAAIBQ2AhQgACABNgIMQQAhEAyjAQsgACgCBCEBIABBADYCBAJAIAAgASAUEKeAgIAAIgENACAUIQEMQwsgAEHlADYCHCAAIBQ2AhQgACABNgIMQQAhEAyiAQsgAEEANgIcIAAgFDYCFCAAQcOPgIAANgIQIABBBzYCDEEAIRAMoQELIABBADYCHCAAIAE2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKABC0EAIRAgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDAyfAQsgAEEANgIcIAAgFDYCFCAAQYycgIAANgIQIABBBzYCDEEAIRAMngELIABBADYCHCAAIBQ2AhQgAEH+kYCAADYCECAAQQc2AgxBACEQDJ0BCyAAQQA2AhwgACABNgIUIABBjpuAgAA2AhAgAEEGNgIMQQAhEAycAQsgEEEVRg1XIABBADYCHCAAIAE2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDJsBCyAAQQA2AgAgEEEBaiEBQSQhEAsgACAQOgApIAAoAgQhECAAQQA2AgQgACAQIAEQq4CAgAAiEA1UIAEhAQw+CyAAQQA2AgALQQAhECAAQQA2AhwgACAENgIUIABB8ZuAgAA2AhAgAEEGNgIMDJcBCyABQRVGDVAgAEEANgIcIAAgBTYCFCAAQfCMgIAANgIQIABBGzYCDEEAIRAMlgELIAAoAgQhBSAAQQA2AgQgACAFIBAQqYCAgAAiBQ0BIBBBAWohBQtBrQEhEAx7CyAAQcEBNgIcIAAgBTYCDCAAIBBBAWo2AhRBACEQDJMBCyAAKAIEIQYgAEEANgIEIAAgBiAQEKmAgIAAIgYNASAQQQFqIQYLQa4BIRAMeAsgAEHCATYCHCAAIAY2AgwgACAQQQFqNgIUQQAhEAyQAQsgAEEANgIcIAAgBzYCFCAAQZeLgIAANgIQIABBDTYCDEEAIRAMjwELIABBADYCHCAAIAg2AhQgAEHjkICAADYCECAAQQk2AgxBACEQDI4BCyAAQQA2AhwgACAINgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAyNAQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgCUEBaiEIAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBCAAIBAgCBCtgICAACIQRQ09IABByQE2AhwgACAINgIUIAAgEDYCDEEAIRAMjAELIAAoAgQhBCAAQQA2AgQgACAEIAgQrYCAgAAiBEUNdiAAQcoBNgIcIAAgCDYCFCAAIAQ2AgxBACEQDIsBCyAAKAIEIQQgAEEANgIEIAAgBCAJEK2AgIAAIgRFDXQgAEHLATYCHCAAIAk2AhQgACAENgIMQQAhEAyKAQsgACgCBCEEIABBADYCBCAAIAQgChCtgICAACIERQ1yIABBzQE2AhwgACAKNgIUIAAgBDYCDEEAIRAMiQELAkAgCy0AAEFQaiIQQf8BcUEKTw0AIAAgEDoAKiALQQFqIQpBtgEhEAxwCyAAKAIEIQQgAEEANgIEIAAgBCALEK2AgIAAIgRFDXAgAEHPATYCHCAAIAs2AhQgACAENgIMQQAhEAyIAQsgAEEANgIcIAAgBDYCFCAAQZCzgIAANgIQIABBCDYCDCAAQQA2AgBBACEQDIcBCyABQRVGDT8gAEEANgIcIAAgDDYCFCAAQcyOgIAANgIQIABBIDYCDEEAIRAMhgELIABBgQQ7ASggACgCBCEQIABCADcDACAAIBAgDEEBaiIMEKuAgIAAIhBFDTggAEHTATYCHCAAIAw2AhQgACAQNgIMQQAhEAyFAQsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQdibgIAANgIQIABBCDYCDAyDAQsgACgCBCEQIABCADcDACAAIBAgC0EBaiILEKuAgIAAIhANAUHGASEQDGkLIABBAjoAKAxVCyAAQdUBNgIcIAAgCzYCFCAAIBA2AgxBACEQDIABCyAQQRVGDTcgAEEANgIcIAAgBDYCFCAAQaSMgIAANgIQIABBEDYCDEEAIRAMfwsgAC0ANEEBRw00IAAgBCACELyAgIAAIhBFDTQgEEEVRw01IABB3AE2AhwgACAENgIUIABB1ZaAgAA2AhAgAEEVNgIMQQAhEAx+C0EAIRAgAEEANgIcIABBr4uAgAA2AhAgAEECNgIMIAAgFEEBajYCFAx9C0EAIRAMYwtBAiEQDGILQQ0hEAxhC0EPIRAMYAtBJSEQDF8LQRMhEAxeC0EVIRAMXQtBFiEQDFwLQRchEAxbC0EYIRAMWgtBGSEQDFkLQRohEAxYC0EbIRAMVwtBHCEQDFYLQR0hEAxVC0EfIRAMVAtBISEQDFMLQSMhEAxSC0HGACEQDFELQS4hEAxQC0EvIRAMTwtBOyEQDE4LQT0hEAxNC0HIACEQDEwLQckAIRAMSwtBywAhEAxKC0HMACEQDEkLQc4AIRAMSAtB0QAhEAxHC0HVACEQDEYLQdgAIRAMRQtB2QAhEAxEC0HbACEQDEMLQeQAIRAMQgtB5QAhEAxBC0HxACEQDEALQfQAIRAMPwtBjQEhEAw+C0GXASEQDD0LQakBIRAMPAtBrAEhEAw7C0HAASEQDDoLQbkBIRAMOQtBrwEhEAw4C0GxASEQDDcLQbIBIRAMNgtBtAEhEAw1C0G1ASEQDDQLQboBIRAMMwtBvQEhEAwyC0G/ASEQDDELQcEBIRAMMAsgAEEANgIcIAAgBDYCFCAAQemLgIAANgIQIABBHzYCDEEAIRAMSAsgAEHbATYCHCAAIAQ2AhQgAEH6loCAADYCECAAQRU2AgxBACEQDEcLIABB+AA2AhwgACAMNgIUIABBypiAgAA2AhAgAEEVNgIMQQAhEAxGCyAAQdEANgIcIAAgBTYCFCAAQbCXgIAANgIQIABBFTYCDEEAIRAMRQsgAEH5ADYCHCAAIAE2AhQgACAQNgIMQQAhEAxECyAAQfgANgIcIAAgATYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMQwsgAEHkADYCHCAAIAE2AhQgAEHjl4CAADYCECAAQRU2AgxBACEQDEILIABB1wA2AhwgACABNgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAxBCyAAQQA2AhwgACABNgIUIABBuY2AgAA2AhAgAEEaNgIMQQAhEAxACyAAQcIANgIcIAAgATYCFCAAQeOYgIAANgIQIABBFTYCDEEAIRAMPwsgAEEANgIEIAAgDyAPELGAgIAAIgRFDQEgAEE6NgIcIAAgBDYCDCAAIA9BAWo2AhRBACEQDD4LIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCxgICAACIERQ0AIABBOzYCHCAAIAQ2AgwgACABQQFqNgIUQQAhEAw+CyABQQFqIQEMLQsgD0EBaiEBDC0LIABBADYCHCAAIA82AhQgAEHkkoCAADYCECAAQQQ2AgxBACEQDDsLIABBNjYCHCAAIAQ2AhQgACACNgIMQQAhEAw6CyAAQS42AhwgACAONgIUIAAgBDYCDEEAIRAMOQsgAEHQADYCHCAAIAE2AhQgAEGRmICAADYCECAAQRU2AgxBACEQDDgLIA1BAWohAQwsCyAAQRU2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAw2CyAAQRs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw1CyAAQQ82AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAw0CyAAQQs2AhwgACABNgIUIABBkZeAgAA2AhAgAEEVNgIMQQAhEAwzCyAAQRo2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwyCyAAQQs2AhwgACABNgIUIABBgpmAgAA2AhAgAEEVNgIMQQAhEAwxCyAAQQo2AhwgACABNgIUIABB5JaAgAA2AhAgAEEVNgIMQQAhEAwwCyAAQR42AhwgACABNgIUIABB+ZeAgAA2AhAgAEEVNgIMQQAhEAwvCyAAQQA2AhwgACAQNgIUIABB2o2AgAA2AhAgAEEUNgIMQQAhEAwuCyAAQQQ2AhwgACABNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAwtCyAAQQA2AgAgC0EBaiELC0G4ASEQDBILIABBADYCACAQQQFqIQFB9QAhEAwRCyABIQECQCAALQApQQVHDQBB4wAhEAwRC0HiACEQDBALQQAhECAAQQA2AhwgAEHkkYCAADYCECAAQQc2AgwgACAUQQFqNgIUDCgLIABBADYCACAXQQFqIQFBwAAhEAwOC0EBIQELIAAgAToALCAAQQA2AgAgF0EBaiEBC0EoIRAMCwsgASEBC0E4IRAMCQsCQCABIg8gAkYNAANAAkAgDy0AAEGAvoCAAGotAAAiAUEBRg0AIAFBAkcNAyAPQQFqIQEMBAsgD0EBaiIPIAJHDQALQT4hEAwiC0E+IRAMIQsgAEEAOgAsIA8hAQwBC0ELIRAMBgtBOiEQDAULIAFBAWohAUEtIRAMBAsgACABOgAsIABBADYCACAWQQFqIQFBDCEQDAMLIABBADYCACAXQQFqIQFBCiEQDAILIABBADYCAAsgAEEAOgAsIA0hAUEJIRAMAAsLQQAhECAAQQA2AhwgACALNgIUIABBzZCAgAA2AhAgAEEJNgIMDBcLQQAhECAAQQA2AhwgACAKNgIUIABB6YqAgAA2AhAgAEEJNgIMDBYLQQAhECAAQQA2AhwgACAJNgIUIABBt5CAgAA2AhAgAEEJNgIMDBULQQAhECAAQQA2AhwgACAINgIUIABBnJGAgAA2AhAgAEEJNgIMDBQLQQAhECAAQQA2AhwgACABNgIUIABBzZCAgAA2AhAgAEEJNgIMDBMLQQAhECAAQQA2AhwgACABNgIUIABB6YqAgAA2AhAgAEEJNgIMDBILQQAhECAAQQA2AhwgACABNgIUIABBt5CAgAA2AhAgAEEJNgIMDBELQQAhECAAQQA2AhwgACABNgIUIABBnJGAgAA2AhAgAEEJNgIMDBALQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA8LQQAhECAAQQA2AhwgACABNgIUIABBl5WAgAA2AhAgAEEPNgIMDA4LQQAhECAAQQA2AhwgACABNgIUIABBwJKAgAA2AhAgAEELNgIMDA0LQQAhECAAQQA2AhwgACABNgIUIABBlYmAgAA2AhAgAEELNgIMDAwLQQAhECAAQQA2AhwgACABNgIUIABB4Y+AgAA2AhAgAEEKNgIMDAsLQQAhECAAQQA2AhwgACABNgIUIABB+4+AgAA2AhAgAEEKNgIMDAoLQQAhECAAQQA2AhwgACABNgIUIABB8ZmAgAA2AhAgAEECNgIMDAkLQQAhECAAQQA2AhwgACABNgIUIABBxJSAgAA2AhAgAEECNgIMDAgLQQAhECAAQQA2AhwgACABNgIUIABB8pWAgAA2AhAgAEECNgIMDAcLIABBAjYCHCAAIAE2AhQgAEGcmoCAADYCECAAQRY2AgxBACEQDAYLQQEhEAwFC0HUACEQIAEiBCACRg0EIANBCGogACAEIAJB2MKAgABBChDFgICAACADKAIMIQQgAygCCA4DAQQCAAsQyoCAgAAACyAAQQA2AhwgAEG1moCAADYCECAAQRc2AgwgACAEQQFqNgIUQQAhEAwCCyAAQQA2AhwgACAENgIUIABBypqAgAA2AhAgAEEJNgIMQQAhEAwBCwJAIAEiBCACRw0AQSIhEAwBCyAAQYmAgIAANgIIIAAgBDYCBEEhIRALIANBEGokgICAgAAgEAuvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAEMeAgIAAC/I2AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKg0ICAAA0AQQAQy4CAgABBgNSEgABrIgJB2QBJDQBBACEDAkBBACgC4NOAgAAiBA0AQQBCfzcC7NOAgABBAEKAgISAgIDAADcC5NOAgABBACABQQhqQXBxQdiq1aoFcyIENgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgAALQQAgAjYCzNOAgABBAEGA1ISAADYCyNOAgABBAEGA1ISAADYCmNCAgABBACAENgKs0ICAAEEAQX82AqjQgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgNSEgABBeEGA1ISAAGtBD3FBAEGA1ISAAEEIakEPcRsiA2oiBEEEaiACQUhqIgUgA2siA0EBcjYCAEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgABBgNSEgAAgBWpBODYCBAsCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHsAUsNAAJAQQAoAojQgIAAIgZBECAAQRNqQXBxIABBC0kbIgJBA3YiBHYiA0EDcUUNAAJAAkAgA0EBcSAEckEBcyIFQQN0IgRBsNCAgABqIgMgBEG40ICAAGooAgAiBCgCCCICRw0AQQAgBkF+IAV3cTYCiNCAgAAMAQsgAyACNgIIIAIgAzYCDAsgBEEIaiEDIAQgBUEDdCIFQQNyNgIEIAQgBWoiBCAEKAIEQQFyNgIEDAwLIAJBACgCkNCAgAAiB00NAQJAIANFDQACQAJAIAMgBHRBAiAEdCIDQQAgA2tycSIDQQAgA2txQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmoiBEEDdCIDQbDQgIAAaiIFIANBuNCAgABqKAIAIgMoAggiAEcNAEEAIAZBfiAEd3EiBjYCiNCAgAAMAQsgBSAANgIIIAAgBTYCDAsgAyACQQNyNgIEIAMgBEEDdCIEaiAEIAJrIgU2AgAgAyACaiIAIAVBAXI2AgQCQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhBAJAAkAgBkEBIAdBA3Z0IghxDQBBACAGIAhyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAQ2AgwgAiAENgIIIAQgAjYCDCAEIAg2AggLIANBCGohA0EAIAA2ApzQgIAAQQAgBTYCkNCAgAAMDAtBACgCjNCAgAAiCUUNASAJQQAgCWtxQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmpBAnRBuNKAgABqKAIAIgAoAgRBeHEgAmshBCAAIQUCQANAAkAgBSgCECIDDQAgBUEUaigCACIDRQ0CCyADKAIEQXhxIAJrIgUgBCAFIARJIgUbIQQgAyAAIAUbIQAgAyEFDAALCyAAKAIYIQoCQCAAKAIMIgggAEYNACAAKAIIIgNBACgCmNCAgABJGiAIIAM2AgggAyAINgIMDAsLAkAgAEEUaiIFKAIAIgMNACAAKAIQIgNFDQMgAEEQaiEFCwNAIAUhCyADIghBFGoiBSgCACIDDQAgCEEQaiEFIAgoAhAiAw0ACyALQQA2AgAMCgtBfyECIABBv39LDQAgAEETaiIDQXBxIQJBACgCjNCAgAAiB0UNAEEAIQsCQCACQYACSQ0AQR8hCyACQf///wdLDQAgA0EIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIFIAVBgIAPakEQdkECcSIFdEEPdiADIARyIAVyayIDQQF0IAIgA0EVanZBAXFyQRxqIQsLQQAgAmshBAJAAkACQAJAIAtBAnRBuNKAgABqKAIAIgUNAEEAIQNBACEIDAELQQAhAyACQQBBGSALQQF2ayALQR9GG3QhAEEAIQgDQAJAIAUoAgRBeHEgAmsiBiAETw0AIAYhBCAFIQggBg0AQQAhBCAFIQggBSEDDAMLIAMgBUEUaigCACIGIAYgBSAAQR12QQRxakEQaigCACIFRhsgAyAGGyEDIABBAXQhACAFDQALCwJAIAMgCHINAEEAIQhBAiALdCIDQQAgA2tyIAdxIgNFDQMgA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBUEFdkEIcSIAIANyIAUgAHYiA0ECdkEEcSIFciADIAV2IgNBAXZBAnEiBXIgAyAFdiIDQQF2QQFxIgVyIAMgBXZqQQJ0QbjSgIAAaigCACEDCyADRQ0BCwNAIAMoAgRBeHEgAmsiBiAESSEAAkAgAygCECIFDQAgA0EUaigCACEFCyAGIAQgABshBCADIAggABshCCAFIQMgBQ0ACwsgCEUNACAEQQAoApDQgIAAIAJrTw0AIAgoAhghCwJAIAgoAgwiACAIRg0AIAgoAggiA0EAKAKY0ICAAEkaIAAgAzYCCCADIAA2AgwMCQsCQCAIQRRqIgUoAgAiAw0AIAgoAhAiA0UNAyAIQRBqIQULA0AgBSEGIAMiAEEUaiIFKAIAIgMNACAAQRBqIQUgACgCECIDDQALIAZBADYCAAwICwJAQQAoApDQgIAAIgMgAkkNAEEAKAKc0ICAACEEAkACQCADIAJrIgVBEEkNACAEIAJqIgAgBUEBcjYCBEEAIAU2ApDQgIAAQQAgADYCnNCAgAAgBCADaiAFNgIAIAQgAkEDcjYCBAwBCyAEIANBA3I2AgQgBCADaiIDIAMoAgRBAXI2AgRBAEEANgKc0ICAAEEAQQA2ApDQgIAACyAEQQhqIQMMCgsCQEEAKAKU0ICAACIAIAJNDQBBACgCoNCAgAAiAyACaiIEIAAgAmsiBUEBcjYCBEEAIAU2ApTQgIAAQQAgBDYCoNCAgAAgAyACQQNyNgIEIANBCGohAwwKCwJAAkBBACgC4NOAgABFDQBBACgC6NOAgAAhBAwBC0EAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEMakFwcUHYqtWqBXM2AuDTgIAAQQBBADYC9NOAgABBAEEANgLE04CAAEGAgAQhBAtBACEDAkAgBCACQccAaiIHaiIGQQAgBGsiC3EiCCACSw0AQQBBMDYC+NOAgAAMCgsCQEEAKALA04CAACIDRQ0AAkBBACgCuNOAgAAiBCAIaiIFIARNDQAgBSADTQ0BC0EAIQNBAEEwNgL404CAAAwKC0EALQDE04CAAEEEcQ0EAkACQAJAQQAoAqDQgIAAIgRFDQBByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiAESw0DCyADKAIIIgMNAAsLQQAQy4CAgAAiAEF/Rg0FIAghBgJAQQAoAuTTgIAAIgNBf2oiBCAAcUUNACAIIABrIAQgAGpBACADa3FqIQYLIAYgAk0NBSAGQf7///8HSw0FAkBBACgCwNOAgAAiA0UNAEEAKAK404CAACIEIAZqIgUgBE0NBiAFIANLDQYLIAYQy4CAgAAiAyAARw0BDAcLIAYgAGsgC3EiBkH+////B0sNBCAGEMuAgIAAIgAgAygCACADKAIEakYNAyAAIQMLAkAgA0F/Rg0AIAJByABqIAZNDQACQCAHIAZrQQAoAujTgIAAIgRqQQAgBGtxIgRB/v///wdNDQAgAyEADAcLAkAgBBDLgICAAEF/Rg0AIAQgBmohBiADIQAMBwtBACAGaxDLgICAABoMBAsgAyEAIANBf0cNBQwDC0EAIQgMBwtBACEADAULIABBf0cNAgtBAEEAKALE04CAAEEEcjYCxNOAgAALIAhB/v///wdLDQEgCBDLgICAACEAQQAQy4CAgAAhAyAAQX9GDQEgA0F/Rg0BIAAgA08NASADIABrIgYgAkE4ak0NAQtBAEEAKAK404CAACAGaiIDNgK404CAAAJAIANBACgCvNOAgABNDQBBACADNgK804CAAAsCQAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQCAAIAMoAgAiBSADKAIEIghqRg0CIAMoAggiAw0ADAMLCwJAAkBBACgCmNCAgAAiA0UNACAAIANPDQELQQAgADYCmNCAgAALQQAhA0EAIAY2AszTgIAAQQAgADYCyNOAgABBAEF/NgKo0ICAAEEAQQAoAuDTgIAANgKs0ICAAEEAQQA2AtTTgIAAA0AgA0HE0ICAAGogA0G40ICAAGoiBDYCACAEIANBsNCAgABqIgU2AgAgA0G80ICAAGogBTYCACADQczQgIAAaiADQcDQgIAAaiIFNgIAIAUgBDYCACADQdTQgIAAaiADQcjQgIAAaiIENgIAIAQgBTYCACADQdDQgIAAaiAENgIAIANBIGoiA0GAAkcNAAsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiBCAGQUhqIgUgA2siA0EBcjYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAM2ApTQgIAAQQAgBDYCoNCAgAAgACAFakE4NgIEDAILIAMtAAxBCHENACAEIAVJDQAgBCAATw0AIARBeCAEa0EPcUEAIARBCGpBD3EbIgVqIgBBACgClNCAgAAgBmoiCyAFayIFQQFyNgIEIAMgCCAGajYCBEEAQQAoAvDTgIAANgKk0ICAAEEAIAU2ApTQgIAAQQAgADYCoNCAgAAgBCALakE4NgIEDAELAkAgAEEAKAKY0ICAACIITw0AQQAgADYCmNCAgAAgACEICyAAIAZqIQVByNOAgAAhAwJAAkACQAJAAkACQAJAA0AgAygCACAFRg0BIAMoAggiAw0ADAILCyADLQAMQQhxRQ0BC0HI04CAACEDA0ACQCADKAIAIgUgBEsNACAFIAMoAgRqIgUgBEsNAwsgAygCCCEDDAALCyADIAA2AgAgAyADKAIEIAZqNgIEIABBeCAAa0EPcUEAIABBCGpBD3EbaiILIAJBA3I2AgQgBUF4IAVrQQ9xQQAgBUEIakEPcRtqIgYgCyACaiICayEDAkAgBiAERw0AQQAgAjYCoNCAgABBAEEAKAKU0ICAACADaiIDNgKU0ICAACACIANBAXI2AgQMAwsCQCAGQQAoApzQgIAARw0AQQAgAjYCnNCAgABBAEEAKAKQ0ICAACADaiIDNgKQ0ICAACACIANBAXI2AgQgAiADaiADNgIADAMLAkAgBigCBCIEQQNxQQFHDQAgBEF4cSEHAkACQCAEQf8BSw0AIAYoAggiBSAEQQN2IghBA3RBsNCAgABqIgBGGgJAIAYoAgwiBCAFRw0AQQBBACgCiNCAgABBfiAId3E2AojQgIAADAILIAQgAEYaIAQgBTYCCCAFIAQ2AgwMAQsgBigCGCEJAkACQCAGKAIMIgAgBkYNACAGKAIIIgQgCEkaIAAgBDYCCCAEIAA2AgwMAQsCQCAGQRRqIgQoAgAiBQ0AIAZBEGoiBCgCACIFDQBBACEADAELA0AgBCEIIAUiAEEUaiIEKAIAIgUNACAAQRBqIQQgACgCECIFDQALIAhBADYCAAsgCUUNAAJAAkAgBiAGKAIcIgVBAnRBuNKAgABqIgQoAgBHDQAgBCAANgIAIAANAUEAQQAoAozQgIAAQX4gBXdxNgKM0ICAAAwCCyAJQRBBFCAJKAIQIAZGG2ogADYCACAARQ0BCyAAIAk2AhgCQCAGKAIQIgRFDQAgACAENgIQIAQgADYCGAsgBigCFCIERQ0AIABBFGogBDYCACAEIAA2AhgLIAcgA2ohAyAGIAdqIgYoAgQhBAsgBiAEQX5xNgIEIAIgA2ogAzYCACACIANBAXI2AgQCQCADQf8BSw0AIANBeHFBsNCAgABqIQQCQAJAQQAoAojQgIAAIgVBASADQQN2dCIDcQ0AQQAgBSADcjYCiNCAgAAgBCEDDAELIAQoAgghAwsgAyACNgIMIAQgAjYCCCACIAQ2AgwgAiADNgIIDAMLQR8hBAJAIANB////B0sNACADQQh2IgQgBEGA/j9qQRB2QQhxIgR0IgUgBUGA4B9qQRB2QQRxIgV0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAQgBXIgAHJrIgRBAXQgAyAEQRVqdkEBcXJBHGohBAsgAiAENgIcIAJCADcCECAEQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiAEEBIAR0IghxDQAgBSACNgIAQQAgACAIcjYCjNCAgAAgAiAFNgIYIAIgAjYCCCACIAI2AgwMAwsgA0EAQRkgBEEBdmsgBEEfRht0IQQgBSgCACEAA0AgACIFKAIEQXhxIANGDQIgBEEddiEAIARBAXQhBCAFIABBBHFqQRBqIggoAgAiAA0ACyAIIAI2AgAgAiAFNgIYIAIgAjYCDCACIAI2AggMAgsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiCyAGQUhqIgggA2siA0EBcjYCBCAAIAhqQTg2AgQgBCAFQTcgBWtBD3FBACAFQUlqQQ9xG2pBQWoiCCAIIARBEGpJGyIIQSM2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAs2AqDQgIAAIAhBEGpBACkC0NOAgAA3AgAgCEEAKQLI04CAADcCCEEAIAhBCGo2AtDTgIAAQQAgBjYCzNOAgABBACAANgLI04CAAEEAQQA2AtTTgIAAIAhBJGohAwNAIANBBzYCACADQQRqIgMgBUkNAAsgCCAERg0DIAggCCgCBEF+cTYCBCAIIAggBGsiADYCACAEIABBAXI2AgQCQCAAQf8BSw0AIABBeHFBsNCAgABqIQMCQAJAQQAoAojQgIAAIgVBASAAQQN2dCIAcQ0AQQAgBSAAcjYCiNCAgAAgAyEFDAELIAMoAgghBQsgBSAENgIMIAMgBDYCCCAEIAM2AgwgBCAFNgIIDAQLQR8hAwJAIABB////B0sNACAAQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgUgBUGA4B9qQRB2QQRxIgV0IgggCEGAgA9qQRB2QQJxIgh0QQ92IAMgBXIgCHJrIgNBAXQgACADQRVqdkEBcXJBHGohAwsgBCADNgIcIARCADcCECADQQJ0QbjSgIAAaiEFAkBBACgCjNCAgAAiCEEBIAN0IgZxDQAgBSAENgIAQQAgCCAGcjYCjNCAgAAgBCAFNgIYIAQgBDYCCCAEIAQ2AgwMBAsgAEEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACEIA0AgCCIFKAIEQXhxIABGDQMgA0EddiEIIANBAXQhAyAFIAhBBHFqQRBqIgYoAgAiCA0ACyAGIAQ2AgAgBCAFNgIYIAQgBDYCDCAEIAQ2AggMAwsgBSgCCCIDIAI2AgwgBSACNgIIIAJBADYCGCACIAU2AgwgAiADNgIICyALQQhqIQMMBQsgBSgCCCIDIAQ2AgwgBSAENgIIIARBADYCGCAEIAU2AgwgBCADNgIIC0EAKAKU0ICAACIDIAJNDQBBACgCoNCAgAAiBCACaiIFIAMgAmsiA0EBcjYCBEEAIAM2ApTQgIAAQQAgBTYCoNCAgAAgBCACQQNyNgIEIARBCGohAwwDC0EAIQNBAEEwNgL404CAAAwCCwJAIAtFDQACQAJAIAggCCgCHCIFQQJ0QbjSgIAAaiIDKAIARw0AIAMgADYCACAADQFBACAHQX4gBXdxIgc2AozQgIAADAILIAtBEEEUIAsoAhAgCEYbaiAANgIAIABFDQELIAAgCzYCGAJAIAgoAhAiA0UNACAAIAM2AhAgAyAANgIYCyAIQRRqKAIAIgNFDQAgAEEUaiADNgIAIAMgADYCGAsCQAJAIARBD0sNACAIIAQgAmoiA0EDcjYCBCAIIANqIgMgAygCBEEBcjYCBAwBCyAIIAJqIgAgBEEBcjYCBCAIIAJBA3I2AgQgACAEaiAENgIAAkAgBEH/AUsNACAEQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgBEEDdnQiBHENAEEAIAUgBHI2AojQgIAAIAMhBAwBCyADKAIIIQQLIAQgADYCDCADIAA2AgggACADNgIMIAAgBDYCCAwBC0EfIQMCQCAEQf///wdLDQAgBEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCICIAJBgIAPakEQdkECcSICdEEPdiADIAVyIAJyayIDQQF0IAQgA0EVanZBAXFyQRxqIQMLIAAgAzYCHCAAQgA3AhAgA0ECdEG40oCAAGohBQJAIAdBASADdCICcQ0AIAUgADYCAEEAIAcgAnI2AozQgIAAIAAgBTYCGCAAIAA2AgggACAANgIMDAELIARBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAgJAA0AgAiIFKAIEQXhxIARGDQEgA0EddiECIANBAXQhAyAFIAJBBHFqQRBqIgYoAgAiAg0ACyAGIAA2AgAgACAFNgIYIAAgADYCDCAAIAA2AggMAQsgBSgCCCIDIAA2AgwgBSAANgIIIABBADYCGCAAIAU2AgwgACADNgIICyAIQQhqIQMMAQsCQCAKRQ0AAkACQCAAIAAoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAg2AgAgCA0BQQAgCUF+IAV3cTYCjNCAgAAMAgsgCkEQQRQgCigCECAARhtqIAg2AgAgCEUNAQsgCCAKNgIYAkAgACgCECIDRQ0AIAggAzYCECADIAg2AhgLIABBFGooAgAiA0UNACAIQRRqIAM2AgAgAyAINgIYCwJAAkAgBEEPSw0AIAAgBCACaiIDQQNyNgIEIAAgA2oiAyADKAIEQQFyNgIEDAELIAAgAmoiBSAEQQFyNgIEIAAgAkEDcjYCBCAFIARqIAQ2AgACQCAHRQ0AIAdBeHFBsNCAgABqIQJBACgCnNCAgAAhAwJAAkBBASAHQQN2dCIIIAZxDQBBACAIIAZyNgKI0ICAACACIQgMAQsgAigCCCEICyAIIAM2AgwgAiADNgIIIAMgAjYCDCADIAg2AggLQQAgBTYCnNCAgABBACAENgKQ0ICAAAsgAEEIaiEDCyABQRBqJICAgIAAIAMLCgAgABDJgICAAAviDQEHfwJAIABFDQAgAEF4aiIBIABBfGooAgAiAkF4cSIAaiEDAkAgAkEBcQ0AIAJBA3FFDQEgASABKAIAIgJrIgFBACgCmNCAgAAiBEkNASACIABqIQACQCABQQAoApzQgIAARg0AAkAgAkH/AUsNACABKAIIIgQgAkEDdiIFQQN0QbDQgIAAaiIGRhoCQCABKAIMIgIgBEcNAEEAQQAoAojQgIAAQX4gBXdxNgKI0ICAAAwDCyACIAZGGiACIAQ2AgggBCACNgIMDAILIAEoAhghBwJAAkAgASgCDCIGIAFGDQAgASgCCCICIARJGiAGIAI2AgggAiAGNgIMDAELAkAgAUEUaiICKAIAIgQNACABQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQECQAJAIAEgASgCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAwsgB0EQQRQgBygCECABRhtqIAY2AgAgBkUNAgsgBiAHNgIYAkAgASgCECICRQ0AIAYgAjYCECACIAY2AhgLIAEoAhQiAkUNASAGQRRqIAI2AgAgAiAGNgIYDAELIAMoAgQiAkEDcUEDRw0AIAMgAkF+cTYCBEEAIAA2ApDQgIAAIAEgAGogADYCACABIABBAXI2AgQPCyABIANPDQAgAygCBCICQQFxRQ0AAkACQCACQQJxDQACQCADQQAoAqDQgIAARw0AQQAgATYCoNCAgABBAEEAKAKU0ICAACAAaiIANgKU0ICAACABIABBAXI2AgQgAUEAKAKc0ICAAEcNA0EAQQA2ApDQgIAAQQBBADYCnNCAgAAPCwJAIANBACgCnNCAgABHDQBBACABNgKc0ICAAEEAQQAoApDQgIAAIABqIgA2ApDQgIAAIAEgAEEBcjYCBCABIABqIAA2AgAPCyACQXhxIABqIQACQAJAIAJB/wFLDQAgAygCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgAygCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAgsgAiAGRhogAiAENgIIIAQgAjYCDAwBCyADKAIYIQcCQAJAIAMoAgwiBiADRg0AIAMoAggiAkEAKAKY0ICAAEkaIAYgAjYCCCACIAY2AgwMAQsCQCADQRRqIgIoAgAiBA0AIANBEGoiAigCACIEDQBBACEGDAELA0AgAiEFIAQiBkEUaiICKAIAIgQNACAGQRBqIQIgBigCECIEDQALIAVBADYCAAsgB0UNAAJAAkAgAyADKAIcIgRBAnRBuNKAgABqIgIoAgBHDQAgAiAGNgIAIAYNAUEAQQAoAozQgIAAQX4gBHdxNgKM0ICAAAwCCyAHQRBBFCAHKAIQIANGG2ogBjYCACAGRQ0BCyAGIAc2AhgCQCADKAIQIgJFDQAgBiACNgIQIAIgBjYCGAsgAygCFCICRQ0AIAZBFGogAjYCACACIAY2AhgLIAEgAGogADYCACABIABBAXI2AgQgAUEAKAKc0ICAAEcNAUEAIAA2ApDQgIAADwsgAyACQX5xNgIEIAEgAGogADYCACABIABBAXI2AgQLAkAgAEH/AUsNACAAQXhxQbDQgIAAaiECAkACQEEAKAKI0ICAACIEQQEgAEEDdnQiAHENAEEAIAQgAHI2AojQgIAAIAIhAAwBCyACKAIIIQALIAAgATYCDCACIAE2AgggASACNgIMIAEgADYCCA8LQR8hAgJAIABB////B0sNACAAQQh2IgIgAkGA/j9qQRB2QQhxIgJ0IgQgBEGA4B9qQRB2QQRxIgR0IgYgBkGAgA9qQRB2QQJxIgZ0QQ92IAIgBHIgBnJrIgJBAXQgACACQRVqdkEBcXJBHGohAgsgASACNgIcIAFCADcCECACQQJ0QbjSgIAAaiEEAkACQEEAKAKM0ICAACIGQQEgAnQiA3ENACAEIAE2AgBBACAGIANyNgKM0ICAACABIAQ2AhggASABNgIIIAEgATYCDAwBCyAAQQBBGSACQQF2ayACQR9GG3QhAiAEKAIAIQYCQANAIAYiBCgCBEF4cSAARg0BIAJBHXYhBiACQQF0IQIgBCAGQQRxakEQaiIDKAIAIgYNAAsgAyABNgIAIAEgBDYCGCABIAE2AgwgASABNgIIDAELIAQoAggiACABNgIMIAQgATYCCCABQQA2AhggASAENgIMIAEgADYCCAtBAEEAKAKo0ICAAEF/aiIBQX8gARs2AqjQgIAACwsEAAAAC04AAkAgAA0APwBBEHQPCwJAIABB//8DcQ0AIABBf0wNAAJAIABBEHZAACIAQX9HDQBBAEEwNgL404CAAEF/DwsgAEEQdA8LEMqAgIAAAAvyAgIDfwF+AkAgAkUNACAAIAE6AAAgAiAAaiIDQX9qIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0F9aiABOgAAIANBfmogAToAACACQQdJDQAgACABOgADIANBfGogAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkF8aiABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBeGogATYCACACQXRqIAE2AgAgBEEZSQ0AIAMgATYCGCADIAE2AhQgAyABNgIQIAMgATYCDCACQXBqIAE2AgAgAkFsaiABNgIAIAJBaGogATYCACACQWRqIAE2AgAgBCADQQRxQRhyIgVrIgJBIEkNACABrUKBgICAEH4hBiADIAVqIQEDQCABIAY3AxggASAGNwMQIAEgBjcDCCABIAY3AwAgAUEgaiEBIAJBYGoiAkEfSw0ACwsgAAsLjkgBAEGACAuGSAEAAAACAAAAAwAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
});

// node_modules/undici/lib/client.js
var require_client = __commonJS((exports, module) => {
  var assert = __require("assert");
  var net = __require("net");
  var http = __require("http");
  var { pipeline } = __require("stream");
  var util = require_util();
  var timers = require_timers();
  var Request = require_request();
  var DispatcherBase = require_dispatcher_base();
  var {
    RequestContentLengthMismatchError,
    ResponseContentLengthMismatchError,
    InvalidArgumentError,
    RequestAbortedError,
    HeadersTimeoutError,
    HeadersOverflowError,
    SocketError,
    InformationalError,
    BodyTimeoutError,
    HTTPParserError,
    ResponseExceededMaxSizeError,
    ClientDestroyedError
  } = require_errors();
  var buildConnector = require_connect();
  var {
    kUrl,
    kReset,
    kServerName,
    kClient,
    kBusy,
    kParser,
    kConnect,
    kBlocking,
    kResuming,
    kRunning,
    kPending,
    kSize,
    kWriting,
    kQueue,
    kConnected,
    kConnecting,
    kNeedDrain,
    kNoRef,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kSocket,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kConnector,
    kMaxRedirections,
    kMaxRequests,
    kCounter,
    kClose,
    kDestroy,
    kDispatch,
    kInterceptors,
    kLocalAddress,
    kMaxResponseSize,
    kHTTPConnVersion,
    kHost,
    kHTTP2Session,
    kHTTP2SessionState,
    kHTTP2BuildRequest,
    kHTTP2CopyHeaders,
    kHTTP1BuildRequest
  } = require_symbols();
  var http2;
  try {
    http2 = __require("http2");
  } catch {
    http2 = { constants: {} };
  }
  var {
    constants: {
      HTTP2_HEADER_AUTHORITY,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_SCHEME,
      HTTP2_HEADER_CONTENT_LENGTH,
      HTTP2_HEADER_EXPECT,
      HTTP2_HEADER_STATUS
    }
  } = http2;
  var h2ExperimentalWarned = false;
  var FastBuffer = Buffer[Symbol.species];
  var kClosedResolve = Symbol("kClosedResolve");
  var channels = {};
  try {
    const diagnosticsChannel = __require("diagnostics_channel");
    channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
    channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
    channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
    channels.connected = diagnosticsChannel.channel("undici:client:connected");
  } catch {
    channels.sendHeaders = { hasSubscribers: false };
    channels.beforeConnect = { hasSubscribers: false };
    channels.connectError = { hasSubscribers: false };
    channels.connected = { hasSubscribers: false };
  }

  class Client extends DispatcherBase {
    constructor(url, {
      interceptors,
      maxHeaderSize,
      headersTimeout,
      socketTimeout,
      requestTimeout,
      connectTimeout,
      bodyTimeout,
      idleTimeout,
      keepAlive,
      keepAliveTimeout,
      maxKeepAliveTimeout,
      keepAliveMaxTimeout,
      keepAliveTimeoutThreshold,
      socketPath,
      pipelining,
      tls,
      strictContentLength,
      maxCachedSessions,
      maxRedirections,
      connect: connect2,
      maxRequestsPerClient,
      localAddress,
      maxResponseSize,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      maxConcurrentStreams
    } = {}) {
      super();
      if (keepAlive !== undefined) {
        throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
      }
      if (socketTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (requestTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (idleTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
      }
      if (maxKeepAliveTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      }
      if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
        throw new InvalidArgumentError("invalid maxHeaderSize");
      }
      if (socketPath != null && typeof socketPath !== "string") {
        throw new InvalidArgumentError("invalid socketPath");
      }
      if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
        throw new InvalidArgumentError("invalid connectTimeout");
      }
      if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveTimeout");
      }
      if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
      }
      if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
        throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
      }
      if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
      }
      if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
      }
      if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
        throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
      }
      if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
        throw new InvalidArgumentError("localAddress must be valid string IP address");
      }
      if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
        throw new InvalidArgumentError("maxResponseSize must be a positive number");
      }
      if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
        throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
      }
      if (allowH2 != null && typeof allowH2 !== "boolean") {
        throw new InvalidArgumentError("allowH2 must be a valid boolean value");
      }
      if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
        throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
      }
      if (typeof connect2 !== "function") {
        connect2 = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined,
          ...connect2
        });
      }
      this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
      this[kUrl] = util.parseOrigin(url);
      this[kConnector] = connect2;
      this[kSocket] = null;
      this[kPipelining] = pipelining != null ? pipelining : 1;
      this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
      this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4000 : keepAliveTimeout;
      this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600000 : keepAliveMaxTimeout;
      this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1000 : keepAliveTimeoutThreshold;
      this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
      this[kServerName] = null;
      this[kLocalAddress] = localAddress != null ? localAddress : null;
      this[kResuming] = 0;
      this[kNeedDrain] = 0;
      this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
      this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300000;
      this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300000;
      this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
      this[kMaxRedirections] = maxRedirections;
      this[kMaxRequests] = maxRequestsPerClient;
      this[kClosedResolve] = null;
      this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
      this[kHTTPConnVersion] = "h1";
      this[kHTTP2Session] = null;
      this[kHTTP2SessionState] = !allowH2 ? null : {
        openStreams: 0,
        maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
      };
      this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;
      this[kQueue] = [];
      this[kRunningIdx] = 0;
      this[kPendingIdx] = 0;
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(value) {
      this[kPipelining] = value;
      resume(this, true);
    }
    get [kPending]() {
      return this[kQueue].length - this[kPendingIdx];
    }
    get [kRunning]() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get [kSize]() {
      return this[kQueue].length - this[kRunningIdx];
    }
    get [kConnected]() {
      return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
    }
    get [kBusy]() {
      const socket = this[kSocket];
      return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
    }
    [kConnect](cb) {
      connect(this);
      this.once("connect", cb);
    }
    [kDispatch](opts, handler) {
      const origin = opts.origin || this[kUrl].origin;
      const request = this[kHTTPConnVersion] === "h2" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);
      this[kQueue].push(request);
      if (this[kResuming]) {
      } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
        this[kResuming] = 1;
        process.nextTick(resume, this);
      } else {
        resume(this, true);
      }
      if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
        this[kNeedDrain] = 2;
      }
      return this[kNeedDrain] < 2;
    }
    async[kClose]() {
      return new Promise((resolve) => {
        if (!this[kSize]) {
          resolve(null);
        } else {
          this[kClosedResolve] = resolve;
        }
      });
    }
    async[kDestroy](err) {
      return new Promise((resolve) => {
        const requests = this[kQueue].splice(this[kPendingIdx]);
        for (let i = 0;i < requests.length; i++) {
          const request = requests[i];
          errorRequest(this, request, err);
        }
        const callback = () => {
          if (this[kClosedResolve]) {
            this[kClosedResolve]();
            this[kClosedResolve] = null;
          }
          resolve();
        };
        if (this[kHTTP2Session] != null) {
          util.destroy(this[kHTTP2Session], err);
          this[kHTTP2Session] = null;
          this[kHTTP2SessionState] = null;
        }
        if (!this[kSocket]) {
          queueMicrotask(callback);
        } else {
          util.destroy(this[kSocket].on("close", callback), err);
        }
        resume(this);
      });
    }
  }
  function onHttp2SessionError(err) {
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    this[kSocket][kError] = err;
    onError(this[kClient], err);
  }
  function onHttp2FrameError(type, code, id) {
    const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
    if (id === 0) {
      this[kSocket][kError] = err;
      onError(this[kClient], err);
    }
  }
  function onHttp2SessionEnd() {
    util.destroy(this, new SocketError("other side closed"));
    util.destroy(this[kSocket], new SocketError("other side closed"));
  }
  function onHTTP2GoAway(code) {
    const client = this[kClient];
    const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
    client[kSocket] = null;
    client[kHTTP2Session] = null;
    if (client.destroyed) {
      assert(this[kPending] === 0);
      const requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        const request = requests[i];
        errorRequest(this, request, err);
      }
    } else if (client[kRunning] > 0) {
      const request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null;
      errorRequest(client, request, err);
    }
    client[kPendingIdx] = client[kRunningIdx];
    assert(client[kRunning] === 0);
    client.emit("disconnect", client[kUrl], [client], err);
    resume(client);
  }
  var constants = require_constants3();
  var createRedirectInterceptor = require_redirectInterceptor();
  var EMPTY_BUF = Buffer.alloc(0);
  async function lazyllhttp() {
    const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : undefined;
    let mod;
    try {
      mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
    } catch (e) {
      mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
    }
    return await WebAssembly.instantiate(mod, {
      env: {
        wasm_on_url: (p, at, len) => {
          return 0;
        },
        wasm_on_status: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_message_begin: (p) => {
          assert.strictEqual(currentParser.ptr, p);
          return currentParser.onMessageBegin() || 0;
        },
        wasm_on_header_field: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_header_value: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
          assert.strictEqual(currentParser.ptr, p);
          return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
        },
        wasm_on_body: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_message_complete: (p) => {
          assert.strictEqual(currentParser.ptr, p);
          return currentParser.onMessageComplete() || 0;
        }
      }
    });
  }
  var llhttpInstance = null;
  var llhttpPromise = lazyllhttp();
  llhttpPromise.catch();
  var currentParser = null;
  var currentBufferRef = null;
  var currentBufferSize = 0;
  var currentBufferPtr = null;
  var TIMEOUT_HEADERS = 1;
  var TIMEOUT_BODY = 2;
  var TIMEOUT_IDLE = 3;

  class Parser {
    constructor(client, socket, { exports: exports2 }) {
      assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
      this.llhttp = exports2;
      this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
      this.client = client;
      this.socket = socket;
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.statusCode = null;
      this.statusText = "";
      this.upgrade = false;
      this.headers = [];
      this.headersSize = 0;
      this.headersMaxSize = client[kMaxHeadersSize];
      this.shouldKeepAlive = false;
      this.paused = false;
      this.resume = this.resume.bind(this);
      this.bytesRead = 0;
      this.keepAlive = "";
      this.contentLength = "";
      this.connection = "";
      this.maxResponseSize = client[kMaxResponseSize];
    }
    setTimeout(value, type) {
      this.timeoutType = type;
      if (value !== this.timeoutValue) {
        timers.clearTimeout(this.timeout);
        if (value) {
          this.timeout = timers.setTimeout(onParserTimeout, value, this);
          if (this.timeout.unref) {
            this.timeout.unref();
          }
        } else {
          this.timeout = null;
        }
        this.timeoutValue = value;
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
    }
    resume() {
      if (this.socket.destroyed || !this.paused) {
        return;
      }
      assert(this.ptr != null);
      assert(currentParser == null);
      this.llhttp.llhttp_resume(this.ptr);
      assert(this.timeoutType === TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      this.paused = false;
      this.execute(this.socket.read() || EMPTY_BUF);
      this.readMore();
    }
    readMore() {
      while (!this.paused && this.ptr) {
        const chunk = this.socket.read();
        if (chunk === null) {
          break;
        }
        this.execute(chunk);
      }
    }
    execute(data) {
      assert(this.ptr != null);
      assert(currentParser == null);
      assert(!this.paused);
      const { socket, llhttp } = this;
      if (data.length > currentBufferSize) {
        if (currentBufferPtr) {
          llhttp.free(currentBufferPtr);
        }
        currentBufferSize = Math.ceil(data.length / 4096) * 4096;
        currentBufferPtr = llhttp.malloc(currentBufferSize);
      }
      new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
      try {
        let ret;
        try {
          currentBufferRef = data;
          currentParser = this;
          ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
        } catch (err) {
          throw err;
        } finally {
          currentParser = null;
          currentBufferRef = null;
        }
        const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
        if (ret === constants.ERROR.PAUSED_UPGRADE) {
          this.onUpgrade(data.slice(offset));
        } else if (ret === constants.ERROR.PAUSED) {
          this.paused = true;
          socket.unshift(data.slice(offset));
        } else if (ret !== constants.ERROR.OK) {
          const ptr = llhttp.llhttp_get_error_reason(this.ptr);
          let message = "";
          if (ptr) {
            const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
            message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
          }
          throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
        }
      } catch (err) {
        util.destroy(socket, err);
      }
    }
    destroy() {
      assert(this.ptr != null);
      assert(currentParser == null);
      this.llhttp.llhttp_free(this.ptr);
      this.ptr = null;
      timers.clearTimeout(this.timeout);
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.paused = false;
    }
    onStatus(buf) {
      this.statusText = buf.toString();
    }
    onMessageBegin() {
      const { socket, client } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      if (!request) {
        return -1;
      }
    }
    onHeaderField(buf) {
      const len = this.headers.length;
      if ((len & 1) === 0) {
        this.headers.push(buf);
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      this.trackHeader(buf.length);
    }
    onHeaderValue(buf) {
      let len = this.headers.length;
      if ((len & 1) === 1) {
        this.headers.push(buf);
        len += 1;
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      const key = this.headers[len - 2];
      if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
        this.keepAlive += buf.toString();
      } else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
        this.connection += buf.toString();
      } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
        this.contentLength += buf.toString();
      }
      this.trackHeader(buf.length);
    }
    trackHeader(len) {
      this.headersSize += len;
      if (this.headersSize >= this.headersMaxSize) {
        util.destroy(this.socket, new HeadersOverflowError);
      }
    }
    onUpgrade(head) {
      const { upgrade, client, socket, headers, statusCode } = this;
      assert(upgrade);
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert(!socket.destroyed);
      assert(socket === client[kSocket]);
      assert(!this.paused);
      assert(request.upgrade || request.method === "CONNECT");
      this.statusCode = null;
      this.statusText = "";
      this.shouldKeepAlive = null;
      assert(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      socket.unshift(head);
      socket[kParser].destroy();
      socket[kParser] = null;
      socket[kClient] = null;
      socket[kError] = null;
      socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
      client[kSocket] = null;
      client[kQueue][client[kRunningIdx]++] = null;
      client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
      try {
        request.onUpgrade(statusCode, headers, socket);
      } catch (err) {
        util.destroy(socket, err);
      }
      resume(client);
    }
    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
      const { client, socket, headers, statusText } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      if (!request) {
        return -1;
      }
      assert(!this.upgrade);
      assert(this.statusCode < 200);
      if (statusCode === 100) {
        util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
        return -1;
      }
      if (upgrade && !request.upgrade) {
        util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
        return -1;
      }
      assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
      this.statusCode = statusCode;
      this.shouldKeepAlive = shouldKeepAlive || request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
      if (this.statusCode >= 200) {
        const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
        this.setTimeout(bodyTimeout, TIMEOUT_BODY);
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      if (request.method === "CONNECT") {
        assert(client[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      if (upgrade) {
        assert(client[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      assert(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      if (this.shouldKeepAlive && client[kPipelining]) {
        const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
        if (keepAliveTimeout != null) {
          const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
          if (timeout <= 0) {
            socket[kReset] = true;
          } else {
            client[kKeepAliveTimeoutValue] = timeout;
          }
        } else {
          client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
        }
      } else {
        socket[kReset] = true;
      }
      const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
      if (request.aborted) {
        return -1;
      }
      if (request.method === "HEAD") {
        return 1;
      }
      if (statusCode < 200) {
        return 1;
      }
      if (socket[kBlocking]) {
        socket[kBlocking] = false;
        resume(client);
      }
      return pause ? constants.ERROR.PAUSED : 0;
    }
    onBody(buf) {
      const { client, socket, statusCode, maxResponseSize } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      assert(statusCode >= 200);
      if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
        util.destroy(socket, new ResponseExceededMaxSizeError);
        return -1;
      }
      this.bytesRead += buf.length;
      if (request.onData(buf) === false) {
        return constants.ERROR.PAUSED;
      }
    }
    onMessageComplete() {
      const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
      if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
        return -1;
      }
      if (upgrade) {
        return;
      }
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert(statusCode >= 100);
      this.statusCode = null;
      this.statusText = "";
      this.bytesRead = 0;
      this.contentLength = "";
      this.keepAlive = "";
      this.connection = "";
      assert(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      if (statusCode < 200) {
        return;
      }
      if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
        util.destroy(socket, new ResponseContentLengthMismatchError);
        return -1;
      }
      request.onComplete(headers);
      client[kQueue][client[kRunningIdx]++] = null;
      if (socket[kWriting]) {
        assert.strictEqual(client[kRunning], 0);
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (!shouldKeepAlive) {
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (socket[kReset] && client[kRunning] === 0) {
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (client[kPipelining] === 1) {
        setImmediate(resume, client);
      } else {
        resume(client);
      }
    }
  }
  function onParserTimeout(parser) {
    const { socket, timeoutType, client } = parser;
    if (timeoutType === TIMEOUT_HEADERS) {
      if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
        assert(!parser.paused, "cannot be paused while waiting for headers");
        util.destroy(socket, new HeadersTimeoutError);
      }
    } else if (timeoutType === TIMEOUT_BODY) {
      if (!parser.paused) {
        util.destroy(socket, new BodyTimeoutError);
      }
    } else if (timeoutType === TIMEOUT_IDLE) {
      assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
      util.destroy(socket, new InformationalError("socket idle timeout"));
    }
  }
  function onSocketReadable() {
    const { [kParser]: parser } = this;
    if (parser) {
      parser.readMore();
    }
  }
  function onSocketError(err) {
    const { [kClient]: client, [kParser]: parser } = this;
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    if (client[kHTTPConnVersion] !== "h2") {
      if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
    }
    this[kError] = err;
    onError(this[kClient], err);
  }
  function onError(client, err) {
    if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
      assert(client[kPendingIdx] === client[kRunningIdx]);
      const requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        const request = requests[i];
        errorRequest(client, request, err);
      }
      assert(client[kSize] === 0);
    }
  }
  function onSocketEnd() {
    const { [kParser]: parser, [kClient]: client } = this;
    if (client[kHTTPConnVersion] !== "h2") {
      if (parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
    }
    util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
  }
  function onSocketClose() {
    const { [kClient]: client, [kParser]: parser } = this;
    if (client[kHTTPConnVersion] === "h1" && parser) {
      if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
      }
      this[kParser].destroy();
      this[kParser] = null;
    }
    const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
    client[kSocket] = null;
    if (client.destroyed) {
      assert(client[kPending] === 0);
      const requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        const request = requests[i];
        errorRequest(client, request, err);
      }
    } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
      const request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null;
      errorRequest(client, request, err);
    }
    client[kPendingIdx] = client[kRunningIdx];
    assert(client[kRunning] === 0);
    client.emit("disconnect", client[kUrl], [client], err);
    resume(client);
  }
  async function connect(client) {
    assert(!client[kConnecting]);
    assert(!client[kSocket]);
    let { host, hostname, protocol, port } = client[kUrl];
    if (hostname[0] === "[") {
      const idx = hostname.indexOf("]");
      assert(idx !== -1);
      const ip = hostname.substring(1, idx);
      assert(net.isIP(ip));
      hostname = ip;
    }
    client[kConnecting] = true;
    if (channels.beforeConnect.hasSubscribers) {
      channels.beforeConnect.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        },
        connector: client[kConnector]
      });
    }
    try {
      const socket = await new Promise((resolve, reject) => {
        client[kConnector]({
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        }, (err, socket2) => {
          if (err) {
            reject(err);
          } else {
            resolve(socket2);
          }
        });
      });
      if (client.destroyed) {
        util.destroy(socket.on("error", () => {
        }), new ClientDestroyedError);
        return;
      }
      client[kConnecting] = false;
      assert(socket);
      const isH2 = socket.alpnProtocol === "h2";
      if (isH2) {
        if (!h2ExperimentalWarned) {
          h2ExperimentalWarned = true;
          process.emitWarning("H2 support is experimental, expect them to change at any time.", {
            code: "UNDICI-H2"
          });
        }
        const session = http2.connect(client[kUrl], {
          createConnection: () => socket,
          peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
        });
        client[kHTTPConnVersion] = "h2";
        session[kClient] = client;
        session[kSocket] = socket;
        session.on("error", onHttp2SessionError);
        session.on("frameError", onHttp2FrameError);
        session.on("end", onHttp2SessionEnd);
        session.on("goaway", onHTTP2GoAway);
        session.on("close", onSocketClose);
        session.unref();
        client[kHTTP2Session] = session;
        socket[kHTTP2Session] = session;
      } else {
        if (!llhttpInstance) {
          llhttpInstance = await llhttpPromise;
          llhttpPromise = null;
        }
        socket[kNoRef] = false;
        socket[kWriting] = false;
        socket[kReset] = false;
        socket[kBlocking] = false;
        socket[kParser] = new Parser(client, socket, llhttpInstance);
      }
      socket[kCounter] = 0;
      socket[kMaxRequests] = client[kMaxRequests];
      socket[kClient] = client;
      socket[kError] = null;
      socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
      client[kSocket] = socket;
      if (channels.connected.hasSubscribers) {
        channels.connected.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          socket
        });
      }
      client.emit("connect", client[kUrl], [client]);
    } catch (err) {
      if (client.destroyed) {
        return;
      }
      client[kConnecting] = false;
      if (channels.connectError.hasSubscribers) {
        channels.connectError.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          error: err
        });
      }
      if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
        assert(client[kRunning] === 0);
        while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
          const request = client[kQueue][client[kPendingIdx]++];
          errorRequest(client, request, err);
        }
      } else {
        onError(client, err);
      }
      client.emit("connectionError", client[kUrl], [client], err);
    }
    resume(client);
  }
  function emitDrain(client) {
    client[kNeedDrain] = 0;
    client.emit("drain", client[kUrl], [client]);
  }
  function resume(client, sync) {
    if (client[kResuming] === 2) {
      return;
    }
    client[kResuming] = 2;
    _resume(client, sync);
    client[kResuming] = 0;
    if (client[kRunningIdx] > 256) {
      client[kQueue].splice(0, client[kRunningIdx]);
      client[kPendingIdx] -= client[kRunningIdx];
      client[kRunningIdx] = 0;
    }
  }
  function _resume(client, sync) {
    while (true) {
      if (client.destroyed) {
        assert(client[kPending] === 0);
        return;
      }
      if (client[kClosedResolve] && !client[kSize]) {
        client[kClosedResolve]();
        client[kClosedResolve] = null;
        return;
      }
      const socket = client[kSocket];
      if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
        if (client[kSize] === 0) {
          if (!socket[kNoRef] && socket.unref) {
            socket.unref();
            socket[kNoRef] = true;
          }
        } else if (socket[kNoRef] && socket.ref) {
          socket.ref();
          socket[kNoRef] = false;
        }
        if (client[kSize] === 0) {
          if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
            socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
          }
        } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
          if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
            const request2 = client[kQueue][client[kRunningIdx]];
            const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
            socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
          }
        }
      }
      if (client[kBusy]) {
        client[kNeedDrain] = 2;
      } else if (client[kNeedDrain] === 2) {
        if (sync) {
          client[kNeedDrain] = 1;
          process.nextTick(emitDrain, client);
        } else {
          emitDrain(client);
        }
        continue;
      }
      if (client[kPending] === 0) {
        return;
      }
      if (client[kRunning] >= (client[kPipelining] || 1)) {
        return;
      }
      const request = client[kQueue][client[kPendingIdx]];
      if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
        if (client[kRunning] > 0) {
          return;
        }
        client[kServerName] = request.servername;
        if (socket && socket.servername !== request.servername) {
          util.destroy(socket, new InformationalError("servername changed"));
          return;
        }
      }
      if (client[kConnecting]) {
        return;
      }
      if (!socket && !client[kHTTP2Session]) {
        connect(client);
        return;
      }
      if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
        return;
      }
      if (client[kRunning] > 0 && !request.idempotent) {
        return;
      }
      if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
        return;
      }
      if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
        return;
      }
      if (!request.aborted && write(client, request)) {
        client[kPendingIdx]++;
      } else {
        client[kQueue].splice(client[kPendingIdx], 1);
      }
    }
  }
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  function write(client, request) {
    if (client[kHTTPConnVersion] === "h2") {
      writeH2(client, client[kHTTP2Session], request);
      return;
    }
    const { body, method, path, host, upgrade, headers, blocking, reset } = request;
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function") {
      body.read(0);
    }
    const bodyLength = util.bodyLength(body);
    let contentLength = bodyLength;
    if (contentLength === null) {
      contentLength = request.contentLength;
    }
    if (contentLength === 0 && !expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength]) {
        errorRequest(client, request, new RequestContentLengthMismatchError);
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    const socket = client[kSocket];
    try {
      request.onConnect((err) => {
        if (request.aborted || request.completed) {
          return;
        }
        errorRequest(client, request, err || new RequestAbortedError);
        util.destroy(socket, new InformationalError("aborted"));
      });
    } catch (err) {
      errorRequest(client, request, err);
    }
    if (request.aborted) {
      return false;
    }
    if (method === "HEAD") {
      socket[kReset] = true;
    }
    if (upgrade || method === "CONNECT") {
      socket[kReset] = true;
    }
    if (reset != null) {
      socket[kReset] = reset;
    }
    if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
      socket[kReset] = true;
    }
    if (blocking) {
      socket[kBlocking] = true;
    }
    let header = `${method} ${path} HTTP/1.1\r
`;
    if (typeof host === "string") {
      header += `host: ${host}\r
`;
    } else {
      header += client[kHostHeader];
    }
    if (upgrade) {
      header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
    } else if (client[kPipelining] && !socket[kReset]) {
      header += `connection: keep-alive\r
`;
    } else {
      header += `connection: close\r
`;
    }
    if (headers) {
      header += headers;
    }
    if (channels.sendHeaders.hasSubscribers) {
      channels.sendHeaders.publish({ request, headers: header, socket });
    }
    if (!body || bodyLength === 0) {
      if (contentLength === 0) {
        socket.write(`${header}content-length: 0\r
\r
`, "latin1");
      } else {
        assert(contentLength === null, "no body must not have content length");
        socket.write(`${header}\r
`, "latin1");
      }
      request.onRequestSent();
    } else if (util.isBuffer(body)) {
      assert(contentLength === body.byteLength, "buffer body must have content length");
      socket.cork();
      socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
      socket.write(body);
      socket.uncork();
      request.onBodySent(body);
      request.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
    } else if (util.isBlobLike(body)) {
      if (typeof body.stream === "function") {
        writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
      } else {
        writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
      }
    } else if (util.isStream(body)) {
      writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
    } else if (util.isIterable(body)) {
      writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
    } else {
      assert(false);
    }
    return true;
  }
  function writeH2(client, session, request) {
    const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
    let headers;
    if (typeof reqHeaders === "string")
      headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
    else
      headers = reqHeaders;
    if (upgrade) {
      errorRequest(client, request, new Error("Upgrade not supported for H2"));
      return false;
    }
    try {
      request.onConnect((err) => {
        if (request.aborted || request.completed) {
          return;
        }
        errorRequest(client, request, err || new RequestAbortedError);
      });
    } catch (err) {
      errorRequest(client, request, err);
    }
    if (request.aborted) {
      return false;
    }
    let stream;
    const h2State = client[kHTTP2SessionState];
    headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
    headers[HTTP2_HEADER_METHOD] = method;
    if (method === "CONNECT") {
      session.ref();
      stream = session.request(headers, { endStream: false, signal });
      if (stream.id && !stream.pending) {
        request.onUpgrade(null, null, stream);
        ++h2State.openStreams;
      } else {
        stream.once("ready", () => {
          request.onUpgrade(null, null, stream);
          ++h2State.openStreams;
        });
      }
      stream.once("close", () => {
        h2State.openStreams -= 1;
        if (h2State.openStreams === 0)
          session.unref();
      });
      return true;
    }
    headers[HTTP2_HEADER_PATH] = path;
    headers[HTTP2_HEADER_SCHEME] = "https";
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function") {
      body.read(0);
    }
    let contentLength = util.bodyLength(body);
    if (contentLength == null) {
      contentLength = request.contentLength;
    }
    if (contentLength === 0 || !expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength]) {
        errorRequest(client, request, new RequestContentLengthMismatchError);
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    if (contentLength != null) {
      assert(body, "no body must not have content length");
      headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
    }
    session.ref();
    const shouldEndStream = method === "GET" || method === "HEAD";
    if (expectContinue) {
      headers[HTTP2_HEADER_EXPECT] = "100-continue";
      stream = session.request(headers, { endStream: shouldEndStream, signal });
      stream.once("continue", writeBodyH2);
    } else {
      stream = session.request(headers, {
        endStream: shouldEndStream,
        signal
      });
      writeBodyH2();
    }
    ++h2State.openStreams;
    stream.once("response", (headers2) => {
      const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
      if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), "") === false) {
        stream.pause();
      }
    });
    stream.once("end", () => {
      request.onComplete([]);
    });
    stream.on("data", (chunk) => {
      if (request.onData(chunk) === false) {
        stream.pause();
      }
    });
    stream.once("close", () => {
      h2State.openStreams -= 1;
      if (h2State.openStreams === 0) {
        session.unref();
      }
    });
    stream.once("error", function(err) {
      if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
        h2State.streams -= 1;
        util.destroy(stream, err);
      }
    });
    stream.once("frameError", (type, code) => {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      errorRequest(client, request, err);
      if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
        h2State.streams -= 1;
        util.destroy(stream, err);
      }
    });
    return true;
    function writeBodyH2() {
      if (!body) {
        request.onRequestSent();
      } else if (util.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        stream.cork();
        stream.write(body);
        stream.uncork();
        stream.end();
        request.onBodySent(body);
        request.onRequestSent();
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable({
            client,
            request,
            contentLength,
            h2stream: stream,
            expectsPayload,
            body: body.stream(),
            socket: client[kSocket],
            header: ""
          });
        } else {
          writeBlob({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            h2stream: stream,
            header: "",
            socket: client[kSocket]
          });
        }
      } else if (util.isStream(body)) {
        writeStream({
          body,
          client,
          request,
          contentLength,
          expectsPayload,
          socket: client[kSocket],
          h2stream: stream,
          header: ""
        });
      } else if (util.isIterable(body)) {
        writeIterable({
          body,
          client,
          request,
          contentLength,
          expectsPayload,
          header: "",
          h2stream: stream,
          socket: client[kSocket]
        });
      } else {
        assert(false);
      }
    }
  }
  function writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
    assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
    if (client[kHTTPConnVersion] === "h2") {
      let onPipeData = function(chunk) {
        request.onBodySent(chunk);
      };
      const pipe = pipeline(body, h2stream, (err) => {
        if (err) {
          util.destroy(body, err);
          util.destroy(h2stream, err);
        } else {
          request.onRequestSent();
        }
      });
      pipe.on("data", onPipeData);
      pipe.once("end", () => {
        pipe.removeListener("data", onPipeData);
        util.destroy(pipe);
      });
      return;
    }
    let finished = false;
    const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
    const onData = function(chunk) {
      if (finished) {
        return;
      }
      try {
        if (!writer.write(chunk) && this.pause) {
          this.pause();
        }
      } catch (err) {
        util.destroy(this, err);
      }
    };
    const onDrain = function() {
      if (finished) {
        return;
      }
      if (body.resume) {
        body.resume();
      }
    };
    const onAbort = function() {
      if (finished) {
        return;
      }
      const err = new RequestAbortedError;
      queueMicrotask(() => onFinished(err));
    };
    const onFinished = function(err) {
      if (finished) {
        return;
      }
      finished = true;
      assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
      socket.off("drain", onDrain).off("error", onFinished);
      body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
      if (!err) {
        try {
          writer.end();
        } catch (er) {
          err = er;
        }
      }
      writer.destroy(err);
      if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
        util.destroy(body, err);
      } else {
        util.destroy(body);
      }
    };
    body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
    if (body.resume) {
      body.resume();
    }
    socket.on("drain", onDrain).on("error", onFinished);
  }
  async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
    assert(contentLength === body.size, "blob body must have content length");
    const isH2 = client[kHTTPConnVersion] === "h2";
    try {
      if (contentLength != null && contentLength !== body.size) {
        throw new RequestContentLengthMismatchError;
      }
      const buffer = Buffer.from(await body.arrayBuffer());
      if (isH2) {
        h2stream.cork();
        h2stream.write(buffer);
        h2stream.uncork();
      } else {
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(buffer);
        socket.uncork();
      }
      request.onBodySent(buffer);
      request.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      resume(client);
    } catch (err) {
      util.destroy(isH2 ? h2stream : socket, err);
    }
  }
  async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
    assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        const cb = callback;
        callback = null;
        cb();
      }
    }
    const waitForDrain = () => new Promise((resolve, reject) => {
      assert(callback === null);
      if (socket[kError]) {
        reject(socket[kError]);
      } else {
        callback = resolve;
      }
    });
    if (client[kHTTPConnVersion] === "h2") {
      h2stream.on("close", onDrain).on("drain", onDrain);
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          const res = h2stream.write(chunk);
          request.onBodySent(chunk);
          if (!res) {
            await waitForDrain();
          }
        }
      } catch (err) {
        h2stream.destroy(err);
      } finally {
        request.onRequestSent();
        h2stream.end();
        h2stream.off("close", onDrain).off("drain", onDrain);
      }
      return;
    }
    socket.on("close", onDrain).on("drain", onDrain);
    const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
    try {
      for await (const chunk of body) {
        if (socket[kError]) {
          throw socket[kError];
        }
        if (!writer.write(chunk)) {
          await waitForDrain();
        }
      }
      writer.end();
    } catch (err) {
      writer.destroy(err);
    } finally {
      socket.off("close", onDrain).off("drain", onDrain);
    }
  }

  class AsyncWriter {
    constructor({ socket, request, contentLength, client, expectsPayload, header }) {
      this.socket = socket;
      this.request = request;
      this.contentLength = contentLength;
      this.client = client;
      this.bytesWritten = 0;
      this.expectsPayload = expectsPayload;
      this.header = header;
      socket[kWriting] = true;
    }
    write(chunk) {
      const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return false;
      }
      const len = Buffer.byteLength(chunk);
      if (!len) {
        return true;
      }
      if (contentLength !== null && bytesWritten + len > contentLength) {
        if (client[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError;
        }
        process.emitWarning(new RequestContentLengthMismatchError);
      }
      socket.cork();
      if (bytesWritten === 0) {
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        if (contentLength === null) {
          socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
        } else {
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        }
      }
      if (contentLength === null) {
        socket.write(`\r
${len.toString(16)}\r
`, "latin1");
      }
      this.bytesWritten += len;
      const ret = socket.write(chunk);
      socket.uncork();
      request.onBodySent(chunk);
      if (!ret) {
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
      }
      return ret;
    }
    end() {
      const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
      request.onRequestSent();
      socket[kWriting] = false;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return;
      }
      if (bytesWritten === 0) {
        if (expectsPayload) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          socket.write(`${header}\r
`, "latin1");
        }
      } else if (contentLength === null) {
        socket.write(`\r
0\r
\r
`, "latin1");
      }
      if (contentLength !== null && bytesWritten !== contentLength) {
        if (client[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError;
        } else {
          process.emitWarning(new RequestContentLengthMismatchError);
        }
      }
      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
        if (socket[kParser].timeout.refresh) {
          socket[kParser].timeout.refresh();
        }
      }
      resume(client);
    }
    destroy(err) {
      const { socket, client } = this;
      socket[kWriting] = false;
      if (err) {
        assert(client[kRunning] <= 1, "pipeline should only contain this request");
        util.destroy(socket, err);
      }
    }
  }
  function errorRequest(client, request, err) {
    try {
      request.onError(err);
      assert(request.aborted);
    } catch (err2) {
      client.emit("error", err2);
    }
  }
  module.exports = Client;
});

// node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS((exports, module) => {
  var kSize = 2048;
  var kMask = kSize - 1;

  class FixedCircularBuffer {
    constructor() {
      this.bottom = 0;
      this.top = 0;
      this.list = new Array(kSize);
      this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
      this.list[this.top] = data;
      this.top = this.top + 1 & kMask;
    }
    shift() {
      const nextItem = this.list[this.bottom];
      if (nextItem === undefined)
        return null;
      this.list[this.bottom] = undefined;
      this.bottom = this.bottom + 1 & kMask;
      return nextItem;
    }
  }
  module.exports = class FixedQueue {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(data) {
      if (this.head.isFull()) {
        this.head = this.head.next = new FixedCircularBuffer;
      }
      this.head.push(data);
    }
    shift() {
      const tail = this.tail;
      const next = tail.shift();
      if (tail.isEmpty() && tail.next !== null) {
        this.tail = tail.next;
      }
      return next;
    }
  };
});

// node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS((exports, module) => {
  var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
  var kPool = Symbol("pool");

  class PoolStats {
    constructor(pool) {
      this[kPool] = pool;
    }
    get connected() {
      return this[kPool][kConnected];
    }
    get free() {
      return this[kPool][kFree];
    }
    get pending() {
      return this[kPool][kPending];
    }
    get queued() {
      return this[kPool][kQueued];
    }
    get running() {
      return this[kPool][kRunning];
    }
    get size() {
      return this[kPool][kSize];
    }
  }
  module.exports = PoolStats;
});

// node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS((exports, module) => {
  var DispatcherBase = require_dispatcher_base();
  var FixedQueue = require_fixed_queue();
  var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
  var PoolStats = require_pool_stats();
  var kClients = Symbol("clients");
  var kNeedDrain = Symbol("needDrain");
  var kQueue = Symbol("queue");
  var kClosedResolve = Symbol("closed resolve");
  var kOnDrain = Symbol("onDrain");
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kOnConnectionError = Symbol("onConnectionError");
  var kGetDispatcher = Symbol("get dispatcher");
  var kAddClient = Symbol("add client");
  var kRemoveClient = Symbol("remove client");
  var kStats = Symbol("stats");

  class PoolBase extends DispatcherBase {
    constructor() {
      super();
      this[kQueue] = new FixedQueue;
      this[kClients] = [];
      this[kQueued] = 0;
      const pool = this;
      this[kOnDrain] = function onDrain(origin, targets) {
        const queue = pool[kQueue];
        let needDrain = false;
        while (!needDrain) {
          const item = queue.shift();
          if (!item) {
            break;
          }
          pool[kQueued]--;
          needDrain = !this.dispatch(item.opts, item.handler);
        }
        this[kNeedDrain] = needDrain;
        if (!this[kNeedDrain] && pool[kNeedDrain]) {
          pool[kNeedDrain] = false;
          pool.emit("drain", origin, [pool, ...targets]);
        }
        if (pool[kClosedResolve] && queue.isEmpty()) {
          Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
        }
      };
      this[kOnConnect] = (origin, targets) => {
        pool.emit("connect", origin, [pool, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        pool.emit("disconnect", origin, [pool, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        pool.emit("connectionError", origin, [pool, ...targets], err);
      };
      this[kStats] = new PoolStats(this);
    }
    get [kBusy]() {
      return this[kNeedDrain];
    }
    get [kConnected]() {
      return this[kClients].filter((client) => client[kConnected]).length;
    }
    get [kFree]() {
      return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
    }
    get [kPending]() {
      let ret = this[kQueued];
      for (const { [kPending]: pending } of this[kClients]) {
        ret += pending;
      }
      return ret;
    }
    get [kRunning]() {
      let ret = 0;
      for (const { [kRunning]: running } of this[kClients]) {
        ret += running;
      }
      return ret;
    }
    get [kSize]() {
      let ret = this[kQueued];
      for (const { [kSize]: size } of this[kClients]) {
        ret += size;
      }
      return ret;
    }
    get stats() {
      return this[kStats];
    }
    async[kClose]() {
      if (this[kQueue].isEmpty()) {
        return Promise.all(this[kClients].map((c) => c.close()));
      } else {
        return new Promise((resolve) => {
          this[kClosedResolve] = resolve;
        });
      }
    }
    async[kDestroy](err) {
      while (true) {
        const item = this[kQueue].shift();
        if (!item) {
          break;
        }
        item.handler.onError(err);
      }
      return Promise.all(this[kClients].map((c) => c.destroy(err)));
    }
    [kDispatch](opts, handler) {
      const dispatcher = this[kGetDispatcher]();
      if (!dispatcher) {
        this[kNeedDrain] = true;
        this[kQueue].push({ opts, handler });
        this[kQueued]++;
      } else if (!dispatcher.dispatch(opts, handler)) {
        dispatcher[kNeedDrain] = true;
        this[kNeedDrain] = !this[kGetDispatcher]();
      }
      return !this[kNeedDrain];
    }
    [kAddClient](client) {
      client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
      this[kClients].push(client);
      if (this[kNeedDrain]) {
        process.nextTick(() => {
          if (this[kNeedDrain]) {
            this[kOnDrain](client[kUrl], [this, client]);
          }
        });
      }
      return this;
    }
    [kRemoveClient](client) {
      client.close(() => {
        const idx = this[kClients].indexOf(client);
        if (idx !== -1) {
          this[kClients].splice(idx, 1);
        }
      });
      this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
    }
  }
  module.exports = {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  };
});

// node_modules/undici/lib/pool.js
var require_pool = __commonJS((exports, module) => {
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kGetDispatcher
  } = require_pool_base();
  var Client = require_client();
  var {
    InvalidArgumentError
  } = require_errors();
  var util = require_util();
  var { kUrl, kInterceptors } = require_symbols();
  var buildConnector = require_connect();
  var kOptions = Symbol("options");
  var kConnections = Symbol("connections");
  var kFactory = Symbol("factory");
  function defaultFactory(origin, opts) {
    return new Client(origin, opts);
  }

  class Pool extends PoolBase {
    constructor(origin, {
      connections,
      factory = defaultFactory,
      connect,
      connectTimeout,
      tls,
      maxCachedSessions,
      socketPath,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      ...options
    } = {}) {
      super();
      if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
        throw new InvalidArgumentError("invalid connections");
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (typeof connect !== "function") {
        connect = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined,
          ...connect
        });
      }
      this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
      this[kConnections] = connections || null;
      this[kUrl] = util.parseOrigin(origin);
      this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
      this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : undefined;
      this[kFactory] = factory;
      this.on("connectionError", (origin2, targets, error) => {
        for (const target of targets) {
          const idx = this[kClients].indexOf(target);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        }
      });
    }
    [kGetDispatcher]() {
      let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
      if (dispatcher) {
        return dispatcher;
      }
      if (!this[kConnections] || this[kClients].length < this[kConnections]) {
        dispatcher = this[kFactory](this[kUrl], this[kOptions]);
        this[kAddClient](dispatcher);
      }
      return dispatcher;
    }
  }
  module.exports = Pool;
});

// node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS((exports, module) => {
  var {
    BalancedPoolMissingUpstreamError,
    InvalidArgumentError
  } = require_errors();
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  } = require_pool_base();
  var Pool = require_pool();
  var { kUrl, kInterceptors } = require_symbols();
  var { parseOrigin } = require_util();
  var kFactory = Symbol("factory");
  var kOptions = Symbol("options");
  var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
  var kCurrentWeight = Symbol("kCurrentWeight");
  var kIndex = Symbol("kIndex");
  var kWeight = Symbol("kWeight");
  var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
  var kErrorPenalty = Symbol("kErrorPenalty");
  function getGreatestCommonDivisor(a, b) {
    if (b === 0)
      return a;
    return getGreatestCommonDivisor(b, a % b);
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }

  class BalancedPool extends PoolBase {
    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
      super();
      this[kOptions] = opts;
      this[kIndex] = -1;
      this[kCurrentWeight] = 0;
      this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
      this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
      if (!Array.isArray(upstreams)) {
        upstreams = [upstreams];
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
      this[kFactory] = factory;
      for (const upstream of upstreams) {
        this.addUpstream(upstream);
      }
      this._updateBalancedPoolStats();
    }
    addUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
        return this;
      }
      const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
      this[kAddClient](pool);
      pool.on("connect", () => {
        pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
      });
      pool.on("connectionError", () => {
        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
        this._updateBalancedPoolStats();
      });
      pool.on("disconnect", (...args) => {
        const err = args[2];
        if (err && err.code === "UND_ERR_SOCKET") {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        }
      });
      for (const client of this[kClients]) {
        client[kWeight] = this[kMaxWeightPerServer];
      }
      this._updateBalancedPoolStats();
      return this;
    }
    _updateBalancedPoolStats() {
      this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
    }
    removeUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
      if (pool) {
        this[kRemoveClient](pool);
      }
      return this;
    }
    get upstreams() {
      return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
    }
    [kGetDispatcher]() {
      if (this[kClients].length === 0) {
        throw new BalancedPoolMissingUpstreamError;
      }
      const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
      if (!dispatcher) {
        return;
      }
      const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
      if (allClientsBusy) {
        return;
      }
      let counter = 0;
      let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
      while (counter++ < this[kClients].length) {
        this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
        const pool = this[kClients][this[kIndex]];
        if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
          maxWeightIndex = this[kIndex];
        }
        if (this[kIndex] === 0) {
          this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
          if (this[kCurrentWeight] <= 0) {
            this[kCurrentWeight] = this[kMaxWeightPerServer];
          }
        }
        if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
          return pool;
        }
      }
      this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
      this[kIndex] = maxWeightIndex;
      return this[kClients][maxWeightIndex];
    }
  }
  module.exports = BalancedPool;
});

// node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS((exports, module) => {
  var { kConnected, kSize } = require_symbols();

  class CompatWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value[kConnected] === 0 && this.value[kSize] === 0 ? undefined : this.value;
    }
  }

  class CompatFinalizer {
    constructor(finalizer) {
      this.finalizer = finalizer;
    }
    register(dispatcher, key) {
      if (dispatcher.on) {
        dispatcher.on("disconnect", () => {
          if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
            this.finalizer(key);
          }
        });
      }
    }
  }
  module.exports = function() {
    if (process.env.NODE_V8_COVERAGE) {
      return {
        WeakRef: CompatWeakRef,
        FinalizationRegistry: CompatFinalizer
      };
    }
    return {
      WeakRef: global.WeakRef || CompatWeakRef,
      FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
    };
  };
});

// node_modules/undici/lib/agent.js
var require_agent = __commonJS((exports, module) => {
  var { InvalidArgumentError } = require_errors();
  var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
  var DispatcherBase = require_dispatcher_base();
  var Pool = require_pool();
  var Client = require_client();
  var util = require_util();
  var createRedirectInterceptor = require_redirectInterceptor();
  var { WeakRef: WeakRef2, FinalizationRegistry: FinalizationRegistry2 } = require_dispatcher_weakref()();
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kOnConnectionError = Symbol("onConnectionError");
  var kMaxRedirections = Symbol("maxRedirections");
  var kOnDrain = Symbol("onDrain");
  var kFactory = Symbol("factory");
  var kFinalizer = Symbol("finalizer");
  var kOptions = Symbol("options");
  function defaultFactory(origin, opts) {
    return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
  }

  class Agent extends DispatcherBase {
    constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
      super();
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      if (connect && typeof connect !== "function") {
        connect = { ...connect };
      }
      this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
      this[kOptions] = { ...util.deepClone(options), connect };
      this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : undefined;
      this[kMaxRedirections] = maxRedirections;
      this[kFactory] = factory;
      this[kClients] = new Map;
      this[kFinalizer] = new FinalizationRegistry2((key) => {
        const ref = this[kClients].get(key);
        if (ref !== undefined && ref.deref() === undefined) {
          this[kClients].delete(key);
        }
      });
      const agent = this;
      this[kOnDrain] = (origin, targets) => {
        agent.emit("drain", origin, [agent, ...targets]);
      };
      this[kOnConnect] = (origin, targets) => {
        agent.emit("connect", origin, [agent, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        agent.emit("disconnect", origin, [agent, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        agent.emit("connectionError", origin, [agent, ...targets], err);
      };
    }
    get [kRunning]() {
      let ret = 0;
      for (const ref of this[kClients].values()) {
        const client = ref.deref();
        if (client) {
          ret += client[kRunning];
        }
      }
      return ret;
    }
    [kDispatch](opts, handler) {
      let key;
      if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
        key = String(opts.origin);
      } else {
        throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
      }
      const ref = this[kClients].get(key);
      let dispatcher = ref ? ref.deref() : null;
      if (!dispatcher) {
        dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].set(key, new WeakRef2(dispatcher));
        this[kFinalizer].register(dispatcher, key);
      }
      return dispatcher.dispatch(opts, handler);
    }
    async[kClose]() {
      const closePromises = [];
      for (const ref of this[kClients].values()) {
        const client = ref.deref();
        if (client) {
          closePromises.push(client.close());
        }
      }
      await Promise.all(closePromises);
    }
    async[kDestroy](err) {
      const destroyPromises = [];
      for (const ref of this[kClients].values()) {
        const client = ref.deref();
        if (client) {
          destroyPromises.push(client.destroy(err));
        }
      }
      await Promise.all(destroyPromises);
    }
  }
  module.exports = Agent;
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS((exports, module) => {
  var assert = __require("assert");
  var { Readable } = __require("stream");
  var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors();
  var util = require_util();
  var { ReadableStreamFrom, toUSVString } = require_util();
  var Blob2;
  var kConsume = Symbol("kConsume");
  var kReading = Symbol("kReading");
  var kBody = Symbol("kBody");
  var kAbort = Symbol("abort");
  var kContentType = Symbol("kContentType");
  var noop = () => {
  };
  module.exports = class BodyReadable extends Readable {
    constructor({
      resume,
      abort,
      contentType = "",
      highWaterMark = 64 * 1024
    }) {
      super({
        autoDestroy: true,
        read: resume,
        highWaterMark
      });
      this._readableState.dataEmitted = false;
      this[kAbort] = abort;
      this[kConsume] = null;
      this[kBody] = null;
      this[kContentType] = contentType;
      this[kReading] = false;
    }
    destroy(err) {
      if (this.destroyed) {
        return this;
      }
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError;
      }
      if (err) {
        this[kAbort]();
      }
      return super.destroy(err);
    }
    emit(ev, ...args) {
      if (ev === "data") {
        this._readableState.dataEmitted = true;
      } else if (ev === "error") {
        this._readableState.errorEmitted = true;
      }
      return super.emit(ev, ...args);
    }
    on(ev, ...args) {
      if (ev === "data" || ev === "readable") {
        this[kReading] = true;
      }
      return super.on(ev, ...args);
    }
    addListener(ev, ...args) {
      return this.on(ev, ...args);
    }
    off(ev, ...args) {
      const ret = super.off(ev, ...args);
      if (ev === "data" || ev === "readable") {
        this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
      }
      return ret;
    }
    removeListener(ev, ...args) {
      return this.off(ev, ...args);
    }
    push(chunk) {
      if (this[kConsume] && chunk !== null && this.readableLength === 0) {
        consumePush(this[kConsume], chunk);
        return this[kReading] ? super.push(chunk) : true;
      }
      return super.push(chunk);
    }
    async text() {
      return consume(this, "text");
    }
    async json() {
      return consume(this, "json");
    }
    async blob() {
      return consume(this, "blob");
    }
    async arrayBuffer() {
      return consume(this, "arrayBuffer");
    }
    async formData() {
      throw new NotSupportedError;
    }
    get bodyUsed() {
      return util.isDisturbed(this);
    }
    get body() {
      if (!this[kBody]) {
        this[kBody] = ReadableStreamFrom(this);
        if (this[kConsume]) {
          this[kBody].getReader();
          assert(this[kBody].locked);
        }
      }
      return this[kBody];
    }
    dump(opts) {
      let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
      const signal = opts && opts.signal;
      if (signal) {
        try {
          if (typeof signal !== "object" || !("aborted" in signal)) {
            throw new InvalidArgumentError("signal must be an AbortSignal");
          }
          util.throwIfAborted(signal);
        } catch (err) {
          return Promise.reject(err);
        }
      }
      if (this.closed) {
        return Promise.resolve(null);
      }
      return new Promise((resolve, reject) => {
        const signalListenerCleanup = signal ? util.addAbortListener(signal, () => {
          this.destroy();
        }) : noop;
        this.on("close", function() {
          signalListenerCleanup();
          if (signal && signal.aborted) {
            reject(signal.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" }));
          } else {
            resolve(null);
          }
        }).on("error", noop).on("data", function(chunk) {
          limit -= chunk.length;
          if (limit <= 0) {
            this.destroy();
          }
        }).resume();
      });
    }
  };
  function isLocked(self2) {
    return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
  }
  function isUnusable(self2) {
    return util.isDisturbed(self2) || isLocked(self2);
  }
  async function consume(stream, type) {
    if (isUnusable(stream)) {
      throw new TypeError("unusable");
    }
    assert(!stream[kConsume]);
    return new Promise((resolve, reject) => {
      stream[kConsume] = {
        type,
        stream,
        resolve,
        reject,
        length: 0,
        body: []
      };
      stream.on("error", function(err) {
        consumeFinish(this[kConsume], err);
      }).on("close", function() {
        if (this[kConsume].body !== null) {
          consumeFinish(this[kConsume], new RequestAbortedError);
        }
      });
      process.nextTick(consumeStart, stream[kConsume]);
    });
  }
  function consumeStart(consume2) {
    if (consume2.body === null) {
      return;
    }
    const { _readableState: state } = consume2.stream;
    for (const chunk of state.buffer) {
      consumePush(consume2, chunk);
    }
    if (state.endEmitted) {
      consumeEnd(this[kConsume]);
    } else {
      consume2.stream.on("end", function() {
        consumeEnd(this[kConsume]);
      });
    }
    consume2.stream.resume();
    while (consume2.stream.read() != null) {
    }
  }
  function consumeEnd(consume2) {
    const { type, body, resolve, stream, length } = consume2;
    try {
      if (type === "text") {
        resolve(toUSVString(Buffer.concat(body)));
      } else if (type === "json") {
        resolve(JSON.parse(Buffer.concat(body)));
      } else if (type === "arrayBuffer") {
        const dst = new Uint8Array(length);
        let pos = 0;
        for (const buf of body) {
          dst.set(buf, pos);
          pos += buf.byteLength;
        }
        resolve(dst.buffer);
      } else if (type === "blob") {
        if (!Blob2) {
          Blob2 = __require("buffer").Blob;
        }
        resolve(new Blob2(body, { type: stream[kContentType] }));
      }
      consumeFinish(consume2);
    } catch (err) {
      stream.destroy(err);
    }
  }
  function consumePush(consume2, chunk) {
    consume2.length += chunk.length;
    consume2.body.push(chunk);
  }
  function consumeFinish(consume2, err) {
    if (consume2.body === null) {
      return;
    }
    if (err) {
      consume2.reject(err);
    } else {
      consume2.resolve();
    }
    consume2.type = null;
    consume2.stream = null;
    consume2.resolve = null;
    consume2.reject = null;
    consume2.length = 0;
    consume2.body = null;
  }
});

// node_modules/undici/lib/api/util.js
var require_util3 = __commonJS((exports, module) => {
  var assert = __require("assert");
  var {
    ResponseStatusCodeError
  } = require_errors();
  var { toUSVString } = require_util();
  async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
    assert(body);
    let chunks = [];
    let limit = 0;
    for await (const chunk of body) {
      chunks.push(chunk);
      limit += chunk.length;
      if (limit > 128 * 1024) {
        chunks = null;
        break;
      }
    }
    if (statusCode === 204 || !contentType || !chunks) {
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
      return;
    }
    try {
      if (contentType.startsWith("application/json")) {
        const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
        return;
      }
      if (contentType.startsWith("text/")) {
        const payload = toUSVString(Buffer.concat(chunks));
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
        return;
      }
    } catch (err) {
    }
    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
  }
  module.exports = { getResolveErrorBodyCallback };
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS((exports, module) => {
  var { addAbortListener } = require_util();
  var { RequestAbortedError } = require_errors();
  var kListener = Symbol("kListener");
  var kSignal = Symbol("kSignal");
  function abort(self2) {
    if (self2.abort) {
      self2.abort();
    } else {
      self2.onError(new RequestAbortedError);
    }
  }
  function addSignal(self2, signal) {
    self2[kSignal] = null;
    self2[kListener] = null;
    if (!signal) {
      return;
    }
    if (signal.aborted) {
      abort(self2);
      return;
    }
    self2[kSignal] = signal;
    self2[kListener] = () => {
      abort(self2);
    };
    addAbortListener(self2[kSignal], self2[kListener]);
  }
  function removeSignal(self2) {
    if (!self2[kSignal]) {
      return;
    }
    if ("removeEventListener" in self2[kSignal]) {
      self2[kSignal].removeEventListener("abort", self2[kListener]);
    } else {
      self2[kSignal].removeListener("abort", self2[kListener]);
    }
    self2[kSignal] = null;
    self2[kListener] = null;
  }
  module.exports = {
    addSignal,
    removeSignal
  };
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS((exports, module) => {
  var Readable = require_readable();
  var {
    InvalidArgumentError,
    RequestAbortedError
  } = require_errors();
  var util = require_util();
  var { getResolveErrorBodyCallback } = require_util3();
  var { AsyncResource } = __require("async_hooks");
  var { addSignal, removeSignal } = require_abort_signal();

  class RequestHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
          throw new InvalidArgumentError("invalid highWaterMark");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_REQUEST");
      } catch (err) {
        if (util.isStream(body)) {
          util.destroy(body.on("error", util.nop), err);
        }
        throw err;
      }
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.body = body;
      this.trailers = {};
      this.context = null;
      this.onInfo = onInfo || null;
      this.throwOnError = throwOnError;
      this.highWaterMark = highWaterMark;
      if (util.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback) {
        throw new RequestAbortedError;
      }
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
      const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
      const contentType = parsedHeaders["content-type"];
      const body = new Readable({ resume, abort, contentType, highWaterMark });
      this.callback = null;
      this.res = body;
      if (callback !== null) {
        if (this.throwOnError && statusCode >= 400) {
          this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body, contentType, statusCode, statusMessage, headers });
        } else {
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers,
            trailers: this.trailers,
            opaque,
            body,
            context
          });
        }
      }
    }
    onData(chunk) {
      const { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const { res } = this;
      removeSignal(this);
      util.parseHeaders(trailers, this.trailers);
      res.push(null);
    }
    onError(err) {
      const { res, callback, body, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (res) {
        this.res = null;
        queueMicrotask(() => {
          util.destroy(res, err);
        });
      }
      if (body) {
        this.body = null;
        util.destroy(body, err);
      }
    }
  }
  function request(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        request.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new RequestHandler(opts, callback));
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = request;
  module.exports.RequestHandler = RequestHandler;
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS((exports, module) => {
  var { finished, PassThrough } = __require("stream");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors();
  var util = require_util();
  var { getResolveErrorBodyCallback } = require_util3();
  var { AsyncResource } = __require("async_hooks");
  var { addSignal, removeSignal } = require_abort_signal();

  class StreamHandler extends AsyncResource {
    constructor(opts, factory, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("invalid factory");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_STREAM");
      } catch (err) {
        if (util.isStream(body)) {
          util.destroy(body.on("error", util.nop), err);
        }
        throw err;
      }
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.factory = factory;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.context = null;
      this.trailers = null;
      this.body = body;
      this.onInfo = onInfo || null;
      this.throwOnError = throwOnError || false;
      if (util.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback) {
        throw new RequestAbortedError;
      }
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { factory, opaque, context, callback, responseHeaders } = this;
      const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      this.factory = null;
      let res;
      if (this.throwOnError && statusCode >= 400) {
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        res = new PassThrough;
        this.callback = null;
        this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body: res, contentType, statusCode, statusMessage, headers });
      } else {
        if (factory === null) {
          return;
        }
        res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers,
          opaque,
          context
        });
        if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
          throw new InvalidReturnValueError("expected Writable");
        }
        finished(res, { readable: false }, (err) => {
          const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
          this.res = null;
          if (err || !res2.readable) {
            util.destroy(res2, err);
          }
          this.callback = null;
          this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
          if (err) {
            abort();
          }
        });
      }
      res.on("drain", resume);
      this.res = res;
      const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
      return needDrain !== true;
    }
    onData(chunk) {
      const { res } = this;
      return res ? res.write(chunk) : true;
    }
    onComplete(trailers) {
      const { res } = this;
      removeSignal(this);
      if (!res) {
        return;
      }
      this.trailers = util.parseHeaders(trailers);
      res.end();
    }
    onError(err) {
      const { res, callback, opaque, body } = this;
      removeSignal(this);
      this.factory = null;
      if (res) {
        this.res = null;
        util.destroy(res, err);
      } else if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (body) {
        this.body = null;
        util.destroy(body, err);
      }
    }
  }
  function stream(opts, factory, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        stream.call(this, opts, factory, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new StreamHandler(opts, factory, callback));
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = stream;
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS((exports, module) => {
  var {
    Readable,
    Duplex,
    PassThrough
  } = __require("stream");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors();
  var util = require_util();
  var { AsyncResource } = __require("async_hooks");
  var { addSignal, removeSignal } = require_abort_signal();
  var assert = __require("assert");
  var kResume = Symbol("resume");

  class PipelineRequest extends Readable {
    constructor() {
      super({ autoDestroy: true });
      this[kResume] = null;
    }
    _read() {
      const { [kResume]: resume } = this;
      if (resume) {
        this[kResume] = null;
        resume();
      }
    }
    _destroy(err, callback) {
      this._read();
      callback(err);
    }
  }

  class PipelineResponse extends Readable {
    constructor(resume) {
      super({ autoDestroy: true });
      this[kResume] = resume;
    }
    _read() {
      this[kResume]();
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError;
      }
      callback(err);
    }
  }

  class PipelineHandler extends AsyncResource {
    constructor(opts, handler) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof handler !== "function") {
        throw new InvalidArgumentError("invalid handler");
      }
      const { signal, method, opaque, onInfo, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError("invalid method");
      }
      if (onInfo && typeof onInfo !== "function") {
        throw new InvalidArgumentError("invalid onInfo callback");
      }
      super("UNDICI_PIPELINE");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.handler = handler;
      this.abort = null;
      this.context = null;
      this.onInfo = onInfo || null;
      this.req = new PipelineRequest().on("error", util.nop);
      this.ret = new Duplex({
        readableObjectMode: opts.objectMode,
        autoDestroy: true,
        read: () => {
          const { body } = this;
          if (body && body.resume) {
            body.resume();
          }
        },
        write: (chunk, encoding, callback) => {
          const { req } = this;
          if (req.push(chunk, encoding) || req._readableState.destroyed) {
            callback();
          } else {
            req[kResume] = callback;
          }
        },
        destroy: (err, callback) => {
          const { body, req, res, ret, abort } = this;
          if (!err && !ret._readableState.endEmitted) {
            err = new RequestAbortedError;
          }
          if (abort && err) {
            abort();
          }
          util.destroy(body, err);
          util.destroy(req, err);
          util.destroy(res, err);
          removeSignal(this);
          callback(err);
        }
      }).on("prefinish", () => {
        const { req } = this;
        req.push(null);
      });
      this.res = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      const { ret, res } = this;
      assert(!res, "pipeline cannot be retried");
      if (ret.destroyed) {
        throw new RequestAbortedError;
      }
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume) {
      const { opaque, handler, context } = this;
      if (statusCode < 200) {
        if (this.onInfo) {
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      this.res = new PipelineResponse(resume);
      let body;
      try {
        this.handler = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        body = this.runInAsyncScope(handler, null, {
          statusCode,
          headers,
          opaque,
          body: this.res,
          context
        });
      } catch (err) {
        this.res.on("error", util.nop);
        throw err;
      }
      if (!body || typeof body.on !== "function") {
        throw new InvalidReturnValueError("expected Readable");
      }
      body.on("data", (chunk) => {
        const { ret, body: body2 } = this;
        if (!ret.push(chunk) && body2.pause) {
          body2.pause();
        }
      }).on("error", (err) => {
        const { ret } = this;
        util.destroy(ret, err);
      }).on("end", () => {
        const { ret } = this;
        ret.push(null);
      }).on("close", () => {
        const { ret } = this;
        if (!ret._readableState.ended) {
          util.destroy(ret, new RequestAbortedError);
        }
      });
      this.body = body;
    }
    onData(chunk) {
      const { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const { res } = this;
      res.push(null);
    }
    onError(err) {
      const { ret } = this;
      this.handler = null;
      util.destroy(ret, err);
    }
  }
  function pipeline(opts, handler) {
    try {
      const pipelineHandler = new PipelineHandler(opts, handler);
      this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
      return pipelineHandler.ret;
    } catch (err) {
      return new PassThrough().destroy(err);
    }
  }
  module.exports = pipeline;
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS((exports, module) => {
  var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
  var { AsyncResource } = __require("async_hooks");
  var util = require_util();
  var { addSignal, removeSignal } = require_abort_signal();
  var assert = __require("assert");

  class UpgradeHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_UPGRADE");
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.abort = null;
      this.context = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback) {
        throw new RequestAbortedError;
      }
      this.abort = abort;
      this.context = null;
    }
    onHeaders() {
      throw new SocketError("bad upgrade", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      const { callback, opaque, context } = this;
      assert.strictEqual(statusCode, 101);
      removeSignal(this);
      this.callback = null;
      const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      this.runInAsyncScope(callback, null, null, {
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  function upgrade(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        upgrade.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      const upgradeHandler = new UpgradeHandler(opts, callback);
      this.dispatch({
        ...opts,
        method: opts.method || "GET",
        upgrade: opts.protocol || "Websocket"
      }, upgradeHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = upgrade;
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS((exports, module) => {
  var { AsyncResource } = __require("async_hooks");
  var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
  var util = require_util();
  var { addSignal, removeSignal } = require_abort_signal();

  class ConnectHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_CONNECT");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.callback = callback;
      this.abort = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback) {
        throw new RequestAbortedError;
      }
      this.abort = abort;
      this.context = context;
    }
    onHeaders() {
      throw new SocketError("bad connect", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      const { callback, opaque, context } = this;
      removeSignal(this);
      this.callback = null;
      let headers = rawHeaders;
      if (headers != null) {
        headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      }
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  function connect(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        connect.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      const connectHandler = new ConnectHandler(opts, callback);
      this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = connect;
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS((exports, module) => {
  exports.request = require_api_request();
  exports.stream = require_api_stream();
  exports.pipeline = require_api_pipeline();
  exports.upgrade = require_api_upgrade();
  exports.connect = require_api_connect();
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS((exports, module) => {
  var { UndiciError } = require_errors();

  class MockNotMatchedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, MockNotMatchedError);
      this.name = "MockNotMatchedError";
      this.message = message || "The request does not match any registered mock dispatches";
      this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
    }
  }
  module.exports = {
    MockNotMatchedError
  };
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS((exports, module) => {
  module.exports = {
    kAgent: Symbol("agent"),
    kOptions: Symbol("options"),
    kFactory: Symbol("factory"),
    kDispatches: Symbol("dispatches"),
    kDispatchKey: Symbol("dispatch key"),
    kDefaultHeaders: Symbol("default headers"),
    kDefaultTrailers: Symbol("default trailers"),
    kContentLength: Symbol("content length"),
    kMockAgent: Symbol("mock agent"),
    kMockAgentSet: Symbol("mock agent set"),
    kMockAgentGet: Symbol("mock agent get"),
    kMockDispatch: Symbol("mock dispatch"),
    kClose: Symbol("close"),
    kOriginalClose: Symbol("original agent close"),
    kOrigin: Symbol("origin"),
    kIsMockActive: Symbol("is mock active"),
    kNetConnect: Symbol("net connect"),
    kGetNetConnect: Symbol("get net connect"),
    kConnected: Symbol("connected")
  };
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS((exports, module) => {
  var { MockNotMatchedError } = require_mock_errors();
  var {
    kDispatches,
    kMockAgent,
    kOriginalDispatch,
    kOrigin,
    kGetNetConnect
  } = require_mock_symbols();
  var { buildURL, nop } = require_util();
  var { STATUS_CODES } = __require("http");
  var {
    types: {
      isPromise
    }
  } = __require("util");
  function matchValue(match, value) {
    if (typeof match === "string") {
      return match === value;
    }
    if (match instanceof RegExp) {
      return match.test(value);
    }
    if (typeof match === "function") {
      return match(value) === true;
    }
    return false;
  }
  function lowerCaseEntries(headers) {
    return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {
      return [headerName.toLocaleLowerCase(), headerValue];
    }));
  }
  function getHeaderByName(headers, key) {
    if (Array.isArray(headers)) {
      for (let i = 0;i < headers.length; i += 2) {
        if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
          return headers[i + 1];
        }
      }
      return;
    } else if (typeof headers.get === "function") {
      return headers.get(key);
    } else {
      return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
    }
  }
  function buildHeadersFromArray(headers) {
    const clone = headers.slice();
    const entries = [];
    for (let index = 0;index < clone.length; index += 2) {
      entries.push([clone[index], clone[index + 1]]);
    }
    return Object.fromEntries(entries);
  }
  function matchHeaders(mockDispatch2, headers) {
    if (typeof mockDispatch2.headers === "function") {
      if (Array.isArray(headers)) {
        headers = buildHeadersFromArray(headers);
      }
      return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
    }
    if (typeof mockDispatch2.headers === "undefined") {
      return true;
    }
    if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
      return false;
    }
    for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
      const headerValue = getHeaderByName(headers, matchHeaderName);
      if (!matchValue(matchHeaderValue, headerValue)) {
        return false;
      }
    }
    return true;
  }
  function safeUrl(path) {
    if (typeof path !== "string") {
      return path;
    }
    const pathSegments = path.split("?");
    if (pathSegments.length !== 2) {
      return path;
    }
    const qp = new URLSearchParams(pathSegments.pop());
    qp.sort();
    return [...pathSegments, qp.toString()].join("?");
  }
  function matchKey(mockDispatch2, { path, method, body, headers }) {
    const pathMatch = matchValue(mockDispatch2.path, path);
    const methodMatch = matchValue(mockDispatch2.method, method);
    const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
    const headersMatch = matchHeaders(mockDispatch2, headers);
    return pathMatch && methodMatch && bodyMatch && headersMatch;
  }
  function getResponseData(data) {
    if (Buffer.isBuffer(data)) {
      return data;
    } else if (typeof data === "object") {
      return JSON.stringify(data);
    } else {
      return data.toString();
    }
  }
  function getMockDispatch(mockDispatches, key) {
    const basePath = key.query ? buildURL(key.path, key.query) : key.path;
    const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
    let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
    }
    return matchedMockDispatches[0];
  }
  function addMockDispatch(mockDispatches, key, data) {
    const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
    const replyData = typeof data === "function" ? { callback: data } : { ...data };
    const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
    mockDispatches.push(newMockDispatch);
    return newMockDispatch;
  }
  function deleteMockDispatch(mockDispatches, key) {
    const index = mockDispatches.findIndex((dispatch) => {
      if (!dispatch.consumed) {
        return false;
      }
      return matchKey(dispatch, key);
    });
    if (index !== -1) {
      mockDispatches.splice(index, 1);
    }
  }
  function buildKey(opts) {
    const { path, method, body, headers, query } = opts;
    return {
      path,
      method,
      body,
      headers,
      query
    };
  }
  function generateKeyValues(data) {
    return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
      ...keyValuePairs,
      Buffer.from(`${key}`),
      Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
    ], []);
  }
  function getStatusText(statusCode) {
    return STATUS_CODES[statusCode] || "unknown";
  }
  async function getResponse(body) {
    const buffers = [];
    for await (const data of body) {
      buffers.push(data);
    }
    return Buffer.concat(buffers).toString("utf8");
  }
  function mockDispatch(opts, handler) {
    const key = buildKey(opts);
    const mockDispatch2 = getMockDispatch(this[kDispatches], key);
    mockDispatch2.timesInvoked++;
    if (mockDispatch2.data.callback) {
      mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
    }
    const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2;
    const { timesInvoked, times } = mockDispatch2;
    mockDispatch2.consumed = !persist && timesInvoked >= times;
    mockDispatch2.pending = timesInvoked < times;
    if (error !== null) {
      deleteMockDispatch(this[kDispatches], key);
      handler.onError(error);
      return true;
    }
    if (typeof delay === "number" && delay > 0) {
      setTimeout(() => {
        handleReply(this[kDispatches]);
      }, delay);
    } else {
      handleReply(this[kDispatches]);
    }
    function handleReply(mockDispatches, _data = data) {
      const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
      const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
      if (isPromise(body)) {
        body.then((newData) => handleReply(mockDispatches, newData));
        return;
      }
      const responseData = getResponseData(body);
      const responseHeaders = generateKeyValues(headers);
      const responseTrailers = generateKeyValues(trailers);
      handler.abort = nop;
      handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
      handler.onData(Buffer.from(responseData));
      handler.onComplete(responseTrailers);
      deleteMockDispatch(mockDispatches, key);
    }
    function resume() {
    }
    return true;
  }
  function buildMockDispatch() {
    const agent = this[kMockAgent];
    const origin = this[kOrigin];
    const originalDispatch = this[kOriginalDispatch];
    return function dispatch(opts, handler) {
      if (agent.isMockActive) {
        try {
          mockDispatch.call(this, opts, handler);
        } catch (error) {
          if (error instanceof MockNotMatchedError) {
            const netConnect = agent[kGetNetConnect]();
            if (netConnect === false) {
              throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
            }
            if (checkNetConnect(netConnect, origin)) {
              originalDispatch.call(this, opts, handler);
            } else {
              throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
            }
          } else {
            throw error;
          }
        }
      } else {
        originalDispatch.call(this, opts, handler);
      }
    };
  }
  function checkNetConnect(netConnect, origin) {
    const url = new URL(origin);
    if (netConnect === true) {
      return true;
    } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
      return true;
    }
    return false;
  }
  function buildMockOptions(opts) {
    if (opts) {
      const { agent, ...mockOptions } = opts;
      return mockOptions;
    }
  }
  module.exports = {
    getResponseData,
    getMockDispatch,
    addMockDispatch,
    deleteMockDispatch,
    buildKey,
    generateKeyValues,
    matchValue,
    getResponse,
    getStatusText,
    mockDispatch,
    buildMockDispatch,
    checkNetConnect,
    buildMockOptions,
    getHeaderByName
  };
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS((exports, module) => {
  var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kDispatchKey,
    kDefaultHeaders,
    kDefaultTrailers,
    kContentLength,
    kMockDispatch
  } = require_mock_symbols();
  var { InvalidArgumentError } = require_errors();
  var { buildURL } = require_util();

  class MockScope {
    constructor(mockDispatch) {
      this[kMockDispatch] = mockDispatch;
    }
    delay(waitInMs) {
      if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
        throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
      }
      this[kMockDispatch].delay = waitInMs;
      return this;
    }
    persist() {
      this[kMockDispatch].persist = true;
      return this;
    }
    times(repeatTimes) {
      if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
        throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
      }
      this[kMockDispatch].times = repeatTimes;
      return this;
    }
  }

  class MockInterceptor {
    constructor(opts, mockDispatches) {
      if (typeof opts !== "object") {
        throw new InvalidArgumentError("opts must be an object");
      }
      if (typeof opts.path === "undefined") {
        throw new InvalidArgumentError("opts.path must be defined");
      }
      if (typeof opts.method === "undefined") {
        opts.method = "GET";
      }
      if (typeof opts.path === "string") {
        if (opts.query) {
          opts.path = buildURL(opts.path, opts.query);
        } else {
          const parsedURL = new URL(opts.path, "data://");
          opts.path = parsedURL.pathname + parsedURL.search;
        }
      }
      if (typeof opts.method === "string") {
        opts.method = opts.method.toUpperCase();
      }
      this[kDispatchKey] = buildKey(opts);
      this[kDispatches] = mockDispatches;
      this[kDefaultHeaders] = {};
      this[kDefaultTrailers] = {};
      this[kContentLength] = false;
    }
    createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
      const responseData = getResponseData(data);
      const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
      const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
      const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
      return { statusCode, data, headers, trailers };
    }
    validateReplyParameters(statusCode, data, responseOptions) {
      if (typeof statusCode === "undefined") {
        throw new InvalidArgumentError("statusCode must be defined");
      }
      if (typeof data === "undefined") {
        throw new InvalidArgumentError("data must be defined");
      }
      if (typeof responseOptions !== "object") {
        throw new InvalidArgumentError("responseOptions must be an object");
      }
    }
    reply(replyData) {
      if (typeof replyData === "function") {
        const wrappedDefaultsCallback = (opts) => {
          const resolvedData = replyData(opts);
          if (typeof resolvedData !== "object") {
            throw new InvalidArgumentError("reply options callback must return an object");
          }
          const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
          this.validateReplyParameters(statusCode2, data2, responseOptions2);
          return {
            ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
          };
        };
        const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
        return new MockScope(newMockDispatch2);
      }
      const [statusCode, data = "", responseOptions = {}] = [...arguments];
      this.validateReplyParameters(statusCode, data, responseOptions);
      const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
      return new MockScope(newMockDispatch);
    }
    replyWithError(error) {
      if (typeof error === "undefined") {
        throw new InvalidArgumentError("error must be defined");
      }
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
      return new MockScope(newMockDispatch);
    }
    defaultReplyHeaders(headers) {
      if (typeof headers === "undefined") {
        throw new InvalidArgumentError("headers must be defined");
      }
      this[kDefaultHeaders] = headers;
      return this;
    }
    defaultReplyTrailers(trailers) {
      if (typeof trailers === "undefined") {
        throw new InvalidArgumentError("trailers must be defined");
      }
      this[kDefaultTrailers] = trailers;
      return this;
    }
    replyContentLength() {
      this[kContentLength] = true;
      return this;
    }
  }
  exports.MockInterceptor = MockInterceptor;
  exports.MockScope = MockScope;
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS((exports, module) => {
  var { promisify } = __require("util");
  var Client = require_client();
  var { buildMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = require_mock_symbols();
  var { MockInterceptor } = require_mock_interceptor();
  var Symbols = require_symbols();
  var { InvalidArgumentError } = require_errors();

  class MockClient extends Client {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockClient;
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS((exports, module) => {
  var { promisify } = __require("util");
  var Pool = require_pool();
  var { buildMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = require_mock_symbols();
  var { MockInterceptor } = require_mock_interceptor();
  var Symbols = require_symbols();
  var { InvalidArgumentError } = require_errors();

  class MockPool extends Pool {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockPool;
});

// node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS((exports, module) => {
  var singulars = {
    pronoun: "it",
    is: "is",
    was: "was",
    this: "this"
  };
  var plurals = {
    pronoun: "they",
    is: "are",
    was: "were",
    this: "these"
  };
  module.exports = class Pluralizer {
    constructor(singular, plural) {
      this.singular = singular;
      this.plural = plural;
    }
    pluralize(count) {
      const one = count === 1;
      const keys = one ? singulars : plurals;
      const noun = one ? this.singular : this.plural;
      return { ...keys, count, noun };
    }
  };
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS((exports, module) => {
  var { Transform } = __require("stream");
  var { Console } = __require("console");
  module.exports = class PendingInterceptorsFormatter {
    constructor({ disableColors } = {}) {
      this.transform = new Transform({
        transform(chunk, _enc, cb) {
          cb(null, chunk);
        }
      });
      this.logger = new Console({
        stdout: this.transform,
        inspectOptions: {
          colors: !disableColors && !process.env.CI
        }
      });
    }
    format(pendingInterceptors) {
      const withPrettyHeaders = pendingInterceptors.map(({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
        Method: method,
        Origin: origin,
        Path: path,
        "Status code": statusCode,
        Persistent: persist ? "" : "",
        Invocations: timesInvoked,
        Remaining: persist ? Infinity : times - timesInvoked
      }));
      this.logger.table(withPrettyHeaders);
      return this.transform.read().toString();
    }
  };
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS((exports, module) => {
  var { kClients } = require_symbols();
  var Agent = require_agent();
  var {
    kAgent,
    kMockAgentSet,
    kMockAgentGet,
    kDispatches,
    kIsMockActive,
    kNetConnect,
    kGetNetConnect,
    kOptions,
    kFactory
  } = require_mock_symbols();
  var MockClient = require_mock_client();
  var MockPool = require_mock_pool();
  var { matchValue, buildMockOptions } = require_mock_utils();
  var { InvalidArgumentError, UndiciError } = require_errors();
  var Dispatcher = require_dispatcher();
  var Pluralizer = require_pluralizer();
  var PendingInterceptorsFormatter = require_pending_interceptors_formatter();

  class FakeWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value;
    }
  }

  class MockAgent extends Dispatcher {
    constructor(opts) {
      super(opts);
      this[kNetConnect] = true;
      this[kIsMockActive] = true;
      if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      const agent = opts && opts.agent ? opts.agent : new Agent(opts);
      this[kAgent] = agent;
      this[kClients] = agent[kClients];
      this[kOptions] = buildMockOptions(opts);
    }
    get(origin) {
      let dispatcher = this[kMockAgentGet](origin);
      if (!dispatcher) {
        dispatcher = this[kFactory](origin);
        this[kMockAgentSet](origin, dispatcher);
      }
      return dispatcher;
    }
    dispatch(opts, handler) {
      this.get(opts.origin);
      return this[kAgent].dispatch(opts, handler);
    }
    async close() {
      await this[kAgent].close();
      this[kClients].clear();
    }
    deactivate() {
      this[kIsMockActive] = false;
    }
    activate() {
      this[kIsMockActive] = true;
    }
    enableNetConnect(matcher) {
      if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
        if (Array.isArray(this[kNetConnect])) {
          this[kNetConnect].push(matcher);
        } else {
          this[kNetConnect] = [matcher];
        }
      } else if (typeof matcher === "undefined") {
        this[kNetConnect] = true;
      } else {
        throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
      }
    }
    disableNetConnect() {
      this[kNetConnect] = false;
    }
    get isMockActive() {
      return this[kIsMockActive];
    }
    [kMockAgentSet](origin, dispatcher) {
      this[kClients].set(origin, new FakeWeakRef(dispatcher));
    }
    [kFactory](origin) {
      const mockOptions = Object.assign({ agent: this }, this[kOptions]);
      return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
    }
    [kMockAgentGet](origin) {
      const ref = this[kClients].get(origin);
      if (ref) {
        return ref.deref();
      }
      if (typeof origin !== "string") {
        const dispatcher = this[kFactory]("http://localhost:9999");
        this[kMockAgentSet](origin, dispatcher);
        return dispatcher;
      }
      for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
        const nonExplicitDispatcher = nonExplicitRef.deref();
        if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
          const dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
          dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
          return dispatcher;
        }
      }
    }
    [kGetNetConnect]() {
      return this[kNetConnect];
    }
    pendingInterceptors() {
      const mockAgentClients = this[kClients];
      return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
    }
    assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter } = {}) {
      const pending = this.pendingInterceptors();
      if (pending.length === 0) {
        return;
      }
      const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
      throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
    }
  }
  module.exports = MockAgent;
});

// node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS((exports, module) => {
  var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
  var { URL: URL2 } = __require("url");
  var Agent = require_agent();
  var Pool = require_pool();
  var DispatcherBase = require_dispatcher_base();
  var { InvalidArgumentError, RequestAbortedError } = require_errors();
  var buildConnector = require_connect();
  var kAgent = Symbol("proxy agent");
  var kClient = Symbol("proxy client");
  var kProxyHeaders = Symbol("proxy headers");
  var kRequestTls = Symbol("request tls settings");
  var kProxyTls = Symbol("proxy tls settings");
  var kConnectEndpoint = Symbol("connect endpoint function");
  function defaultProtocolPort(protocol) {
    return protocol === "https:" ? 443 : 80;
  }
  function buildProxyOptions(opts) {
    if (typeof opts === "string") {
      opts = { uri: opts };
    }
    if (!opts || !opts.uri) {
      throw new InvalidArgumentError("Proxy opts.uri is mandatory");
    }
    return {
      uri: opts.uri,
      protocol: opts.protocol || "https"
    };
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }

  class ProxyAgent extends DispatcherBase {
    constructor(opts) {
      super(opts);
      this[kProxy] = buildProxyOptions(opts);
      this[kAgent] = new Agent(opts);
      this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      const { clientFactory = defaultFactory } = opts;
      if (typeof clientFactory !== "function") {
        throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
      }
      this[kRequestTls] = opts.requestTls;
      this[kProxyTls] = opts.proxyTls;
      this[kProxyHeaders] = opts.headers || {};
      const resolvedUrl = new URL2(opts.uri);
      const { origin, port, host, username, password } = resolvedUrl;
      if (opts.auth && opts.token) {
        throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
      } else if (opts.auth) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
      } else if (opts.token) {
        this[kProxyHeaders]["proxy-authorization"] = opts.token;
      } else if (username && password) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
      }
      const connect = buildConnector({ ...opts.proxyTls });
      this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
      this[kClient] = clientFactory(resolvedUrl, { connect });
      this[kAgent] = new Agent({
        ...opts,
        connect: async (opts2, callback) => {
          let requestedHost = opts2.host;
          if (!opts2.port) {
            requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
          }
          try {
            const { socket, statusCode } = await this[kClient].connect({
              origin,
              port,
              path: requestedHost,
              signal: opts2.signal,
              headers: {
                ...this[kProxyHeaders],
                host
              }
            });
            if (statusCode !== 200) {
              socket.on("error", () => {
              }).destroy();
              callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
            }
            if (opts2.protocol !== "https:") {
              callback(null, socket);
              return;
            }
            let servername;
            if (this[kRequestTls]) {
              servername = this[kRequestTls].servername;
            } else {
              servername = opts2.servername;
            }
            this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
          } catch (err) {
            callback(err);
          }
        }
      });
    }
    dispatch(opts, handler) {
      const { host } = new URL2(opts.origin);
      const headers = buildHeaders(opts.headers);
      throwIfProxyAuthIsSent(headers);
      return this[kAgent].dispatch({
        ...opts,
        headers: {
          ...headers,
          host
        }
      }, handler);
    }
    async[kClose]() {
      await this[kAgent].close();
      await this[kClient].close();
    }
    async[kDestroy]() {
      await this[kAgent].destroy();
      await this[kClient].destroy();
    }
  }
  function buildHeaders(headers) {
    if (Array.isArray(headers)) {
      const headersPair = {};
      for (let i = 0;i < headers.length; i += 2) {
        headersPair[headers[i]] = headers[i + 1];
      }
      return headersPair;
    }
    return headers;
  }
  function throwIfProxyAuthIsSent(headers) {
    const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
    if (existProxyAuth) {
      throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
    }
  }
  module.exports = ProxyAgent;
});

// node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = __commonJS((exports, module) => {
  var assert = __require("assert");
  var { kRetryHandlerDefaultRetry } = require_symbols();
  var { RequestRetryError } = require_errors();
  var { isDisturbed, parseHeaders, parseRangeHeader } = require_util();
  function calculateRetryAfterHeader(retryAfter) {
    const current = Date.now();
    const diff = new Date(retryAfter).getTime() - current;
    return diff;
  }

  class RetryHandler {
    constructor(opts, handlers) {
      const { retryOptions, ...dispatchOpts } = opts;
      const {
        retry: retryFn,
        maxRetries,
        maxTimeout,
        minTimeout,
        timeoutFactor,
        methods,
        errorCodes,
        retryAfter,
        statusCodes
      } = retryOptions ?? {};
      this.dispatch = handlers.dispatch;
      this.handler = handlers.handler;
      this.opts = dispatchOpts;
      this.abort = null;
      this.aborted = false;
      this.retryOpts = {
        retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
        retryAfter: retryAfter ?? true,
        maxTimeout: maxTimeout ?? 30 * 1000,
        timeout: minTimeout ?? 500,
        timeoutFactor: timeoutFactor ?? 2,
        maxRetries: maxRetries ?? 5,
        methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
        statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
        errorCodes: errorCodes ?? [
          "ECONNRESET",
          "ECONNREFUSED",
          "ENOTFOUND",
          "ENETDOWN",
          "ENETUNREACH",
          "EHOSTDOWN",
          "EHOSTUNREACH",
          "EPIPE"
        ]
      };
      this.retryCount = 0;
      this.start = 0;
      this.end = null;
      this.etag = null;
      this.resume = null;
      this.handler.onConnect((reason) => {
        this.aborted = true;
        if (this.abort) {
          this.abort(reason);
        } else {
          this.reason = reason;
        }
      });
    }
    onRequestSent() {
      if (this.handler.onRequestSent) {
        this.handler.onRequestSent();
      }
    }
    onUpgrade(statusCode, headers, socket) {
      if (this.handler.onUpgrade) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
    }
    onConnect(abort) {
      if (this.aborted) {
        abort(this.reason);
      } else {
        this.abort = abort;
      }
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent)
        return this.handler.onBodySent(chunk);
    }
    static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
      const { statusCode, code, headers } = err;
      const { method, retryOptions } = opts;
      const {
        maxRetries,
        timeout,
        maxTimeout,
        timeoutFactor,
        statusCodes,
        errorCodes,
        methods
      } = retryOptions;
      let { counter, currentTimeout } = state;
      currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;
      if (code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
        cb(err);
        return;
      }
      if (Array.isArray(methods) && !methods.includes(method)) {
        cb(err);
        return;
      }
      if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
        cb(err);
        return;
      }
      if (counter > maxRetries) {
        cb(err);
        return;
      }
      let retryAfterHeader = headers != null && headers["retry-after"];
      if (retryAfterHeader) {
        retryAfterHeader = Number(retryAfterHeader);
        retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1000;
      }
      const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
      state.currentTimeout = retryTimeout;
      setTimeout(() => cb(null), retryTimeout);
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const headers = parseHeaders(rawHeaders);
      this.retryCount += 1;
      if (statusCode >= 300) {
        this.abort(new RequestRetryError("Request failed", statusCode, {
          headers,
          count: this.retryCount
        }));
        return false;
      }
      if (this.resume != null) {
        this.resume = null;
        if (statusCode !== 206) {
          return true;
        }
        const contentRange = parseRangeHeader(headers["content-range"]);
        if (!contentRange) {
          this.abort(new RequestRetryError("Content-Range mismatch", statusCode, {
            headers,
            count: this.retryCount
          }));
          return false;
        }
        if (this.etag != null && this.etag !== headers.etag) {
          this.abort(new RequestRetryError("ETag mismatch", statusCode, {
            headers,
            count: this.retryCount
          }));
          return false;
        }
        const { start, size, end = size } = contentRange;
        assert(this.start === start, "content-range mismatch");
        assert(this.end == null || this.end === end, "content-range mismatch");
        this.resume = resume;
        return true;
      }
      if (this.end == null) {
        if (statusCode === 206) {
          const range = parseRangeHeader(headers["content-range"]);
          if (range == null) {
            return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
          }
          const { start, size, end = size } = range;
          assert(start != null && Number.isFinite(start) && this.start !== start, "content-range mismatch");
          assert(Number.isFinite(start));
          assert(end != null && Number.isFinite(end) && this.end !== end, "invalid content-length");
          this.start = start;
          this.end = end;
        }
        if (this.end == null) {
          const contentLength = headers["content-length"];
          this.end = contentLength != null ? Number(contentLength) : null;
        }
        assert(Number.isFinite(this.start));
        assert(this.end == null || Number.isFinite(this.end), "invalid content-length");
        this.resume = resume;
        this.etag = headers.etag != null ? headers.etag : null;
        return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
      }
      const err = new RequestRetryError("Request failed", statusCode, {
        headers,
        count: this.retryCount
      });
      this.abort(err);
      return false;
    }
    onData(chunk) {
      this.start += chunk.length;
      return this.handler.onData(chunk);
    }
    onComplete(rawTrailers) {
      this.retryCount = 0;
      return this.handler.onComplete(rawTrailers);
    }
    onError(err) {
      if (this.aborted || isDisturbed(this.opts.body)) {
        return this.handler.onError(err);
      }
      this.retryOpts.retry(err, {
        state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
        opts: { retryOptions: this.retryOpts, ...this.opts }
      }, onRetry.bind(this));
      function onRetry(err2) {
        if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
          return this.handler.onError(err2);
        }
        if (this.start !== 0) {
          this.opts = {
            ...this.opts,
            headers: {
              ...this.opts.headers,
              range: `bytes=${this.start}-${this.end ?? ""}`
            }
          };
        }
        try {
          this.dispatch(this.opts, this);
        } catch (err3) {
          this.handler.onError(err3);
        }
      }
    }
  }
  module.exports = RetryHandler;
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS((exports, module) => {
  var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
  var { InvalidArgumentError } = require_errors();
  var Agent = require_agent();
  if (getGlobalDispatcher() === undefined) {
    setGlobalDispatcher(new Agent);
  }
  function setGlobalDispatcher(agent) {
    if (!agent || typeof agent.dispatch !== "function") {
      throw new InvalidArgumentError("Argument agent must implement Agent");
    }
    Object.defineProperty(globalThis, globalDispatcher, {
      value: agent,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  function getGlobalDispatcher() {
    return globalThis[globalDispatcher];
  }
  module.exports = {
    setGlobalDispatcher,
    getGlobalDispatcher
  };
});

// node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS((exports, module) => {
  module.exports = class DecoratorHandler {
    constructor(handler) {
      this.handler = handler;
    }
    onConnect(...args) {
      return this.handler.onConnect(...args);
    }
    onError(...args) {
      return this.handler.onError(...args);
    }
    onUpgrade(...args) {
      return this.handler.onUpgrade(...args);
    }
    onHeaders(...args) {
      return this.handler.onHeaders(...args);
    }
    onData(...args) {
      return this.handler.onData(...args);
    }
    onComplete(...args) {
      return this.handler.onComplete(...args);
    }
    onBodySent(...args) {
      return this.handler.onBodySent(...args);
    }
  };
});

// node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS((exports, module) => {
  var { kHeadersList, kConstruct } = require_symbols();
  var { kGuard } = require_symbols2();
  var { kEnumerableProperty } = require_util();
  var {
    makeIterator,
    isValidHeaderName,
    isValidHeaderValue
  } = require_util2();
  var util = __require("util");
  var { webidl } = require_webidl();
  var assert = __require("assert");
  var kHeadersMap = Symbol("headers map");
  var kHeadersSortedMap = Symbol("headers map sorted");
  function isHTTPWhiteSpaceCharCode(code) {
    return code === 10 || code === 13 || code === 9 || code === 32;
  }
  function headerValueNormalize(potentialValue) {
    let i = 0;
    let j = potentialValue.length;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1)))
      --j;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))
      ++i;
    return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
  }
  function fill(headers, object) {
    if (Array.isArray(object)) {
      for (let i = 0;i < object.length; ++i) {
        const header = object[i];
        if (header.length !== 2) {
          throw webidl.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${header.length}.`
          });
        }
        appendHeader(headers, header[0], header[1]);
      }
    } else if (typeof object === "object" && object !== null) {
      const keys = Object.keys(object);
      for (let i = 0;i < keys.length; ++i) {
        appendHeader(headers, keys[i], object[keys[i]]);
      }
    } else {
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    }
  }
  function appendHeader(headers, name, value) {
    value = headerValueNormalize(value);
    if (!isValidHeaderName(name)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value: name,
        type: "header name"
      });
    } else if (!isValidHeaderValue(value)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value,
        type: "header value"
      });
    }
    if (headers[kGuard] === "immutable") {
      throw new TypeError("immutable");
    } else if (headers[kGuard] === "request-no-cors") {
    }
    return headers[kHeadersList].append(name, value);
  }

  class HeadersList {
    cookies = null;
    constructor(init) {
      if (init instanceof HeadersList) {
        this[kHeadersMap] = new Map(init[kHeadersMap]);
        this[kHeadersSortedMap] = init[kHeadersSortedMap];
        this.cookies = init.cookies === null ? null : [...init.cookies];
      } else {
        this[kHeadersMap] = new Map(init);
        this[kHeadersSortedMap] = null;
      }
    }
    contains(name) {
      name = name.toLowerCase();
      return this[kHeadersMap].has(name);
    }
    clear() {
      this[kHeadersMap].clear();
      this[kHeadersSortedMap] = null;
      this.cookies = null;
    }
    append(name, value) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = name.toLowerCase();
      const exists = this[kHeadersMap].get(lowercaseName);
      if (exists) {
        const delimiter = lowercaseName === "cookie" ? "; " : ", ";
        this[kHeadersMap].set(lowercaseName, {
          name: exists.name,
          value: `${exists.value}${delimiter}${value}`
        });
      } else {
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      if (lowercaseName === "set-cookie") {
        this.cookies ??= [];
        this.cookies.push(value);
      }
    }
    set(name, value) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = name.toLowerCase();
      if (lowercaseName === "set-cookie") {
        this.cookies = [value];
      }
      this[kHeadersMap].set(lowercaseName, { name, value });
    }
    delete(name) {
      this[kHeadersSortedMap] = null;
      name = name.toLowerCase();
      if (name === "set-cookie") {
        this.cookies = null;
      }
      this[kHeadersMap].delete(name);
    }
    get(name) {
      const value = this[kHeadersMap].get(name.toLowerCase());
      return value === undefined ? null : value.value;
    }
    *[Symbol.iterator]() {
      for (const [name, { value }] of this[kHeadersMap]) {
        yield [name, value];
      }
    }
    get entries() {
      const headers = {};
      if (this[kHeadersMap].size) {
        for (const { name, value } of this[kHeadersMap].values()) {
          headers[name] = value;
        }
      }
      return headers;
    }
  }

  class Headers {
    constructor(init = undefined) {
      if (init === kConstruct) {
        return;
      }
      this[kHeadersList] = new HeadersList;
      this[kGuard] = "none";
      if (init !== undefined) {
        init = webidl.converters.HeadersInit(init);
        fill(this, init);
      }
    }
    append(name, value) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
      name = webidl.converters.ByteString(name);
      value = webidl.converters.ByteString(value);
      return appendHeader(this, name, value);
    }
    delete(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
      name = webidl.converters.ByteString(name);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.delete",
          value: name,
          type: "header name"
        });
      }
      if (this[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (this[kGuard] === "request-no-cors") {
      }
      if (!this[kHeadersList].contains(name)) {
        return;
      }
      this[kHeadersList].delete(name);
    }
    get(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
      name = webidl.converters.ByteString(name);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.get",
          value: name,
          type: "header name"
        });
      }
      return this[kHeadersList].get(name);
    }
    has(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
      name = webidl.converters.ByteString(name);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.has",
          value: name,
          type: "header name"
        });
      }
      return this[kHeadersList].contains(name);
    }
    set(name, value) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
      name = webidl.converters.ByteString(name);
      value = webidl.converters.ByteString(value);
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.set",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.set",
          value,
          type: "header value"
        });
      }
      if (this[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (this[kGuard] === "request-no-cors") {
      }
      this[kHeadersList].set(name, value);
    }
    getSetCookie() {
      webidl.brandCheck(this, Headers);
      const list = this[kHeadersList].cookies;
      if (list) {
        return [...list];
      }
      return [];
    }
    get [kHeadersSortedMap]() {
      if (this[kHeadersList][kHeadersSortedMap]) {
        return this[kHeadersList][kHeadersSortedMap];
      }
      const headers = [];
      const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
      const cookies = this[kHeadersList].cookies;
      for (let i = 0;i < names.length; ++i) {
        const [name, value] = names[i];
        if (name === "set-cookie") {
          for (let j = 0;j < cookies.length; ++j) {
            headers.push([name, cookies[j]]);
          }
        } else {
          assert(value !== null);
          headers.push([name, value]);
        }
      }
      this[kHeadersList][kHeadersSortedMap] = headers;
      return headers;
    }
    keys() {
      webidl.brandCheck(this, Headers);
      if (this[kGuard] === "immutable") {
        const value = this[kHeadersSortedMap];
        return makeIterator(() => value, "Headers", "key");
      }
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key");
    }
    values() {
      webidl.brandCheck(this, Headers);
      if (this[kGuard] === "immutable") {
        const value = this[kHeadersSortedMap];
        return makeIterator(() => value, "Headers", "value");
      }
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "value");
    }
    entries() {
      webidl.brandCheck(this, Headers);
      if (this[kGuard] === "immutable") {
        const value = this[kHeadersSortedMap];
        return makeIterator(() => value, "Headers", "key+value");
      }
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key+value");
    }
    forEach(callbackFn, thisArg = globalThis) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
      if (typeof callbackFn !== "function") {
        throw new TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");
      }
      for (const [key, value] of this) {
        callbackFn.apply(thisArg, [value, key, this]);
      }
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      webidl.brandCheck(this, Headers);
      return this[kHeadersList];
    }
  }
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  Object.defineProperties(Headers.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    getSetCookie: kEnumerableProperty,
    keys: kEnumerableProperty,
    values: kEnumerableProperty,
    entries: kEnumerableProperty,
    forEach: kEnumerableProperty,
    [Symbol.iterator]: { enumerable: false },
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: true
    },
    [util.inspect.custom]: {
      enumerable: false
    }
  });
  webidl.converters.HeadersInit = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (V[Symbol.iterator]) {
        return webidl.converters["sequence<sequence<ByteString>>"](V);
      }
      return webidl.converters["record<ByteString, ByteString>"](V);
    }
    throw webidl.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  };
  module.exports = {
    fill,
    Headers,
    HeadersList
  };
});

// node_modules/undici/lib/fetch/response.js
var require_response = __commonJS((exports, module) => {
  var { Headers, HeadersList, fill } = require_headers();
  var { extractBody, cloneBody, mixinBody } = require_body();
  var util = require_util();
  var { kEnumerableProperty } = util;
  var {
    isValidReasonPhrase,
    isCancelled,
    isAborted,
    isBlobLike,
    serializeJavascriptValueToJSONString,
    isErrorLike,
    isomorphicEncode
  } = require_util2();
  var {
    redirectStatusSet,
    nullBodyStatus,
    DOMException: DOMException2
  } = require_constants2();
  var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
  var { webidl } = require_webidl();
  var { FormData: FormData2 } = require_formdata();
  var { getGlobalOrigin } = require_global();
  var { URLSerializer } = require_dataURL();
  var { kHeadersList, kConstruct } = require_symbols();
  var assert = __require("assert");
  var { types } = __require("util");
  var ReadableStream2 = globalThis.ReadableStream || __require("stream/web").ReadableStream;
  var textEncoder = new TextEncoder("utf-8");

  class Response {
    static error() {
      const relevantRealm = { settingsObject: {} };
      const responseObject = new Response;
      responseObject[kState] = makeNetworkError();
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
      responseObject[kHeaders][kGuard] = "immutable";
      responseObject[kHeaders][kRealm] = relevantRealm;
      return responseObject;
    }
    static json(data, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
      if (init !== null) {
        init = webidl.converters.ResponseInit(init);
      }
      const bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data));
      const body = extractBody(bytes);
      const relevantRealm = { settingsObject: {} };
      const responseObject = new Response;
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kGuard] = "response";
      responseObject[kHeaders][kRealm] = relevantRealm;
      initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
      return responseObject;
    }
    static redirect(url, status = 302) {
      const relevantRealm = { settingsObject: {} };
      webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
      url = webidl.converters.USVString(url);
      status = webidl.converters["unsigned short"](status);
      let parsedURL;
      try {
        parsedURL = new URL(url, getGlobalOrigin());
      } catch (err) {
        throw Object.assign(new TypeError("Failed to parse URL from " + url), {
          cause: err
        });
      }
      if (!redirectStatusSet.has(status)) {
        throw new RangeError("Invalid status code " + status);
      }
      const responseObject = new Response;
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kGuard] = "immutable";
      responseObject[kHeaders][kRealm] = relevantRealm;
      responseObject[kState].status = status;
      const value = isomorphicEncode(URLSerializer(parsedURL));
      responseObject[kState].headersList.append("location", value);
      return responseObject;
    }
    constructor(body = null, init = {}) {
      if (body !== null) {
        body = webidl.converters.BodyInit(body);
      }
      init = webidl.converters.ResponseInit(init);
      this[kRealm] = { settingsObject: {} };
      this[kState] = makeResponse({});
      this[kHeaders] = new Headers(kConstruct);
      this[kHeaders][kGuard] = "response";
      this[kHeaders][kHeadersList] = this[kState].headersList;
      this[kHeaders][kRealm] = this[kRealm];
      let bodyWithType = null;
      if (body != null) {
        const [extractedBody, type] = extractBody(body);
        bodyWithType = { body: extractedBody, type };
      }
      initializeResponse(this, init, bodyWithType);
    }
    get type() {
      webidl.brandCheck(this, Response);
      return this[kState].type;
    }
    get url() {
      webidl.brandCheck(this, Response);
      const urlList = this[kState].urlList;
      const url = urlList[urlList.length - 1] ?? null;
      if (url === null) {
        return "";
      }
      return URLSerializer(url, true);
    }
    get redirected() {
      webidl.brandCheck(this, Response);
      return this[kState].urlList.length > 1;
    }
    get status() {
      webidl.brandCheck(this, Response);
      return this[kState].status;
    }
    get ok() {
      webidl.brandCheck(this, Response);
      return this[kState].status >= 200 && this[kState].status <= 299;
    }
    get statusText() {
      webidl.brandCheck(this, Response);
      return this[kState].statusText;
    }
    get headers() {
      webidl.brandCheck(this, Response);
      return this[kHeaders];
    }
    get body() {
      webidl.brandCheck(this, Response);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Response);
      return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
    }
    clone() {
      webidl.brandCheck(this, Response);
      if (this.bodyUsed || this.body && this.body.locked) {
        throw webidl.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      }
      const clonedResponse = cloneResponse(this[kState]);
      const clonedResponseObject = new Response;
      clonedResponseObject[kState] = clonedResponse;
      clonedResponseObject[kRealm] = this[kRealm];
      clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
      clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
      clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
      return clonedResponseObject;
    }
  }
  mixinBody(Response);
  Object.defineProperties(Response.prototype, {
    type: kEnumerableProperty,
    url: kEnumerableProperty,
    status: kEnumerableProperty,
    ok: kEnumerableProperty,
    redirected: kEnumerableProperty,
    statusText: kEnumerableProperty,
    headers: kEnumerableProperty,
    clone: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: true
    }
  });
  Object.defineProperties(Response, {
    json: kEnumerableProperty,
    redirect: kEnumerableProperty,
    error: kEnumerableProperty
  });
  function cloneResponse(response) {
    if (response.internalResponse) {
      return filterResponse(cloneResponse(response.internalResponse), response.type);
    }
    const newResponse = makeResponse({ ...response, body: null });
    if (response.body != null) {
      newResponse.body = cloneBody(response.body);
    }
    return newResponse;
  }
  function makeResponse(init) {
    return {
      aborted: false,
      rangeRequested: false,
      timingAllowPassed: false,
      requestIncludesCredentials: false,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...init,
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList,
      urlList: init.urlList ? [...init.urlList] : []
    };
  }
  function makeNetworkError(reason) {
    const isError = isErrorLike(reason);
    return makeResponse({
      type: "error",
      status: 0,
      error: isError ? reason : new Error(reason ? String(reason) : reason),
      aborted: reason && reason.name === "AbortError"
    });
  }
  function makeFilteredResponse(response, state) {
    state = {
      internalResponse: response,
      ...state
    };
    return new Proxy(response, {
      get(target, p) {
        return p in state ? state[p] : target[p];
      },
      set(target, p, value) {
        assert(!(p in state));
        target[p] = value;
        return true;
      }
    });
  }
  function filterResponse(response, type) {
    if (type === "basic") {
      return makeFilteredResponse(response, {
        type: "basic",
        headersList: response.headersList
      });
    } else if (type === "cors") {
      return makeFilteredResponse(response, {
        type: "cors",
        headersList: response.headersList
      });
    } else if (type === "opaque") {
      return makeFilteredResponse(response, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null
      });
    } else if (type === "opaqueredirect") {
      return makeFilteredResponse(response, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    } else {
      assert(false);
    }
  }
  function makeAppropriateNetworkError(fetchParams, err = null) {
    assert(isCancelled(fetchParams));
    return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
  }
  function initializeResponse(response, init, body) {
    if (init.status !== null && (init.status < 200 || init.status > 599)) {
      throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    }
    if ("statusText" in init && init.statusText != null) {
      if (!isValidReasonPhrase(String(init.statusText))) {
        throw new TypeError("Invalid statusText");
      }
    }
    if ("status" in init && init.status != null) {
      response[kState].status = init.status;
    }
    if ("statusText" in init && init.statusText != null) {
      response[kState].statusText = init.statusText;
    }
    if ("headers" in init && init.headers != null) {
      fill(response[kHeaders], init.headers);
    }
    if (body) {
      if (nullBodyStatus.includes(response.status)) {
        throw webidl.errors.exception({
          header: "Response constructor",
          message: "Invalid response status code " + response.status
        });
      }
      response[kState].body = body.body;
      if (body.type != null && !response[kState].headersList.contains("Content-Type")) {
        response[kState].headersList.append("content-type", body.type);
      }
    }
  }
  webidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream2);
  webidl.converters.FormData = webidl.interfaceConverter(FormData2);
  webidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);
  webidl.converters.XMLHttpRequestBodyInit = function(V) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V);
    }
    if (isBlobLike(V)) {
      return webidl.converters.Blob(V, { strict: false });
    }
    if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
      return webidl.converters.BufferSource(V);
    }
    if (util.isFormDataLike(V)) {
      return webidl.converters.FormData(V, { strict: false });
    }
    if (V instanceof URLSearchParams) {
      return webidl.converters.URLSearchParams(V);
    }
    return webidl.converters.DOMString(V);
  };
  webidl.converters.BodyInit = function(V) {
    if (V instanceof ReadableStream2) {
      return webidl.converters.ReadableStream(V);
    }
    if (V?.[Symbol.asyncIterator]) {
      return V;
    }
    return webidl.converters.XMLHttpRequestBodyInit(V);
  };
  webidl.converters.ResponseInit = webidl.dictionaryConverter([
    {
      key: "status",
      converter: webidl.converters["unsigned short"],
      defaultValue: 200
    },
    {
      key: "statusText",
      converter: webidl.converters.ByteString,
      defaultValue: ""
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    }
  ]);
  module.exports = {
    makeNetworkError,
    makeResponse,
    makeAppropriateNetworkError,
    filterResponse,
    Response,
    cloneResponse
  };
});

// node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS((exports, module) => {
  var { extractBody, mixinBody, cloneBody } = require_body();
  var { Headers, fill: fillHeaders, HeadersList } = require_headers();
  var { FinalizationRegistry: FinalizationRegistry2 } = require_dispatcher_weakref()();
  var util = require_util();
  var {
    isValidHTTPToken,
    sameOrigin,
    normalizeMethod,
    makePolicyContainer,
    normalizeMethodRecord
  } = require_util2();
  var {
    forbiddenMethodsSet,
    corsSafeListedMethodsSet,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    requestDuplex
  } = require_constants2();
  var { kEnumerableProperty } = util;
  var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
  var { webidl } = require_webidl();
  var { getGlobalOrigin } = require_global();
  var { URLSerializer } = require_dataURL();
  var { kHeadersList, kConstruct } = require_symbols();
  var assert = __require("assert");
  var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __require("events");
  var TransformStream = globalThis.TransformStream;
  var kAbortController = Symbol("abortController");
  var requestFinalizer = new FinalizationRegistry2(({ signal, abort }) => {
    signal.removeEventListener("abort", abort);
  });

  class Request {
    constructor(input, init = {}) {
      if (input === kConstruct) {
        return;
      }
      webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
      input = webidl.converters.RequestInfo(input);
      init = webidl.converters.RequestInit(init);
      this[kRealm] = {
        settingsObject: {
          baseUrl: getGlobalOrigin(),
          get origin() {
            return this.baseUrl?.origin;
          },
          policyContainer: makePolicyContainer()
        }
      };
      let request = null;
      let fallbackMode = null;
      const baseUrl = this[kRealm].settingsObject.baseUrl;
      let signal = null;
      if (typeof input === "string") {
        let parsedURL;
        try {
          parsedURL = new URL(input, baseUrl);
        } catch (err) {
          throw new TypeError("Failed to parse URL from " + input, { cause: err });
        }
        if (parsedURL.username || parsedURL.password) {
          throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
        }
        request = makeRequest({ urlList: [parsedURL] });
        fallbackMode = "cors";
      } else {
        assert(input instanceof Request);
        request = input[kState];
        signal = input[kSignal];
      }
      const origin = this[kRealm].settingsObject.origin;
      let window2 = "client";
      if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
        window2 = request.window;
      }
      if (init.window != null) {
        throw new TypeError(`'window' option '${window2}' must be null`);
      }
      if ("window" in init) {
        window2 = "no-window";
      }
      request = makeRequest({
        method: request.method,
        headersList: request.headersList,
        unsafeRequest: request.unsafeRequest,
        client: this[kRealm].settingsObject,
        window: window2,
        priority: request.priority,
        origin: request.origin,
        referrer: request.referrer,
        referrerPolicy: request.referrerPolicy,
        mode: request.mode,
        credentials: request.credentials,
        cache: request.cache,
        redirect: request.redirect,
        integrity: request.integrity,
        keepalive: request.keepalive,
        reloadNavigation: request.reloadNavigation,
        historyNavigation: request.historyNavigation,
        urlList: [...request.urlList]
      });
      const initHasKey = Object.keys(init).length !== 0;
      if (initHasKey) {
        if (request.mode === "navigate") {
          request.mode = "same-origin";
        }
        request.reloadNavigation = false;
        request.historyNavigation = false;
        request.origin = "client";
        request.referrer = "client";
        request.referrerPolicy = "";
        request.url = request.urlList[request.urlList.length - 1];
        request.urlList = [request.url];
      }
      if (init.referrer !== undefined) {
        const referrer = init.referrer;
        if (referrer === "") {
          request.referrer = "no-referrer";
        } else {
          let parsedReferrer;
          try {
            parsedReferrer = new URL(referrer, baseUrl);
          } catch (err) {
            throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
          }
          if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {
            request.referrer = "client";
          } else {
            request.referrer = parsedReferrer;
          }
        }
      }
      if (init.referrerPolicy !== undefined) {
        request.referrerPolicy = init.referrerPolicy;
      }
      let mode;
      if (init.mode !== undefined) {
        mode = init.mode;
      } else {
        mode = fallbackMode;
      }
      if (mode === "navigate") {
        throw webidl.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      }
      if (mode != null) {
        request.mode = mode;
      }
      if (init.credentials !== undefined) {
        request.credentials = init.credentials;
      }
      if (init.cache !== undefined) {
        request.cache = init.cache;
      }
      if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
        throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
      }
      if (init.redirect !== undefined) {
        request.redirect = init.redirect;
      }
      if (init.integrity != null) {
        request.integrity = String(init.integrity);
      }
      if (init.keepalive !== undefined) {
        request.keepalive = Boolean(init.keepalive);
      }
      if (init.method !== undefined) {
        let method = init.method;
        if (!isValidHTTPToken(method)) {
          throw new TypeError(`'${method}' is not a valid HTTP method.`);
        }
        if (forbiddenMethodsSet.has(method.toUpperCase())) {
          throw new TypeError(`'${method}' HTTP method is unsupported.`);
        }
        method = normalizeMethodRecord[method] ?? normalizeMethod(method);
        request.method = method;
      }
      if (init.signal !== undefined) {
        signal = init.signal;
      }
      this[kState] = request;
      const ac = new AbortController;
      this[kSignal] = ac.signal;
      this[kSignal][kRealm] = this[kRealm];
      if (signal != null) {
        if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
          throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
        }
        if (signal.aborted) {
          ac.abort(signal.reason);
        } else {
          this[kAbortController] = ac;
          const acRef = new WeakRef(ac);
          const abort = function() {
            const ac2 = acRef.deref();
            if (ac2 !== undefined) {
              ac2.abort(this.reason);
            }
          };
          try {
            if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
              setMaxListeners(100, signal);
            } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
              setMaxListeners(100, signal);
            }
          } catch {
          }
          util.addAbortListener(signal, abort);
          requestFinalizer.register(ac, { signal, abort });
        }
      }
      this[kHeaders] = new Headers(kConstruct);
      this[kHeaders][kHeadersList] = request.headersList;
      this[kHeaders][kGuard] = "request";
      this[kHeaders][kRealm] = this[kRealm];
      if (mode === "no-cors") {
        if (!corsSafeListedMethodsSet.has(request.method)) {
          throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);
        }
        this[kHeaders][kGuard] = "request-no-cors";
      }
      if (initHasKey) {
        const headersList = this[kHeaders][kHeadersList];
        const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList);
        headersList.clear();
        if (headers instanceof HeadersList) {
          for (const [key, val] of headers) {
            headersList.append(key, val);
          }
          headersList.cookies = headers.cookies;
        } else {
          fillHeaders(this[kHeaders], headers);
        }
      }
      const inputBody = input instanceof Request ? input[kState].body : null;
      if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body.");
      }
      let initBody = null;
      if (init.body != null) {
        const [extractedBody, contentType] = extractBody(init.body, request.keepalive);
        initBody = extractedBody;
        if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
          this[kHeaders].append("content-type", contentType);
        }
      }
      const inputOrInitBody = initBody ?? inputBody;
      if (inputOrInitBody != null && inputOrInitBody.source == null) {
        if (initBody != null && init.duplex == null) {
          throw new TypeError("RequestInit: duplex option is required when sending a body.");
        }
        if (request.mode !== "same-origin" && request.mode !== "cors") {
          throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
        }
        request.useCORSPreflightFlag = true;
      }
      let finalBody = inputOrInitBody;
      if (initBody == null && inputBody != null) {
        if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
          throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
        }
        if (!TransformStream) {
          TransformStream = __require("stream/web").TransformStream;
        }
        const identityTransform = new TransformStream;
        inputBody.stream.pipeThrough(identityTransform);
        finalBody = {
          source: inputBody.source,
          length: inputBody.length,
          stream: identityTransform.readable
        };
      }
      this[kState].body = finalBody;
    }
    get method() {
      webidl.brandCheck(this, Request);
      return this[kState].method;
    }
    get url() {
      webidl.brandCheck(this, Request);
      return URLSerializer(this[kState].url);
    }
    get headers() {
      webidl.brandCheck(this, Request);
      return this[kHeaders];
    }
    get destination() {
      webidl.brandCheck(this, Request);
      return this[kState].destination;
    }
    get referrer() {
      webidl.brandCheck(this, Request);
      if (this[kState].referrer === "no-referrer") {
        return "";
      }
      if (this[kState].referrer === "client") {
        return "about:client";
      }
      return this[kState].referrer.toString();
    }
    get referrerPolicy() {
      webidl.brandCheck(this, Request);
      return this[kState].referrerPolicy;
    }
    get mode() {
      webidl.brandCheck(this, Request);
      return this[kState].mode;
    }
    get credentials() {
      return this[kState].credentials;
    }
    get cache() {
      webidl.brandCheck(this, Request);
      return this[kState].cache;
    }
    get redirect() {
      webidl.brandCheck(this, Request);
      return this[kState].redirect;
    }
    get integrity() {
      webidl.brandCheck(this, Request);
      return this[kState].integrity;
    }
    get keepalive() {
      webidl.brandCheck(this, Request);
      return this[kState].keepalive;
    }
    get isReloadNavigation() {
      webidl.brandCheck(this, Request);
      return this[kState].reloadNavigation;
    }
    get isHistoryNavigation() {
      webidl.brandCheck(this, Request);
      return this[kState].historyNavigation;
    }
    get signal() {
      webidl.brandCheck(this, Request);
      return this[kSignal];
    }
    get body() {
      webidl.brandCheck(this, Request);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Request);
      return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
    }
    get duplex() {
      webidl.brandCheck(this, Request);
      return "half";
    }
    clone() {
      webidl.brandCheck(this, Request);
      if (this.bodyUsed || this.body?.locked) {
        throw new TypeError("unusable");
      }
      const clonedRequest = cloneRequest(this[kState]);
      const clonedRequestObject = new Request(kConstruct);
      clonedRequestObject[kState] = clonedRequest;
      clonedRequestObject[kRealm] = this[kRealm];
      clonedRequestObject[kHeaders] = new Headers(kConstruct);
      clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
      clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
      clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
      const ac = new AbortController;
      if (this.signal.aborted) {
        ac.abort(this.signal.reason);
      } else {
        util.addAbortListener(this.signal, () => {
          ac.abort(this.signal.reason);
        });
      }
      clonedRequestObject[kSignal] = ac.signal;
      return clonedRequestObject;
    }
  }
  mixinBody(Request);
  function makeRequest(init) {
    const request = {
      method: "GET",
      localURLsOnly: false,
      unsafeRequest: false,
      body: null,
      client: null,
      reservedClient: null,
      replacesClientId: "",
      window: "client",
      keepalive: false,
      serviceWorkers: "all",
      initiator: "",
      destination: "",
      priority: null,
      origin: "client",
      policyContainer: "client",
      referrer: "client",
      referrerPolicy: "",
      mode: "no-cors",
      useCORSPreflightFlag: false,
      credentials: "same-origin",
      useCredentials: false,
      cache: "default",
      redirect: "follow",
      integrity: "",
      cryptoGraphicsNonceMetadata: "",
      parserMetadata: "",
      reloadNavigation: false,
      historyNavigation: false,
      userActivation: false,
      taintedOrigin: false,
      redirectCount: 0,
      responseTainting: "basic",
      preventNoCacheCacheControlHeaderModification: false,
      done: false,
      timingAllowFailed: false,
      ...init,
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList
    };
    request.url = request.urlList[0];
    return request;
  }
  function cloneRequest(request) {
    const newRequest = makeRequest({ ...request, body: null });
    if (request.body != null) {
      newRequest.body = cloneBody(request.body);
    }
    return newRequest;
  }
  Object.defineProperties(Request.prototype, {
    method: kEnumerableProperty,
    url: kEnumerableProperty,
    headers: kEnumerableProperty,
    redirect: kEnumerableProperty,
    clone: kEnumerableProperty,
    signal: kEnumerableProperty,
    duplex: kEnumerableProperty,
    destination: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    isHistoryNavigation: kEnumerableProperty,
    isReloadNavigation: kEnumerableProperty,
    keepalive: kEnumerableProperty,
    integrity: kEnumerableProperty,
    cache: kEnumerableProperty,
    credentials: kEnumerableProperty,
    attribute: kEnumerableProperty,
    referrerPolicy: kEnumerableProperty,
    referrer: kEnumerableProperty,
    mode: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: true
    }
  });
  webidl.converters.Request = webidl.interfaceConverter(Request);
  webidl.converters.RequestInfo = function(V) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V);
    }
    if (V instanceof Request) {
      return webidl.converters.Request(V);
    }
    return webidl.converters.USVString(V);
  };
  webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);
  webidl.converters.RequestInit = webidl.dictionaryConverter([
    {
      key: "method",
      converter: webidl.converters.ByteString
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    },
    {
      key: "body",
      converter: webidl.nullableConverter(webidl.converters.BodyInit)
    },
    {
      key: "referrer",
      converter: webidl.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: webidl.converters.DOMString,
      allowedValues: referrerPolicy
    },
    {
      key: "mode",
      converter: webidl.converters.DOMString,
      allowedValues: requestMode
    },
    {
      key: "credentials",
      converter: webidl.converters.DOMString,
      allowedValues: requestCredentials
    },
    {
      key: "cache",
      converter: webidl.converters.DOMString,
      allowedValues: requestCache
    },
    {
      key: "redirect",
      converter: webidl.converters.DOMString,
      allowedValues: requestRedirect
    },
    {
      key: "integrity",
      converter: webidl.converters.DOMString
    },
    {
      key: "keepalive",
      converter: webidl.converters.boolean
    },
    {
      key: "signal",
      converter: webidl.nullableConverter((signal) => webidl.converters.AbortSignal(signal, { strict: false }))
    },
    {
      key: "window",
      converter: webidl.converters.any
    },
    {
      key: "duplex",
      converter: webidl.converters.DOMString,
      allowedValues: requestDuplex
    }
  ]);
  module.exports = { Request, makeRequest };
});

// node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS((exports, module) => {
  var {
    Response,
    makeNetworkError,
    makeAppropriateNetworkError,
    filterResponse,
    makeResponse
  } = require_response();
  var { Headers } = require_headers();
  var { Request, makeRequest } = require_request2();
  var zlib = __require("zlib");
  var {
    bytesMatch,
    makePolicyContainer,
    clonePolicyContainer,
    requestBadPort,
    TAOCheck,
    appendRequestOriginHeader,
    responseLocationURL,
    requestCurrentURL,
    setRequestReferrerPolicyOnRedirect,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    createOpaqueTimingInfo,
    appendFetchMetadata,
    corsCheck,
    crossOriginResourcePolicyCheck,
    determineRequestsReferrer,
    coarsenedSharedCurrentTime,
    createDeferredPromise,
    isBlobLike,
    sameOrigin,
    isCancelled,
    isAborted,
    isErrorLike,
    fullyReadBody,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlIsHttpHttpsScheme,
    urlHasHttpsScheme
  } = require_util2();
  var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
  var assert = __require("assert");
  var { safelyExtractBody } = require_body();
  var {
    redirectStatusSet,
    nullBodyStatus,
    safeMethodsSet,
    requestBodyHeader,
    subresourceSet,
    DOMException: DOMException2
  } = require_constants2();
  var { kHeadersList } = require_symbols();
  var EE = __require("events");
  var { Readable, pipeline } = __require("stream");
  var { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util();
  var { dataURLProcessor, serializeAMimeType } = require_dataURL();
  var { TransformStream } = __require("stream/web");
  var { getGlobalDispatcher } = require_global2();
  var { webidl } = require_webidl();
  var { STATUS_CODES } = __require("http");
  var GET_OR_HEAD = ["GET", "HEAD"];
  var resolveObjectURL;
  var ReadableStream2 = globalThis.ReadableStream;

  class Fetch extends EE {
    constructor(dispatcher) {
      super();
      this.dispatcher = dispatcher;
      this.connection = null;
      this.dump = false;
      this.state = "ongoing";
      this.setMaxListeners(21);
    }
    terminate(reason) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "terminated";
      this.connection?.destroy(reason);
      this.emit("terminated", reason);
    }
    abort(error) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "aborted";
      if (!error) {
        error = new DOMException2("The operation was aborted.", "AbortError");
      }
      this.serializedAbortReason = error;
      this.connection?.destroy(error);
      this.emit("terminated", error);
    }
  }
  function fetch(input, init = {}) {
    webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
    const p = createDeferredPromise();
    let requestObject;
    try {
      requestObject = new Request(input, init);
    } catch (e) {
      p.reject(e);
      return p.promise;
    }
    const request = requestObject[kState];
    if (requestObject.signal.aborted) {
      abortFetch(p, request, null, requestObject.signal.reason);
      return p.promise;
    }
    const globalObject = request.client.globalObject;
    if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
      request.serviceWorkers = "none";
    }
    let responseObject = null;
    const relevantRealm = null;
    let locallyAborted = false;
    let controller = null;
    addAbortListener(requestObject.signal, () => {
      locallyAborted = true;
      assert(controller != null);
      controller.abort(requestObject.signal.reason);
      abortFetch(p, request, responseObject, requestObject.signal.reason);
    });
    const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
    const processResponse = (response) => {
      if (locallyAborted) {
        return Promise.resolve();
      }
      if (response.aborted) {
        abortFetch(p, request, responseObject, controller.serializedAbortReason);
        return Promise.resolve();
      }
      if (response.type === "error") {
        p.reject(Object.assign(new TypeError("fetch failed"), { cause: response.error }));
        return Promise.resolve();
      }
      responseObject = new Response;
      responseObject[kState] = response;
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kHeadersList] = response.headersList;
      responseObject[kHeaders][kGuard] = "immutable";
      responseObject[kHeaders][kRealm] = relevantRealm;
      p.resolve(responseObject);
    };
    controller = fetching({
      request,
      processResponseEndOfBody: handleFetchDone,
      processResponse,
      dispatcher: init.dispatcher ?? getGlobalDispatcher()
    });
    return p.promise;
  }
  function finalizeAndReportTiming(response, initiatorType = "other") {
    if (response.type === "error" && response.aborted) {
      return;
    }
    if (!response.urlList?.length) {
      return;
    }
    const originalURL = response.urlList[0];
    let timingInfo = response.timingInfo;
    let cacheState = response.cacheState;
    if (!urlIsHttpHttpsScheme(originalURL)) {
      return;
    }
    if (timingInfo === null) {
      return;
    }
    if (!response.timingAllowPassed) {
      timingInfo = createOpaqueTimingInfo({
        startTime: timingInfo.startTime
      });
      cacheState = "";
    }
    timingInfo.endTime = coarsenedSharedCurrentTime();
    response.timingInfo = timingInfo;
    markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);
  }
  function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
    if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {
      performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
    }
  }
  function abortFetch(p, request, responseObject, error) {
    if (!error) {
      error = new DOMException2("The operation was aborted.", "AbortError");
    }
    p.reject(error);
    if (request.body != null && isReadable(request.body?.stream)) {
      request.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
    if (responseObject == null) {
      return;
    }
    const response = responseObject[kState];
    if (response.body != null && isReadable(response.body?.stream)) {
      response.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
  }
  function fetching({
    request,
    processRequestBodyChunkLength,
    processRequestEndOfBody,
    processResponse,
    processResponseEndOfBody,
    processResponseConsumeBody,
    useParallelQueue = false,
    dispatcher
  }) {
    let taskDestination = null;
    let crossOriginIsolatedCapability = false;
    if (request.client != null) {
      taskDestination = request.client.globalObject;
      crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
    }
    const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
    const timingInfo = createOpaqueTimingInfo({
      startTime: currenTime
    });
    const fetchParams = {
      controller: new Fetch(dispatcher),
      request,
      timingInfo,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseConsumeBody,
      processResponseEndOfBody,
      taskDestination,
      crossOriginIsolatedCapability
    };
    assert(!request.body || request.body.stream);
    if (request.window === "client") {
      request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
    }
    if (request.origin === "client") {
      request.origin = request.client?.origin;
    }
    if (request.policyContainer === "client") {
      if (request.client != null) {
        request.policyContainer = clonePolicyContainer(request.client.policyContainer);
      } else {
        request.policyContainer = makePolicyContainer();
      }
    }
    if (!request.headersList.contains("accept")) {
      const value = "*/*";
      request.headersList.append("accept", value);
    }
    if (!request.headersList.contains("accept-language")) {
      request.headersList.append("accept-language", "*");
    }
    if (request.priority === null) {
    }
    if (subresourceSet.has(request.destination)) {
    }
    mainFetch(fetchParams).catch((err) => {
      fetchParams.controller.terminate(err);
    });
    return fetchParams.controller;
  }
  async function mainFetch(fetchParams, recursive = false) {
    const request = fetchParams.request;
    let response = null;
    if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
      response = makeNetworkError("local URLs only");
    }
    tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
    if (requestBadPort(request) === "blocked") {
      response = makeNetworkError("bad port");
    }
    if (request.referrerPolicy === "") {
      request.referrerPolicy = request.policyContainer.referrerPolicy;
    }
    if (request.referrer !== "no-referrer") {
      request.referrer = determineRequestsReferrer(request);
    }
    if (response === null) {
      response = await (async () => {
        const currentURL = requestCurrentURL(request);
        if (sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || currentURL.protocol === "data:" || (request.mode === "navigate" || request.mode === "websocket")) {
          request.responseTainting = "basic";
          return await schemeFetch(fetchParams);
        }
        if (request.mode === "same-origin") {
          return makeNetworkError('request mode cannot be "same-origin"');
        }
        if (request.mode === "no-cors") {
          if (request.redirect !== "follow") {
            return makeNetworkError('redirect mode cannot be "follow" for "no-cors" request');
          }
          request.responseTainting = "opaque";
          return await schemeFetch(fetchParams);
        }
        if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
          return makeNetworkError("URL scheme must be a HTTP(S) scheme");
        }
        request.responseTainting = "cors";
        return await httpFetch(fetchParams);
      })();
    }
    if (recursive) {
      return response;
    }
    if (response.status !== 0 && !response.internalResponse) {
      if (request.responseTainting === "cors") {
      }
      if (request.responseTainting === "basic") {
        response = filterResponse(response, "basic");
      } else if (request.responseTainting === "cors") {
        response = filterResponse(response, "cors");
      } else if (request.responseTainting === "opaque") {
        response = filterResponse(response, "opaque");
      } else {
        assert(false);
      }
    }
    let internalResponse = response.status === 0 ? response : response.internalResponse;
    if (internalResponse.urlList.length === 0) {
      internalResponse.urlList.push(...request.urlList);
    }
    if (!request.timingAllowFailed) {
      response.timingAllowPassed = true;
    }
    if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range")) {
      response = internalResponse = makeNetworkError();
    }
    if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
      internalResponse.body = null;
      fetchParams.controller.dump = true;
    }
    if (request.integrity) {
      const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
      if (request.responseTainting === "opaque" || response.body == null) {
        processBodyError(response.error);
        return;
      }
      const processBody = (bytes) => {
        if (!bytesMatch(bytes, request.integrity)) {
          processBodyError("integrity mismatch");
          return;
        }
        response.body = safelyExtractBody(bytes)[0];
        fetchFinale(fetchParams, response);
      };
      await fullyReadBody(response.body, processBody, processBodyError);
    } else {
      fetchFinale(fetchParams, response);
    }
  }
  function schemeFetch(fetchParams) {
    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
      return Promise.resolve(makeAppropriateNetworkError(fetchParams));
    }
    const { request } = fetchParams;
    const { protocol: scheme } = requestCurrentURL(request);
    switch (scheme) {
      case "about:": {
        return Promise.resolve(makeNetworkError("about scheme is not supported"));
      }
      case "blob:": {
        if (!resolveObjectURL) {
          resolveObjectURL = __require("buffer").resolveObjectURL;
        }
        const blobURLEntry = requestCurrentURL(request);
        if (blobURLEntry.search.length !== 0) {
          return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
        }
        const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
        if (request.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
          return Promise.resolve(makeNetworkError("invalid method"));
        }
        const bodyWithType = safelyExtractBody(blobURLEntryObject);
        const body = bodyWithType[0];
        const length = isomorphicEncode(`${body.length}`);
        const type = bodyWithType[1] ?? "";
        const response = makeResponse({
          statusText: "OK",
          headersList: [
            ["content-length", { name: "Content-Length", value: length }],
            ["content-type", { name: "Content-Type", value: type }]
          ]
        });
        response.body = body;
        return Promise.resolve(response);
      }
      case "data:": {
        const currentURL = requestCurrentURL(request);
        const dataURLStruct = dataURLProcessor(currentURL);
        if (dataURLStruct === "failure") {
          return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
        }
        const mimeType = serializeAMimeType(dataURLStruct.mimeType);
        return Promise.resolve(makeResponse({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: mimeType }]
          ],
          body: safelyExtractBody(dataURLStruct.body)[0]
        }));
      }
      case "file:": {
        return Promise.resolve(makeNetworkError("not implemented... yet..."));
      }
      case "http:":
      case "https:": {
        return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
      }
      default: {
        return Promise.resolve(makeNetworkError("unknown scheme"));
      }
    }
  }
  function finalizeResponse(fetchParams, response) {
    fetchParams.request.done = true;
    if (fetchParams.processResponseDone != null) {
      queueMicrotask(() => fetchParams.processResponseDone(response));
    }
  }
  function fetchFinale(fetchParams, response) {
    if (response.type === "error") {
      response.urlList = [fetchParams.request.urlList[0]];
      response.timingInfo = createOpaqueTimingInfo({
        startTime: fetchParams.timingInfo.startTime
      });
    }
    const processResponseEndOfBody = () => {
      fetchParams.request.done = true;
      if (fetchParams.processResponseEndOfBody != null) {
        queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
      }
    };
    if (fetchParams.processResponse != null) {
      queueMicrotask(() => fetchParams.processResponse(response));
    }
    if (response.body == null) {
      processResponseEndOfBody();
    } else {
      const identityTransformAlgorithm = (chunk, controller) => {
        controller.enqueue(chunk);
      };
      const transformStream = new TransformStream({
        start() {
        },
        transform: identityTransformAlgorithm,
        flush: processResponseEndOfBody
      }, {
        size() {
          return 1;
        }
      }, {
        size() {
          return 1;
        }
      });
      response.body = { stream: response.body.stream.pipeThrough(transformStream) };
    }
    if (fetchParams.processResponseConsumeBody != null) {
      const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
      const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
      if (response.body == null) {
        queueMicrotask(() => processBody(null));
      } else {
        return fullyReadBody(response.body, processBody, processBodyError);
      }
      return Promise.resolve();
    }
  }
  async function httpFetch(fetchParams) {
    const request = fetchParams.request;
    let response = null;
    let actualResponse = null;
    const timingInfo = fetchParams.timingInfo;
    if (request.serviceWorkers === "all") {
    }
    if (response === null) {
      if (request.redirect === "follow") {
        request.serviceWorkers = "none";
      }
      actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
      if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
        return makeNetworkError("cors failure");
      }
      if (TAOCheck(request, response) === "failure") {
        request.timingAllowFailed = true;
      }
    }
    if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === "blocked") {
      return makeNetworkError("blocked");
    }
    if (redirectStatusSet.has(actualResponse.status)) {
      if (request.redirect !== "manual") {
        fetchParams.controller.connection.destroy();
      }
      if (request.redirect === "error") {
        response = makeNetworkError("unexpected redirect");
      } else if (request.redirect === "manual") {
        response = actualResponse;
      } else if (request.redirect === "follow") {
        response = await httpRedirectFetch(fetchParams, response);
      } else {
        assert(false);
      }
    }
    response.timingInfo = timingInfo;
    return response;
  }
  function httpRedirectFetch(fetchParams, response) {
    const request = fetchParams.request;
    const actualResponse = response.internalResponse ? response.internalResponse : response;
    let locationURL;
    try {
      locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);
      if (locationURL == null) {
        return response;
      }
    } catch (err) {
      return Promise.resolve(makeNetworkError(err));
    }
    if (!urlIsHttpHttpsScheme(locationURL)) {
      return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
    }
    if (request.redirectCount === 20) {
      return Promise.resolve(makeNetworkError("redirect count exceeded"));
    }
    request.redirectCount += 1;
    if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
      return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
    }
    if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
      return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode "cors"'));
    }
    if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
      return Promise.resolve(makeNetworkError());
    }
    if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
      request.method = "GET";
      request.body = null;
      for (const headerName of requestBodyHeader) {
        request.headersList.delete(headerName);
      }
    }
    if (!sameOrigin(requestCurrentURL(request), locationURL)) {
      request.headersList.delete("authorization");
      request.headersList.delete("proxy-authorization", true);
      request.headersList.delete("cookie");
      request.headersList.delete("host");
    }
    if (request.body != null) {
      assert(request.body.source != null);
      request.body = safelyExtractBody(request.body.source)[0];
    }
    const timingInfo = fetchParams.timingInfo;
    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
    if (timingInfo.redirectStartTime === 0) {
      timingInfo.redirectStartTime = timingInfo.startTime;
    }
    request.urlList.push(locationURL);
    setRequestReferrerPolicyOnRedirect(request, actualResponse);
    return mainFetch(fetchParams, true);
  }
  async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
    const request = fetchParams.request;
    let httpFetchParams = null;
    let httpRequest = null;
    let response = null;
    const httpCache = null;
    const revalidatingFlag = false;
    if (request.window === "no-window" && request.redirect === "error") {
      httpFetchParams = fetchParams;
      httpRequest = request;
    } else {
      httpRequest = makeRequest(request);
      httpFetchParams = { ...fetchParams };
      httpFetchParams.request = httpRequest;
    }
    const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
    const contentLength = httpRequest.body ? httpRequest.body.length : null;
    let contentLengthHeaderValue = null;
    if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
      contentLengthHeaderValue = "0";
    }
    if (contentLength != null) {
      contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
    }
    if (contentLengthHeaderValue != null) {
      httpRequest.headersList.append("content-length", contentLengthHeaderValue);
    }
    if (contentLength != null && httpRequest.keepalive) {
    }
    if (httpRequest.referrer instanceof URL) {
      httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
    }
    appendRequestOriginHeader(httpRequest);
    appendFetchMetadata(httpRequest);
    if (!httpRequest.headersList.contains("user-agent")) {
      httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
    }
    if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) {
      httpRequest.headersList.append("cache-control", "max-age=0");
    }
    if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
      if (!httpRequest.headersList.contains("pragma")) {
        httpRequest.headersList.append("pragma", "no-cache");
      }
      if (!httpRequest.headersList.contains("cache-control")) {
        httpRequest.headersList.append("cache-control", "no-cache");
      }
    }
    if (httpRequest.headersList.contains("range")) {
      httpRequest.headersList.append("accept-encoding", "identity");
    }
    if (!httpRequest.headersList.contains("accept-encoding")) {
      if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
        httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
      } else {
        httpRequest.headersList.append("accept-encoding", "gzip, deflate");
      }
    }
    httpRequest.headersList.delete("host");
    if (includeCredentials) {
    }
    if (httpCache == null) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
    }
    if (response == null) {
      if (httpRequest.mode === "only-if-cached") {
        return makeNetworkError("only if cached");
      }
      const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
      if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
      }
      if (revalidatingFlag && forwardResponse.status === 304) {
      }
      if (response == null) {
        response = forwardResponse;
      }
    }
    response.urlList = [...httpRequest.urlList];
    if (httpRequest.headersList.contains("range")) {
      response.rangeRequested = true;
    }
    response.requestIncludesCredentials = includeCredentials;
    if (response.status === 407) {
      if (request.window === "no-window") {
        return makeNetworkError();
      }
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      return makeNetworkError("proxy authentication required");
    }
    if (response.status === 421 && !isNewConnectionFetch && (request.body == null || request.body.source != null)) {
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      fetchParams.controller.connection.destroy();
      response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
    }
    if (isAuthenticationFetch) {
    }
    return response;
  }
  async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
    fetchParams.controller.connection = {
      abort: null,
      destroyed: false,
      destroy(err) {
        if (!this.destroyed) {
          this.destroyed = true;
          this.abort?.(err ?? new DOMException2("The operation was aborted.", "AbortError"));
        }
      }
    };
    const request = fetchParams.request;
    let response = null;
    const timingInfo = fetchParams.timingInfo;
    const httpCache = null;
    if (httpCache == null) {
      request.cache = "no-store";
    }
    const newConnection = forceNewConnection ? "yes" : "no";
    if (request.mode === "websocket") {
    } else {
    }
    let requestBody = null;
    if (request.body == null && fetchParams.processRequestEndOfBody) {
      queueMicrotask(() => fetchParams.processRequestEndOfBody());
    } else if (request.body != null) {
      const processBodyChunk = async function* (bytes) {
        if (isCancelled(fetchParams)) {
          return;
        }
        yield bytes;
        fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
      };
      const processEndOfBody = () => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (fetchParams.processRequestEndOfBody) {
          fetchParams.processRequestEndOfBody();
        }
      };
      const processBodyError = (e) => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (e.name === "AbortError") {
          fetchParams.controller.abort();
        } else {
          fetchParams.controller.terminate(e);
        }
      };
      requestBody = async function* () {
        try {
          for await (const bytes of request.body.stream) {
            yield* processBodyChunk(bytes);
          }
          processEndOfBody();
        } catch (err) {
          processBodyError(err);
        }
      }();
    }
    try {
      const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
      if (socket) {
        response = makeResponse({ status, statusText, headersList, socket });
      } else {
        const iterator = body[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next();
        response = makeResponse({ status, statusText, headersList });
      }
    } catch (err) {
      if (err.name === "AbortError") {
        fetchParams.controller.connection.destroy();
        return makeAppropriateNetworkError(fetchParams, err);
      }
      return makeNetworkError(err);
    }
    const pullAlgorithm = () => {
      fetchParams.controller.resume();
    };
    const cancelAlgorithm = (reason) => {
      fetchParams.controller.abort(reason);
    };
    if (!ReadableStream2) {
      ReadableStream2 = __require("stream/web").ReadableStream;
    }
    const stream = new ReadableStream2({
      async start(controller) {
        fetchParams.controller.controller = controller;
      },
      async pull(controller) {
        await pullAlgorithm(controller);
      },
      async cancel(reason) {
        await cancelAlgorithm(reason);
      }
    }, {
      highWaterMark: 0,
      size() {
        return 1;
      }
    });
    response.body = { stream };
    fetchParams.controller.on("terminated", onAborted);
    fetchParams.controller.resume = async () => {
      while (true) {
        let bytes;
        let isFailure;
        try {
          const { done, value } = await fetchParams.controller.next();
          if (isAborted(fetchParams)) {
            break;
          }
          bytes = done ? undefined : value;
        } catch (err) {
          if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
            bytes = undefined;
          } else {
            bytes = err;
            isFailure = true;
          }
        }
        if (bytes === undefined) {
          readableStreamClose(fetchParams.controller.controller);
          finalizeResponse(fetchParams, response);
          return;
        }
        timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
        if (isFailure) {
          fetchParams.controller.terminate(bytes);
          return;
        }
        fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
        if (isErrored(stream)) {
          fetchParams.controller.terminate();
          return;
        }
        if (!fetchParams.controller.controller.desiredSize) {
          return;
        }
      }
    };
    function onAborted(reason) {
      if (isAborted(fetchParams)) {
        response.aborted = true;
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
        }
      } else {
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(new TypeError("terminated", {
            cause: isErrorLike(reason) ? reason : undefined
          }));
        }
      }
      fetchParams.controller.connection.destroy();
    }
    return response;
    async function dispatch({ body }) {
      const url = requestCurrentURL(request);
      const agent = fetchParams.controller.dispatcher;
      return new Promise((resolve, reject) => agent.dispatch({
        path: url.pathname + url.search,
        origin: url.origin,
        method: request.method,
        body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
        headers: request.headersList.entries,
        maxRedirections: 0,
        upgrade: request.mode === "websocket" ? "websocket" : undefined
      }, {
        body: null,
        abort: null,
        onConnect(abort) {
          const { connection } = fetchParams.controller;
          if (connection.destroyed) {
            abort(new DOMException2("The operation was aborted.", "AbortError"));
          } else {
            fetchParams.controller.on("terminated", abort);
            this.abort = connection.abort = abort;
          }
        },
        onHeaders(status, headersList, resume, statusText) {
          if (status < 200) {
            return;
          }
          let codings = [];
          let location = "";
          const headers = new Headers;
          if (Array.isArray(headersList)) {
            for (let n = 0;n < headersList.length; n += 2) {
              const key = headersList[n + 0].toString("latin1");
              const val = headersList[n + 1].toString("latin1");
              if (key.toLowerCase() === "content-encoding") {
                codings = val.toLowerCase().split(",").map((x) => x.trim());
              } else if (key.toLowerCase() === "location") {
                location = val;
              }
              headers[kHeadersList].append(key, val);
            }
          } else {
            const keys = Object.keys(headersList);
            for (const key of keys) {
              const val = headersList[key];
              if (key.toLowerCase() === "content-encoding") {
                codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse();
              } else if (key.toLowerCase() === "location") {
                location = val;
              }
              headers[kHeadersList].append(key, val);
            }
          }
          this.body = new Readable({ read: resume });
          const decoders = [];
          const willFollow = request.redirect === "follow" && location && redirectStatusSet.has(status);
          if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
            for (const coding of codings) {
              if (coding === "x-gzip" || coding === "gzip") {
                decoders.push(zlib.createGunzip({
                  flush: zlib.constants.Z_SYNC_FLUSH,
                  finishFlush: zlib.constants.Z_SYNC_FLUSH
                }));
              } else if (coding === "deflate") {
                decoders.push(zlib.createInflate());
              } else if (coding === "br") {
                decoders.push(zlib.createBrotliDecompress());
              } else {
                decoders.length = 0;
                break;
              }
            }
          }
          resolve({
            status,
            statusText,
            headersList: headers[kHeadersList],
            body: decoders.length ? pipeline(this.body, ...decoders, () => {
            }) : this.body.on("error", () => {
            })
          });
          return true;
        },
        onData(chunk) {
          if (fetchParams.controller.dump) {
            return;
          }
          const bytes = chunk;
          timingInfo.encodedBodySize += bytes.byteLength;
          return this.body.push(bytes);
        },
        onComplete() {
          if (this.abort) {
            fetchParams.controller.off("terminated", this.abort);
          }
          fetchParams.controller.ended = true;
          this.body.push(null);
        },
        onError(error) {
          if (this.abort) {
            fetchParams.controller.off("terminated", this.abort);
          }
          this.body?.destroy(error);
          fetchParams.controller.terminate(error);
          reject(error);
        },
        onUpgrade(status, headersList, socket) {
          if (status !== 101) {
            return;
          }
          const headers = new Headers;
          for (let n = 0;n < headersList.length; n += 2) {
            const key = headersList[n + 0].toString("latin1");
            const val = headersList[n + 1].toString("latin1");
            headers[kHeadersList].append(key, val);
          }
          resolve({
            status,
            statusText: STATUS_CODES[status],
            headersList: headers[kHeadersList],
            socket
          });
          return true;
        }
      }));
    }
  }
  module.exports = {
    fetch,
    Fetch,
    fetching,
    finalizeAndReportTiming
  };
});

// node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS((exports, module) => {
  module.exports = {
    kState: Symbol("FileReader state"),
    kResult: Symbol("FileReader result"),
    kError: Symbol("FileReader error"),
    kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
    kEvents: Symbol("FileReader events"),
    kAborted: Symbol("FileReader aborted")
  };
});

// node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var kState = Symbol("ProgressEvent state");

  class ProgressEvent extends Event {
    constructor(type, eventInitDict = {}) {
      type = webidl.converters.DOMString(type);
      eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
      super(type, eventInitDict);
      this[kState] = {
        lengthComputable: eventInitDict.lengthComputable,
        loaded: eventInitDict.loaded,
        total: eventInitDict.total
      };
    }
    get lengthComputable() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].lengthComputable;
    }
    get loaded() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].loaded;
    }
    get total() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].total;
    }
  }
  webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
    {
      key: "lengthComputable",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "loaded",
      converter: webidl.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "total",
      converter: webidl.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: false
    }
  ]);
  module.exports = {
    ProgressEvent
  };
});

// node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS((exports, module) => {
  function getEncoding(label) {
    if (!label) {
      return "failure";
    }
    switch (label.trim().toLowerCase()) {
      case "unicode-1-1-utf-8":
      case "unicode11utf8":
      case "unicode20utf8":
      case "utf-8":
      case "utf8":
      case "x-unicode20utf8":
        return "UTF-8";
      case "866":
      case "cp866":
      case "csibm866":
      case "ibm866":
        return "IBM866";
      case "csisolatin2":
      case "iso-8859-2":
      case "iso-ir-101":
      case "iso8859-2":
      case "iso88592":
      case "iso_8859-2":
      case "iso_8859-2:1987":
      case "l2":
      case "latin2":
        return "ISO-8859-2";
      case "csisolatin3":
      case "iso-8859-3":
      case "iso-ir-109":
      case "iso8859-3":
      case "iso88593":
      case "iso_8859-3":
      case "iso_8859-3:1988":
      case "l3":
      case "latin3":
        return "ISO-8859-3";
      case "csisolatin4":
      case "iso-8859-4":
      case "iso-ir-110":
      case "iso8859-4":
      case "iso88594":
      case "iso_8859-4":
      case "iso_8859-4:1988":
      case "l4":
      case "latin4":
        return "ISO-8859-4";
      case "csisolatincyrillic":
      case "cyrillic":
      case "iso-8859-5":
      case "iso-ir-144":
      case "iso8859-5":
      case "iso88595":
      case "iso_8859-5":
      case "iso_8859-5:1988":
        return "ISO-8859-5";
      case "arabic":
      case "asmo-708":
      case "csiso88596e":
      case "csiso88596i":
      case "csisolatinarabic":
      case "ecma-114":
      case "iso-8859-6":
      case "iso-8859-6-e":
      case "iso-8859-6-i":
      case "iso-ir-127":
      case "iso8859-6":
      case "iso88596":
      case "iso_8859-6":
      case "iso_8859-6:1987":
        return "ISO-8859-6";
      case "csisolatingreek":
      case "ecma-118":
      case "elot_928":
      case "greek":
      case "greek8":
      case "iso-8859-7":
      case "iso-ir-126":
      case "iso8859-7":
      case "iso88597":
      case "iso_8859-7":
      case "iso_8859-7:1987":
      case "sun_eu_greek":
        return "ISO-8859-7";
      case "csiso88598e":
      case "csisolatinhebrew":
      case "hebrew":
      case "iso-8859-8":
      case "iso-8859-8-e":
      case "iso-ir-138":
      case "iso8859-8":
      case "iso88598":
      case "iso_8859-8":
      case "iso_8859-8:1988":
      case "visual":
        return "ISO-8859-8";
      case "csiso88598i":
      case "iso-8859-8-i":
      case "logical":
        return "ISO-8859-8-I";
      case "csisolatin6":
      case "iso-8859-10":
      case "iso-ir-157":
      case "iso8859-10":
      case "iso885910":
      case "l6":
      case "latin6":
        return "ISO-8859-10";
      case "iso-8859-13":
      case "iso8859-13":
      case "iso885913":
        return "ISO-8859-13";
      case "iso-8859-14":
      case "iso8859-14":
      case "iso885914":
        return "ISO-8859-14";
      case "csisolatin9":
      case "iso-8859-15":
      case "iso8859-15":
      case "iso885915":
      case "iso_8859-15":
      case "l9":
        return "ISO-8859-15";
      case "iso-8859-16":
        return "ISO-8859-16";
      case "cskoi8r":
      case "koi":
      case "koi8":
      case "koi8-r":
      case "koi8_r":
        return "KOI8-R";
      case "koi8-ru":
      case "koi8-u":
        return "KOI8-U";
      case "csmacintosh":
      case "mac":
      case "macintosh":
      case "x-mac-roman":
        return "macintosh";
      case "iso-8859-11":
      case "iso8859-11":
      case "iso885911":
      case "tis-620":
      case "windows-874":
        return "windows-874";
      case "cp1250":
      case "windows-1250":
      case "x-cp1250":
        return "windows-1250";
      case "cp1251":
      case "windows-1251":
      case "x-cp1251":
        return "windows-1251";
      case "ansi_x3.4-1968":
      case "ascii":
      case "cp1252":
      case "cp819":
      case "csisolatin1":
      case "ibm819":
      case "iso-8859-1":
      case "iso-ir-100":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "iso_8859-1:1987":
      case "l1":
      case "latin1":
      case "us-ascii":
      case "windows-1252":
      case "x-cp1252":
        return "windows-1252";
      case "cp1253":
      case "windows-1253":
      case "x-cp1253":
        return "windows-1253";
      case "cp1254":
      case "csisolatin5":
      case "iso-8859-9":
      case "iso-ir-148":
      case "iso8859-9":
      case "iso88599":
      case "iso_8859-9":
      case "iso_8859-9:1989":
      case "l5":
      case "latin5":
      case "windows-1254":
      case "x-cp1254":
        return "windows-1254";
      case "cp1255":
      case "windows-1255":
      case "x-cp1255":
        return "windows-1255";
      case "cp1256":
      case "windows-1256":
      case "x-cp1256":
        return "windows-1256";
      case "cp1257":
      case "windows-1257":
      case "x-cp1257":
        return "windows-1257";
      case "cp1258":
      case "windows-1258":
      case "x-cp1258":
        return "windows-1258";
      case "x-mac-cyrillic":
      case "x-mac-ukrainian":
        return "x-mac-cyrillic";
      case "chinese":
      case "csgb2312":
      case "csiso58gb231280":
      case "gb2312":
      case "gb_2312":
      case "gb_2312-80":
      case "gbk":
      case "iso-ir-58":
      case "x-gbk":
        return "GBK";
      case "gb18030":
        return "gb18030";
      case "big5":
      case "big5-hkscs":
      case "cn-big5":
      case "csbig5":
      case "x-x-big5":
        return "Big5";
      case "cseucpkdfmtjapanese":
      case "euc-jp":
      case "x-euc-jp":
        return "EUC-JP";
      case "csiso2022jp":
      case "iso-2022-jp":
        return "ISO-2022-JP";
      case "csshiftjis":
      case "ms932":
      case "ms_kanji":
      case "shift-jis":
      case "shift_jis":
      case "sjis":
      case "windows-31j":
      case "x-sjis":
        return "Shift_JIS";
      case "cseuckr":
      case "csksc56011987":
      case "euc-kr":
      case "iso-ir-149":
      case "korean":
      case "ks_c_5601-1987":
      case "ks_c_5601-1989":
      case "ksc5601":
      case "ksc_5601":
      case "windows-949":
        return "EUC-KR";
      case "csiso2022kr":
      case "hz-gb-2312":
      case "iso-2022-cn":
      case "iso-2022-cn-ext":
      case "iso-2022-kr":
      case "replacement":
        return "replacement";
      case "unicodefffe":
      case "utf-16be":
        return "UTF-16BE";
      case "csunicode":
      case "iso-10646-ucs-2":
      case "ucs-2":
      case "unicode":
      case "unicodefeff":
      case "utf-16":
      case "utf-16le":
        return "UTF-16LE";
      case "x-user-defined":
        return "x-user-defined";
      default:
        return "failure";
    }
  }
  module.exports = {
    getEncoding
  };
});

// node_modules/undici/lib/fileapi/util.js
var require_util4 = __commonJS((exports, module) => {
  var {
    kState,
    kError,
    kResult,
    kAborted,
    kLastProgressEventFired
  } = require_symbols3();
  var { ProgressEvent } = require_progressevent();
  var { getEncoding } = require_encoding();
  var { DOMException: DOMException2 } = require_constants2();
  var { serializeAMimeType, parseMIMEType } = require_dataURL();
  var { types } = __require("util");
  var { StringDecoder } = __require("string_decoder");
  var { btoa: btoa2 } = __require("buffer");
  var staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  function readOperation(fr, blob, type, encodingName) {
    if (fr[kState] === "loading") {
      throw new DOMException2("Invalid state", "InvalidStateError");
    }
    fr[kState] = "loading";
    fr[kResult] = null;
    fr[kError] = null;
    const stream = blob.stream();
    const reader = stream.getReader();
    const bytes = [];
    let chunkPromise = reader.read();
    let isFirstChunk = true;
    (async () => {
      while (!fr[kAborted]) {
        try {
          const { done, value } = await chunkPromise;
          if (isFirstChunk && !fr[kAborted]) {
            queueMicrotask(() => {
              fireAProgressEvent("loadstart", fr);
            });
          }
          isFirstChunk = false;
          if (!done && types.isUint8Array(value)) {
            bytes.push(value);
            if ((fr[kLastProgressEventFired] === undefined || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
              fr[kLastProgressEventFired] = Date.now();
              queueMicrotask(() => {
                fireAProgressEvent("progress", fr);
              });
            }
            chunkPromise = reader.read();
          } else if (done) {
            queueMicrotask(() => {
              fr[kState] = "done";
              try {
                const result = packageData(bytes, type, blob.type, encodingName);
                if (fr[kAborted]) {
                  return;
                }
                fr[kResult] = result;
                fireAProgressEvent("load", fr);
              } catch (error) {
                fr[kError] = error;
                fireAProgressEvent("error", fr);
              }
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        } catch (error) {
          if (fr[kAborted]) {
            return;
          }
          queueMicrotask(() => {
            fr[kState] = "done";
            fr[kError] = error;
            fireAProgressEvent("error", fr);
            if (fr[kState] !== "loading") {
              fireAProgressEvent("loadend", fr);
            }
          });
          break;
        }
      }
    })();
  }
  function fireAProgressEvent(e, reader) {
    const event = new ProgressEvent(e, {
      bubbles: false,
      cancelable: false
    });
    reader.dispatchEvent(event);
  }
  function packageData(bytes, type, mimeType, encodingName) {
    switch (type) {
      case "DataURL": {
        let dataURL = "data:";
        const parsed = parseMIMEType(mimeType || "application/octet-stream");
        if (parsed !== "failure") {
          dataURL += serializeAMimeType(parsed);
        }
        dataURL += ";base64,";
        const decoder = new StringDecoder("latin1");
        for (const chunk of bytes) {
          dataURL += btoa2(decoder.write(chunk));
        }
        dataURL += btoa2(decoder.end());
        return dataURL;
      }
      case "Text": {
        let encoding = "failure";
        if (encodingName) {
          encoding = getEncoding(encodingName);
        }
        if (encoding === "failure" && mimeType) {
          const type2 = parseMIMEType(mimeType);
          if (type2 !== "failure") {
            encoding = getEncoding(type2.parameters.get("charset"));
          }
        }
        if (encoding === "failure") {
          encoding = "UTF-8";
        }
        return decode(bytes, encoding);
      }
      case "ArrayBuffer": {
        const sequence = combineByteSequences(bytes);
        return sequence.buffer;
      }
      case "BinaryString": {
        let binaryString = "";
        const decoder = new StringDecoder("latin1");
        for (const chunk of bytes) {
          binaryString += decoder.write(chunk);
        }
        binaryString += decoder.end();
        return binaryString;
      }
    }
  }
  function decode(ioQueue, encoding) {
    const bytes = combineByteSequences(ioQueue);
    const BOMEncoding = BOMSniffing(bytes);
    let slice = 0;
    if (BOMEncoding !== null) {
      encoding = BOMEncoding;
      slice = BOMEncoding === "UTF-8" ? 3 : 2;
    }
    const sliced = bytes.slice(slice);
    return new TextDecoder(encoding).decode(sliced);
  }
  function BOMSniffing(ioQueue) {
    const [a, b, c] = ioQueue;
    if (a === 239 && b === 187 && c === 191) {
      return "UTF-8";
    } else if (a === 254 && b === 255) {
      return "UTF-16BE";
    } else if (a === 255 && b === 254) {
      return "UTF-16LE";
    }
    return null;
  }
  function combineByteSequences(sequences) {
    const size = sequences.reduce((a, b) => {
      return a + b.byteLength;
    }, 0);
    let offset = 0;
    return sequences.reduce((a, b) => {
      a.set(b, offset);
      offset += b.byteLength;
      return a;
    }, new Uint8Array(size));
  }
  module.exports = {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  };
});

// node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS((exports, module) => {
  var {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  } = require_util4();
  var {
    kState,
    kError,
    kResult,
    kEvents,
    kAborted
  } = require_symbols3();
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();

  class FileReader extends EventTarget {
    constructor() {
      super();
      this[kState] = "empty";
      this[kResult] = null;
      this[kError] = null;
      this[kEvents] = {
        loadend: null,
        error: null,
        abort: null,
        load: null,
        progress: null,
        loadstart: null
      };
    }
    readAsArrayBuffer(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "ArrayBuffer");
    }
    readAsBinaryString(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "BinaryString");
    }
    readAsText(blob, encoding = undefined) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
      blob = webidl.converters.Blob(blob, { strict: false });
      if (encoding !== undefined) {
        encoding = webidl.converters.DOMString(encoding);
      }
      readOperation(this, blob, "Text", encoding);
    }
    readAsDataURL(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "DataURL");
    }
    abort() {
      if (this[kState] === "empty" || this[kState] === "done") {
        this[kResult] = null;
        return;
      }
      if (this[kState] === "loading") {
        this[kState] = "done";
        this[kResult] = null;
      }
      this[kAborted] = true;
      fireAProgressEvent("abort", this);
      if (this[kState] !== "loading") {
        fireAProgressEvent("loadend", this);
      }
    }
    get readyState() {
      webidl.brandCheck(this, FileReader);
      switch (this[kState]) {
        case "empty":
          return this.EMPTY;
        case "loading":
          return this.LOADING;
        case "done":
          return this.DONE;
      }
    }
    get result() {
      webidl.brandCheck(this, FileReader);
      return this[kResult];
    }
    get error() {
      webidl.brandCheck(this, FileReader);
      return this[kError];
    }
    get onloadend() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadend;
    }
    set onloadend(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadend) {
        this.removeEventListener("loadend", this[kEvents].loadend);
      }
      if (typeof fn === "function") {
        this[kEvents].loadend = fn;
        this.addEventListener("loadend", fn);
      } else {
        this[kEvents].loadend = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].error) {
        this.removeEventListener("error", this[kEvents].error);
      }
      if (typeof fn === "function") {
        this[kEvents].error = fn;
        this.addEventListener("error", fn);
      } else {
        this[kEvents].error = null;
      }
    }
    get onloadstart() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadstart;
    }
    set onloadstart(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadstart) {
        this.removeEventListener("loadstart", this[kEvents].loadstart);
      }
      if (typeof fn === "function") {
        this[kEvents].loadstart = fn;
        this.addEventListener("loadstart", fn);
      } else {
        this[kEvents].loadstart = null;
      }
    }
    get onprogress() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].progress;
    }
    set onprogress(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].progress) {
        this.removeEventListener("progress", this[kEvents].progress);
      }
      if (typeof fn === "function") {
        this[kEvents].progress = fn;
        this.addEventListener("progress", fn);
      } else {
        this[kEvents].progress = null;
      }
    }
    get onload() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].load;
    }
    set onload(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].load) {
        this.removeEventListener("load", this[kEvents].load);
      }
      if (typeof fn === "function") {
        this[kEvents].load = fn;
        this.addEventListener("load", fn);
      } else {
        this[kEvents].load = null;
      }
    }
    get onabort() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].abort;
    }
    set onabort(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].abort) {
        this.removeEventListener("abort", this[kEvents].abort);
      }
      if (typeof fn === "function") {
        this[kEvents].abort = fn;
        this.addEventListener("abort", fn);
      } else {
        this[kEvents].abort = null;
      }
    }
  }
  FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
  FileReader.LOADING = FileReader.prototype.LOADING = 1;
  FileReader.DONE = FileReader.prototype.DONE = 2;
  Object.defineProperties(FileReader.prototype, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors,
    readAsArrayBuffer: kEnumerableProperty,
    readAsBinaryString: kEnumerableProperty,
    readAsText: kEnumerableProperty,
    readAsDataURL: kEnumerableProperty,
    abort: kEnumerableProperty,
    readyState: kEnumerableProperty,
    result: kEnumerableProperty,
    error: kEnumerableProperty,
    onloadstart: kEnumerableProperty,
    onprogress: kEnumerableProperty,
    onload: kEnumerableProperty,
    onabort: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onloadend: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "FileReader",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(FileReader, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors
  });
  module.exports = {
    FileReader
  };
});

// node_modules/undici/lib/cache/symbols.js
var require_symbols4 = __commonJS((exports, module) => {
  module.exports = {
    kConstruct: require_symbols().kConstruct
  };
});

// node_modules/undici/lib/cache/util.js
var require_util5 = __commonJS((exports, module) => {
  var assert = __require("assert");
  var { URLSerializer } = require_dataURL();
  var { isValidHeaderName } = require_util2();
  function urlEquals(A, B, excludeFragment = false) {
    const serializedA = URLSerializer(A, excludeFragment);
    const serializedB = URLSerializer(B, excludeFragment);
    return serializedA === serializedB;
  }
  function fieldValues(header) {
    assert(header !== null);
    const values = [];
    for (let value of header.split(",")) {
      value = value.trim();
      if (!value.length) {
        continue;
      } else if (!isValidHeaderName(value)) {
        continue;
      }
      values.push(value);
    }
    return values;
  }
  module.exports = {
    urlEquals,
    fieldValues
  };
});

// node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols4();
  var { urlEquals, fieldValues: getFieldValues } = require_util5();
  var { kEnumerableProperty, isDisturbed } = require_util();
  var { kHeadersList } = require_symbols();
  var { webidl } = require_webidl();
  var { Response, cloneResponse } = require_response();
  var { Request } = require_request2();
  var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
  var { fetching } = require_fetch();
  var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
  var assert = __require("assert");
  var { getGlobalDispatcher } = require_global2();

  class Cache {
    #relevantRequestResponseList;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
      this.#relevantRequestResponseList = arguments[1];
    }
    async match(request, options = {}) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
      request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options);
      const p = await this.matchAll(request, options);
      if (p.length === 0) {
        return;
      }
      return p[0];
    }
    async matchAll(request = undefined, options = {}) {
      webidl.brandCheck(this, Cache);
      if (request !== undefined)
        request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options);
      let r = null;
      if (request !== undefined) {
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request === "string") {
          r = new Request(request)[kState];
        }
      }
      const responses = [];
      if (request === undefined) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          responses.push(requestResponse[1]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options);
        for (const requestResponse of requestResponses) {
          responses.push(requestResponse[1]);
        }
      }
      const responseList = [];
      for (const response of responses) {
        const responseObject = new Response(response.body?.source ?? null);
        const body = responseObject[kState].body;
        responseObject[kState] = response;
        responseObject[kState].body = body;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseList.push(responseObject);
      }
      return Object.freeze(responseList);
    }
    async add(request) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
      request = webidl.converters.RequestInfo(request);
      const requests = [request];
      const responseArrayPromise = this.addAll(requests);
      return await responseArrayPromise;
    }
    async addAll(requests) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
      requests = webidl.converters["sequence<RequestInfo>"](requests);
      const responsePromises = [];
      const requestList = [];
      for (const request of requests) {
        if (typeof request === "string") {
          continue;
        }
        const r = request[kState];
        if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
          throw webidl.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme when method is not GET."
          });
        }
      }
      const fetchControllers = [];
      for (const request of requests) {
        const r = new Request(request)[kState];
        if (!urlIsHttpHttpsScheme(r.url)) {
          throw webidl.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme."
          });
        }
        r.initiator = "fetch";
        r.destination = "subresource";
        requestList.push(r);
        const responsePromise = createDeferredPromise();
        fetchControllers.push(fetching({
          request: r,
          dispatcher: getGlobalDispatcher(),
          processResponse(response) {
            if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
              responsePromise.reject(webidl.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            } else if (response.headersList.contains("vary")) {
              const fieldValues = getFieldValues(response.headersList.get("vary"));
              for (const fieldValue of fieldValues) {
                if (fieldValue === "*") {
                  responsePromise.reject(webidl.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (const controller of fetchControllers) {
                    controller.abort();
                  }
                  return;
                }
              }
            }
          },
          processResponseEndOfBody(response) {
            if (response.aborted) {
              responsePromise.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            responsePromise.resolve(response);
          }
        }));
        responsePromises.push(responsePromise.promise);
      }
      const p = Promise.all(responsePromises);
      const responses = await p;
      const operations = [];
      let index = 0;
      for (const response of responses) {
        const operation = {
          type: "put",
          request: requestList[index],
          response
        };
        operations.push(operation);
        index++;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(undefined);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async put(request, response) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
      request = webidl.converters.RequestInfo(request);
      response = webidl.converters.Response(response);
      let innerRequest = null;
      if (request instanceof Request) {
        innerRequest = request[kState];
      } else {
        innerRequest = new Request(request)[kState];
      }
      if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Expected an http/s scheme when method is not GET"
        });
      }
      const innerResponse = response[kState];
      if (innerResponse.status === 206) {
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Got 206 status"
        });
      }
      if (innerResponse.headersList.contains("vary")) {
        const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            throw webidl.errors.exception({
              header: "Cache.put",
              message: "Got * vary field value"
            });
          }
        }
      }
      if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Response body is locked or disturbed"
        });
      }
      const clonedResponse = cloneResponse(innerResponse);
      const bodyReadPromise = createDeferredPromise();
      if (innerResponse.body != null) {
        const stream = innerResponse.body.stream;
        const reader = stream.getReader();
        readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
      } else {
        bodyReadPromise.resolve(undefined);
      }
      const operations = [];
      const operation = {
        type: "put",
        request: innerRequest,
        response: clonedResponse
      };
      operations.push(operation);
      const bytes = await bodyReadPromise.promise;
      if (clonedResponse.body != null) {
        clonedResponse.body.source = bytes;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve();
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async delete(request, options = {}) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
      request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options);
      let r = null;
      if (request instanceof Request) {
        r = request[kState];
        if (r.method !== "GET" && !options.ignoreMethod) {
          return false;
        }
      } else {
        assert(typeof request === "string");
        r = new Request(request)[kState];
      }
      const operations = [];
      const operation = {
        type: "delete",
        request: r,
        options
      };
      operations.push(operation);
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      let requestResponses;
      try {
        requestResponses = this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(!!requestResponses?.length);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async keys(request = undefined, options = {}) {
      webidl.brandCheck(this, Cache);
      if (request !== undefined)
        request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options);
      let r = null;
      if (request !== undefined) {
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request === "string") {
          r = new Request(request)[kState];
        }
      }
      const promise = createDeferredPromise();
      const requests = [];
      if (request === undefined) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          requests.push(requestResponse[0]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options);
        for (const requestResponse of requestResponses) {
          requests.push(requestResponse[0]);
        }
      }
      queueMicrotask(() => {
        const requestList = [];
        for (const request2 of requests) {
          const requestObject = new Request("https://a");
          requestObject[kState] = request2;
          requestObject[kHeaders][kHeadersList] = request2.headersList;
          requestObject[kHeaders][kGuard] = "immutable";
          requestObject[kRealm] = request2.client;
          requestList.push(requestObject);
        }
        promise.resolve(Object.freeze(requestList));
      });
      return promise.promise;
    }
    #batchCacheOperations(operations) {
      const cache = this.#relevantRequestResponseList;
      const backupCache = [...cache];
      const addedItems = [];
      const resultList = [];
      try {
        for (const operation of operations) {
          if (operation.type !== "delete" && operation.type !== "put") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          }
          if (operation.type === "delete" && operation.response != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          }
          if (this.#queryCache(operation.request, operation.options, addedItems).length) {
            throw new DOMException("???", "InvalidStateError");
          }
          let requestResponses;
          if (operation.type === "delete") {
            requestResponses = this.#queryCache(operation.request, operation.options);
            if (requestResponses.length === 0) {
              return [];
            }
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
          } else if (operation.type === "put") {
            if (operation.response == null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            }
            const r = operation.request;
            if (!urlIsHttpHttpsScheme(r.url)) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            }
            if (r.method !== "GET") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            }
            if (operation.options != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            }
            requestResponses = this.#queryCache(operation.request);
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
            cache.push([operation.request, operation.response]);
            addedItems.push([operation.request, operation.response]);
          }
          resultList.push([operation.request, operation.response]);
        }
        return resultList;
      } catch (e) {
        this.#relevantRequestResponseList.length = 0;
        this.#relevantRequestResponseList = backupCache;
        throw e;
      }
    }
    #queryCache(requestQuery, options, targetStorage) {
      const resultList = [];
      const storage = targetStorage ?? this.#relevantRequestResponseList;
      for (const requestResponse of storage) {
        const [cachedRequest, cachedResponse] = requestResponse;
        if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
          resultList.push(requestResponse);
        }
      }
      return resultList;
    }
    #requestMatchesCachedItem(requestQuery, request, response = null, options) {
      const queryURL = new URL(requestQuery.url);
      const cachedURL = new URL(request.url);
      if (options?.ignoreSearch) {
        cachedURL.search = "";
        queryURL.search = "";
      }
      if (!urlEquals(queryURL, cachedURL, true)) {
        return false;
      }
      if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
        return true;
      }
      const fieldValues = getFieldValues(response.headersList.get("vary"));
      for (const fieldValue of fieldValues) {
        if (fieldValue === "*") {
          return false;
        }
        const requestValue = request.headersList.get(fieldValue);
        const queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue) {
          return false;
        }
      }
      return true;
    }
  }
  Object.defineProperties(Cache.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: true
    },
    match: kEnumerableProperty,
    matchAll: kEnumerableProperty,
    add: kEnumerableProperty,
    addAll: kEnumerableProperty,
    put: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  var cacheQueryOptionConverters = [
    {
      key: "ignoreSearch",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "ignoreMethod",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "ignoreVary",
      converter: webidl.converters.boolean,
      defaultValue: false
    }
  ];
  webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
  webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
    ...cacheQueryOptionConverters,
    {
      key: "cacheName",
      converter: webidl.converters.DOMString
    }
  ]);
  webidl.converters.Response = webidl.interfaceConverter(Response);
  webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(webidl.converters.RequestInfo);
  module.exports = {
    Cache
  };
});

// node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols4();
  var { Cache } = require_cache();
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();

  class CacheStorage {
    #caches = new Map;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
    }
    async match(request, options = {}) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
      request = webidl.converters.RequestInfo(request);
      options = webidl.converters.MultiCacheQueryOptions(options);
      if (options.cacheName != null) {
        if (this.#caches.has(options.cacheName)) {
          const cacheList = this.#caches.get(options.cacheName);
          const cache = new Cache(kConstruct, cacheList);
          return await cache.match(request, options);
        }
      } else {
        for (const cacheList of this.#caches.values()) {
          const cache = new Cache(kConstruct, cacheList);
          const response = await cache.match(request, options);
          if (response !== undefined) {
            return response;
          }
        }
      }
    }
    async has(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
      cacheName = webidl.converters.DOMString(cacheName);
      return this.#caches.has(cacheName);
    }
    async open(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
      cacheName = webidl.converters.DOMString(cacheName);
      if (this.#caches.has(cacheName)) {
        const cache2 = this.#caches.get(cacheName);
        return new Cache(kConstruct, cache2);
      }
      const cache = [];
      this.#caches.set(cacheName, cache);
      return new Cache(kConstruct, cache);
    }
    async delete(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
      cacheName = webidl.converters.DOMString(cacheName);
      return this.#caches.delete(cacheName);
    }
    async keys() {
      webidl.brandCheck(this, CacheStorage);
      const keys = this.#caches.keys();
      return [...keys];
    }
  }
  Object.defineProperties(CacheStorage.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: true
    },
    match: kEnumerableProperty,
    has: kEnumerableProperty,
    open: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  module.exports = {
    CacheStorage
  };
});

// node_modules/undici/lib/cookies/constants.js
var require_constants4 = __commonJS((exports, module) => {
  var maxAttributeValueSize = 1024;
  var maxNameValuePairSize = 4096;
  module.exports = {
    maxAttributeValueSize,
    maxNameValuePairSize
  };
});

// node_modules/undici/lib/cookies/util.js
var require_util6 = __commonJS((exports, module) => {
  function isCTLExcludingHtab(value) {
    if (value.length === 0) {
      return false;
    }
    for (const char of value) {
      const code = char.charCodeAt(0);
      if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127) {
        return false;
      }
    }
  }
  function validateCookieName(name) {
    for (const char of name) {
      const code = char.charCodeAt(0);
      if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") {
        throw new Error("Invalid cookie name");
      }
    }
  }
  function validateCookieValue(value) {
    for (const char of value) {
      const code = char.charCodeAt(0);
      if (code < 33 || code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
        throw new Error("Invalid header value");
      }
    }
  }
  function validateCookiePath(path) {
    for (const char of path) {
      const code = char.charCodeAt(0);
      if (code < 33 || char === ";") {
        throw new Error("Invalid cookie path");
      }
    }
  }
  function validateCookieDomain(domain) {
    if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
      throw new Error("Invalid cookie domain");
    }
  }
  function toIMFDate(date) {
    if (typeof date === "number") {
      date = new Date(date);
    }
    const days = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    const months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    const dayName = days[date.getUTCDay()];
    const day = date.getUTCDate().toString().padStart(2, "0");
    const month = months[date.getUTCMonth()];
    const year = date.getUTCFullYear();
    const hour = date.getUTCHours().toString().padStart(2, "0");
    const minute = date.getUTCMinutes().toString().padStart(2, "0");
    const second = date.getUTCSeconds().toString().padStart(2, "0");
    return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
  }
  function validateCookieMaxAge(maxAge) {
    if (maxAge < 0) {
      throw new Error("Invalid cookie max-age");
    }
  }
  function stringify(cookie) {
    if (cookie.name.length === 0) {
      return null;
    }
    validateCookieName(cookie.name);
    validateCookieValue(cookie.value);
    const out = [`${cookie.name}=${cookie.value}`];
    if (cookie.name.startsWith("__Secure-")) {
      cookie.secure = true;
    }
    if (cookie.name.startsWith("__Host-")) {
      cookie.secure = true;
      cookie.domain = null;
      cookie.path = "/";
    }
    if (cookie.secure) {
      out.push("Secure");
    }
    if (cookie.httpOnly) {
      out.push("HttpOnly");
    }
    if (typeof cookie.maxAge === "number") {
      validateCookieMaxAge(cookie.maxAge);
      out.push(`Max-Age=${cookie.maxAge}`);
    }
    if (cookie.domain) {
      validateCookieDomain(cookie.domain);
      out.push(`Domain=${cookie.domain}`);
    }
    if (cookie.path) {
      validateCookiePath(cookie.path);
      out.push(`Path=${cookie.path}`);
    }
    if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
      out.push(`Expires=${toIMFDate(cookie.expires)}`);
    }
    if (cookie.sameSite) {
      out.push(`SameSite=${cookie.sameSite}`);
    }
    for (const part of cookie.unparsed) {
      if (!part.includes("=")) {
        throw new Error("Invalid unparsed");
      }
      const [key, ...value] = part.split("=");
      out.push(`${key.trim()}=${value.join("=")}`);
    }
    return out.join("; ");
  }
  module.exports = {
    isCTLExcludingHtab,
    validateCookieName,
    validateCookiePath,
    validateCookieValue,
    toIMFDate,
    stringify
  };
});

// node_modules/undici/lib/cookies/parse.js
var require_parse = __commonJS((exports, module) => {
  var { maxNameValuePairSize, maxAttributeValueSize } = require_constants4();
  var { isCTLExcludingHtab } = require_util6();
  var { collectASequenceOfCodePointsFast } = require_dataURL();
  var assert = __require("assert");
  function parseSetCookie(header) {
    if (isCTLExcludingHtab(header)) {
      return null;
    }
    let nameValuePair = "";
    let unparsedAttributes = "";
    let name = "";
    let value = "";
    if (header.includes(";")) {
      const position = { position: 0 };
      nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
      unparsedAttributes = header.slice(position.position);
    } else {
      nameValuePair = header;
    }
    if (!nameValuePair.includes("=")) {
      value = nameValuePair;
    } else {
      const position = { position: 0 };
      name = collectASequenceOfCodePointsFast("=", nameValuePair, position);
      value = nameValuePair.slice(position.position + 1);
    }
    name = name.trim();
    value = value.trim();
    if (name.length + value.length > maxNameValuePairSize) {
      return null;
    }
    return {
      name,
      value,
      ...parseUnparsedAttributes(unparsedAttributes)
    };
  }
  function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
    if (unparsedAttributes.length === 0) {
      return cookieAttributeList;
    }
    assert(unparsedAttributes[0] === ";");
    unparsedAttributes = unparsedAttributes.slice(1);
    let cookieAv = "";
    if (unparsedAttributes.includes(";")) {
      cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, { position: 0 });
      unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
    } else {
      cookieAv = unparsedAttributes;
      unparsedAttributes = "";
    }
    let attributeName = "";
    let attributeValue = "";
    if (cookieAv.includes("=")) {
      const position = { position: 0 };
      attributeName = collectASequenceOfCodePointsFast("=", cookieAv, position);
      attributeValue = cookieAv.slice(position.position + 1);
    } else {
      attributeName = cookieAv;
    }
    attributeName = attributeName.trim();
    attributeValue = attributeValue.trim();
    if (attributeValue.length > maxAttributeValueSize) {
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    const attributeNameLowercase = attributeName.toLowerCase();
    if (attributeNameLowercase === "expires") {
      const expiryTime = new Date(attributeValue);
      cookieAttributeList.expires = expiryTime;
    } else if (attributeNameLowercase === "max-age") {
      const charCode = attributeValue.charCodeAt(0);
      if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      if (!/^\d+$/.test(attributeValue)) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const deltaSeconds = Number(attributeValue);
      cookieAttributeList.maxAge = deltaSeconds;
    } else if (attributeNameLowercase === "domain") {
      let cookieDomain = attributeValue;
      if (cookieDomain[0] === ".") {
        cookieDomain = cookieDomain.slice(1);
      }
      cookieDomain = cookieDomain.toLowerCase();
      cookieAttributeList.domain = cookieDomain;
    } else if (attributeNameLowercase === "path") {
      let cookiePath = "";
      if (attributeValue.length === 0 || attributeValue[0] !== "/") {
        cookiePath = "/";
      } else {
        cookiePath = attributeValue;
      }
      cookieAttributeList.path = cookiePath;
    } else if (attributeNameLowercase === "secure") {
      cookieAttributeList.secure = true;
    } else if (attributeNameLowercase === "httponly") {
      cookieAttributeList.httpOnly = true;
    } else if (attributeNameLowercase === "samesite") {
      let enforcement = "Default";
      const attributeValueLowercase = attributeValue.toLowerCase();
      if (attributeValueLowercase.includes("none")) {
        enforcement = "None";
      }
      if (attributeValueLowercase.includes("strict")) {
        enforcement = "Strict";
      }
      if (attributeValueLowercase.includes("lax")) {
        enforcement = "Lax";
      }
      cookieAttributeList.sameSite = enforcement;
    } else {
      cookieAttributeList.unparsed ??= [];
      cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
    }
    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
  }
  module.exports = {
    parseSetCookie,
    parseUnparsedAttributes
  };
});

// node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS((exports, module) => {
  var { parseSetCookie } = require_parse();
  var { stringify } = require_util6();
  var { webidl } = require_webidl();
  var { Headers } = require_headers();
  function getCookies(headers) {
    webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
    webidl.brandCheck(headers, Headers, { strict: false });
    const cookie = headers.get("cookie");
    const out = {};
    if (!cookie) {
      return out;
    }
    for (const piece of cookie.split(";")) {
      const [name, ...value] = piece.split("=");
      out[name.trim()] = value.join("=");
    }
    return out;
  }
  function deleteCookie(headers, name, attributes) {
    webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
    webidl.brandCheck(headers, Headers, { strict: false });
    name = webidl.converters.DOMString(name);
    attributes = webidl.converters.DeleteCookieAttributes(attributes);
    setCookie(headers, {
      name,
      value: "",
      expires: new Date(0),
      ...attributes
    });
  }
  function getSetCookies(headers) {
    webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
    webidl.brandCheck(headers, Headers, { strict: false });
    const cookies = headers.getSetCookie();
    if (!cookies) {
      return [];
    }
    return cookies.map((pair) => parseSetCookie(pair));
  }
  function setCookie(headers, cookie) {
    webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
    webidl.brandCheck(headers, Headers, { strict: false });
    cookie = webidl.converters.Cookie(cookie);
    const str = stringify(cookie);
    if (str) {
      headers.append("Set-Cookie", stringify(cookie));
    }
  }
  webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: null
    }
  ]);
  webidl.converters.Cookie = webidl.dictionaryConverter([
    {
      converter: webidl.converters.DOMString,
      key: "name"
    },
    {
      converter: webidl.converters.DOMString,
      key: "value"
    },
    {
      converter: webidl.nullableConverter((value) => {
        if (typeof value === "number") {
          return webidl.converters["unsigned long long"](value);
        }
        return new Date(value);
      }),
      key: "expires",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters["long long"]),
      key: "maxAge",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "secure",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "httpOnly",
      defaultValue: null
    },
    {
      converter: webidl.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: webidl.sequenceConverter(webidl.converters.DOMString),
      key: "unparsed",
      defaultValue: []
    }
  ]);
  module.exports = {
    getCookies,
    deleteCookie,
    getSetCookies,
    setCookie
  };
});

// node_modules/undici/lib/websocket/constants.js
var require_constants5 = __commonJS((exports, module) => {
  var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  var staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  var states = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  };
  var opcodes = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  };
  var maxUnsigned16Bit = 2 ** 16 - 1;
  var parserStates = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  };
  var emptyBuffer = Buffer.allocUnsafe(0);
  module.exports = {
    uid,
    staticPropertyDescriptors,
    states,
    opcodes,
    maxUnsigned16Bit,
    parserStates,
    emptyBuffer
  };
});

// node_modules/undici/lib/websocket/symbols.js
var require_symbols5 = __commonJS((exports, module) => {
  module.exports = {
    kWebSocketURL: Symbol("url"),
    kReadyState: Symbol("ready state"),
    kController: Symbol("controller"),
    kResponse: Symbol("response"),
    kBinaryType: Symbol("binary type"),
    kSentClose: Symbol("sent close"),
    kReceivedClose: Symbol("received close"),
    kByteParser: Symbol("byte parser")
  };
});

// node_modules/undici/lib/websocket/events.js
var require_events = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();
  var { MessagePort } = __require("worker_threads");

  class MessageEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
      type = webidl.converters.DOMString(type);
      eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
    }
    get data() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.data;
    }
    get origin() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.origin;
    }
    get lastEventId() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.lastEventId;
    }
    get source() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.source;
    }
    get ports() {
      webidl.brandCheck(this, MessageEvent);
      if (!Object.isFrozen(this.#eventInit.ports)) {
        Object.freeze(this.#eventInit.ports);
      }
      return this.#eventInit.ports;
    }
    initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
      webidl.brandCheck(this, MessageEvent);
      webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
      return new MessageEvent(type, {
        bubbles,
        cancelable,
        data,
        origin,
        lastEventId,
        source,
        ports
      });
    }
  }

  class CloseEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
      type = webidl.converters.DOMString(type);
      eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
    }
    get wasClean() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.wasClean;
    }
    get code() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.code;
    }
    get reason() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.reason;
    }
  }

  class ErrorEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict) {
      webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
      super(type, eventInitDict);
      type = webidl.converters.DOMString(type);
      eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
      this.#eventInit = eventInitDict;
    }
    get message() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.message;
    }
    get filename() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.filename;
    }
    get lineno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.lineno;
    }
    get colno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.colno;
    }
    get error() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.error;
    }
  }
  Object.defineProperties(MessageEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: true
    },
    data: kEnumerableProperty,
    origin: kEnumerableProperty,
    lastEventId: kEnumerableProperty,
    source: kEnumerableProperty,
    ports: kEnumerableProperty,
    initMessageEvent: kEnumerableProperty
  });
  Object.defineProperties(CloseEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: true
    },
    reason: kEnumerableProperty,
    code: kEnumerableProperty,
    wasClean: kEnumerableProperty
  });
  Object.defineProperties(ErrorEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: true
    },
    message: kEnumerableProperty,
    filename: kEnumerableProperty,
    lineno: kEnumerableProperty,
    colno: kEnumerableProperty,
    error: kEnumerableProperty
  });
  webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
  webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(webidl.converters.MessagePort);
  var eventInit = [
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: false
    }
  ];
  webidl.converters.MessageEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "data",
      converter: webidl.converters.any,
      defaultValue: null
    },
    {
      key: "origin",
      converter: webidl.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lastEventId",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "source",
      converter: webidl.nullableConverter(webidl.converters.MessagePort),
      defaultValue: null
    },
    {
      key: "ports",
      converter: webidl.converters["sequence<MessagePort>"],
      get defaultValue() {
        return [];
      }
    }
  ]);
  webidl.converters.CloseEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "wasClean",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "code",
      converter: webidl.converters["unsigned short"],
      defaultValue: 0
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: ""
    }
  ]);
  webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "message",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "filename",
      converter: webidl.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lineno",
      converter: webidl.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "colno",
      converter: webidl.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "error",
      converter: webidl.converters.any
    }
  ]);
  module.exports = {
    MessageEvent,
    CloseEvent,
    ErrorEvent
  };
});

// node_modules/undici/lib/websocket/util.js
var require_util7 = __commonJS((exports, module) => {
  var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
  var { states, opcodes } = require_constants5();
  var { MessageEvent, ErrorEvent } = require_events();
  function isEstablished(ws) {
    return ws[kReadyState] === states.OPEN;
  }
  function isClosing(ws) {
    return ws[kReadyState] === states.CLOSING;
  }
  function isClosed(ws) {
    return ws[kReadyState] === states.CLOSED;
  }
  function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
    const event = new eventConstructor(e, eventInitDict);
    target.dispatchEvent(event);
  }
  function websocketMessageReceived(ws, type, data) {
    if (ws[kReadyState] !== states.OPEN) {
      return;
    }
    let dataForEvent;
    if (type === opcodes.TEXT) {
      try {
        dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
      } catch {
        failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
        return;
      }
    } else if (type === opcodes.BINARY) {
      if (ws[kBinaryType] === "blob") {
        dataForEvent = new Blob([data]);
      } else {
        dataForEvent = new Uint8Array(data).buffer;
      }
    }
    fireEvent("message", ws, MessageEvent, {
      origin: ws[kWebSocketURL].origin,
      data: dataForEvent
    });
  }
  function isValidSubprotocol(protocol) {
    if (protocol.length === 0) {
      return false;
    }
    for (const char of protocol) {
      const code = char.charCodeAt(0);
      if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || code === 9) {
        return false;
      }
    }
    return true;
  }
  function isValidStatusCode(code) {
    if (code >= 1000 && code < 1015) {
      return code !== 1004 && code !== 1005 && code !== 1006;
    }
    return code >= 3000 && code <= 4999;
  }
  function failWebsocketConnection(ws, reason) {
    const { [kController]: controller, [kResponse]: response } = ws;
    controller.abort();
    if (response?.socket && !response.socket.destroyed) {
      response.socket.destroy();
    }
    if (reason) {
      fireEvent("error", ws, ErrorEvent, {
        error: new Error(reason)
      });
    }
  }
  module.exports = {
    isEstablished,
    isClosing,
    isClosed,
    fireEvent,
    isValidSubprotocol,
    isValidStatusCode,
    failWebsocketConnection,
    websocketMessageReceived
  };
});

// node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS((exports, module) => {
  var diagnosticsChannel = __require("diagnostics_channel");
  var { uid, states } = require_constants5();
  var {
    kReadyState,
    kSentClose,
    kByteParser,
    kReceivedClose
  } = require_symbols5();
  var { fireEvent, failWebsocketConnection } = require_util7();
  var { CloseEvent } = require_events();
  var { makeRequest } = require_request2();
  var { fetching } = require_fetch();
  var { Headers } = require_headers();
  var { getGlobalDispatcher } = require_global2();
  var { kHeadersList } = require_symbols();
  var channels = {};
  channels.open = diagnosticsChannel.channel("undici:websocket:open");
  channels.close = diagnosticsChannel.channel("undici:websocket:close");
  channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
  var crypto;
  try {
    crypto = __require("crypto");
  } catch {
  }
  function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {
    const requestURL = url;
    requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
    const request = makeRequest({
      urlList: [requestURL],
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (options.headers) {
      const headersList = new Headers(options.headers)[kHeadersList];
      request.headersList = headersList;
    }
    const keyValue = crypto.randomBytes(16).toString("base64");
    request.headersList.append("sec-websocket-key", keyValue);
    request.headersList.append("sec-websocket-version", "13");
    for (const protocol of protocols) {
      request.headersList.append("sec-websocket-protocol", protocol);
    }
    const permessageDeflate = "";
    const controller = fetching({
      request,
      useParallelQueue: true,
      dispatcher: options.dispatcher ?? getGlobalDispatcher(),
      processResponse(response) {
        if (response.type === "error" || response.status !== 101) {
          failWebsocketConnection(ws, "Received network error or non-101 status code.");
          return;
        }
        if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Server did not respond with sent protocols.");
          return;
        }
        if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
        const digest = crypto.createHash("sha1").update(keyValue + uid).digest("base64");
        if (secWSAccept !== digest) {
          failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
        if (secExtension !== null && secExtension !== permessageDeflate) {
          failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
          return;
        }
        const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
        if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
          return;
        }
        response.socket.on("data", onSocketData);
        response.socket.on("close", onSocketClose);
        response.socket.on("error", onSocketError);
        if (channels.open.hasSubscribers) {
          channels.open.publish({
            address: response.socket.address(),
            protocol: secProtocol,
            extensions: secExtension
          });
        }
        onEstablish(response);
      }
    });
    return controller;
  }
  function onSocketData(chunk) {
    if (!this.ws[kByteParser].write(chunk)) {
      this.pause();
    }
  }
  function onSocketClose() {
    const { ws } = this;
    const wasClean = ws[kSentClose] && ws[kReceivedClose];
    let code = 1005;
    let reason = "";
    const result = ws[kByteParser].closingInfo;
    if (result) {
      code = result.code ?? 1005;
      reason = result.reason;
    } else if (!ws[kSentClose]) {
      code = 1006;
    }
    ws[kReadyState] = states.CLOSED;
    fireEvent("close", ws, CloseEvent, {
      wasClean,
      code,
      reason
    });
    if (channels.close.hasSubscribers) {
      channels.close.publish({
        websocket: ws,
        code,
        reason
      });
    }
  }
  function onSocketError(error) {
    const { ws } = this;
    ws[kReadyState] = states.CLOSING;
    if (channels.socketError.hasSubscribers) {
      channels.socketError.publish(error);
    }
    this.destroy();
  }
  module.exports = {
    establishWebSocketConnection
  };
});

// node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS((exports, module) => {
  var { maxUnsigned16Bit } = require_constants5();
  var crypto;
  try {
    crypto = __require("crypto");
  } catch {
  }

  class WebsocketFrameSend {
    constructor(data) {
      this.frameData = data;
      this.maskKey = crypto.randomBytes(4);
    }
    createFrame(opcode) {
      const bodyLength = this.frameData?.byteLength ?? 0;
      let payloadLength = bodyLength;
      let offset = 6;
      if (bodyLength > maxUnsigned16Bit) {
        offset += 8;
        payloadLength = 127;
      } else if (bodyLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const buffer = Buffer.allocUnsafe(bodyLength + offset);
      buffer[0] = buffer[1] = 0;
      buffer[0] |= 128;
      buffer[0] = (buffer[0] & 240) + opcode;
      /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
      buffer[offset - 4] = this.maskKey[0];
      buffer[offset - 3] = this.maskKey[1];
      buffer[offset - 2] = this.maskKey[2];
      buffer[offset - 1] = this.maskKey[3];
      buffer[1] = payloadLength;
      if (payloadLength === 126) {
        buffer.writeUInt16BE(bodyLength, 2);
      } else if (payloadLength === 127) {
        buffer[2] = buffer[3] = 0;
        buffer.writeUIntBE(bodyLength, 4, 6);
      }
      buffer[1] |= 128;
      for (let i = 0;i < bodyLength; i++) {
        buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
      }
      return buffer;
    }
  }
  module.exports = {
    WebsocketFrameSend
  };
});

// node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable } = __require("stream");
  var diagnosticsChannel = __require("diagnostics_channel");
  var { parserStates, opcodes, states, emptyBuffer } = require_constants5();
  var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
  var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util7();
  var { WebsocketFrameSend } = require_frame();
  var channels = {};
  channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
  channels.pong = diagnosticsChannel.channel("undici:websocket:pong");

  class ByteParser extends Writable {
    #buffers = [];
    #byteOffset = 0;
    #state = parserStates.INFO;
    #info = {};
    #fragments = [];
    constructor(ws) {
      super();
      this.ws = ws;
    }
    _write(chunk, _, callback) {
      this.#buffers.push(chunk);
      this.#byteOffset += chunk.length;
      this.run(callback);
    }
    run(callback) {
      while (true) {
        if (this.#state === parserStates.INFO) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          this.#info.fin = (buffer[0] & 128) !== 0;
          this.#info.opcode = buffer[0] & 15;
          this.#info.originalOpcode ??= this.#info.opcode;
          this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;
          if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
            failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
            return;
          }
          const payloadLength = buffer[1] & 127;
          if (payloadLength <= 125) {
            this.#info.payloadLength = payloadLength;
            this.#state = parserStates.READ_DATA;
          } else if (payloadLength === 126) {
            this.#state = parserStates.PAYLOADLENGTH_16;
          } else if (payloadLength === 127) {
            this.#state = parserStates.PAYLOADLENGTH_64;
          }
          if (this.#info.fragmented && payloadLength > 125) {
            failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
            return;
          } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {
            failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
            return;
          } else if (this.#info.opcode === opcodes.CLOSE) {
            if (payloadLength === 1) {
              failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
              return;
            }
            const body = this.consume(payloadLength);
            this.#info.closeInfo = this.parseCloseBody(false, body);
            if (!this.ws[kSentClose]) {
              const body2 = Buffer.allocUnsafe(2);
              body2.writeUInt16BE(this.#info.closeInfo.code, 0);
              const closeFrame = new WebsocketFrameSend(body2);
              this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err) => {
                if (!err) {
                  this.ws[kSentClose] = true;
                }
              });
            }
            this.ws[kReadyState] = states.CLOSING;
            this.ws[kReceivedClose] = true;
            this.end();
            return;
          } else if (this.#info.opcode === opcodes.PING) {
            const body = this.consume(payloadLength);
            if (!this.ws[kReceivedClose]) {
              const frame = new WebsocketFrameSend(body);
              this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
              if (channels.ping.hasSubscribers) {
                channels.ping.publish({
                  payload: body
                });
              }
            }
            this.#state = parserStates.INFO;
            if (this.#byteOffset > 0) {
              continue;
            } else {
              callback();
              return;
            }
          } else if (this.#info.opcode === opcodes.PONG) {
            const body = this.consume(payloadLength);
            if (channels.pong.hasSubscribers) {
              channels.pong.publish({
                payload: body
              });
            }
            if (this.#byteOffset > 0) {
              continue;
            } else {
              callback();
              return;
            }
          }
        } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          this.#info.payloadLength = buffer.readUInt16BE(0);
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
          if (this.#byteOffset < 8) {
            return callback();
          }
          const buffer = this.consume(8);
          const upper = buffer.readUInt32BE(0);
          if (upper > 2 ** 31 - 1) {
            failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
            return;
          }
          const lower = buffer.readUInt32BE(4);
          this.#info.payloadLength = (upper << 8) + lower;
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.READ_DATA) {
          if (this.#byteOffset < this.#info.payloadLength) {
            return callback();
          } else if (this.#byteOffset >= this.#info.payloadLength) {
            const body = this.consume(this.#info.payloadLength);
            this.#fragments.push(body);
            if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
              const fullMessage = Buffer.concat(this.#fragments);
              websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
              this.#info = {};
              this.#fragments.length = 0;
            }
            this.#state = parserStates.INFO;
          }
        }
        if (this.#byteOffset > 0) {
          continue;
        } else {
          callback();
          break;
        }
      }
    }
    consume(n) {
      if (n > this.#byteOffset) {
        return null;
      } else if (n === 0) {
        return emptyBuffer;
      }
      if (this.#buffers[0].length === n) {
        this.#byteOffset -= this.#buffers[0].length;
        return this.#buffers.shift();
      }
      const buffer = Buffer.allocUnsafe(n);
      let offset = 0;
      while (offset !== n) {
        const next = this.#buffers[0];
        const { length } = next;
        if (length + offset === n) {
          buffer.set(this.#buffers.shift(), offset);
          break;
        } else if (length + offset > n) {
          buffer.set(next.subarray(0, n - offset), offset);
          this.#buffers[0] = next.subarray(n - offset);
          break;
        } else {
          buffer.set(this.#buffers.shift(), offset);
          offset += next.length;
        }
      }
      this.#byteOffset -= n;
      return buffer;
    }
    parseCloseBody(onlyCode, data) {
      let code;
      if (data.length >= 2) {
        code = data.readUInt16BE(0);
      }
      if (onlyCode) {
        if (!isValidStatusCode(code)) {
          return null;
        }
        return { code };
      }
      let reason = data.subarray(2);
      if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
        reason = reason.subarray(3);
      }
      if (code !== undefined && !isValidStatusCode(code)) {
        return null;
      }
      try {
        reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
      } catch {
        return null;
      }
      return { code, reason };
    }
    get closingInfo() {
      return this.#info.closeInfo;
    }
  }
  module.exports = {
    ByteParser
  };
});

// node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var { DOMException: DOMException2 } = require_constants2();
  var { URLSerializer } = require_dataURL();
  var { getGlobalOrigin } = require_global();
  var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants5();
  var {
    kWebSocketURL,
    kReadyState,
    kController,
    kBinaryType,
    kResponse,
    kSentClose,
    kByteParser
  } = require_symbols5();
  var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util7();
  var { establishWebSocketConnection } = require_connection();
  var { WebsocketFrameSend } = require_frame();
  var { ByteParser } = require_receiver();
  var { kEnumerableProperty, isBlobLike } = require_util();
  var { getGlobalDispatcher } = require_global2();
  var { types } = __require("util");
  var experimentalWarned = false;

  class WebSocket extends EventTarget {
    #events = {
      open: null,
      error: null,
      close: null,
      message: null
    };
    #bufferedAmount = 0;
    #protocol = "";
    #extensions = "";
    constructor(url, protocols = []) {
      super();
      webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
      if (!experimentalWarned) {
        experimentalWarned = true;
        process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
          code: "UNDICI-WS"
        });
      }
      const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
      url = webidl.converters.USVString(url);
      protocols = options.protocols;
      const baseURL = getGlobalOrigin();
      let urlRecord;
      try {
        urlRecord = new URL(url, baseURL);
      } catch (e) {
        throw new DOMException2(e, "SyntaxError");
      }
      if (urlRecord.protocol === "http:") {
        urlRecord.protocol = "ws:";
      } else if (urlRecord.protocol === "https:") {
        urlRecord.protocol = "wss:";
      }
      if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
        throw new DOMException2(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, "SyntaxError");
      }
      if (urlRecord.hash || urlRecord.href.endsWith("#")) {
        throw new DOMException2("Got fragment", "SyntaxError");
      }
      if (typeof protocols === "string") {
        protocols = [protocols];
      }
      if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
        throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
        throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      this[kWebSocketURL] = new URL(urlRecord.href);
      this[kController] = establishWebSocketConnection(urlRecord, protocols, this, (response) => this.#onConnectionEstablished(response), options);
      this[kReadyState] = WebSocket.CONNECTING;
      this[kBinaryType] = "blob";
    }
    close(code = undefined, reason = undefined) {
      webidl.brandCheck(this, WebSocket);
      if (code !== undefined) {
        code = webidl.converters["unsigned short"](code, { clamp: true });
      }
      if (reason !== undefined) {
        reason = webidl.converters.USVString(reason);
      }
      if (code !== undefined) {
        if (code !== 1000 && (code < 3000 || code > 4999)) {
          throw new DOMException2("invalid code", "InvalidAccessError");
        }
      }
      let reasonByteLength = 0;
      if (reason !== undefined) {
        reasonByteLength = Buffer.byteLength(reason);
        if (reasonByteLength > 123) {
          throw new DOMException2(`Reason must be less than 123 bytes; received ${reasonByteLength}`, "SyntaxError");
        }
      }
      if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {
      } else if (!isEstablished(this)) {
        failWebsocketConnection(this, "Connection was closed before it was established.");
        this[kReadyState] = WebSocket.CLOSING;
      } else if (!isClosing(this)) {
        const frame = new WebsocketFrameSend;
        if (code !== undefined && reason === undefined) {
          frame.frameData = Buffer.allocUnsafe(2);
          frame.frameData.writeUInt16BE(code, 0);
        } else if (code !== undefined && reason !== undefined) {
          frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
          frame.frameData.writeUInt16BE(code, 0);
          frame.frameData.write(reason, 2, "utf-8");
        } else {
          frame.frameData = emptyBuffer;
        }
        const socket = this[kResponse].socket;
        socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
          if (!err) {
            this[kSentClose] = true;
          }
        });
        this[kReadyState] = states.CLOSING;
      } else {
        this[kReadyState] = WebSocket.CLOSING;
      }
    }
    send(data) {
      webidl.brandCheck(this, WebSocket);
      webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
      data = webidl.converters.WebSocketSendData(data);
      if (this[kReadyState] === WebSocket.CONNECTING) {
        throw new DOMException2("Sent before connected.", "InvalidStateError");
      }
      if (!isEstablished(this) || isClosing(this)) {
        return;
      }
      const socket = this[kResponse].socket;
      if (typeof data === "string") {
        const value = Buffer.from(data);
        const frame = new WebsocketFrameSend(value);
        const buffer = frame.createFrame(opcodes.TEXT);
        this.#bufferedAmount += value.byteLength;
        socket.write(buffer, () => {
          this.#bufferedAmount -= value.byteLength;
        });
      } else if (types.isArrayBuffer(data)) {
        const value = Buffer.from(data);
        const frame = new WebsocketFrameSend(value);
        const buffer = frame.createFrame(opcodes.BINARY);
        this.#bufferedAmount += value.byteLength;
        socket.write(buffer, () => {
          this.#bufferedAmount -= value.byteLength;
        });
      } else if (ArrayBuffer.isView(data)) {
        const ab = Buffer.from(data, data.byteOffset, data.byteLength);
        const frame = new WebsocketFrameSend(ab);
        const buffer = frame.createFrame(opcodes.BINARY);
        this.#bufferedAmount += ab.byteLength;
        socket.write(buffer, () => {
          this.#bufferedAmount -= ab.byteLength;
        });
      } else if (isBlobLike(data)) {
        const frame = new WebsocketFrameSend;
        data.arrayBuffer().then((ab) => {
          const value = Buffer.from(ab);
          frame.frameData = value;
          const buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        });
      }
    }
    get readyState() {
      webidl.brandCheck(this, WebSocket);
      return this[kReadyState];
    }
    get bufferedAmount() {
      webidl.brandCheck(this, WebSocket);
      return this.#bufferedAmount;
    }
    get url() {
      webidl.brandCheck(this, WebSocket);
      return URLSerializer(this[kWebSocketURL]);
    }
    get extensions() {
      webidl.brandCheck(this, WebSocket);
      return this.#extensions;
    }
    get protocol() {
      webidl.brandCheck(this, WebSocket);
      return this.#protocol;
    }
    get onopen() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.open;
    }
    set onopen(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.open) {
        this.removeEventListener("open", this.#events.open);
      }
      if (typeof fn === "function") {
        this.#events.open = fn;
        this.addEventListener("open", fn);
      } else {
        this.#events.open = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.error) {
        this.removeEventListener("error", this.#events.error);
      }
      if (typeof fn === "function") {
        this.#events.error = fn;
        this.addEventListener("error", fn);
      } else {
        this.#events.error = null;
      }
    }
    get onclose() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.close;
    }
    set onclose(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.close) {
        this.removeEventListener("close", this.#events.close);
      }
      if (typeof fn === "function") {
        this.#events.close = fn;
        this.addEventListener("close", fn);
      } else {
        this.#events.close = null;
      }
    }
    get onmessage() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.message;
    }
    set onmessage(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.message) {
        this.removeEventListener("message", this.#events.message);
      }
      if (typeof fn === "function") {
        this.#events.message = fn;
        this.addEventListener("message", fn);
      } else {
        this.#events.message = null;
      }
    }
    get binaryType() {
      webidl.brandCheck(this, WebSocket);
      return this[kBinaryType];
    }
    set binaryType(type) {
      webidl.brandCheck(this, WebSocket);
      if (type !== "blob" && type !== "arraybuffer") {
        this[kBinaryType] = "blob";
      } else {
        this[kBinaryType] = type;
      }
    }
    #onConnectionEstablished(response) {
      this[kResponse] = response;
      const parser = new ByteParser(this);
      parser.on("drain", function onParserDrain() {
        this.ws[kResponse].socket.resume();
      });
      response.socket.ws = this;
      this[kByteParser] = parser;
      this[kReadyState] = states.OPEN;
      const extensions = response.headersList.get("sec-websocket-extensions");
      if (extensions !== null) {
        this.#extensions = extensions;
      }
      const protocol = response.headersList.get("sec-websocket-protocol");
      if (protocol !== null) {
        this.#protocol = protocol;
      }
      fireEvent("open", this);
    }
  }
  WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
  WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
  WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
  WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
  Object.defineProperties(WebSocket.prototype, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors,
    url: kEnumerableProperty,
    readyState: kEnumerableProperty,
    bufferedAmount: kEnumerableProperty,
    onopen: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onclose: kEnumerableProperty,
    close: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    binaryType: kEnumerableProperty,
    send: kEnumerableProperty,
    extensions: kEnumerableProperty,
    protocol: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(WebSocket, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors
  });
  webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(webidl.converters.DOMString);
  webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
    if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
      return webidl.converters["sequence<DOMString>"](V);
    }
    return webidl.converters.DOMString(V);
  };
  webidl.converters.WebSocketInit = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.converters["DOMString or sequence<DOMString>"],
      get defaultValue() {
        return [];
      }
    },
    {
      key: "dispatcher",
      converter: (V) => V,
      get defaultValue() {
        return getGlobalDispatcher();
      }
    },
    {
      key: "headers",
      converter: webidl.nullableConverter(webidl.converters.HeadersInit)
    }
  ]);
  webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
    if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
      return webidl.converters.WebSocketInit(V);
    }
    return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
  };
  webidl.converters.WebSocketSendData = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
        return webidl.converters.BufferSource(V);
      }
    }
    return webidl.converters.USVString(V);
  };
  module.exports = {
    WebSocket
  };
});

// node_modules/undici/index.js
var require_undici = __commonJS((exports, module) => {
  var Client = require_client();
  var Dispatcher = require_dispatcher();
  var errors = require_errors();
  var Pool = require_pool();
  var BalancedPool = require_balanced_pool();
  var Agent = require_agent();
  var util = require_util();
  var { InvalidArgumentError } = errors;
  var api = require_api();
  var buildConnector = require_connect();
  var MockClient = require_mock_client();
  var MockAgent = require_mock_agent();
  var MockPool = require_mock_pool();
  var mockErrors = require_mock_errors();
  var ProxyAgent = require_proxy_agent();
  var RetryHandler = require_RetryHandler();
  var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
  var DecoratorHandler = require_DecoratorHandler();
  var RedirectHandler = require_RedirectHandler();
  var createRedirectInterceptor = require_redirectInterceptor();
  var hasCrypto;
  try {
    __require("crypto");
    hasCrypto = true;
  } catch {
    hasCrypto = false;
  }
  Object.assign(Dispatcher.prototype, api);
  exports.Dispatcher = Dispatcher;
  exports.Client = Client;
  exports.Pool = Pool;
  exports.BalancedPool = BalancedPool;
  exports.Agent = Agent;
  exports.ProxyAgent = ProxyAgent;
  exports.RetryHandler = RetryHandler;
  exports.DecoratorHandler = DecoratorHandler;
  exports.RedirectHandler = RedirectHandler;
  exports.createRedirectInterceptor = createRedirectInterceptor;
  exports.buildConnector = buildConnector;
  exports.errors = errors;
  function makeDispatcher(fn) {
    return (url, opts, handler) => {
      if (typeof opts === "function") {
        handler = opts;
        opts = null;
      }
      if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
        throw new InvalidArgumentError("invalid url");
      }
      if (opts != null && typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (opts && opts.path != null) {
        if (typeof opts.path !== "string") {
          throw new InvalidArgumentError("invalid opts.path");
        }
        let path = opts.path;
        if (!opts.path.startsWith("/")) {
          path = `/${path}`;
        }
        url = new URL(util.parseOrigin(url).origin + path);
      } else {
        if (!opts) {
          opts = typeof url === "object" ? url : {};
        }
        url = util.parseURL(url);
      }
      const { agent, dispatcher = getGlobalDispatcher() } = opts;
      if (agent) {
        throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
      }
      return fn.call(dispatcher, {
        ...opts,
        origin: url.origin,
        path: url.search ? `${url.pathname}${url.search}` : url.pathname,
        method: opts.method || (opts.body ? "PUT" : "GET")
      }, handler);
    };
  }
  exports.setGlobalDispatcher = setGlobalDispatcher;
  exports.getGlobalDispatcher = getGlobalDispatcher;
  if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
    let fetchImpl = null;
    exports.fetch = async function fetch(resource) {
      if (!fetchImpl) {
        fetchImpl = require_fetch().fetch;
      }
      try {
        return await fetchImpl(...arguments);
      } catch (err) {
        if (typeof err === "object") {
          Error.captureStackTrace(err, this);
        }
        throw err;
      }
    };
    exports.Headers = require_headers().Headers;
    exports.Response = require_response().Response;
    exports.Request = require_request2().Request;
    exports.FormData = require_formdata().FormData;
    exports.File = require_file().File;
    exports.FileReader = require_filereader().FileReader;
    const { setGlobalOrigin, getGlobalOrigin } = require_global();
    exports.setGlobalOrigin = setGlobalOrigin;
    exports.getGlobalOrigin = getGlobalOrigin;
    const { CacheStorage } = require_cachestorage();
    const { kConstruct } = require_symbols4();
    exports.caches = new CacheStorage(kConstruct);
  }
  if (util.nodeMajor >= 16) {
    const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
    exports.deleteCookie = deleteCookie;
    exports.getCookies = getCookies;
    exports.getSetCookies = getSetCookies;
    exports.setCookie = setCookie;
    const { parseMIMEType, serializeAMimeType } = require_dataURL();
    exports.parseMIMEType = parseMIMEType;
    exports.serializeAMimeType = serializeAMimeType;
  }
  if (util.nodeMajor >= 18 && hasCrypto) {
    const { WebSocket } = require_websocket();
    exports.WebSocket = WebSocket;
  }
  exports.request = makeDispatcher(api.request);
  exports.stream = makeDispatcher(api.stream);
  exports.pipeline = makeDispatcher(api.pipeline);
  exports.connect = makeDispatcher(api.connect);
  exports.upgrade = makeDispatcher(api.upgrade);
  exports.MockClient = MockClient;
  exports.MockPool = MockPool;
  exports.MockAgent = MockAgent;
  exports.mockErrors = mockErrors;
});

// node_modules/@actions/http-client/lib/index.js
var require_lib = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = undefined;
  var http = __importStar(__require("http"));
  var https = __importStar(__require("https"));
  var pm = __importStar(require_proxy());
  var tunnel = __importStar(require_tunnel());
  var undici_1 = require_undici();
  var HttpCodes;
  (function(HttpCodes2) {
    HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
    HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
    HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
    HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
    HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
    HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
    HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
    HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
    HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
    HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
    HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
  })(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
  var Headers;
  (function(Headers2) {
    Headers2["Accept"] = "accept";
    Headers2["ContentType"] = "content-type";
  })(Headers || (exports.Headers = Headers = {}));
  var MediaTypes;
  (function(MediaTypes2) {
    MediaTypes2["ApplicationJson"] = "application/json";
  })(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
  function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : "";
  }
  exports.getProxyUrl = getProxyUrl;
  var HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
  ];
  var HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
  ];
  var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
  var ExponentialBackoffCeiling = 10;
  var ExponentialBackoffTimeSlice = 5;

  class HttpClientError extends Error {
    constructor(message, statusCode) {
      super(message);
      this.name = "HttpClientError";
      this.statusCode = statusCode;
      Object.setPrototypeOf(this, HttpClientError.prototype);
    }
  }
  exports.HttpClientError = HttpClientError;

  class HttpClientResponse {
    constructor(message) {
      this.message = message;
    }
    readBody() {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve) => __awaiter(this, undefined, undefined, function* () {
          let output = Buffer.alloc(0);
          this.message.on("data", (chunk) => {
            output = Buffer.concat([output, chunk]);
          });
          this.message.on("end", () => {
            resolve(output.toString());
          });
        }));
      });
    }
    readBodyBuffer() {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve) => __awaiter(this, undefined, undefined, function* () {
          const chunks = [];
          this.message.on("data", (chunk) => {
            chunks.push(chunk);
          });
          this.message.on("end", () => {
            resolve(Buffer.concat(chunks));
          });
        }));
      });
    }
  }
  exports.HttpClientResponse = HttpClientResponse;
  function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === "https:";
  }
  exports.isHttps = isHttps;

  class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
      this._ignoreSslError = false;
      this._allowRedirects = true;
      this._allowRedirectDowngrade = false;
      this._maxRedirects = 50;
      this._allowRetries = false;
      this._maxRetries = 1;
      this._keepAlive = false;
      this._disposed = false;
      this.userAgent = userAgent;
      this.handlers = handlers || [];
      this.requestOptions = requestOptions;
      if (requestOptions) {
        if (requestOptions.ignoreSslError != null) {
          this._ignoreSslError = requestOptions.ignoreSslError;
        }
        this._socketTimeout = requestOptions.socketTimeout;
        if (requestOptions.allowRedirects != null) {
          this._allowRedirects = requestOptions.allowRedirects;
        }
        if (requestOptions.allowRedirectDowngrade != null) {
          this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
        }
        if (requestOptions.maxRedirects != null) {
          this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
        }
        if (requestOptions.keepAlive != null) {
          this._keepAlive = requestOptions.keepAlive;
        }
        if (requestOptions.allowRetries != null) {
          this._allowRetries = requestOptions.allowRetries;
        }
        if (requestOptions.maxRetries != null) {
          this._maxRetries = requestOptions.maxRetries;
        }
      }
    }
    options(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
      });
    }
    get(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("GET", requestUrl, null, additionalHeaders || {});
      });
    }
    del(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("DELETE", requestUrl, null, additionalHeaders || {});
      });
    }
    post(requestUrl, data, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("POST", requestUrl, data, additionalHeaders || {});
      });
    }
    patch(requestUrl, data, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("PATCH", requestUrl, data, additionalHeaders || {});
      });
    }
    put(requestUrl, data, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("PUT", requestUrl, data, additionalHeaders || {});
      });
    }
    head(requestUrl, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request("HEAD", requestUrl, null, additionalHeaders || {});
      });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
      return __awaiter(this, undefined, undefined, function* () {
        return this.request(verb, requestUrl, stream, additionalHeaders);
      });
    }
    getJson(requestUrl, additionalHeaders = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        const res = yield this.get(requestUrl, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        const res = yield this.post(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        const res = yield this.put(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
      return __awaiter(this, undefined, undefined, function* () {
        const data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        const res = yield this.patch(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    request(verb, requestUrl, data, headers) {
      return __awaiter(this, undefined, undefined, function* () {
        if (this._disposed) {
          throw new Error("Client has already been disposed.");
        }
        const parsedUrl = new URL(requestUrl);
        let info = this._prepareRequest(verb, parsedUrl, headers);
        const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
        let numTries = 0;
        let response;
        do {
          response = yield this.requestRaw(info, data);
          if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
            let authenticationHandler;
            for (const handler of this.handlers) {
              if (handler.canHandleAuthentication(response)) {
                authenticationHandler = handler;
                break;
              }
            }
            if (authenticationHandler) {
              return authenticationHandler.handleAuthentication(this, info, data);
            } else {
              return response;
            }
          }
          let redirectsRemaining = this._maxRedirects;
          while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
            const redirectUrl = response.message.headers["location"];
            if (!redirectUrl) {
              break;
            }
            const parsedRedirectUrl = new URL(redirectUrl);
            if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
              throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
            }
            yield response.readBody();
            if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
              for (const header in headers) {
                if (header.toLowerCase() === "authorization") {
                  delete headers[header];
                }
              }
            }
            info = this._prepareRequest(verb, parsedRedirectUrl, headers);
            response = yield this.requestRaw(info, data);
            redirectsRemaining--;
          }
          if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
            return response;
          }
          numTries += 1;
          if (numTries < maxTries) {
            yield response.readBody();
            yield this._performExponentialBackoff(numTries);
          }
        } while (numTries < maxTries);
        return response;
      });
    }
    dispose() {
      if (this._agent) {
        this._agent.destroy();
      }
      this._disposed = true;
    }
    requestRaw(info, data) {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve, reject) => {
          function callbackForResult(err, res) {
            if (err) {
              reject(err);
            } else if (!res) {
              reject(new Error("Unknown error"));
            } else {
              resolve(res);
            }
          }
          this.requestRawWithCallback(info, data, callbackForResult);
        });
      });
    }
    requestRawWithCallback(info, data, onResult) {
      if (typeof data === "string") {
        if (!info.options.headers) {
          info.options.headers = {};
        }
        info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
      }
      let callbackCalled = false;
      function handleResult(err, res) {
        if (!callbackCalled) {
          callbackCalled = true;
          onResult(err, res);
        }
      }
      const req = info.httpModule.request(info.options, (msg) => {
        const res = new HttpClientResponse(msg);
        handleResult(undefined, res);
      });
      let socket;
      req.on("socket", (sock) => {
        socket = sock;
      });
      req.setTimeout(this._socketTimeout || 3 * 60000, () => {
        if (socket) {
          socket.end();
        }
        handleResult(new Error(`Request timeout: ${info.options.path}`));
      });
      req.on("error", function(err) {
        handleResult(err);
      });
      if (data && typeof data === "string") {
        req.write(data, "utf8");
      }
      if (data && typeof data !== "string") {
        data.on("close", function() {
          req.end();
        });
        data.pipe(req);
      } else {
        req.end();
      }
    }
    getAgent(serverUrl) {
      const parsedUrl = new URL(serverUrl);
      return this._getAgent(parsedUrl);
    }
    getAgentDispatcher(serverUrl) {
      const parsedUrl = new URL(serverUrl);
      const proxyUrl = pm.getProxyUrl(parsedUrl);
      const useProxy = proxyUrl && proxyUrl.hostname;
      if (!useProxy) {
        return;
      }
      return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
      const info = {};
      info.parsedUrl = requestUrl;
      const usingSsl = info.parsedUrl.protocol === "https:";
      info.httpModule = usingSsl ? https : http;
      const defaultPort = usingSsl ? 443 : 80;
      info.options = {};
      info.options.host = info.parsedUrl.hostname;
      info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
      info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
      info.options.method = method;
      info.options.headers = this._mergeHeaders(headers);
      if (this.userAgent != null) {
        info.options.headers["user-agent"] = this.userAgent;
      }
      info.options.agent = this._getAgent(info.parsedUrl);
      if (this.handlers) {
        for (const handler of this.handlers) {
          handler.prepareRequest(info.options);
        }
      }
      return info;
    }
    _mergeHeaders(headers) {
      if (this.requestOptions && this.requestOptions.headers) {
        return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
      }
      return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
      let clientHeader;
      if (this.requestOptions && this.requestOptions.headers) {
        clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
      }
      return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
      let agent;
      const proxyUrl = pm.getProxyUrl(parsedUrl);
      const useProxy = proxyUrl && proxyUrl.hostname;
      if (this._keepAlive && useProxy) {
        agent = this._proxyAgent;
      }
      if (!useProxy) {
        agent = this._agent;
      }
      if (agent) {
        return agent;
      }
      const usingSsl = parsedUrl.protocol === "https:";
      let maxSockets = 100;
      if (this.requestOptions) {
        maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
      }
      if (proxyUrl && proxyUrl.hostname) {
        const agentOptions = {
          maxSockets,
          keepAlive: this._keepAlive,
          proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
            proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
          }), { host: proxyUrl.hostname, port: proxyUrl.port })
        };
        let tunnelAgent;
        const overHttps = proxyUrl.protocol === "https:";
        if (usingSsl) {
          tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
        } else {
          tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
        }
        agent = tunnelAgent(agentOptions);
        this._proxyAgent = agent;
      }
      if (!agent) {
        const options = { keepAlive: this._keepAlive, maxSockets };
        agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
        this._agent = agent;
      }
      if (usingSsl && this._ignoreSslError) {
        agent.options = Object.assign(agent.options || {}, {
          rejectUnauthorized: false
        });
      }
      return agent;
    }
    _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
      let proxyAgent;
      if (this._keepAlive) {
        proxyAgent = this._proxyAgentDispatcher;
      }
      if (proxyAgent) {
        return proxyAgent;
      }
      const usingSsl = parsedUrl.protocol === "https:";
      proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
        token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}`
      }));
      this._proxyAgentDispatcher = proxyAgent;
      if (usingSsl && this._ignoreSslError) {
        proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
          rejectUnauthorized: false
        });
      }
      return proxyAgent;
    }
    _performExponentialBackoff(retryNumber) {
      return __awaiter(this, undefined, undefined, function* () {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise((resolve) => setTimeout(() => resolve(), ms));
      });
    }
    _processResponse(res, options) {
      return __awaiter(this, undefined, undefined, function* () {
        return new Promise((resolve, reject) => __awaiter(this, undefined, undefined, function* () {
          const statusCode = res.message.statusCode || 0;
          const response = {
            statusCode,
            result: null,
            headers: {}
          };
          if (statusCode === HttpCodes.NotFound) {
            resolve(response);
          }
          function dateTimeDeserializer(key, value) {
            if (typeof value === "string") {
              const a = new Date(value);
              if (!isNaN(a.valueOf())) {
                return a;
              }
            }
            return value;
          }
          let obj;
          let contents;
          try {
            contents = yield res.readBody();
            if (contents && contents.length > 0) {
              if (options && options.deserializeDates) {
                obj = JSON.parse(contents, dateTimeDeserializer);
              } else {
                obj = JSON.parse(contents);
              }
              response.result = obj;
            }
            response.headers = res.message.headers;
          } catch (err) {
          }
          if (statusCode > 299) {
            let msg;
            if (obj && obj.message) {
              msg = obj.message;
            } else if (contents && contents.length > 0) {
              msg = contents;
            } else {
              msg = `Failed request: (${statusCode})`;
            }
            const err = new HttpClientError(msg, statusCode);
            err.result = response.result;
            reject(err);
          } else {
            resolve(response);
          }
        }));
      });
    }
  }
  exports.HttpClient = HttpClient;
  var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
});

// node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = undefined;

  class BasicCredentialHandler {
    constructor(username, password) {
      this.username = username;
      this.password = password;
    }
    prepareRequest(options) {
      if (!options.headers) {
        throw Error("The request has no headers");
      }
      options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
    }
    canHandleAuthentication() {
      return false;
    }
    handleAuthentication() {
      return __awaiter(this, undefined, undefined, function* () {
        throw new Error("not implemented");
      });
    }
  }
  exports.BasicCredentialHandler = BasicCredentialHandler;

  class BearerCredentialHandler {
    constructor(token) {
      this.token = token;
    }
    prepareRequest(options) {
      if (!options.headers) {
        throw Error("The request has no headers");
      }
      options.headers["Authorization"] = `Bearer ${this.token}`;
    }
    canHandleAuthentication() {
      return false;
    }
    handleAuthentication() {
      return __awaiter(this, undefined, undefined, function* () {
        throw new Error("not implemented");
      });
    }
  }
  exports.BearerCredentialHandler = BearerCredentialHandler;

  class PersonalAccessTokenCredentialHandler {
    constructor(token) {
      this.token = token;
    }
    prepareRequest(options) {
      if (!options.headers) {
        throw Error("The request has no headers");
      }
      options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
    }
    canHandleAuthentication() {
      return false;
    }
    handleAuthentication() {
      return __awaiter(this, undefined, undefined, function* () {
        throw new Error("not implemented");
      });
    }
  }
  exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
});

// node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OidcClient = undefined;
  var http_client_1 = require_lib();
  var auth_1 = require_auth();
  var core_1 = require_core();

  class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
      const requestOptions = {
        allowRetries: allowRetry,
        maxRetries: maxRetry
      };
      return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
      const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
      if (!token) {
        throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
      }
      return token;
    }
    static getIDTokenUrl() {
      const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
      if (!runtimeUrl) {
        throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
      }
      return runtimeUrl;
    }
    static getCall(id_token_url) {
      var _a;
      return __awaiter(this, undefined, undefined, function* () {
        const httpclient = OidcClient.createHttpClient();
        const res = yield httpclient.getJson(id_token_url).catch((error) => {
          throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error.statusCode}
 
        Error Message: ${error.message}`);
        });
        const id_token = (_a = res.result) === null || _a === undefined ? undefined : _a.value;
        if (!id_token) {
          throw new Error("Response json body do not have ID Token field");
        }
        return id_token;
      });
    }
    static getIDToken(audience) {
      return __awaiter(this, undefined, undefined, function* () {
        try {
          let id_token_url = OidcClient.getIDTokenUrl();
          if (audience) {
            const encodedAudience = encodeURIComponent(audience);
            id_token_url = `${id_token_url}&audience=${encodedAudience}`;
          }
          (0, core_1.debug)(`ID token url is ${id_token_url}`);
          const id_token = yield OidcClient.getCall(id_token_url);
          (0, core_1.setSecret)(id_token);
          return id_token;
        } catch (error) {
          throw new Error(`Error message: ${error.message}`);
        }
      });
    }
  }
  exports.OidcClient = OidcClient;
});

// node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = undefined;
  var os_1 = __require("os");
  var fs_1 = __require("fs");
  var { access, appendFile, writeFile } = fs_1.promises;
  exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
  exports.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";

  class Summary {
    constructor() {
      this._buffer = "";
    }
    filePath() {
      return __awaiter(this, undefined, undefined, function* () {
        if (this._filePath) {
          return this._filePath;
        }
        const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
        if (!pathFromEnv) {
          throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
        }
        try {
          yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
        } catch (_a) {
          throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
        }
        this._filePath = pathFromEnv;
        return this._filePath;
      });
    }
    wrap(tag, content, attrs = {}) {
      const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
      if (!content) {
        return `<${tag}${htmlAttrs}>`;
      }
      return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    write(options) {
      return __awaiter(this, undefined, undefined, function* () {
        const overwrite = !!(options === null || options === undefined ? undefined : options.overwrite);
        const filePath = yield this.filePath();
        const writeFunc = overwrite ? writeFile : appendFile;
        yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
        return this.emptyBuffer();
      });
    }
    clear() {
      return __awaiter(this, undefined, undefined, function* () {
        return this.emptyBuffer().write({ overwrite: true });
      });
    }
    stringify() {
      return this._buffer;
    }
    isEmptyBuffer() {
      return this._buffer.length === 0;
    }
    emptyBuffer() {
      this._buffer = "";
      return this;
    }
    addRaw(text, addEOL = false) {
      this._buffer += text;
      return addEOL ? this.addEOL() : this;
    }
    addEOL() {
      return this.addRaw(os_1.EOL);
    }
    addCodeBlock(code, lang) {
      const attrs = Object.assign({}, lang && { lang });
      const element = this.wrap("pre", this.wrap("code", code), attrs);
      return this.addRaw(element).addEOL();
    }
    addList(items, ordered = false) {
      const tag = ordered ? "ol" : "ul";
      const listItems = items.map((item) => this.wrap("li", item)).join("");
      const element = this.wrap(tag, listItems);
      return this.addRaw(element).addEOL();
    }
    addTable(rows) {
      const tableBody = rows.map((row) => {
        const cells = row.map((cell) => {
          if (typeof cell === "string") {
            return this.wrap("td", cell);
          }
          const { header, data, colspan, rowspan } = cell;
          const tag = header ? "th" : "td";
          const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
          return this.wrap(tag, data, attrs);
        }).join("");
        return this.wrap("tr", cells);
      }).join("");
      const element = this.wrap("table", tableBody);
      return this.addRaw(element).addEOL();
    }
    addDetails(label, content) {
      const element = this.wrap("details", this.wrap("summary", label) + content);
      return this.addRaw(element).addEOL();
    }
    addImage(src, alt, options) {
      const { width, height } = options || {};
      const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
      const element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
      return this.addRaw(element).addEOL();
    }
    addHeading(text, level) {
      const tag = `h${level}`;
      const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
      const element = this.wrap(allowedTag, text);
      return this.addRaw(element).addEOL();
    }
    addSeparator() {
      const element = this.wrap("hr", null);
      return this.addRaw(element).addEOL();
    }
    addBreak() {
      const element = this.wrap("br", null);
      return this.addRaw(element).addEOL();
    }
    addQuote(text, cite) {
      const attrs = Object.assign({}, cite && { cite });
      const element = this.wrap("blockquote", text, attrs);
      return this.addRaw(element).addEOL();
    }
    addLink(text, href) {
      const element = this.wrap("a", text, { href });
      return this.addRaw(element).addEOL();
    }
  }
  var _summary = new Summary;
  exports.markdownSummary = _summary;
  exports.summary = _summary;
});

// node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = undefined;
  var path = __importStar(__require("path"));
  function toPosixPath(pth) {
    return pth.replace(/[\\]/g, "/");
  }
  exports.toPosixPath = toPosixPath;
  function toWin32Path(pth) {
    return pth.replace(/[/]/g, "\\");
  }
  exports.toWin32Path = toWin32Path;
  function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path.sep);
  }
  exports.toPlatformPath = toPlatformPath;
});

// node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readlink = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = undefined;
  var fs = __importStar(__require("fs"));
  var path = __importStar(__require("path"));
  _a = fs.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.open = _a.open, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rm = _a.rm, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
  exports.IS_WINDOWS = process.platform === "win32";
  exports.UV_FS_O_EXLOCK = 268435456;
  exports.READONLY = fs.constants.O_RDONLY;
  function exists(fsPath) {
    return __awaiter(this, undefined, undefined, function* () {
      try {
        yield exports.stat(fsPath);
      } catch (err) {
        if (err.code === "ENOENT") {
          return false;
        }
        throw err;
      }
      return true;
    });
  }
  exports.exists = exists;
  function isDirectory(fsPath, useStat = false) {
    return __awaiter(this, undefined, undefined, function* () {
      const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);
      return stats.isDirectory();
    });
  }
  exports.isDirectory = isDirectory;
  function isRooted(p) {
    p = normalizeSeparators(p);
    if (!p) {
      throw new Error('isRooted() parameter "p" cannot be empty');
    }
    if (exports.IS_WINDOWS) {
      return p.startsWith("\\") || /^[A-Z]:/i.test(p);
    }
    return p.startsWith("/");
  }
  exports.isRooted = isRooted;
  function tryGetExecutablePath(filePath, extensions) {
    return __awaiter(this, undefined, undefined, function* () {
      let stats = undefined;
      try {
        stats = yield exports.stat(filePath);
      } catch (err) {
        if (err.code !== "ENOENT") {
          console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
        }
      }
      if (stats && stats.isFile()) {
        if (exports.IS_WINDOWS) {
          const upperExt = path.extname(filePath).toUpperCase();
          if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
            return filePath;
          }
        } else {
          if (isUnixExecutable(stats)) {
            return filePath;
          }
        }
      }
      const originalFilePath = filePath;
      for (const extension of extensions) {
        filePath = originalFilePath + extension;
        stats = undefined;
        try {
          stats = yield exports.stat(filePath);
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
        }
        if (stats && stats.isFile()) {
          if (exports.IS_WINDOWS) {
            try {
              const directory = path.dirname(filePath);
              const upperName = path.basename(filePath).toUpperCase();
              for (const actualName of yield exports.readdir(directory)) {
                if (upperName === actualName.toUpperCase()) {
                  filePath = path.join(directory, actualName);
                  break;
                }
              }
            } catch (err) {
              console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
            }
            return filePath;
          } else {
            if (isUnixExecutable(stats)) {
              return filePath;
            }
          }
        }
      }
      return "";
    });
  }
  exports.tryGetExecutablePath = tryGetExecutablePath;
  function normalizeSeparators(p) {
    p = p || "";
    if (exports.IS_WINDOWS) {
      p = p.replace(/\//g, "\\");
      return p.replace(/\\\\+/g, "\\");
    }
    return p.replace(/\/\/+/g, "/");
  }
  function isUnixExecutable(stats) {
    return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
  }
  function getCmdPath() {
    var _a2;
    return (_a2 = process.env["COMSPEC"]) !== null && _a2 !== undefined ? _a2 : `cmd.exe`;
  }
  exports.getCmdPath = getCmdPath;
});

// node_modules/@actions/io/lib/io.js
var require_io = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = undefined;
  var assert_1 = __require("assert");
  var path = __importStar(__require("path"));
  var ioUtil = __importStar(require_io_util());
  function cp(source, dest, options = {}) {
    return __awaiter(this, undefined, undefined, function* () {
      const { force, recursive, copySourceDirectory } = readCopyOptions(options);
      const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
      if (destStat && destStat.isFile() && !force) {
        return;
      }
      const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path.join(dest, path.basename(source)) : dest;
      if (!(yield ioUtil.exists(source))) {
        throw new Error(`no such file or directory: ${source}`);
      }
      const sourceStat = yield ioUtil.stat(source);
      if (sourceStat.isDirectory()) {
        if (!recursive) {
          throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
        } else {
          yield cpDirRecursive(source, newDest, 0, force);
        }
      } else {
        if (path.relative(source, newDest) === "") {
          throw new Error(`'${newDest}' and '${source}' are the same file`);
        }
        yield copyFile(source, newDest, force);
      }
    });
  }
  exports.cp = cp;
  function mv(source, dest, options = {}) {
    return __awaiter(this, undefined, undefined, function* () {
      if (yield ioUtil.exists(dest)) {
        let destExists = true;
        if (yield ioUtil.isDirectory(dest)) {
          dest = path.join(dest, path.basename(source));
          destExists = yield ioUtil.exists(dest);
        }
        if (destExists) {
          if (options.force == null || options.force) {
            yield rmRF(dest);
          } else {
            throw new Error("Destination already exists");
          }
        }
      }
      yield mkdirP(path.dirname(dest));
      yield ioUtil.rename(source, dest);
    });
  }
  exports.mv = mv;
  function rmRF(inputPath) {
    return __awaiter(this, undefined, undefined, function* () {
      if (ioUtil.IS_WINDOWS) {
        if (/[*"<>|]/.test(inputPath)) {
          throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
        }
      }
      try {
        yield ioUtil.rm(inputPath, {
          force: true,
          maxRetries: 3,
          recursive: true,
          retryDelay: 300
        });
      } catch (err) {
        throw new Error(`File was unable to be removed ${err}`);
      }
    });
  }
  exports.rmRF = rmRF;
  function mkdirP(fsPath) {
    return __awaiter(this, undefined, undefined, function* () {
      assert_1.ok(fsPath, "a path argument must be provided");
      yield ioUtil.mkdir(fsPath, { recursive: true });
    });
  }
  exports.mkdirP = mkdirP;
  function which(tool, check) {
    return __awaiter(this, undefined, undefined, function* () {
      if (!tool) {
        throw new Error("parameter 'tool' is required");
      }
      if (check) {
        const result = yield which(tool, false);
        if (!result) {
          if (ioUtil.IS_WINDOWS) {
            throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
          } else {
            throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
          }
        }
        return result;
      }
      const matches = yield findInPath(tool);
      if (matches && matches.length > 0) {
        return matches[0];
      }
      return "";
    });
  }
  exports.which = which;
  function findInPath(tool) {
    return __awaiter(this, undefined, undefined, function* () {
      if (!tool) {
        throw new Error("parameter 'tool' is required");
      }
      const extensions = [];
      if (ioUtil.IS_WINDOWS && process.env["PATHEXT"]) {
        for (const extension of process.env["PATHEXT"].split(path.delimiter)) {
          if (extension) {
            extensions.push(extension);
          }
        }
      }
      if (ioUtil.isRooted(tool)) {
        const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
        if (filePath) {
          return [filePath];
        }
        return [];
      }
      if (tool.includes(path.sep)) {
        return [];
      }
      const directories = [];
      if (process.env.PATH) {
        for (const p of process.env.PATH.split(path.delimiter)) {
          if (p) {
            directories.push(p);
          }
        }
      }
      const matches = [];
      for (const directory of directories) {
        const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);
        if (filePath) {
          matches.push(filePath);
        }
      }
      return matches;
    });
  }
  exports.findInPath = findInPath;
  function readCopyOptions(options) {
    const force = options.force == null ? true : options.force;
    const recursive = Boolean(options.recursive);
    const copySourceDirectory = options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory);
    return { force, recursive, copySourceDirectory };
  }
  function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
    return __awaiter(this, undefined, undefined, function* () {
      if (currentDepth >= 255)
        return;
      currentDepth++;
      yield mkdirP(destDir);
      const files = yield ioUtil.readdir(sourceDir);
      for (const fileName of files) {
        const srcFile = `${sourceDir}/${fileName}`;
        const destFile = `${destDir}/${fileName}`;
        const srcFileStat = yield ioUtil.lstat(srcFile);
        if (srcFileStat.isDirectory()) {
          yield cpDirRecursive(srcFile, destFile, currentDepth, force);
        } else {
          yield copyFile(srcFile, destFile, force);
        }
      }
      yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
    });
  }
  function copyFile(srcFile, destFile, force) {
    return __awaiter(this, undefined, undefined, function* () {
      if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
        try {
          yield ioUtil.lstat(destFile);
          yield ioUtil.unlink(destFile);
        } catch (e) {
          if (e.code === "EPERM") {
            yield ioUtil.chmod(destFile, "0666");
            yield ioUtil.unlink(destFile);
          }
        }
        const symlinkFull = yield ioUtil.readlink(srcFile);
        yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
      } else if (!(yield ioUtil.exists(destFile)) || force) {
        yield ioUtil.copyFile(srcFile, destFile);
      }
    });
  }
});

// node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.argStringToArray = exports.ToolRunner = undefined;
  var os = __importStar(__require("os"));
  var events = __importStar(__require("events"));
  var child = __importStar(__require("child_process"));
  var path = __importStar(__require("path"));
  var io = __importStar(require_io());
  var ioUtil = __importStar(require_io_util());
  var timers_1 = __require("timers");
  var IS_WINDOWS = process.platform === "win32";

  class ToolRunner extends events.EventEmitter {
    constructor(toolPath, args, options) {
      super();
      if (!toolPath) {
        throw new Error("Parameter 'toolPath' cannot be null or empty.");
      }
      this.toolPath = toolPath;
      this.args = args || [];
      this.options = options || {};
    }
    _debug(message) {
      if (this.options.listeners && this.options.listeners.debug) {
        this.options.listeners.debug(message);
      }
    }
    _getCommandString(options, noPrefix) {
      const toolPath = this._getSpawnFileName();
      const args = this._getSpawnArgs(options);
      let cmd = noPrefix ? "" : "[command]";
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          cmd += toolPath;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        } else if (options.windowsVerbatimArguments) {
          cmd += `"${toolPath}"`;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        } else {
          cmd += this._windowsQuoteCmdArg(toolPath);
          for (const a of args) {
            cmd += ` ${this._windowsQuoteCmdArg(a)}`;
          }
        }
      } else {
        cmd += toolPath;
        for (const a of args) {
          cmd += ` ${a}`;
        }
      }
      return cmd;
    }
    _processLineBuffer(data, strBuffer, onLine) {
      try {
        let s = strBuffer + data.toString();
        let n = s.indexOf(os.EOL);
        while (n > -1) {
          const line = s.substring(0, n);
          onLine(line);
          s = s.substring(n + os.EOL.length);
          n = s.indexOf(os.EOL);
        }
        return s;
      } catch (err) {
        this._debug(`error processing line. Failed with error ${err}`);
        return "";
      }
    }
    _getSpawnFileName() {
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          return process.env["COMSPEC"] || "cmd.exe";
        }
      }
      return this.toolPath;
    }
    _getSpawnArgs(options) {
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
          for (const a of this.args) {
            argline += " ";
            argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
          }
          argline += '"';
          return [argline];
        }
      }
      return this.args;
    }
    _endsWith(str, end) {
      return str.endsWith(end);
    }
    _isCmdFile() {
      const upperToolPath = this.toolPath.toUpperCase();
      return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
    }
    _windowsQuoteCmdArg(arg) {
      if (!this._isCmdFile()) {
        return this._uvQuoteCmdArg(arg);
      }
      if (!arg) {
        return '""';
      }
      const cmdSpecialChars = [
        " ",
        "\t",
        "&",
        "(",
        ")",
        "[",
        "]",
        "{",
        "}",
        "^",
        "=",
        ";",
        "!",
        "'",
        "+",
        ",",
        "`",
        "~",
        "|",
        "<",
        ">",
        '"'
      ];
      let needsQuotes = false;
      for (const char of arg) {
        if (cmdSpecialChars.some((x) => x === char)) {
          needsQuotes = true;
          break;
        }
      }
      if (!needsQuotes) {
        return arg;
      }
      let reverse = '"';
      let quoteHit = true;
      for (let i = arg.length;i > 0; i--) {
        reverse += arg[i - 1];
        if (quoteHit && arg[i - 1] === "\\") {
          reverse += "\\";
        } else if (arg[i - 1] === '"') {
          quoteHit = true;
          reverse += '"';
        } else {
          quoteHit = false;
        }
      }
      reverse += '"';
      return reverse.split("").reverse().join("");
    }
    _uvQuoteCmdArg(arg) {
      if (!arg) {
        return '""';
      }
      if (!arg.includes(" ") && !arg.includes("\t") && !arg.includes('"')) {
        return arg;
      }
      if (!arg.includes('"') && !arg.includes("\\")) {
        return `"${arg}"`;
      }
      let reverse = '"';
      let quoteHit = true;
      for (let i = arg.length;i > 0; i--) {
        reverse += arg[i - 1];
        if (quoteHit && arg[i - 1] === "\\") {
          reverse += "\\";
        } else if (arg[i - 1] === '"') {
          quoteHit = true;
          reverse += "\\";
        } else {
          quoteHit = false;
        }
      }
      reverse += '"';
      return reverse.split("").reverse().join("");
    }
    _cloneExecOptions(options) {
      options = options || {};
      const result = {
        cwd: options.cwd || process.cwd(),
        env: options.env || process.env,
        silent: options.silent || false,
        windowsVerbatimArguments: options.windowsVerbatimArguments || false,
        failOnStdErr: options.failOnStdErr || false,
        ignoreReturnCode: options.ignoreReturnCode || false,
        delay: options.delay || 1e4
      };
      result.outStream = options.outStream || process.stdout;
      result.errStream = options.errStream || process.stderr;
      return result;
    }
    _getSpawnOptions(options, toolPath) {
      options = options || {};
      const result = {};
      result.cwd = options.cwd;
      result.env = options.env;
      result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
      if (options.windowsVerbatimArguments) {
        result.argv0 = `"${toolPath}"`;
      }
      return result;
    }
    exec() {
      return __awaiter(this, undefined, undefined, function* () {
        if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) {
          this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
        }
        this.toolPath = yield io.which(this.toolPath, true);
        return new Promise((resolve, reject) => __awaiter(this, undefined, undefined, function* () {
          this._debug(`exec tool: ${this.toolPath}`);
          this._debug("arguments:");
          for (const arg of this.args) {
            this._debug(`   ${arg}`);
          }
          const optionsNonNull = this._cloneExecOptions(this.options);
          if (!optionsNonNull.silent && optionsNonNull.outStream) {
            optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
          }
          const state = new ExecState(optionsNonNull, this.toolPath);
          state.on("debug", (message) => {
            this._debug(message);
          });
          if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
            return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
          }
          const fileName = this._getSpawnFileName();
          const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
          let stdbuffer = "";
          if (cp.stdout) {
            cp.stdout.on("data", (data) => {
              if (this.options.listeners && this.options.listeners.stdout) {
                this.options.listeners.stdout(data);
              }
              if (!optionsNonNull.silent && optionsNonNull.outStream) {
                optionsNonNull.outStream.write(data);
              }
              stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                if (this.options.listeners && this.options.listeners.stdline) {
                  this.options.listeners.stdline(line);
                }
              });
            });
          }
          let errbuffer = "";
          if (cp.stderr) {
            cp.stderr.on("data", (data) => {
              state.processStderr = true;
              if (this.options.listeners && this.options.listeners.stderr) {
                this.options.listeners.stderr(data);
              }
              if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                const s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                s.write(data);
              }
              errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                if (this.options.listeners && this.options.listeners.errline) {
                  this.options.listeners.errline(line);
                }
              });
            });
          }
          cp.on("error", (err) => {
            state.processError = err.message;
            state.processExited = true;
            state.processClosed = true;
            state.CheckComplete();
          });
          cp.on("exit", (code) => {
            state.processExitCode = code;
            state.processExited = true;
            this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
            state.CheckComplete();
          });
          cp.on("close", (code) => {
            state.processExitCode = code;
            state.processExited = true;
            state.processClosed = true;
            this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
            state.CheckComplete();
          });
          state.on("done", (error, exitCode) => {
            if (stdbuffer.length > 0) {
              this.emit("stdline", stdbuffer);
            }
            if (errbuffer.length > 0) {
              this.emit("errline", errbuffer);
            }
            cp.removeAllListeners();
            if (error) {
              reject(error);
            } else {
              resolve(exitCode);
            }
          });
          if (this.options.input) {
            if (!cp.stdin) {
              throw new Error("child process missing stdin");
            }
            cp.stdin.end(this.options.input);
          }
        }));
      });
    }
  }
  exports.ToolRunner = ToolRunner;
  function argStringToArray(argString) {
    const args = [];
    let inQuotes = false;
    let escaped = false;
    let arg = "";
    function append(c) {
      if (escaped && c !== '"') {
        arg += "\\";
      }
      arg += c;
      escaped = false;
    }
    for (let i = 0;i < argString.length; i++) {
      const c = argString.charAt(i);
      if (c === '"') {
        if (!escaped) {
          inQuotes = !inQuotes;
        } else {
          append(c);
        }
        continue;
      }
      if (c === "\\" && escaped) {
        append(c);
        continue;
      }
      if (c === "\\" && inQuotes) {
        escaped = true;
        continue;
      }
      if (c === " " && !inQuotes) {
        if (arg.length > 0) {
          args.push(arg);
          arg = "";
        }
        continue;
      }
      append(c);
    }
    if (arg.length > 0) {
      args.push(arg.trim());
    }
    return args;
  }
  exports.argStringToArray = argStringToArray;

  class ExecState extends events.EventEmitter {
    constructor(options, toolPath) {
      super();
      this.processClosed = false;
      this.processError = "";
      this.processExitCode = 0;
      this.processExited = false;
      this.processStderr = false;
      this.delay = 1e4;
      this.done = false;
      this.timeout = null;
      if (!toolPath) {
        throw new Error("toolPath must not be empty");
      }
      this.options = options;
      this.toolPath = toolPath;
      if (options.delay) {
        this.delay = options.delay;
      }
    }
    CheckComplete() {
      if (this.done) {
        return;
      }
      if (this.processClosed) {
        this._setResult();
      } else if (this.processExited) {
        this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);
      }
    }
    _debug(message) {
      this.emit("debug", message);
    }
    _setResult() {
      let error;
      if (this.processExited) {
        if (this.processError) {
          error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
        } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
          error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
        } else if (this.processStderr && this.options.failOnStdErr) {
          error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
        }
      }
      if (this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }
      this.done = true;
      this.emit("done", error, this.processExitCode);
    }
    static HandleTimeout(state) {
      if (state.done) {
        return;
      }
      if (!state.processClosed && state.processExited) {
        const message = `The STDIO streams did not close within ${state.delay / 1000} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
        state._debug(message);
      }
      state._setResult();
    }
  }
});

// node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getExecOutput = exports.exec = undefined;
  var string_decoder_1 = __require("string_decoder");
  var tr = __importStar(require_toolrunner());
  function exec(commandLine, args, options) {
    return __awaiter(this, undefined, undefined, function* () {
      const commandArgs = tr.argStringToArray(commandLine);
      if (commandArgs.length === 0) {
        throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
      }
      const toolPath = commandArgs[0];
      args = commandArgs.slice(1).concat(args || []);
      const runner = new tr.ToolRunner(toolPath, args, options);
      return runner.exec();
    });
  }
  exports.exec = exec;
  function getExecOutput(commandLine, args, options) {
    var _a, _b;
    return __awaiter(this, undefined, undefined, function* () {
      let stdout = "";
      let stderr = "";
      const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
      const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
      const originalStdoutListener = (_a = options === null || options === undefined ? undefined : options.listeners) === null || _a === undefined ? undefined : _a.stdout;
      const originalStdErrListener = (_b = options === null || options === undefined ? undefined : options.listeners) === null || _b === undefined ? undefined : _b.stderr;
      const stdErrListener = (data) => {
        stderr += stderrDecoder.write(data);
        if (originalStdErrListener) {
          originalStdErrListener(data);
        }
      };
      const stdOutListener = (data) => {
        stdout += stdoutDecoder.write(data);
        if (originalStdoutListener) {
          originalStdoutListener(data);
        }
      };
      const listeners = Object.assign(Object.assign({}, options === null || options === undefined ? undefined : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });
      const exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
      stdout += stdoutDecoder.end();
      stderr += stderrDecoder.end();
      return {
        exitCode,
        stdout,
        stderr
      };
    });
  }
  exports.getExecOutput = getExecOutput;
});

// node_modules/@actions/core/lib/platform.js
var require_platform = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getDetails = exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = undefined;
  var os_1 = __importDefault(__require("os"));
  var exec = __importStar(require_exec());
  var getWindowsInfo = () => __awaiter(undefined, undefined, undefined, function* () {
    const { stdout: version } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', undefined, {
      silent: true
    });
    const { stdout: name } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', undefined, {
      silent: true
    });
    return {
      name: name.trim(),
      version: version.trim()
    };
  });
  var getMacOsInfo = () => __awaiter(undefined, undefined, undefined, function* () {
    var _a, _b, _c, _d;
    const { stdout } = yield exec.getExecOutput("sw_vers", undefined, {
      silent: true
    });
    const version = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === undefined ? undefined : _a[1]) !== null && _b !== undefined ? _b : "";
    const name = (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === undefined ? undefined : _c[1]) !== null && _d !== undefined ? _d : "";
    return {
      name,
      version
    };
  });
  var getLinuxInfo = () => __awaiter(undefined, undefined, undefined, function* () {
    const { stdout } = yield exec.getExecOutput("lsb_release", ["-i", "-r", "-s"], {
      silent: true
    });
    const [name, version] = stdout.trim().split(`
`);
    return {
      name,
      version
    };
  });
  exports.platform = os_1.default.platform();
  exports.arch = os_1.default.arch();
  exports.isWindows = exports.platform === "win32";
  exports.isMacOS = exports.platform === "darwin";
  exports.isLinux = exports.platform === "linux";
  function getDetails() {
    return __awaiter(this, undefined, undefined, function* () {
      return Object.assign(Object.assign({}, yield exports.isWindows ? getWindowsInfo() : exports.isMacOS ? getMacOsInfo() : getLinuxInfo()), {
        platform: exports.platform,
        arch: exports.arch,
        isWindows: exports.isWindows,
        isMacOS: exports.isMacOS,
        isLinux: exports.isLinux
      });
    });
  }
  exports.getDetails = getDetails;
});

// node_modules/@actions/core/lib/core.js
var require_core = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = undefined;
  var command_1 = require_command();
  var file_command_1 = require_file_command();
  var utils_1 = require_utils();
  var os = __importStar(__require("os"));
  var path = __importStar(__require("path"));
  var oidc_utils_1 = require_oidc_utils();
  var ExitCode;
  (function(ExitCode2) {
    ExitCode2[ExitCode2["Success"] = 0] = "Success";
    ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
  })(ExitCode || (exports.ExitCode = ExitCode = {}));
  function exportVariable(name, val) {
    const convertedVal = (0, utils_1.toCommandValue)(val);
    process.env[name] = convertedVal;
    const filePath = process.env["GITHUB_ENV"] || "";
    if (filePath) {
      return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name, val));
    }
    (0, command_1.issueCommand)("set-env", { name }, convertedVal);
  }
  exports.exportVariable = exportVariable;
  function setSecret(secret) {
    (0, command_1.issueCommand)("add-mask", {}, secret);
  }
  exports.setSecret = setSecret;
  function addPath(inputPath) {
    const filePath = process.env["GITHUB_PATH"] || "";
    if (filePath) {
      (0, file_command_1.issueFileCommand)("PATH", inputPath);
    } else {
      (0, command_1.issueCommand)("add-path", {}, inputPath);
    }
    process.env["PATH"] = `${inputPath}${path.delimiter}${process.env["PATH"]}`;
  }
  exports.addPath = addPath;
  function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
    if (options && options.required && !val) {
      throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
      return val;
    }
    return val.trim();
  }
  exports.getInput = getInput;
  function getMultilineInput(name, options) {
    const inputs = getInput(name, options).split(`
`).filter((x) => x !== "");
    if (options && options.trimWhitespace === false) {
      return inputs;
    }
    return inputs.map((input) => input.trim());
  }
  exports.getMultilineInput = getMultilineInput;
  function getBooleanInput(name, options) {
    const trueValue = ["true", "True", "TRUE"];
    const falseValue = ["false", "False", "FALSE"];
    const val = getInput(name, options);
    if (trueValue.includes(val))
      return true;
    if (falseValue.includes(val))
      return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}
` + `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
  }
  exports.getBooleanInput = getBooleanInput;
  function setOutput(name, value) {
    const filePath = process.env["GITHUB_OUTPUT"] || "";
    if (filePath) {
      return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name, value));
    }
    process.stdout.write(os.EOL);
    (0, command_1.issueCommand)("set-output", { name }, (0, utils_1.toCommandValue)(value));
  }
  exports.setOutput = setOutput;
  function setCommandEcho(enabled) {
    (0, command_1.issue)("echo", enabled ? "on" : "off");
  }
  exports.setCommandEcho = setCommandEcho;
  function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
  }
  exports.setFailed = setFailed;
  function isDebug() {
    return process.env["RUNNER_DEBUG"] === "1";
  }
  exports.isDebug = isDebug;
  function debug(message) {
    (0, command_1.issueCommand)("debug", {}, message);
  }
  exports.debug = debug;
  function error(message, properties = {}) {
    (0, command_1.issueCommand)("error", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
  }
  exports.error = error;
  function warning(message, properties = {}) {
    (0, command_1.issueCommand)("warning", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
  }
  exports.warning = warning;
  function notice(message, properties = {}) {
    (0, command_1.issueCommand)("notice", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
  }
  exports.notice = notice;
  function info(message) {
    process.stdout.write(message + os.EOL);
  }
  exports.info = info;
  function startGroup(name) {
    (0, command_1.issue)("group", name);
  }
  exports.startGroup = startGroup;
  function endGroup() {
    (0, command_1.issue)("endgroup");
  }
  exports.endGroup = endGroup;
  function group(name, fn) {
    return __awaiter(this, undefined, undefined, function* () {
      startGroup(name);
      let result;
      try {
        result = yield fn();
      } finally {
        endGroup();
      }
      return result;
    });
  }
  exports.group = group;
  function saveState(name, value) {
    const filePath = process.env["GITHUB_STATE"] || "";
    if (filePath) {
      return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name, value));
    }
    (0, command_1.issueCommand)("save-state", { name }, (0, utils_1.toCommandValue)(value));
  }
  exports.saveState = saveState;
  function getState(name) {
    return process.env[`STATE_${name}`] || "";
  }
  exports.getState = getState;
  function getIDToken(aud) {
    return __awaiter(this, undefined, undefined, function* () {
      return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
  }
  exports.getIDToken = getIDToken;
  var summary_1 = require_summary();
  Object.defineProperty(exports, "summary", { enumerable: true, get: function() {
    return summary_1.summary;
  } });
  var summary_2 = require_summary();
  Object.defineProperty(exports, "markdownSummary", { enumerable: true, get: function() {
    return summary_2.markdownSummary;
  } });
  var path_utils_1 = require_path_utils();
  Object.defineProperty(exports, "toPosixPath", { enumerable: true, get: function() {
    return path_utils_1.toPosixPath;
  } });
  Object.defineProperty(exports, "toWin32Path", { enumerable: true, get: function() {
    return path_utils_1.toWin32Path;
  } });
  Object.defineProperty(exports, "toPlatformPath", { enumerable: true, get: function() {
    return path_utils_1.toPlatformPath;
  } });
  exports.platform = __importStar(require_platform());
});

// node_modules/dotenv/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "16.5.0",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      pretest: "npm run lint && npm run dts-check",
      test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
      "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    homepage: "https://github.com/motdotla/dotenv#readme",
    funding: "https://dotenvx.com",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@types/node": "^18.11.3",
      decache: "^4.6.2",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-version": "^9.5.0",
      tap: "^19.2.0",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// node_modules/dotenv/lib/main.js
var require_main2 = __commonJS((exports, module) => {
  var fs = __require("fs");
  var path = __require("path");
  var os = __require("os");
  var crypto = __require("crypto");
  var packageJson = require_package();
  var version = packageJson.version;
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  function parse(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, `
`);
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, `
`);
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  }
  function _parseVault(options) {
    const vaultPath = _vaultPath(options);
    const result = DotenvModule.configDotenv({ path: vaultPath });
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0;i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error) {
        if (i + 1 >= length) {
          throw error;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  }
  function _warn(message) {
    console.log(`[dotenv@${version}][WARN] ${message}`);
  }
  function _debug(message) {
    console.log(`[dotenv@${version}][DEBUG] ${message}`);
  }
  function _dotenvKey(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  }
  function _instructions(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error) {
      if (error.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  }
  function _vaultPath(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          if (fs.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
    }
    if (fs.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  }
  function _resolveHome(envPath) {
    return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
  }
  function _configVault(options) {
    const debug = Boolean(options && options.debug);
    if (debug) {
      _debug("Loading env from encrypted .env.vault");
    }
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  }
  function configDotenv(options) {
    const dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    const debug = Boolean(options && options.debug);
    if (options && options.encoding) {
      encoding = options.encoding;
    } else {
      if (debug) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPaths = [dotenvPath];
    if (options && options.path) {
      if (!Array.isArray(options.path)) {
        optionPaths = [_resolveHome(options.path)];
      } else {
        optionPaths = [];
        for (const filepath of options.path) {
          optionPaths.push(_resolveHome(filepath));
        }
      }
    }
    let lastError;
    const parsedAll = {};
    for (const path2 of optionPaths) {
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
        DotenvModule.populate(parsedAll, parsed, options);
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${path2} ${e.message}`);
        }
        lastError = e;
      }
    }
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsedAll, options);
    if (lastError) {
      return { parsed: parsedAll, error: lastError };
    } else {
      return { parsed: parsedAll };
    }
  }
  function config(options) {
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  }
  function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error) {
      const isRange = error instanceof RangeError;
      const invalidKeyLength = error.message === "Invalid key length";
      const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error;
      }
    }
  }
  function populate(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
        }
        if (debug) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
      }
    }
  }
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config,
    decrypt,
    parse,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS((exports) => {
  var ALIAS = Symbol.for("yaml.alias");
  var DOC = Symbol.for("yaml.document");
  var MAP = Symbol.for("yaml.map");
  var PAIR = Symbol.for("yaml.pair");
  var SCALAR = Symbol.for("yaml.scalar");
  var SEQ = Symbol.for("yaml.seq");
  var NODE_TYPE = Symbol.for("yaml.node.type");
  var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
  var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
  var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
  var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
  var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
  var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
  function isCollection(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case MAP:
        case SEQ:
          return true;
      }
    return false;
  }
  function isNode(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case ALIAS:
        case MAP:
        case SCALAR:
        case SEQ:
          return true;
      }
    return false;
  }
  var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
  exports.ALIAS = ALIAS;
  exports.DOC = DOC;
  exports.MAP = MAP;
  exports.NODE_TYPE = NODE_TYPE;
  exports.PAIR = PAIR;
  exports.SCALAR = SCALAR;
  exports.SEQ = SEQ;
  exports.hasAnchor = hasAnchor;
  exports.isAlias = isAlias;
  exports.isCollection = isCollection;
  exports.isDocument = isDocument;
  exports.isMap = isMap;
  exports.isNode = isNode;
  exports.isPair = isPair;
  exports.isScalar = isScalar;
  exports.isSeq = isSeq;
});

// node_modules/yaml/dist/visit.js
var require_visit = __commonJS((exports) => {
  var identity = require_identity();
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove node");
  function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
      const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      visit_(null, node, visitor_, Object.freeze([]));
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = visit_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = visit_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = visit_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
      const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      await visitAsync_(null, node, visitor_, Object.freeze([]));
  }
  visitAsync.BREAK = BREAK;
  visitAsync.SKIP = SKIP;
  visitAsync.REMOVE = REMOVE;
  async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = await visitAsync_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = await visitAsync_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = await visitAsync_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  function initVisitor(visitor) {
    if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
      return Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
      }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
      }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
      }, visitor);
    }
    return visitor;
  }
  function callVisitor(key, node, visitor, path) {
    if (typeof visitor === "function")
      return visitor(key, node, path);
    if (identity.isMap(node))
      return visitor.Map?.(key, node, path);
    if (identity.isSeq(node))
      return visitor.Seq?.(key, node, path);
    if (identity.isPair(node))
      return visitor.Pair?.(key, node, path);
    if (identity.isScalar(node))
      return visitor.Scalar?.(key, node, path);
    if (identity.isAlias(node))
      return visitor.Alias?.(key, node, path);
    return;
  }
  function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (identity.isCollection(parent)) {
      parent.items[key] = node;
    } else if (identity.isPair(parent)) {
      if (key === "key")
        parent.key = node;
      else
        parent.value = node;
    } else if (identity.isDocument(parent)) {
      parent.contents = node;
    } else {
      const pt = identity.isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
  }
  exports.visit = visit;
  exports.visitAsync = visitAsync;
});

// node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS((exports) => {
  var identity = require_identity();
  var visit = require_visit();
  var escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
  };
  var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);

  class Directives {
    constructor(yaml, tags) {
      this.docStart = null;
      this.docEnd = false;
      this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
      this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
      const copy = new Directives(this.yaml, this.tags);
      copy.docStart = this.docStart;
      return copy;
    }
    atDocument() {
      const res = new Directives(this.yaml, this.tags);
      switch (this.yaml.version) {
        case "1.1":
          this.atNextDocument = true;
          break;
        case "1.2":
          this.atNextDocument = false;
          this.yaml = {
            explicit: Directives.defaultYaml.explicit,
            version: "1.2"
          };
          this.tags = Object.assign({}, Directives.defaultTags);
          break;
      }
      return res;
    }
    add(line, onError) {
      if (this.atNextDocument) {
        this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
        this.tags = Object.assign({}, Directives.defaultTags);
        this.atNextDocument = false;
      }
      const parts = line.trim().split(/[ \t]+/);
      const name = parts.shift();
      switch (name) {
        case "%TAG": {
          if (parts.length !== 2) {
            onError(0, "%TAG directive should contain exactly two parts");
            if (parts.length < 2)
              return false;
          }
          const [handle, prefix] = parts;
          this.tags[handle] = prefix;
          return true;
        }
        case "%YAML": {
          this.yaml.explicit = true;
          if (parts.length !== 1) {
            onError(0, "%YAML directive should contain exactly one part");
            return false;
          }
          const [version] = parts;
          if (version === "1.1" || version === "1.2") {
            this.yaml.version = version;
            return true;
          } else {
            const isValid = /^\d+\.\d+$/.test(version);
            onError(6, `Unsupported YAML version ${version}`, isValid);
            return false;
          }
        }
        default:
          onError(0, `Unknown directive ${name}`, true);
          return false;
      }
    }
    tagName(source, onError) {
      if (source === "!")
        return "!";
      if (source[0] !== "!") {
        onError(`Not a valid tag: ${source}`);
        return null;
      }
      if (source[1] === "<") {
        const verbatim = source.slice(2, -1);
        if (verbatim === "!" || verbatim === "!!") {
          onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
          return null;
        }
        if (source[source.length - 1] !== ">")
          onError("Verbatim tags must end with a >");
        return verbatim;
      }
      const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
      if (!suffix)
        onError(`The ${source} tag has no suffix`);
      const prefix = this.tags[handle];
      if (prefix) {
        try {
          return prefix + decodeURIComponent(suffix);
        } catch (error) {
          onError(String(error));
          return null;
        }
      }
      if (handle === "!")
        return source;
      onError(`Could not resolve tag: ${source}`);
      return null;
    }
    tagString(tag) {
      for (const [handle, prefix] of Object.entries(this.tags)) {
        if (tag.startsWith(prefix))
          return handle + escapeTagName(tag.substring(prefix.length));
      }
      return tag[0] === "!" ? tag : `!<${tag}>`;
    }
    toString(doc) {
      const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
      const tagEntries = Object.entries(this.tags);
      let tagNames;
      if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
        const tags = {};
        visit.visit(doc.contents, (_key, node) => {
          if (identity.isNode(node) && node.tag)
            tags[node.tag] = true;
        });
        tagNames = Object.keys(tags);
      } else
        tagNames = [];
      for (const [handle, prefix] of tagEntries) {
        if (handle === "!!" && prefix === "tag:yaml.org,2002:")
          continue;
        if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
          lines.push(`%TAG ${handle} ${prefix}`);
      }
      return lines.join(`
`);
    }
  }
  Directives.defaultYaml = { explicit: false, version: "1.2" };
  Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
  exports.Directives = Directives;
});

// node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS((exports) => {
  var identity = require_identity();
  var visit = require_visit();
  function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
      const sa = JSON.stringify(anchor);
      const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
      throw new Error(msg);
    }
    return true;
  }
  function anchorNames(root) {
    const anchors = new Set;
    visit.visit(root, {
      Value(_key, node) {
        if (node.anchor)
          anchors.add(node.anchor);
      }
    });
    return anchors;
  }
  function findNewAnchor(prefix, exclude) {
    for (let i = 1;; ++i) {
      const name = `${prefix}${i}`;
      if (!exclude.has(name))
        return name;
    }
  }
  function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map;
    let prevAnchors = null;
    return {
      onAnchor: (source) => {
        aliasObjects.push(source);
        prevAnchors ?? (prevAnchors = anchorNames(doc));
        const anchor = findNewAnchor(prefix, prevAnchors);
        prevAnchors.add(anchor);
        return anchor;
      },
      setAnchors: () => {
        for (const source of aliasObjects) {
          const ref = sourceObjects.get(source);
          if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
            ref.node.anchor = ref.anchor;
          } else {
            const error = new Error("Failed to resolve repeated object (this should not happen)");
            error.source = source;
            throw error;
          }
        }
      },
      sourceObjects
    };
  }
  exports.anchorIsValid = anchorIsValid;
  exports.anchorNames = anchorNames;
  exports.createNodeAnchors = createNodeAnchors;
  exports.findNewAnchor = findNewAnchor;
});

// node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS((exports) => {
  function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === "object") {
      if (Array.isArray(val)) {
        for (let i = 0, len = val.length;i < len; ++i) {
          const v0 = val[i];
          const v1 = applyReviver(reviver, val, String(i), v0);
          if (v1 === undefined)
            delete val[i];
          else if (v1 !== v0)
            val[i] = v1;
        }
      } else if (val instanceof Map) {
        for (const k of Array.from(val.keys())) {
          const v0 = val.get(k);
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            val.delete(k);
          else if (v1 !== v0)
            val.set(k, v1);
        }
      } else if (val instanceof Set) {
        for (const v0 of Array.from(val)) {
          const v1 = applyReviver(reviver, val, v0, v0);
          if (v1 === undefined)
            val.delete(v0);
          else if (v1 !== v0) {
            val.delete(v0);
            val.add(v1);
          }
        }
      } else {
        for (const [k, v0] of Object.entries(val)) {
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            delete val[k];
          else if (v1 !== v0)
            val[k] = v1;
        }
      }
    }
    return reviver.call(obj, key, val);
  }
  exports.applyReviver = applyReviver;
});

// node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS((exports) => {
  var identity = require_identity();
  function toJS(value, arg, ctx) {
    if (Array.isArray(value))
      return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === "function") {
      if (!ctx || !identity.hasAnchor(value))
        return value.toJSON(arg, ctx);
      const data = { aliasCount: 0, count: 1, res: undefined };
      ctx.anchors.set(value, data);
      ctx.onCreate = (res2) => {
        data.res = res2;
        delete ctx.onCreate;
      };
      const res = value.toJSON(arg, ctx);
      if (ctx.onCreate)
        ctx.onCreate(res);
      return res;
    }
    if (typeof value === "bigint" && !ctx?.keep)
      return Number(value);
    return value;
  }
  exports.toJS = toJS;
});

// node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS((exports) => {
  var applyReviver = require_applyReviver();
  var identity = require_identity();
  var toJS = require_toJS();

  class NodeBase {
    constructor(type) {
      Object.defineProperty(this, identity.NODE_TYPE, { value: type });
    }
    clone() {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      if (!identity.isDocument(doc))
        throw new TypeError("A document argument is required");
      const ctx = {
        anchors: new Map,
        doc,
        keep: true,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this, "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
  }
  exports.NodeBase = NodeBase;
});

// node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS((exports) => {
  var anchors = require_anchors();
  var visit = require_visit();
  var identity = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();

  class Alias extends Node.NodeBase {
    constructor(source) {
      super(identity.ALIAS);
      this.source = source;
      Object.defineProperty(this, "tag", {
        set() {
          throw new Error("Alias nodes cannot have tags");
        }
      });
    }
    resolve(doc, ctx) {
      let nodes;
      if (ctx?.aliasResolveCache) {
        nodes = ctx.aliasResolveCache;
      } else {
        nodes = [];
        visit.visit(doc, {
          Node: (_key, node) => {
            if (identity.isAlias(node) || identity.hasAnchor(node))
              nodes.push(node);
          }
        });
        if (ctx)
          ctx.aliasResolveCache = nodes;
      }
      let found = undefined;
      for (const node of nodes) {
        if (node === this)
          break;
        if (node.anchor === this.source)
          found = node;
      }
      return found;
    }
    toJSON(_arg, ctx) {
      if (!ctx)
        return { source: this.source };
      const { anchors: anchors2, doc, maxAliasCount } = ctx;
      const source = this.resolve(doc, ctx);
      if (!source) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new ReferenceError(msg);
      }
      let data = anchors2.get(source);
      if (!data) {
        toJS.toJS(source, null, ctx);
        data = anchors2.get(source);
      }
      if (!data || data.res === undefined) {
        const msg = "This should not happen: Alias anchor was not resolved?";
        throw new ReferenceError(msg);
      }
      if (maxAliasCount >= 0) {
        data.count += 1;
        if (data.aliasCount === 0)
          data.aliasCount = getAliasCount(doc, source, anchors2);
        if (data.count * data.aliasCount > maxAliasCount) {
          const msg = "Excessive alias count indicates a resource exhaustion attack";
          throw new ReferenceError(msg);
        }
      }
      return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
      const src = `*${this.source}`;
      if (ctx) {
        anchors.anchorIsValid(this.source);
        if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new Error(msg);
        }
        if (ctx.implicitKey)
          return `${src} `;
      }
      return src;
    }
  }
  function getAliasCount(doc, node, anchors2) {
    if (identity.isAlias(node)) {
      const source = node.resolve(doc);
      const anchor = anchors2 && source && anchors2.get(source);
      return anchor ? anchor.count * anchor.aliasCount : 0;
    } else if (identity.isCollection(node)) {
      let count = 0;
      for (const item of node.items) {
        const c = getAliasCount(doc, item, anchors2);
        if (c > count)
          count = c;
      }
      return count;
    } else if (identity.isPair(node)) {
      const kc = getAliasCount(doc, node.key, anchors2);
      const vc = getAliasCount(doc, node.value, anchors2);
      return Math.max(kc, vc);
    }
    return 1;
  }
  exports.Alias = Alias;
});

// node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS((exports) => {
  var identity = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();
  var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";

  class Scalar extends Node.NodeBase {
    constructor(value) {
      super(identity.SCALAR);
      this.value = value;
    }
    toJSON(arg, ctx) {
      return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
      return String(this.value);
    }
  }
  Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
  Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
  Scalar.PLAIN = "PLAIN";
  Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
  Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
  exports.Scalar = Scalar;
  exports.isScalarValue = isScalarValue;
});

// node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var defaultTagPrefix = "tag:yaml.org,2002:";
  function findTagObject(value, tagName, tags) {
    if (tagName) {
      const match = tags.filter((t) => t.tag === tagName);
      const tagObj = match.find((t) => !t.format) ?? match[0];
      if (!tagObj)
        throw new Error(`Tag ${tagName} not found`);
      return tagObj;
    }
    return tags.find((t) => t.identify?.(value) && !t.format);
  }
  function createNode(value, tagName, ctx) {
    if (identity.isDocument(value))
      value = value.contents;
    if (identity.isNode(value))
      return value;
    if (identity.isPair(value)) {
      const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
      map.items.push(value);
      return map;
    }
    if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
      value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === "object") {
      ref = sourceObjects.get(value);
      if (ref) {
        ref.anchor ?? (ref.anchor = onAnchor(value));
        return new Alias.Alias(ref.anchor);
      } else {
        ref = { anchor: null, node: null };
        sourceObjects.set(value, ref);
      }
    }
    if (tagName?.startsWith("!!"))
      tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
      if (value && typeof value.toJSON === "function") {
        value = value.toJSON();
      }
      if (!value || typeof value !== "object") {
        const node2 = new Scalar.Scalar(value);
        if (ref)
          ref.node = node2;
        return node2;
      }
      tagObj = value instanceof Map ? schema[identity.MAP] : (Symbol.iterator in Object(value)) ? schema[identity.SEQ] : schema[identity.MAP];
    }
    if (onTagObj) {
      onTagObj(tagObj);
      delete ctx.onTagObj;
    }
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
    if (tagName)
      node.tag = tagName;
    else if (!tagObj.default)
      node.tag = tagObj.tag;
    if (ref)
      ref.node = node;
    return node;
  }
  exports.createNode = createNode;
});

// node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS((exports) => {
  var createNode = require_createNode();
  var identity = require_identity();
  var Node = require_Node();
  function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1;i >= 0; --i) {
      const k = path[i];
      if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
        const a = [];
        a[k] = v;
        v = a;
      } else {
        v = new Map([[k, v]]);
      }
    }
    return createNode.createNode(v, undefined, {
      aliasDuplicateObjects: false,
      keepUndefined: false,
      onAnchor: () => {
        throw new Error("This should not happen, please report a bug.");
      },
      schema,
      sourceObjects: new Map
    });
  }
  var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;

  class Collection extends Node.NodeBase {
    constructor(type, schema) {
      super(type);
      Object.defineProperty(this, "schema", {
        value: schema,
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
    clone(schema) {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (schema)
        copy.schema = schema;
      copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    addIn(path, value) {
      if (isEmptyPath(path))
        this.add(value);
      else {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (identity.isCollection(node))
          node.addIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
    deleteIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.delete(key);
      const node = this.get(key, true);
      if (identity.isCollection(node))
        return node.deleteIn(rest);
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    getIn(path, keepScalar) {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (rest.length === 0)
        return !keepScalar && identity.isScalar(node) ? node.value : node;
      else
        return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
      return this.items.every((node) => {
        if (!identity.isPair(node))
          return false;
        const n = node.value;
        return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
      });
    }
    hasIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.has(key);
      const node = this.get(key, true);
      return identity.isCollection(node) ? node.hasIn(rest) : false;
    }
    setIn(path, value) {
      const [key, ...rest] = path;
      if (rest.length === 0) {
        this.set(key, value);
      } else {
        const node = this.get(key, true);
        if (identity.isCollection(node))
          node.setIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
  }
  exports.Collection = Collection;
  exports.collectionFromPath = collectionFromPath;
  exports.isEmptyPath = isEmptyPath;
});

// node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS((exports) => {
  var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
  function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
      return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
  }
  var lineComment = (str, indent, comment) => str.endsWith(`
`) ? indentComment(comment, indent) : comment.includes(`
`) ? `
` + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
  exports.indentComment = indentComment;
  exports.lineComment = lineComment;
  exports.stringifyComment = stringifyComment;
});

// node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS((exports) => {
  var FOLD_FLOW = "flow";
  var FOLD_BLOCK = "block";
  var FOLD_QUOTED = "quoted";
  function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
      return text;
    if (lineWidth < minContentWidth)
      minContentWidth = 0;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
      return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === "number") {
      if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
        folds.push(0);
      else
        end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
      i = consumeMoreIndentedLines(text, i, indent.length);
      if (i !== -1)
        end = i + endStep;
    }
    for (let ch;ch = text[i += 1]; ) {
      if (mode === FOLD_QUOTED && ch === "\\") {
        escStart = i;
        switch (text[i + 1]) {
          case "x":
            i += 3;
            break;
          case "u":
            i += 5;
            break;
          case "U":
            i += 9;
            break;
          default:
            i += 1;
        }
        escEnd = i;
      }
      if (ch === `
`) {
        if (mode === FOLD_BLOCK)
          i = consumeMoreIndentedLines(text, i, indent.length);
        end = i + indent.length + endStep;
        split = undefined;
      } else {
        if (ch === " " && prev && prev !== " " && prev !== `
` && prev !== "\t") {
          const next = text[i + 1];
          if (next && next !== " " && next !== `
` && next !== "\t")
            split = i;
        }
        if (i >= end) {
          if (split) {
            folds.push(split);
            end = split + endStep;
            split = undefined;
          } else if (mode === FOLD_QUOTED) {
            while (prev === " " || prev === "\t") {
              prev = ch;
              ch = text[i += 1];
              overflow = true;
            }
            const j = i > escEnd + 1 ? i - 2 : escStart - 1;
            if (escapedFolds[j])
              return text;
            folds.push(j);
            escapedFolds[j] = true;
            end = j + endStep;
            split = undefined;
          } else {
            overflow = true;
          }
        }
      }
      prev = ch;
    }
    if (overflow && onOverflow)
      onOverflow();
    if (folds.length === 0)
      return text;
    if (onFold)
      onFold();
    let res = text.slice(0, folds[0]);
    for (let i2 = 0;i2 < folds.length; ++i2) {
      const fold = folds[i2];
      const end2 = folds[i2 + 1] || text.length;
      if (fold === 0)
        res = `
${indent}${text.slice(0, end2)}`;
      else {
        if (mode === FOLD_QUOTED && escapedFolds[fold])
          res += `${text[fold]}\\`;
        res += `
${indent}${text.slice(fold + 1, end2)}`;
      }
    }
    return res;
  }
  function consumeMoreIndentedLines(text, i, indent) {
    let end = i;
    let start = i + 1;
    let ch = text[start];
    while (ch === " " || ch === "\t") {
      if (i < start + indent) {
        ch = text[++i];
      } else {
        do {
          ch = text[++i];
        } while (ch && ch !== `
`);
        end = i;
        start = i + 1;
        ch = text[start];
      }
    }
    return end;
  }
  exports.FOLD_BLOCK = FOLD_BLOCK;
  exports.FOLD_FLOW = FOLD_FLOW;
  exports.FOLD_QUOTED = FOLD_QUOTED;
  exports.foldFlowLines = foldFlowLines;
});

// node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var foldFlowLines = require_foldFlowLines();
  var getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
  });
  var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
  function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
      return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
      return false;
    for (let i = 0, start = 0;i < strLen; ++i) {
      if (str[i] === `
`) {
        if (i - start > limit)
          return true;
        start = i + 1;
        if (strLen - start <= limit)
          return false;
      }
    }
    return true;
  }
  function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
      return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    let str = "";
    let start = 0;
    for (let i = 0, ch = json[i];ch; ch = json[++i]) {
      if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
        str += json.slice(start, i) + "\\ ";
        i += 1;
        start = i;
        ch = "\\";
      }
      if (ch === "\\")
        switch (json[i + 1]) {
          case "u":
            {
              str += json.slice(start, i);
              const code = json.substr(i + 2, 4);
              switch (code) {
                case "0000":
                  str += "\\0";
                  break;
                case "0007":
                  str += "\\a";
                  break;
                case "000b":
                  str += "\\v";
                  break;
                case "001b":
                  str += "\\e";
                  break;
                case "0085":
                  str += "\\N";
                  break;
                case "00a0":
                  str += "\\_";
                  break;
                case "2028":
                  str += "\\L";
                  break;
                case "2029":
                  str += "\\P";
                  break;
                default:
                  if (code.substr(0, 2) === "00")
                    str += "\\x" + code.substr(2);
                  else
                    str += json.substr(i, 6);
              }
              i += 5;
              start = i + 1;
            }
            break;
          case "n":
            if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
              i += 1;
            } else {
              str += json.slice(start, i) + `

`;
              while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                str += `
`;
                i += 2;
              }
              str += indent;
              if (json[i + 2] === " ")
                str += "\\";
              i += 1;
              start = i + 1;
            }
            break;
          default:
            i += 1;
        }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
  }
  function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes(`
`) || /[ \t]\n|\n[ \t]/.test(value))
      return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
    return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
      qs = doubleQuotedString;
    else {
      const hasDouble = value.includes('"');
      const hasSingle = value.includes("'");
      if (hasDouble && !hasSingle)
        qs = singleQuotedString;
      else if (hasSingle && !hasDouble)
        qs = doubleQuotedString;
      else
        qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
  }
  var blockEndNewlines;
  try {
    blockEndNewlines = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
  } catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
  }
  function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
      return quotedString(value, ctx);
    }
    const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
    const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
      return literal ? `|
` : `>
`;
    let chomp;
    let endStart;
    for (endStart = value.length;endStart > 0; --endStart) {
      const ch = value[endStart - 1];
      if (ch !== `
` && ch !== "\t" && ch !== " ")
        break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf(`
`);
    if (endNlPos === -1) {
      chomp = "-";
    } else if (value === end || endNlPos !== end.length - 1) {
      chomp = "+";
      if (onChompKeep)
        onChompKeep();
    } else {
      chomp = "";
    }
    if (end) {
      value = value.slice(0, -end.length);
      if (end[end.length - 1] === `
`)
        end = end.slice(0, -1);
      end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0;startEnd < value.length; ++startEnd) {
      const ch = value[startEnd];
      if (ch === " ")
        startWithSpace = true;
      else if (ch === `
`)
        startNlPos = startEnd;
      else
        break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
      value = value.substring(start.length);
      start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? "2" : "1";
    let header = (startWithSpace ? indentSize : "") + chomp;
    if (comment) {
      header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
      if (onComment)
        onComment();
    }
    if (!literal) {
      const foldedValue = value.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      let literalFallback = false;
      const foldOptions = getFoldOptions(ctx, true);
      if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
        foldOptions.onOverflow = () => {
          literalFallback = true;
        };
      }
      const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
      if (!literalFallback)
        return `>${header}
${indent}${body}`;
    }
    value = value.replace(/\n+/g, `$&${indent}`);
    return `|${header}
${indent}${start}${value}${end}`;
  }
  function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if (implicitKey && value.includes(`
`) || inFlow && /[[\]{},]/.test(value)) {
      return quotedString(value, ctx);
    }
    if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
      return implicitKey || inFlow || !value.includes(`
`) ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes(`
`)) {
      return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
      if (indent === "") {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      } else if (implicitKey && indent === indentStep) {
        return quotedString(value, ctx);
      }
    }
    const str = value.replace(/\n+/g, `$&
${indent}`);
    if (actualString) {
      const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
      const { compat, tags } = ctx.doc.schema;
      if (tags.some(test) || compat?.some(test))
        return quotedString(value, ctx);
    }
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
      if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
        type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
      switch (_type) {
        case Scalar.Scalar.BLOCK_FOLDED:
        case Scalar.Scalar.BLOCK_LITERAL:
          return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
        case Scalar.Scalar.QUOTE_DOUBLE:
          return doubleQuotedString(ss.value, ctx);
        case Scalar.Scalar.QUOTE_SINGLE:
          return singleQuotedString(ss.value, ctx);
        case Scalar.Scalar.PLAIN:
          return plainString(ss, ctx, onComment, onChompKeep);
        default:
          return null;
      }
    };
    let res = _stringify(type);
    if (res === null) {
      const { defaultKeyType, defaultStringType } = ctx.options;
      const t = implicitKey && defaultKeyType || defaultStringType;
      res = _stringify(t);
      if (res === null)
        throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
  }
  exports.stringifyString = stringifyString;
});

// node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS((exports) => {
  var anchors = require_anchors();
  var identity = require_identity();
  var stringifyComment = require_stringifyComment();
  var stringifyString = require_stringifyString();
  function createStringifyContext(doc, options) {
    const opt = Object.assign({
      blockQuote: true,
      commentString: stringifyComment.stringifyComment,
      defaultKeyType: null,
      defaultStringType: "PLAIN",
      directives: null,
      doubleQuotedAsJSON: false,
      doubleQuotedMinMultiLineLength: 40,
      falseStr: "false",
      flowCollectionPadding: true,
      indentSeq: true,
      lineWidth: 80,
      minContentWidth: 20,
      nullStr: "null",
      simpleKeys: false,
      singleQuote: null,
      trueStr: "true",
      verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
      case "block":
        inFlow = false;
        break;
      case "flow":
        inFlow = true;
        break;
      default:
        inFlow = null;
    }
    return {
      anchors: new Set,
      doc,
      flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
      indent: "",
      indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
      inFlow,
      options: opt
    };
  }
  function getTagObject(tags, item) {
    if (item.tag) {
      const match = tags.filter((t) => t.tag === item.tag);
      if (match.length > 0)
        return match.find((t) => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (identity.isScalar(item)) {
      obj = item.value;
      let match = tags.filter((t) => t.identify?.(obj));
      if (match.length > 1) {
        const testMatch = match.filter((t) => t.test);
        if (testMatch.length > 0)
          match = testMatch;
      }
      tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
    } else {
      obj = item;
      tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
      const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
      throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
  }
  function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
    if (!doc.directives)
      return "";
    const props = [];
    const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
      anchors$1.add(anchor);
      props.push(`&${anchor}`);
    }
    const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
    if (tag)
      props.push(doc.directives.tagString(tag));
    return props.join(" ");
  }
  function stringify(item, ctx, onComment, onChompKeep) {
    if (identity.isPair(item))
      return item.toString(ctx, onComment, onChompKeep);
    if (identity.isAlias(item)) {
      if (ctx.doc.directives)
        return item.toString(ctx);
      if (ctx.resolvedAliases?.has(item)) {
        throw new TypeError(`Cannot stringify circular structure without alias nodes`);
      } else {
        if (ctx.resolvedAliases)
          ctx.resolvedAliases.add(item);
        else
          ctx.resolvedAliases = new Set([item]);
        item = item.resolve(ctx.doc);
      }
    }
    let tagObj = undefined;
    const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
    tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
      ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    if (!props)
      return str;
    return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
  }
  exports.createStringifyContext = createStringifyContext;
  exports.stringify = stringify;
});

// node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = identity.isNode(key) && key.comment || null;
    if (simpleKeys) {
      if (keyComment) {
        throw new Error("With simple keys, key nodes cannot have comments");
      }
      if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
        const msg = "With simple keys, collection cannot be used as a key value";
        throw new Error(msg);
      }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
    ctx = Object.assign({}, ctx, {
      allNullValues: false,
      implicitKey: !explicitKey && (simpleKeys || !allNullValues),
      indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
      if (simpleKeys)
        throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
      explicitKey = true;
    }
    if (ctx.inFlow) {
      if (allNullValues || value == null) {
        if (keyCommentDone && onComment)
          onComment();
        return str === "" ? "?" : explicitKey ? `? ${str}` : str;
      }
    } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
      str = `? ${str}`;
      if (keyComment && !keyCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    if (keyCommentDone)
      keyComment = null;
    if (explicitKey) {
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      str = `? ${str}
${indent}:`;
    } else {
      str = `${str}:`;
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (identity.isNode(value)) {
      vsb = !!value.spaceBefore;
      vcb = value.commentBefore;
      valueComment = value.comment;
    } else {
      vsb = false;
      vcb = null;
      valueComment = null;
      if (value && typeof value === "object")
        value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && identity.isScalar(value))
      ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
      ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
    let ws = " ";
    if (keyComment || vsb || vcb) {
      ws = vsb ? `
` : "";
      if (vcb) {
        const cs = commentString(vcb);
        ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
      }
      if (valueStr === "" && !ctx.inFlow) {
        if (ws === `
`)
          ws = `

`;
      } else {
        ws += `
${ctx.indent}`;
      }
    } else if (!explicitKey && identity.isCollection(value)) {
      const vs0 = valueStr[0];
      const nl0 = valueStr.indexOf(`
`);
      const hasNewline = nl0 !== -1;
      const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
      if (hasNewline || !flow) {
        let hasPropsLine = false;
        if (hasNewline && (vs0 === "&" || vs0 === "!")) {
          let sp0 = valueStr.indexOf(" ");
          if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
            sp0 = valueStr.indexOf(" ", sp0 + 1);
          }
          if (sp0 === -1 || nl0 < sp0)
            hasPropsLine = true;
        }
        if (!hasPropsLine)
          ws = `
${ctx.indent}`;
      }
    } else if (valueStr === "" || valueStr[0] === `
`) {
      ws = "";
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
      if (valueCommentDone && onComment)
        onComment();
    } else if (valueComment && !valueCommentDone) {
      str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
    } else if (chompKeep && onChompKeep) {
      onChompKeep();
    }
    return str;
  }
  exports.stringifyPair = stringifyPair;
});

// node_modules/yaml/dist/log.js
var require_log = __commonJS((exports) => {
  var node_process = __require("process");
  function debug(logLevel, ...messages) {
    if (logLevel === "debug")
      console.log(...messages);
  }
  function warn(logLevel, warning) {
    if (logLevel === "debug" || logLevel === "warn") {
      if (typeof node_process.emitWarning === "function")
        node_process.emitWarning(warning);
      else
        console.warn(warning);
    }
  }
  exports.debug = debug;
  exports.warn = warn;
});

// node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var MERGE_KEY = "<<";
  var merge = {
    identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
    default: "key",
    tag: "tag:yaml.org,2002:merge",
    test: /^<<$/,
    resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
      addToJSMap: addMergeToJSMap
    }),
    stringify: () => MERGE_KEY
  };
  var isMergeKey = (ctx, key) => (merge.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default);
  function addMergeToJSMap(ctx, map, value) {
    value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (identity.isSeq(value))
      for (const it of value.items)
        mergeValue(ctx, map, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeValue(ctx, map, it);
    else
      mergeValue(ctx, map, value);
  }
  function mergeValue(ctx, map, value) {
    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!identity.isMap(source))
      throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value2] of srcMap) {
      if (map instanceof Map) {
        if (!map.has(key))
          map.set(key, value2);
      } else if (map instanceof Set) {
        map.add(key);
      } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
        Object.defineProperty(map, key, {
          value: value2,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    }
    return map;
  }
  exports.addMergeToJSMap = addMergeToJSMap;
  exports.isMergeKey = isMergeKey;
  exports.merge = merge;
});

// node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS((exports) => {
  var log = require_log();
  var merge = require_merge();
  var stringify = require_stringify();
  var identity = require_identity();
  var toJS = require_toJS();
  function addPairToJSMap(ctx, map, { key, value }) {
    if (identity.isNode(key) && key.addToJSMap)
      key.addToJSMap(ctx, map, value);
    else if (merge.isMergeKey(ctx, key))
      merge.addMergeToJSMap(ctx, map, value);
    else {
      const jsKey = toJS.toJS(key, "", ctx);
      if (map instanceof Map) {
        map.set(jsKey, toJS.toJS(value, jsKey, ctx));
      } else if (map instanceof Set) {
        map.add(jsKey);
      } else {
        const stringKey = stringifyKey(key, jsKey, ctx);
        const jsValue = toJS.toJS(value, stringKey, ctx);
        if (stringKey in map)
          Object.defineProperty(map, stringKey, {
            value: jsValue,
            writable: true,
            enumerable: true,
            configurable: true
          });
        else
          map[stringKey] = jsValue;
      }
    }
    return map;
  }
  function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
      return "";
    if (typeof jsKey !== "object")
      return String(jsKey);
    if (identity.isNode(key) && ctx?.doc) {
      const strCtx = stringify.createStringifyContext(ctx.doc, {});
      strCtx.anchors = new Set;
      for (const node of ctx.anchors.keys())
        strCtx.anchors.add(node.anchor);
      strCtx.inFlow = true;
      strCtx.inStringifyKey = true;
      const strKey = key.toString(strCtx);
      if (!ctx.mapKeyWarned) {
        let jsonStr = JSON.stringify(strKey);
        if (jsonStr.length > 40)
          jsonStr = jsonStr.substring(0, 36) + '..."';
        log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
        ctx.mapKeyWarned = true;
      }
      return strKey;
    }
    return JSON.stringify(jsKey);
  }
  exports.addPairToJSMap = addPairToJSMap;
});

// node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyPair = require_stringifyPair();
  var addPairToJSMap = require_addPairToJSMap();
  var identity = require_identity();
  function createPair(key, value, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value, undefined, ctx);
    return new Pair(k, v);
  }

  class Pair {
    constructor(key, value = null) {
      Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
      this.key = key;
      this.value = value;
    }
    clone(schema) {
      let { key, value } = this;
      if (identity.isNode(key))
        key = key.clone(schema);
      if (identity.isNode(value))
        value = value.clone(schema);
      return new Pair(key, value);
    }
    toJSON(_, ctx) {
      const pair = ctx?.mapAsMap ? new Map : {};
      return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
      return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
  }
  exports.Pair = Pair;
  exports.createPair = createPair;
});

// node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS((exports) => {
  var identity = require_identity();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify2(collection, ctx, options);
  }
  function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment2 = null;
      if (identity.isNode(item)) {
        if (!chompKeep && item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
        if (item.comment)
          comment2 = item.comment;
      } else if (identity.isPair(item)) {
        const ik = identity.isNode(item.key) ? item.key : null;
        if (ik) {
          if (!chompKeep && ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
        }
      }
      chompKeep = false;
      let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
      if (comment2)
        str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
      if (chompKeep && comment2)
        chompKeep = false;
      lines.push(blockItemPrefix + str2);
    }
    let str;
    if (lines.length === 0) {
      str = flowChars.start + flowChars.end;
    } else {
      str = lines[0];
      for (let i = 1;i < lines.length; ++i) {
        const line = lines[i];
        str += line ? `
${indent}${line}` : `
`;
      }
    }
    if (comment) {
      str += `
` + stringifyComment.indentComment(commentString(comment), indent);
      if (onComment)
        onComment();
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
      indent: itemIndent,
      inFlow: true,
      type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment = null;
      if (identity.isNode(item)) {
        if (item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, false);
        if (item.comment)
          comment = item.comment;
      } else if (identity.isPair(item)) {
        const ik = identity.isNode(item.key) ? item.key : null;
        if (ik) {
          if (ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, false);
          if (ik.comment)
            reqNewline = true;
        }
        const iv = identity.isNode(item.value) ? item.value : null;
        if (iv) {
          if (iv.comment)
            comment = iv.comment;
          if (iv.commentBefore)
            reqNewline = true;
        } else if (item.value == null && ik?.comment) {
          comment = ik.comment;
        }
      }
      if (comment)
        reqNewline = true;
      let str = stringify.stringify(item, itemCtx, () => comment = null);
      if (i < items.length - 1)
        str += ",";
      if (comment)
        str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
      if (!reqNewline && (lines.length > linesAtValue || str.includes(`
`)))
        reqNewline = true;
      lines.push(str);
      linesAtValue = lines.length;
    }
    const { start, end } = flowChars;
    if (lines.length === 0) {
      return start + end;
    } else {
      if (!reqNewline) {
        const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
        reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
      }
      if (reqNewline) {
        let str = start;
        for (const line of lines)
          str += line ? `
${indentStep}${indent}${line}` : `
`;
        return `${str}
${indent}${end}`;
      } else {
        return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
      }
    }
  }
  function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
      comment = comment.replace(/^\n+/, "");
    if (comment) {
      const ic = stringifyComment.indentComment(commentString(comment), indent);
      lines.push(ic.trimStart());
    }
  }
  exports.stringifyCollection = stringifyCollection;
});

// node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS((exports) => {
  var stringifyCollection = require_stringifyCollection();
  var addPairToJSMap = require_addPairToJSMap();
  var Collection = require_Collection();
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  function findPair(items, key) {
    const k = identity.isScalar(key) ? key.value : key;
    for (const it of items) {
      if (identity.isPair(it)) {
        if (it.key === key || it.key === k)
          return it;
        if (identity.isScalar(it.key) && it.key.value === k)
          return it;
      }
    }
    return;
  }

  class YAMLMap extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:map";
    }
    constructor(schema) {
      super(identity.MAP, schema);
      this.items = [];
    }
    static from(schema, obj, ctx) {
      const { keepUndefined, replacer } = ctx;
      const map = new this(schema);
      const add = (key, value) => {
        if (typeof replacer === "function")
          value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
          return;
        if (value !== undefined || keepUndefined)
          map.items.push(Pair.createPair(key, value, ctx));
      };
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          add(key, value);
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          add(key, obj[key]);
      }
      if (typeof schema.sortMapEntries === "function") {
        map.items.sort(schema.sortMapEntries);
      }
      return map;
    }
    add(pair, overwrite) {
      let _pair;
      if (identity.isPair(pair))
        _pair = pair;
      else if (!pair || typeof pair !== "object" || !("key" in pair)) {
        _pair = new Pair.Pair(pair, pair?.value);
      } else
        _pair = new Pair.Pair(pair.key, pair.value);
      const prev = findPair(this.items, _pair.key);
      const sortEntries = this.schema?.sortMapEntries;
      if (prev) {
        if (!overwrite)
          throw new Error(`Key ${_pair.key} already set`);
        if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
          prev.value.value = _pair.value;
        else
          prev.value = _pair.value;
      } else if (sortEntries) {
        const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
        if (i === -1)
          this.items.push(_pair);
        else
          this.items.splice(i, 0, _pair);
      } else {
        this.items.push(_pair);
      }
    }
    delete(key) {
      const it = findPair(this.items, key);
      if (!it)
        return false;
      const del = this.items.splice(this.items.indexOf(it), 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const it = findPair(this.items, key);
      const node = it?.value;
      return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
      return !!findPair(this.items, key);
    }
    set(key, value) {
      this.add(new Pair.Pair(key, value), true);
    }
    toJSON(_, ctx, Type) {
      const map = Type ? new Type : ctx?.mapAsMap ? new Map : {};
      if (ctx?.onCreate)
        ctx.onCreate(map);
      for (const item of this.items)
        addPairToJSMap.addPairToJSMap(ctx, map, item);
      return map;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      for (const item of this.items) {
        if (!identity.isPair(item))
          throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
      }
      if (!ctx.allNullValues && this.hasAllNullValues(false))
        ctx = Object.assign({}, ctx, { allNullValues: true });
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "",
        flowChars: { start: "{", end: "}" },
        itemIndent: ctx.indent || "",
        onChompKeep,
        onComment
      });
    }
  }
  exports.YAMLMap = YAMLMap;
  exports.findPair = findPair;
});

// node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS((exports) => {
  var identity = require_identity();
  var YAMLMap = require_YAMLMap();
  var map = {
    collection: "map",
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve(map2, onError) {
      if (!identity.isMap(map2))
        onError("Expected a mapping for this tag");
      return map2;
    },
    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
  };
  exports.map = map;
});

// node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyCollection = require_stringifyCollection();
  var Collection = require_Collection();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var toJS = require_toJS();

  class YAMLSeq extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:seq";
    }
    constructor(schema) {
      super(identity.SEQ, schema);
      this.items = [];
    }
    add(value) {
      this.items.push(value);
    }
    delete(key) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return false;
      const del = this.items.splice(idx, 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return;
      const it = this.items[idx];
      return !keepScalar && identity.isScalar(it) ? it.value : it;
    }
    has(key) {
      const idx = asItemIndex(key);
      return typeof idx === "number" && idx < this.items.length;
    }
    set(key, value) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        throw new Error(`Expected a valid index, not ${key}.`);
      const prev = this.items[idx];
      if (identity.isScalar(prev) && Scalar.isScalarValue(value))
        prev.value = value;
      else
        this.items[idx] = value;
    }
    toJSON(_, ctx) {
      const seq = [];
      if (ctx?.onCreate)
        ctx.onCreate(seq);
      let i = 0;
      for (const item of this.items)
        seq.push(toJS.toJS(item, String(i++), ctx));
      return seq;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "- ",
        flowChars: { start: "[", end: "]" },
        itemIndent: (ctx.indent || "") + "  ",
        onChompKeep,
        onComment
      });
    }
    static from(schema, obj, ctx) {
      const { replacer } = ctx;
      const seq = new this(schema);
      if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
          if (typeof replacer === "function") {
            const key = obj instanceof Set ? it : String(i++);
            it = replacer.call(obj, key, it);
          }
          seq.items.push(createNode.createNode(it, undefined, ctx));
        }
      }
      return seq;
    }
  }
  function asItemIndex(key) {
    let idx = identity.isScalar(key) ? key.value : key;
    if (idx && typeof idx === "string")
      idx = Number(idx);
    return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
  }
  exports.YAMLSeq = YAMLSeq;
});

// node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS((exports) => {
  var identity = require_identity();
  var YAMLSeq = require_YAMLSeq();
  var seq = {
    collection: "seq",
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve(seq2, onError) {
      if (!identity.isSeq(seq2))
        onError("Expected a sequence for this tag");
      return seq2;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
  };
  exports.seq = seq;
});

// node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS((exports) => {
  var stringifyString = require_stringifyString();
  var string = {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify(item, ctx, onComment, onChompKeep) {
      ctx = Object.assign({ actualString: true }, ctx);
      return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
  };
  exports.string = string;
});

// node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var nullTag = {
    identify: (value) => value == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
  };
  exports.nullTag = nullTag;
});

// node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var boolTag = {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
    stringify({ source, value }, ctx) {
      if (source && boolTag.test.test(source)) {
        const sv = source[0] === "t" || source[0] === "T";
        if (value === sv)
          return source;
      }
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
  };
  exports.boolTag = boolTag;
});

// node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS((exports) => {
  function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === "bigint")
      return String(value);
    const num = typeof value === "number" ? value : Number(value);
    if (!isFinite(num))
      return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = JSON.stringify(value);
    if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
      let i = n.indexOf(".");
      if (i < 0) {
        i = n.length;
        n += ".";
      }
      let d = minFractionDigits - (n.length - i - 1);
      while (d-- > 0)
        n += "0";
    }
    return n;
  }
  exports.stringifyNumber = stringifyNumber;
});

// node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str));
      const dot = str.indexOf(".");
      if (dot !== -1 && str[str.length - 1] === "0")
        node.minFractionDigits = str.length - dot - 1;
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
      return prefix + value.toString(radix);
    return stringifyNumber.stringifyNumber(node);
  }
  var intOct = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: (node) => intStringify(node, 8, "0o")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.boolTag,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var map = require_map();
  var seq = require_seq();
  function intIdentify(value) {
    return typeof value === "bigint" || Number.isInteger(value);
  }
  var stringifyJSON = ({ value }) => JSON.stringify(value);
  var jsonScalars = [
    {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify: stringifyJSON
    },
    {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    },
    {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true$|^false$/,
      resolve: (str) => str === "true",
      stringify: stringifyJSON
    },
    {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON
    }
  ];
  var jsonError = {
    default: true,
    tag: "",
    test: /^/,
    resolve(str, onError) {
      onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
      return str;
    }
  };
  var schema = [map.map, seq.seq].concat(jsonScalars, jsonError);
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS((exports) => {
  var node_buffer = __require("buffer");
  var Scalar = require_Scalar();
  var stringifyString = require_stringifyString();
  var binary = {
    identify: (value) => value instanceof Uint8Array,
    default: false,
    tag: "tag:yaml.org,2002:binary",
    resolve(src, onError) {
      if (typeof node_buffer.Buffer === "function") {
        return node_buffer.Buffer.from(src, "base64");
      } else if (typeof atob === "function") {
        const str = atob(src.replace(/[\n\r]/g, ""));
        const buffer = new Uint8Array(str.length);
        for (let i = 0;i < str.length; ++i)
          buffer[i] = str.charCodeAt(i);
        return buffer;
      } else {
        onError("This environment does not support reading binary tags; either Buffer or atob is required");
        return src;
      }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
      if (!value)
        return "";
      const buf = value;
      let str;
      if (typeof node_buffer.Buffer === "function") {
        str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
      } else if (typeof btoa === "function") {
        let s = "";
        for (let i = 0;i < buf.length; ++i)
          s += String.fromCharCode(buf[i]);
        str = btoa(s);
      } else {
        throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
      }
      type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
        const n = Math.ceil(str.length / lineWidth);
        const lines = new Array(n);
        for (let i = 0, o = 0;i < n; ++i, o += lineWidth) {
          lines[i] = str.substr(o, lineWidth);
        }
        str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? `
` : " ");
      }
      return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
  };
  exports.binary = binary;
});

// node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  var YAMLSeq = require_YAMLSeq();
  function resolvePairs(seq, onError) {
    if (identity.isSeq(seq)) {
      for (let i = 0;i < seq.items.length; ++i) {
        let item = seq.items[i];
        if (identity.isPair(item))
          continue;
        else if (identity.isMap(item)) {
          if (item.items.length > 1)
            onError("Each pair must have its own sequence indicator");
          const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
          if (item.commentBefore)
            pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
          if (item.comment) {
            const cn = pair.value ?? pair.key;
            cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
          }
          item = pair;
        }
        seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
      }
    } else
      onError("Expected a sequence for this tag");
    return seq;
  }
  function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs2 = new YAMLSeq.YAMLSeq(schema);
    pairs2.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
      for (let it of iterable) {
        if (typeof replacer === "function")
          it = replacer.call(iterable, String(i++), it);
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value = it[key];
          } else {
            throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
          }
        } else {
          key = it;
        }
        pairs2.items.push(Pair.createPair(key, value, ctx));
      }
    return pairs2;
  }
  var pairs = {
    collection: "seq",
    default: false,
    tag: "tag:yaml.org,2002:pairs",
    resolve: resolvePairs,
    createNode: createPairs
  };
  exports.createPairs = createPairs;
  exports.pairs = pairs;
  exports.resolvePairs = resolvePairs;
});

// node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS((exports) => {
  var identity = require_identity();
  var toJS = require_toJS();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var pairs = require_pairs();

  class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
      super();
      this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
      this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
      this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
      this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
      this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
      this.tag = YAMLOMap.tag;
    }
    toJSON(_, ctx) {
      if (!ctx)
        return super.toJSON(_);
      const map = new Map;
      if (ctx?.onCreate)
        ctx.onCreate(map);
      for (const pair of this.items) {
        let key, value;
        if (identity.isPair(pair)) {
          key = toJS.toJS(pair.key, "", ctx);
          value = toJS.toJS(pair.value, key, ctx);
        } else {
          key = toJS.toJS(pair, "", ctx);
        }
        if (map.has(key))
          throw new Error("Ordered maps must not include duplicate keys");
        map.set(key, value);
      }
      return map;
    }
    static from(schema, iterable, ctx) {
      const pairs$1 = pairs.createPairs(schema, iterable, ctx);
      const omap2 = new this;
      omap2.items = pairs$1.items;
      return omap2;
    }
  }
  YAMLOMap.tag = "tag:yaml.org,2002:omap";
  var omap = {
    collection: "seq",
    identify: (value) => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: "tag:yaml.org,2002:omap",
    resolve(seq, onError) {
      const pairs$1 = pairs.resolvePairs(seq, onError);
      const seenKeys = [];
      for (const { key } of pairs$1.items) {
        if (identity.isScalar(key)) {
          if (seenKeys.includes(key.value)) {
            onError(`Ordered maps must not include duplicate keys: ${key.value}`);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap, pairs$1);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
  };
  exports.YAMLOMap = YAMLOMap;
  exports.omap = omap;
});

// node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
      return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
  var trueTag = {
    identify: (value) => value === true,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
  };
  var falseTag = {
    identify: (value) => value === false,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
  };
  exports.falseTag = falseTag;
  exports.trueTag = trueTag;
});

// node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, "")),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
      const dot = str.indexOf(".");
      if (dot !== -1) {
        const f = str.substring(dot + 1).replace(/_/g, "");
        if (f[f.length - 1] === "0")
          node.minFractionDigits = f.length;
      }
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === "-" || sign === "+")
      offset += 1;
    str = str.substring(offset).replace(/_/g, "");
    if (intAsBigInt) {
      switch (radix) {
        case 2:
          str = `0b${str}`;
          break;
        case 8:
          str = `0o${str}`;
          break;
        case 16:
          str = `0x${str}`;
          break;
      }
      const n2 = BigInt(str);
      return sign === "-" ? BigInt(-1) * n2 : n2;
    }
    const n = parseInt(str, radix);
    return sign === "-" ? -1 * n : n;
  }
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
      const str = value.toString(radix);
      return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
  }
  var intBin = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: (node) => intStringify(node, 2, "0b")
  };
  var intOct = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: (node) => intStringify(node, 8, "0")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int;
  exports.intBin = intBin;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();

  class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
      super(schema);
      this.tag = YAMLSet.tag;
    }
    add(key) {
      let pair;
      if (identity.isPair(key))
        pair = key;
      else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
        pair = new Pair.Pair(key.key, null);
      else
        pair = new Pair.Pair(key, null);
      const prev = YAMLMap.findPair(this.items, pair.key);
      if (!prev)
        this.items.push(pair);
    }
    get(key, keepPair) {
      const pair = YAMLMap.findPair(this.items, key);
      return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value) {
      if (typeof value !== "boolean")
        throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
      const prev = YAMLMap.findPair(this.items, key);
      if (prev && !value) {
        this.items.splice(this.items.indexOf(prev), 1);
      } else if (!prev && value) {
        this.items.push(new Pair.Pair(key));
      }
    }
    toJSON(_, ctx) {
      return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      if (this.hasAllNullValues(true))
        return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
      else
        throw new Error("Set items must all have null values");
    }
    static from(schema, iterable, ctx) {
      const { replacer } = ctx;
      const set2 = new this(schema);
      if (iterable && Symbol.iterator in Object(iterable))
        for (let value of iterable) {
          if (typeof replacer === "function")
            value = replacer.call(iterable, value, value);
          set2.items.push(Pair.createPair(value, null, ctx));
        }
      return set2;
    }
  }
  YAMLSet.tag = "tag:yaml.org,2002:set";
  var set = {
    collection: "map",
    identify: (value) => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
      if (identity.isMap(map)) {
        if (map.hasAllNullValues(true))
          return Object.assign(new YAMLSet, map);
        else
          onError("Set items must all have null values");
      } else
        onError("Expected a mapping for this tag");
      return map;
    }
  };
  exports.YAMLSet = YAMLSet;
  exports.set = set;
});

// node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
    return sign === "-" ? num(-1) * res : res;
  }
  function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === "bigint")
      num = (n) => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
      return stringifyNumber.stringifyNumber(node);
    let sign = "";
    if (value < 0) {
      sign = "-";
      value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60];
    if (value < 60) {
      parts.unshift(0);
    } else {
      value = (value - parts[0]) / _60;
      parts.unshift(value % _60);
      if (value >= 60) {
        value = (value - parts[0]) / _60;
        parts.unshift(value);
      }
    }
    return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
  }
  var intTime = {
    identify: (value) => typeof value === "bigint" || Number.isInteger(value),
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
  };
  var floatTime = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: (str) => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
  };
  var timestamp = {
    identify: (value) => value instanceof Date,
    default: true,
    tag: "tag:yaml.org,2002:timestamp",
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})" + "(?:" + "(?:t|T|[ \\t]+)" + "([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)" + "(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?" + ")?$"),
    resolve(str) {
      const match = str.match(timestamp.test);
      if (!match)
        throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
      const [, year, month, day, hour, minute, second] = match.map(Number);
      const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
      let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
      const tz = match[8];
      if (tz && tz !== "Z") {
        let d = parseSexagesimal(tz, false);
        if (Math.abs(d) < 30)
          d *= 60;
        date -= 60000 * d;
      }
      return new Date(date);
    },
    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
  };
  exports.floatTime = floatTime;
  exports.intTime = intTime;
  exports.timestamp = timestamp;
});

// node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var binary = require_binary();
  var bool = require_bool2();
  var float = require_float2();
  var int = require_int2();
  var merge = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var set = require_set();
  var timestamp = require_timestamp();
  var schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.trueTag,
    bool.falseTag,
    int.intBin,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    merge.merge,
    omap.omap,
    pairs.pairs,
    set.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = require_schema();
  var schema$1 = require_schema2();
  var binary = require_binary();
  var merge = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var schema$2 = require_schema3();
  var set = require_set();
  var timestamp = require_timestamp();
  var schemas = new Map([
    ["core", schema.schema],
    ["failsafe", [map.map, seq.seq, string.string]],
    ["json", schema$1.schema],
    ["yaml11", schema$2.schema],
    ["yaml-1.1", schema$2.schema]
  ]);
  var tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map.map,
    merge: merge.merge,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set.set,
    timestamp: timestamp.timestamp
  };
  var coreKnownTags = {
    "tag:yaml.org,2002:binary": binary.binary,
    "tag:yaml.org,2002:merge": merge.merge,
    "tag:yaml.org,2002:omap": omap.omap,
    "tag:yaml.org,2002:pairs": pairs.pairs,
    "tag:yaml.org,2002:set": set.set,
    "tag:yaml.org,2002:timestamp": timestamp.timestamp
  };
  function getTags(customTags, schemaName, addMergeTag) {
    const schemaTags = schemas.get(schemaName);
    if (schemaTags && !customTags) {
      return addMergeTag && !schemaTags.includes(merge.merge) ? schemaTags.concat(merge.merge) : schemaTags.slice();
    }
    let tags = schemaTags;
    if (!tags) {
      if (Array.isArray(customTags))
        tags = [];
      else {
        const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
      }
    }
    if (Array.isArray(customTags)) {
      for (const tag of customTags)
        tags = tags.concat(tag);
    } else if (typeof customTags === "function") {
      tags = customTags(tags.slice());
    }
    if (addMergeTag)
      tags = tags.concat(merge.merge);
    return tags.reduce((tags2, tag) => {
      const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
      if (!tagObj) {
        const tagName = JSON.stringify(tag);
        const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
      }
      if (!tags2.includes(tagObj))
        tags2.push(tagObj);
      return tags2;
    }, []);
  }
  exports.coreKnownTags = coreKnownTags;
  exports.getTags = getTags;
});

// node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS((exports) => {
  var identity = require_identity();
  var map = require_map();
  var seq = require_seq();
  var string = require_string();
  var tags = require_tags();
  var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;

  class Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
      this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
      this.name = typeof schema === "string" && schema || "core";
      this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
      this.tags = tags.getTags(customTags, this.name, merge);
      this.toStringOptions = toStringDefaults ?? null;
      Object.defineProperty(this, identity.MAP, { value: map.map });
      Object.defineProperty(this, identity.SCALAR, { value: string.string });
      Object.defineProperty(this, identity.SEQ, { value: seq.seq });
      this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
    }
    clone() {
      const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
      copy.tags = this.tags.slice();
      return copy;
    }
  }
  exports.Schema = Schema;
});

// node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS((exports) => {
  var identity = require_identity();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
      const dir = doc.directives.toString(doc);
      if (dir) {
        lines.push(dir);
        hasDirectives = true;
      } else if (doc.directives.docStart)
        hasDirectives = true;
    }
    if (hasDirectives)
      lines.push("---");
    const ctx = stringify.createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
      if (lines.length !== 1)
        lines.unshift("");
      const cs = commentString(doc.commentBefore);
      lines.unshift(stringifyComment.indentComment(cs, ""));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
      if (identity.isNode(doc.contents)) {
        if (doc.contents.spaceBefore && hasDirectives)
          lines.push("");
        if (doc.contents.commentBefore) {
          const cs = commentString(doc.contents.commentBefore);
          lines.push(stringifyComment.indentComment(cs, ""));
        }
        ctx.forceBlockIndent = !!doc.comment;
        contentComment = doc.contents.comment;
      }
      const onChompKeep = contentComment ? undefined : () => chompKeep = true;
      let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
      if (contentComment)
        body += stringifyComment.lineComment(body, "", commentString(contentComment));
      if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
        lines[lines.length - 1] = `--- ${body}`;
      } else
        lines.push(body);
    } else {
      lines.push(stringify.stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
      if (doc.comment) {
        const cs = commentString(doc.comment);
        if (cs.includes(`
`)) {
          lines.push("...");
          lines.push(stringifyComment.indentComment(cs, ""));
        } else {
          lines.push(`... ${cs}`);
        }
      } else {
        lines.push("...");
      }
    } else {
      let dc = doc.comment;
      if (dc && chompKeep)
        dc = dc.replace(/^\n+/, "");
      if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push(stringifyComment.indentComment(commentString(dc), ""));
      }
    }
    return lines.join(`
`) + `
`;
  }
  exports.stringifyDocument = stringifyDocument;
});

// node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS((exports) => {
  var Alias = require_Alias();
  var Collection = require_Collection();
  var identity = require_identity();
  var Pair = require_Pair();
  var toJS = require_toJS();
  var Schema = require_Schema();
  var stringifyDocument = require_stringifyDocument();
  var anchors = require_anchors();
  var applyReviver = require_applyReviver();
  var createNode = require_createNode();
  var directives = require_directives();

  class Document {
    constructor(value, replacer, options) {
      this.commentBefore = null;
      this.comment = null;
      this.errors = [];
      this.warnings = [];
      Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const opt = Object.assign({
        intAsBigInt: false,
        keepSourceTokens: false,
        logLevel: "warn",
        prettyErrors: true,
        strict: true,
        stringKeys: false,
        uniqueKeys: true,
        version: "1.2"
      }, options);
      this.options = opt;
      let { version } = opt;
      if (options?._directives) {
        this.directives = options._directives.atDocument();
        if (this.directives.yaml.explicit)
          version = this.directives.yaml.version;
      } else
        this.directives = new directives.Directives({ version });
      this.setSchema(version, options);
      this.contents = value === undefined ? null : this.createNode(value, _replacer, options);
    }
    clone() {
      const copy = Object.create(Document.prototype, {
        [identity.NODE_TYPE]: { value: identity.DOC }
      });
      copy.commentBefore = this.commentBefore;
      copy.comment = this.comment;
      copy.errors = this.errors.slice();
      copy.warnings = this.warnings.slice();
      copy.options = Object.assign({}, this.options);
      if (this.directives)
        copy.directives = this.directives.clone();
      copy.schema = this.schema.clone();
      copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    add(value) {
      if (assertCollection(this.contents))
        this.contents.add(value);
    }
    addIn(path, value) {
      if (assertCollection(this.contents))
        this.contents.addIn(path, value);
    }
    createAlias(node, name) {
      if (!node.anchor) {
        const prev = anchors.anchorNames(this);
        node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
      }
      return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
      let _replacer = undefined;
      if (typeof replacer === "function") {
        value = replacer.call({ "": value }, "", value);
        _replacer = replacer;
      } else if (Array.isArray(replacer)) {
        const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
        const asStr = replacer.filter(keyToStr).map(String);
        if (asStr.length > 0)
          replacer = replacer.concat(asStr);
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
      const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
      const ctx = {
        aliasDuplicateObjects: aliasDuplicateObjects ?? true,
        keepUndefined: keepUndefined ?? false,
        onAnchor,
        onTagObj,
        replacer: _replacer,
        schema: this.schema,
        sourceObjects
      };
      const node = createNode.createNode(value, tag, ctx);
      if (flow && identity.isCollection(node))
        node.flow = true;
      setAnchors();
      return node;
    }
    createPair(key, value, options = {}) {
      const k = this.createNode(key, null, options);
      const v = this.createNode(value, null, options);
      return new Pair.Pair(k, v);
    }
    delete(key) {
      return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    deleteIn(path) {
      if (Collection.isEmptyPath(path)) {
        if (this.contents == null)
          return false;
        this.contents = null;
        return true;
      }
      return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
    }
    get(key, keepScalar) {
      return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : undefined;
    }
    getIn(path, keepScalar) {
      if (Collection.isEmptyPath(path))
        return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
      return identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : undefined;
    }
    has(key) {
      return identity.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    hasIn(path) {
      if (Collection.isEmptyPath(path))
        return this.contents !== undefined;
      return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    set(key, value) {
      if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, [key], value);
      } else if (assertCollection(this.contents)) {
        this.contents.set(key, value);
      }
    }
    setIn(path, value) {
      if (Collection.isEmptyPath(path)) {
        this.contents = value;
      } else if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
      } else if (assertCollection(this.contents)) {
        this.contents.setIn(path, value);
      }
    }
    setSchema(version, options = {}) {
      if (typeof version === "number")
        version = String(version);
      let opt;
      switch (version) {
        case "1.1":
          if (this.directives)
            this.directives.yaml.version = "1.1";
          else
            this.directives = new directives.Directives({ version: "1.1" });
          opt = { resolveKnownTags: false, schema: "yaml-1.1" };
          break;
        case "1.2":
        case "next":
          if (this.directives)
            this.directives.yaml.version = version;
          else
            this.directives = new directives.Directives({ version });
          opt = { resolveKnownTags: true, schema: "core" };
          break;
        case null:
          if (this.directives)
            delete this.directives;
          opt = null;
          break;
        default: {
          const sv = JSON.stringify(version);
          throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
        }
      }
      if (options.schema instanceof Object)
        this.schema = options.schema;
      else if (opt)
        this.schema = new Schema.Schema(Object.assign(opt, options));
      else
        throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      const ctx = {
        anchors: new Map,
        doc: this,
        keep: !json,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
    toJSON(jsonArg, onAnchor) {
      return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    toString(options = {}) {
      if (this.errors.length > 0)
        throw new Error("Document with errors cannot be stringified");
      if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
        const s = JSON.stringify(options.indent);
        throw new Error(`"indent" option must be a positive integer, not ${s}`);
      }
      return stringifyDocument.stringifyDocument(this, options);
    }
  }
  function assertCollection(contents) {
    if (identity.isCollection(contents))
      return true;
    throw new Error("Expected a YAML collection as document contents");
  }
  exports.Document = Document;
});

// node_modules/yaml/dist/errors.js
var require_errors2 = __commonJS((exports) => {
  class YAMLError extends Error {
    constructor(name, pos, code, message) {
      super();
      this.name = name;
      this.code = code;
      this.message = message;
      this.pos = pos;
    }
  }

  class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLParseError", pos, code, message);
    }
  }

  class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLWarning", pos, code, message);
    }
  }
  var prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
      return;
    error.linePos = error.pos.map((pos) => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
    if (ci >= 60 && lineStr.length > 80) {
      const trimStart = Math.min(ci - 39, lineStr.length - 79);
      lineStr = "" + lineStr.substring(trimStart);
      ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
      lineStr = lineStr.substring(0, 79) + "";
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
      let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
      if (prev.length > 80)
        prev = prev.substring(0, 79) + `
`;
      lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
      let count = 1;
      const end = error.linePos[1];
      if (end && end.line === line && end.col > col) {
        count = Math.max(1, Math.min(end.col - col, 80 - ci));
      }
      const pointer = " ".repeat(ci) + "^".repeat(count);
      error.message += `:

${lineStr}
${pointer}
`;
    }
  };
  exports.YAMLError = YAMLError;
  exports.YAMLParseError = YAMLParseError;
  exports.YAMLWarning = YAMLWarning;
  exports.prettifyError = prettifyError;
});

// node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS((exports) => {
  function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = "";
    let commentSep = "";
    let hasNewline = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag = null;
    let newlineAfterProp = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
      if (reqSpace) {
        if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
          onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
        reqSpace = false;
      }
      if (tab) {
        if (atNewline && token.type !== "comment" && token.type !== "newline") {
          onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        }
        tab = null;
      }
      switch (token.type) {
        case "space":
          if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("\t")) {
            tab = token;
          }
          hasSpace = true;
          break;
        case "comment": {
          if (!hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = token.source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += commentSep + cb;
          commentSep = "";
          atNewline = false;
          break;
        }
        case "newline":
          if (atNewline) {
            if (comment)
              comment += token.source;
            else if (!found || indicator !== "seq-item-ind")
              spaceBefore = true;
          } else
            commentSep += token.source;
          atNewline = true;
          hasNewline = true;
          if (anchor || tag)
            newlineAfterProp = token;
          hasSpace = true;
          break;
        case "anchor":
          if (anchor)
            onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
          if (token.source.endsWith(":"))
            onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
          anchor = token;
          start ?? (start = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        case "tag": {
          if (tag)
            onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
          tag = token;
          start ?? (start = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        }
        case indicator:
          if (anchor || tag)
            onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
          if (found)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
          found = token;
          atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
          hasSpace = false;
          break;
        case "comma":
          if (flow) {
            if (comma)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
            comma = token;
            atNewline = false;
            hasSpace = false;
            break;
          }
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
          atNewline = false;
          hasSpace = false;
      }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
      onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
    }
    if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
      onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
    return {
      comma,
      found,
      spaceBefore,
      comment,
      hasNewline,
      anchor,
      tag,
      newlineAfterProp,
      end,
      start: start ?? end
    };
  }
  exports.resolveProps = resolveProps;
});

// node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS((exports) => {
  function containsNewline(key) {
    if (!key)
      return null;
    switch (key.type) {
      case "alias":
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        if (key.source.includes(`
`))
          return true;
        if (key.end) {
          for (const st of key.end)
            if (st.type === "newline")
              return true;
        }
        return false;
      case "flow-collection":
        for (const it of key.items) {
          for (const st of it.start)
            if (st.type === "newline")
              return true;
          if (it.sep) {
            for (const st of it.sep)
              if (st.type === "newline")
                return true;
          }
          if (containsNewline(it.key) || containsNewline(it.value))
            return true;
        }
        return false;
      default:
        return true;
    }
  }
  exports.containsNewline = containsNewline;
});

// node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS((exports) => {
  var utilContainsNewline = require_util_contains_newline();
  function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === "flow-collection") {
      const end = fc.end[0];
      if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
        const msg = "Flow end indicator should be more indented than parent";
        onError(end, "BAD_INDENT", msg, true);
      }
    }
  }
  exports.flowIndentCheck = flowIndentCheck;
});

// node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS((exports) => {
  var identity = require_identity();
  function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
      return false;
    const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
    return items.some((pair) => isEqual(pair.key, search));
  }
  exports.mapIncludes = mapIncludes;
});

// node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS((exports) => {
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  var utilMapIncludes = require_util_map_includes();
  var startColMsg = "All mapping items must start at the same column";
  function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
      const { start, key, sep, value } = collItem;
      const keyProps = resolveProps.resolveProps(start, {
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        parentIndent: bm.indent,
        startOnNewline: true
      });
      const implicitKey = !keyProps.found;
      if (implicitKey) {
        if (key) {
          if (key.type === "block-seq")
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
          else if ("indent" in key && key.indent !== bm.indent)
            onError(offset, "BAD_INDENT", startColMsg);
        }
        if (!keyProps.anchor && !keyProps.tag && !sep) {
          commentEnd = keyProps.end;
          if (keyProps.comment) {
            if (map.comment)
              map.comment += `
` + keyProps.comment;
            else
              map.comment = keyProps.comment;
          }
          continue;
        }
        if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
          onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        }
      } else if (keyProps.found?.indent !== bm.indent) {
        onError(offset, "BAD_INDENT", startColMsg);
      }
      ctx.atKey = true;
      const keyStart = keyProps.end;
      const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
      ctx.atKey = false;
      if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
        onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
      const valueProps = resolveProps.resolveProps(sep ?? [], {
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: bm.indent,
        startOnNewline: !key || key.type === "block-scalar"
      });
      offset = valueProps.end;
      if (valueProps.found) {
        if (implicitKey) {
          if (value?.type === "block-map" && !valueProps.hasNewline)
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
          if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
            onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
        offset = valueNode.range[2];
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map.items.push(pair);
      } else {
        if (implicitKey)
          onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
        if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map.items.push(pair);
      }
    }
    if (commentEnd && commentEnd < offset)
      onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
    map.range = [bm.offset, offset, commentEnd ?? offset];
    return map;
  }
  exports.resolveBlockMap = resolveBlockMap;
});

// node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS((exports) => {
  var YAMLSeq = require_YAMLSeq();
  var resolveProps = require_resolve_props();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
      const props = resolveProps.resolveProps(start, {
        indicator: "seq-item-ind",
        next: value,
        offset,
        onError,
        parentIndent: bs.indent,
        startOnNewline: true
      });
      if (!props.found) {
        if (props.anchor || props.tag || value) {
          if (value && value.type === "block-seq")
            onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
          else
            onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
        } else {
          commentEnd = props.end;
          if (props.comment)
            seq.comment = props.comment;
          continue;
        }
      }
      const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
      offset = node.range[2];
      seq.items.push(node);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
  }
  exports.resolveBlockSeq = resolveBlockSeq;
});

// node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS((exports) => {
  function resolveEnd(end, offset, reqSpace, onError) {
    let comment = "";
    if (end) {
      let hasSpace = false;
      let sep = "";
      for (const token of end) {
        const { source, type } = token;
        switch (type) {
          case "space":
            hasSpace = true;
            break;
          case "comment": {
            if (reqSpace && !hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += sep + cb;
            sep = "";
            break;
          }
          case "newline":
            if (comment)
              sep += source;
            hasSpace = true;
            break;
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
        }
        offset += source.length;
      }
    }
    return { comment, offset };
  }
  exports.resolveEnd = resolveEnd;
});

// node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilMapIncludes = require_util_map_includes();
  var blockMsg = "Block collections are not allowed within flow collections";
  var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === "{";
    const fcName = isMap ? "flow map" : "flow sequence";
    const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0;i < fc.items.length; ++i) {
      const collItem = fc.items[i];
      const { start, key, sep, value } = collItem;
      const props = resolveProps.resolveProps(start, {
        flow: fcName,
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (!props.found) {
        if (!props.anchor && !props.tag && !sep && !value) {
          if (i === 0 && props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
          else if (i < fc.items.length - 1)
            onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
          if (props.comment) {
            if (coll.comment)
              coll.comment += `
` + props.comment;
            else
              coll.comment = props.comment;
          }
          offset = props.end;
          continue;
        }
        if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
          onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
      }
      if (i === 0) {
        if (props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
      } else {
        if (!props.comma)
          onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
        if (props.comment) {
          let prevItemComment = "";
          loop:
            for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
          if (prevItemComment) {
            let prev = coll.items[coll.items.length - 1];
            if (identity.isPair(prev))
              prev = prev.value ?? prev.key;
            if (prev.comment)
              prev.comment += `
` + prevItemComment;
            else
              prev.comment = prevItemComment;
            props.comment = props.comment.substring(prevItemComment.length + 1);
          }
        }
      }
      if (!isMap && !sep && !props.found) {
        const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
        coll.items.push(valueNode);
        offset = valueNode.range[2];
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else {
        ctx.atKey = true;
        const keyStart = props.end;
        const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
        if (isBlock(key))
          onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
        ctx.atKey = false;
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          flow: fcName,
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (valueProps.found) {
          if (!isMap && !props.found && ctx.options.strict) {
            if (sep)
              for (const st of sep) {
                if (st === valueProps.found)
                  break;
                if (st.type === "newline") {
                  onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                  break;
                }
              }
            if (props.start < valueProps.found.offset - 1024)
              onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
          }
        } else if (value) {
          if ("source" in value && value.source && value.source[0] === ":")
            onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
          else
            onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
        if (valueNode) {
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        if (isMap) {
          const map = coll;
          if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
          map.items.push(pair);
        } else {
          const map = new YAMLMap.YAMLMap(ctx.schema);
          map.flow = true;
          map.items.push(pair);
          const endRange = (valueNode ?? keyNode).range;
          map.range = [keyNode.range[0], endRange[1], endRange[2]];
          coll.items.push(map);
        }
        offset = valueNode ? valueNode.range[2] : valueProps.end;
      }
    }
    const expectedEnd = isMap ? "}" : "]";
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
      cePos = ce.offset + ce.source.length;
    else {
      const name = fcName[0].toUpperCase() + fcName.substring(1);
      const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
      onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
      if (ce && ce.source.length !== 1)
        ee.unshift(ce);
    }
    if (ee.length > 0) {
      const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
      if (end.comment) {
        if (coll.comment)
          coll.comment += `
` + end.comment;
        else
          coll.comment = end.comment;
      }
      coll.range = [fc.offset, cePos, end.offset];
    } else {
      coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
  }
  exports.resolveFlowCollection = resolveFlowCollection;
});

// node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveBlockMap = require_resolve_block_map();
  var resolveBlockSeq = require_resolve_block_seq();
  var resolveFlowCollection = require_resolve_flow_collection();
  function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    if (tagName === "!" || tagName === Coll.tagName) {
      coll.tag = Coll.tagName;
      return coll;
    }
    if (tagName)
      coll.tag = tagName;
    return coll;
  }
  function composeCollection(CN, ctx, token, props, onError) {
    const tagToken = props.tag;
    const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
    if (token.type === "block-seq") {
      const { anchor, newlineAfterProp: nl } = props;
      const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
      if (lastProp && (!nl || nl.offset < lastProp.offset)) {
        const message = "Missing newline after block sequence props";
        onError(lastProp, "MISSING_CHAR", message);
      }
    }
    const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
    if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
      return resolveCollection(CN, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
    if (!tag) {
      const kt = ctx.schema.knownTags[tagName];
      if (kt && kt.collection === expType) {
        ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
        tag = kt;
      } else {
        if (kt) {
          onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
        } else {
          onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
        }
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
    const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
      node.format = tag.format;
    return node;
  }
  exports.composeCollection = composeCollection;
});

// node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function resolveBlockScalar(ctx, scalar, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
    if (!header)
      return { value: "", type: null, comment: "", range: [start, start, start] };
    const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    let chompStart = lines.length;
    for (let i = lines.length - 1;i >= 0; --i) {
      const content = lines[i][1];
      if (content === "" || content === "\r")
        chompStart = i;
      else
        break;
    }
    if (chompStart === 0) {
      const value2 = header.chomp === "+" && lines.length > 0 ? `
`.repeat(Math.max(1, lines.length - 1)) : "";
      let end2 = start + header.length;
      if (scalar.source)
        end2 += scalar.source.length;
      return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
    }
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0;i < chompStart; ++i) {
      const [indent, content] = lines[i];
      if (content === "" || content === "\r") {
        if (header.indent === 0 && indent.length > trimIndent)
          trimIndent = indent.length;
      } else {
        if (indent.length < trimIndent) {
          const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
          onError(offset + indent.length, "MISSING_CHAR", message);
        }
        if (header.indent === 0)
          trimIndent = indent.length;
        contentStart = i;
        if (trimIndent === 0 && !ctx.atRoot) {
          const message = "Block scalar values in collections must be indented";
          onError(offset, "BAD_INDENT", message);
        }
        break;
      }
      offset += indent.length + content.length + 1;
    }
    for (let i = lines.length - 1;i >= chompStart; --i) {
      if (lines[i][0].length > trimIndent)
        chompStart = i + 1;
    }
    let value = "";
    let sep = "";
    let prevMoreIndented = false;
    for (let i = 0;i < contentStart; ++i)
      value += lines[i][0].slice(trimIndent) + `
`;
    for (let i = contentStart;i < chompStart; ++i) {
      let [indent, content] = lines[i];
      offset += indent.length + content.length + 1;
      const crlf = content[content.length - 1] === "\r";
      if (crlf)
        content = content.slice(0, -1);
      if (content && indent.length < trimIndent) {
        const src = header.indent ? "explicit indentation indicator" : "first line";
        const message = `Block scalar lines must not be less indented than their ${src}`;
        onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
        indent = "";
      }
      if (type === Scalar.Scalar.BLOCK_LITERAL) {
        value += sep + indent.slice(trimIndent) + content;
        sep = `
`;
      } else if (indent.length > trimIndent || content[0] === "\t") {
        if (sep === " ")
          sep = `
`;
        else if (!prevMoreIndented && sep === `
`)
          sep = `

`;
        value += sep + indent.slice(trimIndent) + content;
        sep = `
`;
        prevMoreIndented = true;
      } else if (content === "") {
        if (sep === `
`)
          value += `
`;
        else
          sep = `
`;
      } else {
        value += sep + content;
        sep = " ";
        prevMoreIndented = false;
      }
    }
    switch (header.chomp) {
      case "-":
        break;
      case "+":
        for (let i = chompStart;i < lines.length; ++i)
          value += `
` + lines[i][0].slice(trimIndent);
        if (value[value.length - 1] !== `
`)
          value += `
`;
        break;
      default:
        value += `
`;
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
  }
  function parseBlockScalarHeader({ offset, props }, strict, onError) {
    if (props[0].type !== "block-scalar-header") {
      onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
      return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = "";
    let error = -1;
    for (let i = 1;i < source.length; ++i) {
      const ch = source[i];
      if (!chomp && (ch === "-" || ch === "+"))
        chomp = ch;
      else {
        const n = Number(ch);
        if (!indent && n)
          indent = n;
        else if (error === -1)
          error = offset + i;
      }
    }
    if (error !== -1)
      onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = "";
    let length = source.length;
    for (let i = 1;i < props.length; ++i) {
      const token = props[i];
      switch (token.type) {
        case "space":
          hasSpace = true;
        case "newline":
          length += token.source.length;
          break;
        case "comment":
          if (strict && !hasSpace) {
            const message = "Comments must be separated from other tokens by white space characters";
            onError(token, "MISSING_CHAR", message);
          }
          length += token.source.length;
          comment = token.source.substring(1);
          break;
        case "error":
          onError(token, "UNEXPECTED_TOKEN", token.message);
          length += token.source.length;
          break;
        default: {
          const message = `Unexpected token in block scalar header: ${token.type}`;
          onError(token, "UNEXPECTED_TOKEN", message);
          const ts = token.source;
          if (ts && typeof ts === "string")
            length += ts.length;
        }
      }
    }
    return { mode, indent, chomp, comment, length };
  }
  function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
    const lines = [line0];
    for (let i = 1;i < split.length; i += 2)
      lines.push([split[i], split[i + 1]]);
    return lines;
  }
  exports.resolveBlockScalar = resolveBlockScalar;
});

// node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var resolveEnd = require_resolve_end();
  function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
      case "scalar":
        _type = Scalar.Scalar.PLAIN;
        value = plainValue(source, _onError);
        break;
      case "single-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_SINGLE;
        value = singleQuotedValue(source, _onError);
        break;
      case "double-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_DOUBLE;
        value = doubleQuotedValue(source, _onError);
        break;
      default:
        onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
        return {
          value: "",
          type: null,
          comment: "",
          range: [offset, offset + source.length, offset + source.length]
        };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
      value,
      type: _type,
      comment: re.comment,
      range: [offset, valueEnd, re.offset]
    };
  }
  function plainValue(source, onError) {
    let badChar = "";
    switch (source[0]) {
      case "\t":
        badChar = "a tab character";
        break;
      case ",":
        badChar = "flow indicator character ,";
        break;
      case "%":
        badChar = "directive indicator character %";
        break;
      case "|":
      case ">": {
        badChar = `block scalar indicator ${source[0]}`;
        break;
      }
      case "@":
      case "`": {
        badChar = `reserved character ${source[0]}`;
        break;
      }
    }
    if (badChar)
      onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
    return foldLines(source);
  }
  function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
      onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
  }
  function foldLines(source) {
    let first, line;
    try {
      first = new RegExp(`(.*?)(?<![ \t])[ \t]*\r?
`, "sy");
      line = new RegExp(`[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?
`, "sy");
    } catch {
      first = /(.*?)[ \t]*\r?\n/sy;
      line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
      return source;
    let res = match[1];
    let sep = " ";
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while (match = line.exec(source)) {
      if (match[1] === "") {
        if (sep === `
`)
          res += sep;
        else
          sep = `
`;
      } else {
        res += sep + match[1];
        sep = " ";
      }
      pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? "");
  }
  function doubleQuotedValue(source, onError) {
    let res = "";
    for (let i = 1;i < source.length - 1; ++i) {
      const ch = source[i];
      if (ch === "\r" && source[i + 1] === `
`)
        continue;
      if (ch === `
`) {
        const { fold, offset } = foldNewline(source, i);
        res += fold;
        i = offset;
      } else if (ch === "\\") {
        let next = source[++i];
        const cc = escapeCodes[next];
        if (cc)
          res += cc;
        else if (next === `
`) {
          next = source[i + 1];
          while (next === " " || next === "\t")
            next = source[++i + 1];
        } else if (next === "\r" && source[i + 1] === `
`) {
          next = source[++i + 1];
          while (next === " " || next === "\t")
            next = source[++i + 1];
        } else if (next === "x" || next === "u" || next === "U") {
          const length = { x: 2, u: 4, U: 8 }[next];
          res += parseCharCode(source, i + 1, length, onError);
          i += length;
        } else {
          const raw = source.substr(i - 1, 2);
          onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
          res += raw;
        }
      } else if (ch === " " || ch === "\t") {
        const wsStart = i;
        let next = source[i + 1];
        while (next === " " || next === "\t")
          next = source[++i + 1];
        if (next !== `
` && !(next === "\r" && source[i + 2] === `
`))
          res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
      } else {
        res += ch;
      }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
      onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
    return res;
  }
  function foldNewline(source, offset) {
    let fold = "";
    let ch = source[offset + 1];
    while (ch === " " || ch === "\t" || ch === `
` || ch === "\r") {
      if (ch === "\r" && source[offset + 2] !== `
`)
        break;
      if (ch === `
`)
        fold += `
`;
      offset += 1;
      ch = source[offset + 1];
    }
    if (!fold)
      fold = " ";
    return { fold, offset };
  }
  var escapeCodes = {
    "0": "\x00",
    a: "\x07",
    b: "\b",
    e: "\x1B",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "\t",
    v: "\v",
    N: "",
    _: "",
    L: "\u2028",
    P: "\u2029",
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "\t": "\t"
  };
  function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
      const raw = source.substr(offset - 2, length + 2);
      onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
      return raw;
    }
    return String.fromCodePoint(code);
  }
  exports.resolveFlowScalar = resolveFlowScalar;
});

// node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
    let tag;
    if (ctx.options.stringKeys && ctx.atKey) {
      tag = ctx.schema[identity.SCALAR];
    } else if (tagName)
      tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
    else if (token.type === "scalar")
      tag = findScalarTagByTest(ctx, value, token, onError);
    else
      tag = ctx.schema[identity.SCALAR];
    let scalar;
    try {
      const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
      scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
      scalar = new Scalar.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
      scalar.type = type;
    if (tagName)
      scalar.tag = tagName;
    if (tag.format)
      scalar.format = tag.format;
    if (comment)
      scalar.comment = comment;
    return scalar;
  }
  function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === "!")
      return schema[identity.SCALAR];
    const matchWithTest = [];
    for (const tag of schema.tags) {
      if (!tag.collection && tag.tag === tagName) {
        if (tag.default && tag.test)
          matchWithTest.push(tag);
        else
          return tag;
      }
    }
    for (const tag of matchWithTest)
      if (tag.test?.test(value))
        return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
      schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
      return kt;
    }
    onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
    return schema[identity.SCALAR];
  }
  function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
    const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema[identity.SCALAR];
    if (schema.compat) {
      const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema[identity.SCALAR];
      if (tag.tag !== compat.tag) {
        const ts = directives.tagString(tag.tag);
        const cs = directives.tagString(compat.tag);
        const msg = `Value may be parsed as either ${ts} or ${cs}`;
        onError(token, "TAG_RESOLVE_FAILED", msg, true);
      }
    }
    return tag;
  }
  exports.composeScalar = composeScalar;
});

// node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS((exports) => {
  function emptyScalarPosition(offset, before, pos) {
    if (before) {
      pos ?? (pos = before.length);
      for (let i = pos - 1;i >= 0; --i) {
        let st = before[i];
        switch (st.type) {
          case "space":
          case "comment":
          case "newline":
            offset -= st.source.length;
            continue;
        }
        st = before[++i];
        while (st?.type === "space") {
          offset += st.source.length;
          st = before[++i];
        }
        break;
      }
    }
    return offset;
  }
  exports.emptyScalarPosition = emptyScalarPosition;
});

// node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity = require_identity();
  var composeCollection = require_compose_collection();
  var composeScalar = require_compose_scalar();
  var resolveEnd = require_resolve_end();
  var utilEmptyScalarPosition = require_util_empty_scalar_position();
  var CN = { composeNode, composeEmptyNode };
  function composeNode(ctx, token, props, onError) {
    const atKey = ctx.atKey;
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
      case "alias":
        node = composeAlias(ctx, token, onError);
        if (anchor || tag)
          onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
        break;
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "block-scalar":
        node = composeScalar.composeScalar(ctx, token, tag, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      case "block-map":
      case "block-seq":
      case "flow-collection":
        node = composeCollection.composeCollection(CN, ctx, token, props, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      default: {
        const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
        onError(token, "UNEXPECTED_TOKEN", message);
        node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
        isSrcToken = false;
      }
    }
    if (anchor && node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
      const msg = "With stringKeys, all keys must be strings";
      onError(tag ?? token, "NON_STRING_KEY", msg);
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      if (token.type === "scalar" && token.source === "")
        node.comment = comment;
      else
        node.commentBefore = comment;
    }
    if (ctx.options.keepSourceTokens && isSrcToken)
      node.srcToken = token;
    return node;
  }
  function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
      type: "scalar",
      offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
      indent: -1,
      source: ""
    };
    const node = composeScalar.composeScalar(ctx, token, tag, onError);
    if (anchor) {
      node.anchor = anchor.source.substring(1);
      if (node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      node.comment = comment;
      node.range[2] = end;
    }
    return node;
  }
  function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === "")
      onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
    if (alias.source.endsWith(":"))
      onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
      alias.comment = re.comment;
    return alias;
  }
  exports.composeEmptyNode = composeEmptyNode;
  exports.composeNode = composeNode;
});

// node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS((exports) => {
  var Document = require_Document();
  var composeNode = require_compose_node();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document.Document(undefined, opts);
    const ctx = {
      atKey: false,
      atRoot: true,
      directives: doc.directives,
      options: doc.options,
      schema: doc.schema
    };
    const props = resolveProps.resolveProps(start, {
      indicator: "doc-start",
      next: value ?? end?.[0],
      offset,
      onError,
      parentIndent: 0,
      startOnNewline: true
    });
    if (props.found) {
      doc.directives.docStart = true;
      if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
        onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
    }
    doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
      doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
  }
  exports.composeDoc = composeDoc;
});

// node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS((exports) => {
  var node_process = __require("process");
  var directives = require_directives();
  var Document = require_Document();
  var errors = require_errors2();
  var identity = require_identity();
  var composeDoc = require_compose_doc();
  var resolveEnd = require_resolve_end();
  function getErrorPos(src) {
    if (typeof src === "number")
      return [src, src + 1];
    if (Array.isArray(src))
      return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === "string" ? source.length : 1)];
  }
  function parsePrelude(prelude) {
    let comment = "";
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0;i < prelude.length; ++i) {
      const source = prelude[i];
      switch (source[0]) {
        case "#":
          comment += (comment === "" ? "" : afterEmptyLine ? `

` : `
`) + (source.substring(1) || " ");
          atComment = true;
          afterEmptyLine = false;
          break;
        case "%":
          if (prelude[i + 1]?.[0] !== "#")
            i += 1;
          atComment = false;
          break;
        default:
          if (!atComment)
            afterEmptyLine = true;
          atComment = false;
      }
    }
    return { comment, afterEmptyLine };
  }

  class Composer {
    constructor(options = {}) {
      this.doc = null;
      this.atDirectives = false;
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
      this.onError = (source, code, message, warning) => {
        const pos = getErrorPos(source);
        if (warning)
          this.warnings.push(new errors.YAMLWarning(pos, code, message));
        else
          this.errors.push(new errors.YAMLParseError(pos, code, message));
      };
      this.directives = new directives.Directives({ version: options.version || "1.2" });
      this.options = options;
    }
    decorate(doc, afterDoc) {
      const { comment, afterEmptyLine } = parsePrelude(this.prelude);
      if (comment) {
        const dc = doc.contents;
        if (afterDoc) {
          doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
        } else if (afterEmptyLine || doc.directives.docStart || !dc) {
          doc.commentBefore = comment;
        } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
          let it = dc.items[0];
          if (identity.isPair(it))
            it = it.key;
          const cb = it.commentBefore;
          it.commentBefore = cb ? `${comment}
${cb}` : comment;
        } else {
          const cb = dc.commentBefore;
          dc.commentBefore = cb ? `${comment}
${cb}` : comment;
        }
      }
      if (afterDoc) {
        Array.prototype.push.apply(doc.errors, this.errors);
        Array.prototype.push.apply(doc.warnings, this.warnings);
      } else {
        doc.errors = this.errors;
        doc.warnings = this.warnings;
      }
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
    }
    streamInfo() {
      return {
        comment: parsePrelude(this.prelude).comment,
        directives: this.directives,
        errors: this.errors,
        warnings: this.warnings
      };
    }
    *compose(tokens, forceDoc = false, endOffset = -1) {
      for (const token of tokens)
        yield* this.next(token);
      yield* this.end(forceDoc, endOffset);
    }
    *next(token) {
      if (node_process.env.LOG_STREAM)
        console.dir(token, { depth: null });
      switch (token.type) {
        case "directive":
          this.directives.add(token.source, (offset, message, warning) => {
            const pos = getErrorPos(token);
            pos[0] += offset;
            this.onError(pos, "BAD_DIRECTIVE", message, warning);
          });
          this.prelude.push(token.source);
          this.atDirectives = true;
          break;
        case "document": {
          const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
          if (this.atDirectives && !doc.directives.docStart)
            this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
          this.decorate(doc, false);
          if (this.doc)
            yield this.doc;
          this.doc = doc;
          this.atDirectives = false;
          break;
        }
        case "byte-order-mark":
        case "space":
          break;
        case "comment":
        case "newline":
          this.prelude.push(token.source);
          break;
        case "error": {
          const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
          const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
          if (this.atDirectives || !this.doc)
            this.errors.push(error);
          else
            this.doc.errors.push(error);
          break;
        }
        case "doc-end": {
          if (!this.doc) {
            const msg = "Unexpected doc-end without preceding document";
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
            break;
          }
          this.doc.directives.docEnd = true;
          const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
          this.decorate(this.doc, true);
          if (end.comment) {
            const dc = this.doc.comment;
            this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
          }
          this.doc.range[2] = end.offset;
          break;
        }
        default:
          this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
      }
    }
    *end(forceDoc = false, endOffset = -1) {
      if (this.doc) {
        this.decorate(this.doc, true);
        yield this.doc;
        this.doc = null;
      } else if (forceDoc) {
        const opts = Object.assign({ _directives: this.directives }, this.options);
        const doc = new Document.Document(undefined, opts);
        if (this.atDirectives)
          this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
        doc.range = [0, endOffset, endOffset];
        this.decorate(doc, false);
        yield doc;
      }
    }
  }
  exports.Composer = Composer;
});

// node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS((exports) => {
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  var errors = require_errors2();
  var stringifyString = require_stringifyString();
  function resolveAsScalar(token, strict = true, onError) {
    if (token) {
      const _onError = (pos, code, message) => {
        const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
        if (onError)
          onError(offset, code, message);
        else
          throw new errors.YAMLParseError([offset, offset + 1], code, message);
      };
      switch (token.type) {
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
        case "block-scalar":
          return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
      }
    }
    return null;
  }
  function createScalarToken(value, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey,
      indent: indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context.end ?? [
      { type: "newline", offset: -1, indent, source: `
` }
    ];
    switch (source[0]) {
      case "|":
      case ">": {
        const he = source.indexOf(`
`);
        const head = source.substring(0, he);
        const body = source.substring(he + 1) + `
`;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, end))
          props.push({ type: "newline", offset: -1, indent, source: `
` });
        return { type: "block-scalar", offset, indent, props, source: body };
      }
      case '"':
        return { type: "double-quoted-scalar", offset, indent, source, end };
      case "'":
        return { type: "single-quoted-scalar", offset, indent, source, end };
      default:
        return { type: "scalar", offset, indent, source, end };
    }
  }
  function setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = "indent" in token ? token.indent : null;
    if (afterKey && typeof indent === "number")
      indent += 2;
    if (!type)
      switch (token.type) {
        case "single-quoted-scalar":
          type = "QUOTE_SINGLE";
          break;
        case "double-quoted-scalar":
          type = "QUOTE_DOUBLE";
          break;
        case "block-scalar": {
          const header = token.props[0];
          if (header.type !== "block-scalar-header")
            throw new Error("Invalid block scalar header");
          type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
          break;
        }
        default:
          type = "PLAIN";
      }
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey: implicitKey || indent === null,
      indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
      case "|":
      case ">":
        setBlockScalarValue(token, source);
        break;
      case '"':
        setFlowScalarValue(token, source, "double-quoted-scalar");
        break;
      case "'":
        setFlowScalarValue(token, source, "single-quoted-scalar");
        break;
      default:
        setFlowScalarValue(token, source, "scalar");
    }
  }
  function setBlockScalarValue(token, source) {
    const he = source.indexOf(`
`);
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + `
`;
    if (token.type === "block-scalar") {
      const header = token.props[0];
      if (header.type !== "block-scalar-header")
        throw new Error("Invalid block scalar header");
      header.source = head;
      token.source = body;
    } else {
      const { offset } = token;
      const indent = "indent" in token ? token.indent : -1;
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, "end" in token ? token.end : undefined))
        props.push({ type: "newline", offset: -1, indent, source: `
` });
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type: "block-scalar", indent, props, source: body });
    }
  }
  function addEndtoBlockProps(props, end) {
    if (end)
      for (const st of end)
        switch (st.type) {
          case "space":
          case "comment":
            props.push(st);
            break;
          case "newline":
            props.push(st);
            return true;
        }
    return false;
  }
  function setFlowScalarValue(token, source, type) {
    switch (token.type) {
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        token.type = type;
        token.source = source;
        break;
      case "block-scalar": {
        const end = token.props.slice(1);
        let oa = source.length;
        if (token.props[0].type === "block-scalar-header")
          oa -= token.props[0].source.length;
        for (const tok of end)
          tok.offset += oa;
        delete token.props;
        Object.assign(token, { type, source, end });
        break;
      }
      case "block-map":
      case "block-seq": {
        const offset = token.offset + source.length;
        const nl = { type: "newline", offset, indent: token.indent, source: `
` };
        delete token.items;
        Object.assign(token, { type, source, end: [nl] });
        break;
      }
      default: {
        const indent = "indent" in token ? token.indent : -1;
        const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type, indent, source, end });
      }
    }
  }
  exports.createScalarToken = createScalarToken;
  exports.resolveAsScalar = resolveAsScalar;
  exports.setScalarValue = setScalarValue;
});

// node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS((exports) => {
  var stringify = (cst) => ("type" in cst) ? stringifyToken(cst) : stringifyItem(cst);
  function stringifyToken(token) {
    switch (token.type) {
      case "block-scalar": {
        let res = "";
        for (const tok of token.props)
          res += stringifyToken(tok);
        return res + token.source;
      }
      case "block-map":
      case "block-seq": {
        let res = "";
        for (const item of token.items)
          res += stringifyItem(item);
        return res;
      }
      case "flow-collection": {
        let res = token.start.source;
        for (const item of token.items)
          res += stringifyItem(item);
        for (const st of token.end)
          res += st.source;
        return res;
      }
      case "document": {
        let res = stringifyItem(token);
        if (token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
      default: {
        let res = token.source;
        if ("end" in token && token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
    }
  }
  function stringifyItem({ start, key, sep, value }) {
    let res = "";
    for (const st of start)
      res += st.source;
    if (key)
      res += stringifyToken(key);
    if (sep)
      for (const st of sep)
        res += st.source;
    if (value)
      res += stringifyToken(value);
    return res;
  }
  exports.stringify = stringify;
});

// node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS((exports) => {
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove item");
  function visit(cst, visitor) {
    if ("type" in cst && cst.type === "document")
      cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
      const tok = item?.[field];
      if (tok && "items" in tok) {
        item = tok.items[index];
      } else
        return;
    }
    return item;
  };
  visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && "items" in coll)
      return coll;
    throw new Error("Parent collection not found");
  };
  function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === "symbol")
      return ctrl;
    for (const field of ["key", "value"]) {
      const token = item[field];
      if (token && "items" in token) {
        for (let i = 0;i < token.items.length; ++i) {
          const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            token.items.splice(i, 1);
            i -= 1;
          }
        }
        if (typeof ctrl === "function" && field === "key")
          ctrl = ctrl(item, path);
      }
    }
    return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
  }
  exports.visit = visit;
});

// node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS((exports) => {
  var cstScalar = require_cst_scalar();
  var cstStringify = require_cst_stringify();
  var cstVisit = require_cst_visit();
  var BOM = "\uFEFF";
  var DOCUMENT = "\x02";
  var FLOW_END = "\x18";
  var SCALAR = "\x1F";
  var isCollection = (token) => !!token && ("items" in token);
  var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  function prettyToken(token) {
    switch (token) {
      case BOM:
        return "<BOM>";
      case DOCUMENT:
        return "<DOC>";
      case FLOW_END:
        return "<FLOW_END>";
      case SCALAR:
        return "<SCALAR>";
      default:
        return JSON.stringify(token);
    }
  }
  function tokenType(source) {
    switch (source) {
      case BOM:
        return "byte-order-mark";
      case DOCUMENT:
        return "doc-mode";
      case FLOW_END:
        return "flow-error-end";
      case SCALAR:
        return "scalar";
      case "---":
        return "doc-start";
      case "...":
        return "doc-end";
      case "":
      case `
`:
      case `\r
`:
        return "newline";
      case "-":
        return "seq-item-ind";
      case "?":
        return "explicit-key-ind";
      case ":":
        return "map-value-ind";
      case "{":
        return "flow-map-start";
      case "}":
        return "flow-map-end";
      case "[":
        return "flow-seq-start";
      case "]":
        return "flow-seq-end";
      case ",":
        return "comma";
    }
    switch (source[0]) {
      case " ":
      case "\t":
        return "space";
      case "#":
        return "comment";
      case "%":
        return "directive-line";
      case "*":
        return "alias";
      case "&":
        return "anchor";
      case "!":
        return "tag";
      case "'":
        return "single-quoted-scalar";
      case '"':
        return "double-quoted-scalar";
      case "|":
      case ">":
        return "block-scalar-header";
    }
    return null;
  }
  exports.createScalarToken = cstScalar.createScalarToken;
  exports.resolveAsScalar = cstScalar.resolveAsScalar;
  exports.setScalarValue = cstScalar.setScalarValue;
  exports.stringify = cstStringify.stringify;
  exports.visit = cstVisit.visit;
  exports.BOM = BOM;
  exports.DOCUMENT = DOCUMENT;
  exports.FLOW_END = FLOW_END;
  exports.SCALAR = SCALAR;
  exports.isCollection = isCollection;
  exports.isScalar = isScalar;
  exports.prettyToken = prettyToken;
  exports.tokenType = tokenType;
});

// node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS((exports) => {
  var cst = require_cst();
  function isEmpty(ch) {
    switch (ch) {
      case undefined:
      case " ":
      case `
`:
      case "\r":
      case "\t":
        return true;
      default:
        return false;
    }
  }
  var hexDigits = new Set("0123456789ABCDEFabcdef");
  var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
  var flowIndicatorChars = new Set(",[]{}");
  var invalidAnchorChars = new Set(` ,[]{}
\r\t`);
  var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);

  class Lexer {
    constructor() {
      this.atEnd = false;
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      this.buffer = "";
      this.flowKey = false;
      this.flowLevel = 0;
      this.indentNext = 0;
      this.indentValue = 0;
      this.lineEndPos = null;
      this.next = null;
      this.pos = 0;
    }
    *lex(source, incomplete = false) {
      if (source) {
        if (typeof source !== "string")
          throw TypeError("source is not a string");
        this.buffer = this.buffer ? this.buffer + source : source;
        this.lineEndPos = null;
      }
      this.atEnd = !incomplete;
      let next = this.next ?? "stream";
      while (next && (incomplete || this.hasChars(1)))
        next = yield* this.parseNext(next);
    }
    atLineEnd() {
      let i = this.pos;
      let ch = this.buffer[i];
      while (ch === " " || ch === "\t")
        ch = this.buffer[++i];
      if (!ch || ch === "#" || ch === `
`)
        return true;
      if (ch === "\r")
        return this.buffer[i + 1] === `
`;
      return false;
    }
    charAt(n) {
      return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
      let ch = this.buffer[offset];
      if (this.indentNext > 0) {
        let indent = 0;
        while (ch === " ")
          ch = this.buffer[++indent + offset];
        if (ch === "\r") {
          const next = this.buffer[indent + offset + 1];
          if (next === `
` || !next && !this.atEnd)
            return offset + indent + 1;
        }
        return ch === `
` || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
      }
      if (ch === "-" || ch === ".") {
        const dt = this.buffer.substr(offset, 3);
        if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
          return -1;
      }
      return offset;
    }
    getLine() {
      let end = this.lineEndPos;
      if (typeof end !== "number" || end !== -1 && end < this.pos) {
        end = this.buffer.indexOf(`
`, this.pos);
        this.lineEndPos = end;
      }
      if (end === -1)
        return this.atEnd ? this.buffer.substring(this.pos) : null;
      if (this.buffer[end - 1] === "\r")
        end -= 1;
      return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
      return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
      this.buffer = this.buffer.substring(this.pos);
      this.pos = 0;
      this.lineEndPos = null;
      this.next = state;
      return null;
    }
    peek(n) {
      return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
      switch (next) {
        case "stream":
          return yield* this.parseStream();
        case "line-start":
          return yield* this.parseLineStart();
        case "block-start":
          return yield* this.parseBlockStart();
        case "doc":
          return yield* this.parseDocument();
        case "flow":
          return yield* this.parseFlowCollection();
        case "quoted-scalar":
          return yield* this.parseQuotedScalar();
        case "block-scalar":
          return yield* this.parseBlockScalar();
        case "plain-scalar":
          return yield* this.parsePlainScalar();
      }
    }
    *parseStream() {
      let line = this.getLine();
      if (line === null)
        return this.setNext("stream");
      if (line[0] === cst.BOM) {
        yield* this.pushCount(1);
        line = line.substring(1);
      }
      if (line[0] === "%") {
        let dirEnd = line.length;
        let cs = line.indexOf("#");
        while (cs !== -1) {
          const ch = line[cs - 1];
          if (ch === " " || ch === "\t") {
            dirEnd = cs - 1;
            break;
          } else {
            cs = line.indexOf("#", cs + 1);
          }
        }
        while (true) {
          const ch = line[dirEnd - 1];
          if (ch === " " || ch === "\t")
            dirEnd -= 1;
          else
            break;
        }
        const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
        yield* this.pushCount(line.length - n);
        this.pushNewline();
        return "stream";
      }
      if (this.atLineEnd()) {
        const sp = yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - sp);
        yield* this.pushNewline();
        return "stream";
      }
      yield cst.DOCUMENT;
      return yield* this.parseLineStart();
    }
    *parseLineStart() {
      const ch = this.charAt(0);
      if (!ch && !this.atEnd)
        return this.setNext("line-start");
      if (ch === "-" || ch === ".") {
        if (!this.atEnd && !this.hasChars(4))
          return this.setNext("line-start");
        const s = this.peek(3);
        if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
          yield* this.pushCount(3);
          this.indentValue = 0;
          this.indentNext = 0;
          return s === "---" ? "doc" : "stream";
        }
      }
      this.indentValue = yield* this.pushSpaces(false);
      if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
        this.indentNext = this.indentValue;
      return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
      const [ch0, ch1] = this.peek(2);
      if (!ch1 && !this.atEnd)
        return this.setNext("block-start");
      if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
        const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
        this.indentNext = this.indentValue + 1;
        this.indentValue += n;
        return yield* this.parseBlockStart();
      }
      return "doc";
    }
    *parseDocument() {
      yield* this.pushSpaces(true);
      const line = this.getLine();
      if (line === null)
        return this.setNext("doc");
      let n = yield* this.pushIndicators();
      switch (line[n]) {
        case "#":
          yield* this.pushCount(line.length - n);
        case undefined:
          yield* this.pushNewline();
          return yield* this.parseLineStart();
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel = 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          return "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "doc";
        case '"':
        case "'":
          return yield* this.parseQuotedScalar();
        case "|":
        case ">":
          n += yield* this.parseBlockScalarHeader();
          n += yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - n);
          yield* this.pushNewline();
          return yield* this.parseBlockScalar();
        default:
          return yield* this.parsePlainScalar();
      }
    }
    *parseFlowCollection() {
      let nl, sp;
      let indent = -1;
      do {
        nl = yield* this.pushNewline();
        if (nl > 0) {
          sp = yield* this.pushSpaces(false);
          this.indentValue = indent = sp;
        } else {
          sp = 0;
        }
        sp += yield* this.pushSpaces(true);
      } while (nl + sp > 0);
      const line = this.getLine();
      if (line === null)
        return this.setNext("flow");
      if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
        const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
        if (!atFlowEndMarker) {
          this.flowLevel = 0;
          yield cst.FLOW_END;
          return yield* this.parseLineStart();
        }
      }
      let n = 0;
      while (line[n] === ",") {
        n += yield* this.pushCount(1);
        n += yield* this.pushSpaces(true);
        this.flowKey = false;
      }
      n += yield* this.pushIndicators();
      switch (line[n]) {
        case undefined:
          return "flow";
        case "#":
          yield* this.pushCount(line.length - n);
          return "flow";
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel += 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          this.flowKey = true;
          this.flowLevel -= 1;
          return this.flowLevel ? "flow" : "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "flow";
        case '"':
        case "'":
          this.flowKey = true;
          return yield* this.parseQuotedScalar();
        case ":": {
          const next = this.charAt(1);
          if (this.flowKey || isEmpty(next) || next === ",") {
            this.flowKey = false;
            yield* this.pushCount(1);
            yield* this.pushSpaces(true);
            return "flow";
          }
        }
        default:
          this.flowKey = false;
          return yield* this.parsePlainScalar();
      }
    }
    *parseQuotedScalar() {
      const quote = this.charAt(0);
      let end = this.buffer.indexOf(quote, this.pos + 1);
      if (quote === "'") {
        while (end !== -1 && this.buffer[end + 1] === "'")
          end = this.buffer.indexOf("'", end + 2);
      } else {
        while (end !== -1) {
          let n = 0;
          while (this.buffer[end - 1 - n] === "\\")
            n += 1;
          if (n % 2 === 0)
            break;
          end = this.buffer.indexOf('"', end + 1);
        }
      }
      const qb = this.buffer.substring(0, end);
      let nl = qb.indexOf(`
`, this.pos);
      if (nl !== -1) {
        while (nl !== -1) {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = qb.indexOf(`
`, cs);
        }
        if (nl !== -1) {
          end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
        }
      }
      if (end === -1) {
        if (!this.atEnd)
          return this.setNext("quoted-scalar");
        end = this.buffer.length;
      }
      yield* this.pushToIndex(end + 1, false);
      return this.flowLevel ? "flow" : "doc";
    }
    *parseBlockScalarHeader() {
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      let i = this.pos;
      while (true) {
        const ch = this.buffer[++i];
        if (ch === "+")
          this.blockScalarKeep = true;
        else if (ch > "0" && ch <= "9")
          this.blockScalarIndent = Number(ch) - 1;
        else if (ch !== "-")
          break;
      }
      return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
    }
    *parseBlockScalar() {
      let nl = this.pos - 1;
      let indent = 0;
      let ch;
      loop:
        for (let i2 = this.pos;ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case `
`:
              nl = i2;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i2 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === `
`)
                break;
            }
            default:
              break loop;
          }
        }
      if (!ch && !this.atEnd)
        return this.setNext("block-scalar");
      if (indent >= this.indentNext) {
        if (this.blockScalarIndent === -1)
          this.indentNext = indent;
        else {
          this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
        }
        do {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = this.buffer.indexOf(`
`, cs);
        } while (nl !== -1);
        if (nl === -1) {
          if (!this.atEnd)
            return this.setNext("block-scalar");
          nl = this.buffer.length;
        }
      }
      let i = nl + 1;
      ch = this.buffer[i];
      while (ch === " ")
        ch = this.buffer[++i];
      if (ch === "\t") {
        while (ch === "\t" || ch === " " || ch === "\r" || ch === `
`)
          ch = this.buffer[++i];
        nl = i - 1;
      } else if (!this.blockScalarKeep) {
        do {
          let i2 = nl - 1;
          let ch2 = this.buffer[i2];
          if (ch2 === "\r")
            ch2 = this.buffer[--i2];
          const lastChar = i2;
          while (ch2 === " ")
            ch2 = this.buffer[--i2];
          if (ch2 === `
` && i2 >= this.pos && i2 + 1 + indent > lastChar)
            nl = i2;
          else
            break;
        } while (true);
      }
      yield cst.SCALAR;
      yield* this.pushToIndex(nl + 1, true);
      return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
      const inFlow = this.flowLevel > 0;
      let end = this.pos - 1;
      let i = this.pos - 1;
      let ch;
      while (ch = this.buffer[++i]) {
        if (ch === ":") {
          const next = this.buffer[i + 1];
          if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
            break;
          end = i;
        } else if (isEmpty(ch)) {
          let next = this.buffer[i + 1];
          if (ch === "\r") {
            if (next === `
`) {
              i += 1;
              ch = `
`;
              next = this.buffer[i + 1];
            } else
              end = i;
          }
          if (next === "#" || inFlow && flowIndicatorChars.has(next))
            break;
          if (ch === `
`) {
            const cs = this.continueScalar(i + 1);
            if (cs === -1)
              break;
            i = Math.max(i, cs - 2);
          }
        } else {
          if (inFlow && flowIndicatorChars.has(ch))
            break;
          end = i;
        }
      }
      if (!ch && !this.atEnd)
        return this.setNext("plain-scalar");
      yield cst.SCALAR;
      yield* this.pushToIndex(end + 1, true);
      return inFlow ? "flow" : "doc";
    }
    *pushCount(n) {
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos += n;
        return n;
      }
      return 0;
    }
    *pushToIndex(i, allowEmpty) {
      const s = this.buffer.slice(this.pos, i);
      if (s) {
        yield s;
        this.pos += s.length;
        return s.length;
      } else if (allowEmpty)
        yield "";
      return 0;
    }
    *pushIndicators() {
      switch (this.charAt(0)) {
        case "!":
          return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "&":
          return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "-":
        case "?":
        case ":": {
          const inFlow = this.flowLevel > 0;
          const ch1 = this.charAt(1);
          if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
            if (!inFlow)
              this.indentNext = this.indentValue + 1;
            else if (this.flowKey)
              this.flowKey = false;
            return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          }
        }
      }
      return 0;
    }
    *pushTag() {
      if (this.charAt(1) === "<") {
        let i = this.pos + 2;
        let ch = this.buffer[i];
        while (!isEmpty(ch) && ch !== ">")
          ch = this.buffer[++i];
        return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
      } else {
        let i = this.pos + 1;
        let ch = this.buffer[i];
        while (ch) {
          if (tagChars.has(ch))
            ch = this.buffer[++i];
          else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
            ch = this.buffer[i += 3];
          } else
            break;
        }
        return yield* this.pushToIndex(i, false);
      }
    }
    *pushNewline() {
      const ch = this.buffer[this.pos];
      if (ch === `
`)
        return yield* this.pushCount(1);
      else if (ch === "\r" && this.charAt(1) === `
`)
        return yield* this.pushCount(2);
      else
        return 0;
    }
    *pushSpaces(allowTabs) {
      let i = this.pos - 1;
      let ch;
      do {
        ch = this.buffer[++i];
      } while (ch === " " || allowTabs && ch === "\t");
      const n = i - this.pos;
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos = i;
      }
      return n;
    }
    *pushUntil(test) {
      let i = this.pos;
      let ch = this.buffer[i];
      while (!test(ch))
        ch = this.buffer[++i];
      return yield* this.pushToIndex(i, false);
    }
  }
  exports.Lexer = Lexer;
});

// node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS((exports) => {
  class LineCounter {
    constructor() {
      this.lineStarts = [];
      this.addNewLine = (offset) => this.lineStarts.push(offset);
      this.linePos = (offset) => {
        let low = 0;
        let high = this.lineStarts.length;
        while (low < high) {
          const mid = low + high >> 1;
          if (this.lineStarts[mid] < offset)
            low = mid + 1;
          else
            high = mid;
        }
        if (this.lineStarts[low] === offset)
          return { line: low + 1, col: 1 };
        if (low === 0)
          return { line: 0, col: offset };
        const start = this.lineStarts[low - 1];
        return { line: low, col: offset - start + 1 };
      };
    }
  }
  exports.LineCounter = LineCounter;
});

// node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS((exports) => {
  var node_process = __require("process");
  var cst = require_cst();
  var lexer = require_lexer();
  function includesToken(list, type) {
    for (let i = 0;i < list.length; ++i)
      if (list[i].type === type)
        return true;
    return false;
  }
  function findNonEmptyIndex(list) {
    for (let i = 0;i < list.length; ++i) {
      switch (list[i].type) {
        case "space":
        case "comment":
        case "newline":
          break;
        default:
          return i;
      }
    }
    return -1;
  }
  function isFlowToken(token) {
    switch (token?.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "flow-collection":
        return true;
      default:
        return false;
    }
  }
  function getPrevProps(parent) {
    switch (parent.type) {
      case "document":
        return parent.start;
      case "block-map": {
        const it = parent.items[parent.items.length - 1];
        return it.sep ?? it.start;
      }
      case "block-seq":
        return parent.items[parent.items.length - 1].start;
      default:
        return [];
    }
  }
  function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
      return [];
    let i = prev.length;
    loop:
      while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
    while (prev[++i]?.type === "space") {
    }
    return prev.splice(i, prev.length);
  }
  function fixFlowSeqItems(fc) {
    if (fc.start.type === "flow-seq-start") {
      for (const it of fc.items) {
        if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
          if (it.key)
            it.value = it.key;
          delete it.key;
          if (isFlowToken(it.value)) {
            if (it.value.end)
              Array.prototype.push.apply(it.value.end, it.sep);
            else
              it.value.end = it.sep;
          } else
            Array.prototype.push.apply(it.start, it.sep);
          delete it.sep;
        }
      }
    }
  }

  class Parser {
    constructor(onNewLine) {
      this.atNewLine = true;
      this.atScalar = false;
      this.indent = 0;
      this.offset = 0;
      this.onKeyLine = false;
      this.stack = [];
      this.source = "";
      this.type = "";
      this.lexer = new lexer.Lexer;
      this.onNewLine = onNewLine;
    }
    *parse(source, incomplete = false) {
      if (this.onNewLine && this.offset === 0)
        this.onNewLine(0);
      for (const lexeme of this.lexer.lex(source, incomplete))
        yield* this.next(lexeme);
      if (!incomplete)
        yield* this.end();
    }
    *next(source) {
      this.source = source;
      if (node_process.env.LOG_TOKENS)
        console.log("|", cst.prettyToken(source));
      if (this.atScalar) {
        this.atScalar = false;
        yield* this.step();
        this.offset += source.length;
        return;
      }
      const type = cst.tokenType(source);
      if (!type) {
        const message = `Not a YAML token: ${source}`;
        yield* this.pop({ type: "error", offset: this.offset, message, source });
        this.offset += source.length;
      } else if (type === "scalar") {
        this.atNewLine = false;
        this.atScalar = true;
        this.type = "scalar";
      } else {
        this.type = type;
        yield* this.step();
        switch (type) {
          case "newline":
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine)
              this.onNewLine(this.offset + source.length);
            break;
          case "space":
            if (this.atNewLine && source[0] === " ")
              this.indent += source.length;
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            if (this.atNewLine)
              this.indent += source.length;
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += source.length;
      }
    }
    *end() {
      while (this.stack.length > 0)
        yield* this.pop();
    }
    get sourceToken() {
      const st = {
        type: this.type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
      return st;
    }
    *step() {
      const top = this.peek(1);
      if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
        while (this.stack.length > 0)
          yield* this.pop();
        this.stack.push({
          type: "doc-end",
          offset: this.offset,
          source: this.source
        });
        return;
      }
      if (!top)
        return yield* this.stream();
      switch (top.type) {
        case "document":
          return yield* this.document(top);
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return yield* this.scalar(top);
        case "block-scalar":
          return yield* this.blockScalar(top);
        case "block-map":
          return yield* this.blockMap(top);
        case "block-seq":
          return yield* this.blockSequence(top);
        case "flow-collection":
          return yield* this.flowCollection(top);
        case "doc-end":
          return yield* this.documentEnd(top);
      }
      yield* this.pop();
    }
    peek(n) {
      return this.stack[this.stack.length - n];
    }
    *pop(error) {
      const token = error ?? this.stack.pop();
      if (!token) {
        const message = "Tried to pop an empty stack";
        yield { type: "error", offset: this.offset, source: "", message };
      } else if (this.stack.length === 0) {
        yield token;
      } else {
        const top = this.peek(1);
        if (token.type === "block-scalar") {
          token.indent = "indent" in top ? top.indent : 0;
        } else if (token.type === "flow-collection" && top.type === "document") {
          token.indent = 0;
        }
        if (token.type === "flow-collection")
          fixFlowSeqItems(token);
        switch (top.type) {
          case "document":
            top.value = token;
            break;
          case "block-scalar":
            top.props.push(token);
            break;
          case "block-map": {
            const it = top.items[top.items.length - 1];
            if (it.value) {
              top.items.push({ start: [], key: token, sep: [] });
              this.onKeyLine = true;
              return;
            } else if (it.sep) {
              it.value = token;
            } else {
              Object.assign(it, { key: token, sep: [] });
              this.onKeyLine = !it.explicitKey;
              return;
            }
            break;
          }
          case "block-seq": {
            const it = top.items[top.items.length - 1];
            if (it.value)
              top.items.push({ start: [], value: token });
            else
              it.value = token;
            break;
          }
          case "flow-collection": {
            const it = top.items[top.items.length - 1];
            if (!it || it.value)
              top.items.push({ start: [], key: token, sep: [] });
            else if (it.sep)
              it.value = token;
            else
              Object.assign(it, { key: token, sep: [] });
            return;
          }
          default:
            yield* this.pop();
            yield* this.pop(token);
        }
        if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
          const last = token.items[token.items.length - 1];
          if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
            if (top.type === "document")
              top.end = last.start;
            else
              top.items.push({ start: last.start });
            token.items.splice(-1, 1);
          }
        }
      }
    }
    *stream() {
      switch (this.type) {
        case "directive-line":
          yield { type: "directive", offset: this.offset, source: this.source };
          return;
        case "byte-order-mark":
        case "space":
        case "comment":
        case "newline":
          yield this.sourceToken;
          return;
        case "doc-mode":
        case "doc-start": {
          const doc = {
            type: "document",
            offset: this.offset,
            start: []
          };
          if (this.type === "doc-start")
            doc.start.push(this.sourceToken);
          this.stack.push(doc);
          return;
        }
      }
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML stream`,
        source: this.source
      };
    }
    *document(doc) {
      if (doc.value)
        return yield* this.lineEnd(doc);
      switch (this.type) {
        case "doc-start": {
          if (findNonEmptyIndex(doc.start) !== -1) {
            yield* this.pop();
            yield* this.step();
          } else
            doc.start.push(this.sourceToken);
          return;
        }
        case "anchor":
        case "tag":
        case "space":
        case "comment":
        case "newline":
          doc.start.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(doc);
      if (bv)
        this.stack.push(bv);
      else {
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML document`,
          source: this.source
        };
      }
    }
    *scalar(scalar) {
      if (this.type === "map-value-ind") {
        const prev = getPrevProps(this.peek(2));
        const start = getFirstKeyStartProps(prev);
        let sep;
        if (scalar.end) {
          sep = scalar.end;
          sep.push(this.sourceToken);
          delete scalar.end;
        } else
          sep = [this.sourceToken];
        const map = {
          type: "block-map",
          offset: scalar.offset,
          indent: scalar.indent,
          items: [{ start, key: scalar, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map;
      } else
        yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
      switch (this.type) {
        case "space":
        case "comment":
        case "newline":
          scalar.props.push(this.sourceToken);
          return;
        case "scalar":
          scalar.source = this.source;
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine) {
            let nl = this.source.indexOf(`
`) + 1;
            while (nl !== 0) {
              this.onNewLine(this.offset + nl);
              nl = this.source.indexOf(`
`, nl) + 1;
            }
          }
          yield* this.pop();
          break;
        default:
          yield* this.pop();
          yield* this.step();
      }
    }
    *blockMap(map) {
      const it = map.items[map.items.length - 1];
      switch (this.type) {
        case "newline":
          this.onKeyLine = false;
          if (it.value) {
            const end = "end" in it.value ? it.value.end : undefined;
            const last = Array.isArray(end) ? end[end.length - 1] : undefined;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              map.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "space":
        case "comment":
          if (it.value) {
            map.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            if (this.atIndentedComment(it.start, map.indent)) {
              const prev = map.items[map.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                map.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
      }
      if (this.indent >= map.indent) {
        const atMapIndent = !this.onKeyLine && this.indent === map.indent;
        const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
        let start = [];
        if (atNextItem && it.sep && !it.value) {
          const nl = [];
          for (let i = 0;i < it.sep.length; ++i) {
            const st = it.sep[i];
            switch (st.type) {
              case "newline":
                nl.push(i);
                break;
              case "space":
                break;
              case "comment":
                if (st.indent > map.indent)
                  nl.length = 0;
                break;
              default:
                nl.length = 0;
            }
          }
          if (nl.length >= 2)
            start = it.sep.splice(nl[1]);
        }
        switch (this.type) {
          case "anchor":
          case "tag":
            if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map.items.push({ start });
              this.onKeyLine = true;
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "explicit-key-ind":
            if (!it.sep && !it.explicitKey) {
              it.start.push(this.sourceToken);
              it.explicitKey = true;
            } else if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map.items.push({ start, explicitKey: true });
            } else {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [this.sourceToken], explicitKey: true }]
              });
            }
            this.onKeyLine = true;
            return;
          case "map-value-ind":
            if (it.explicitKey) {
              if (!it.sep) {
                if (includesToken(it.start, "newline")) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else {
                  const start2 = getFirstKeyStartProps(it.start);
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                  });
                }
              } else if (it.value) {
                map.items.push({ start: [], key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start, key: null, sep: [this.sourceToken] }]
                });
              } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                const start2 = getFirstKeyStartProps(it.start);
                const key = it.key;
                const sep = it.sep;
                sep.push(this.sourceToken);
                delete it.key;
                delete it.sep;
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key, sep }]
                });
              } else if (start.length > 0) {
                it.sep = it.sep.concat(start, this.sourceToken);
              } else {
                it.sep.push(this.sourceToken);
              }
            } else {
              if (!it.sep) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else if (it.value || atNextItem) {
                map.items.push({ start, key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [], key: null, sep: [this.sourceToken] }]
                });
              } else {
                it.sep.push(this.sourceToken);
              }
            }
            this.onKeyLine = true;
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (atNextItem || it.value) {
              map.items.push({ start, key: fs, sep: [] });
              this.onKeyLine = true;
            } else if (it.sep) {
              this.stack.push(fs);
            } else {
              Object.assign(it, { key: fs, sep: [] });
              this.onKeyLine = true;
            }
            return;
          }
          default: {
            const bv = this.startBlockValue(map);
            if (bv) {
              if (bv.type === "block-seq") {
                if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                  yield* this.pop({
                    type: "error",
                    offset: this.offset,
                    message: "Unexpected block-seq-ind on same line with key",
                    source: this.source
                  });
                  return;
                }
              } else if (atMapIndent) {
                map.items.push({ start });
              }
              this.stack.push(bv);
              return;
            }
          }
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *blockSequence(seq) {
      const it = seq.items[seq.items.length - 1];
      switch (this.type) {
        case "newline":
          if (it.value) {
            const end = "end" in it.value ? it.value.end : undefined;
            const last = Array.isArray(end) ? end[end.length - 1] : undefined;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              seq.items.push({ start: [this.sourceToken] });
          } else
            it.start.push(this.sourceToken);
          return;
        case "space":
        case "comment":
          if (it.value)
            seq.items.push({ start: [this.sourceToken] });
          else {
            if (this.atIndentedComment(it.start, seq.indent)) {
              const prev = seq.items[seq.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                seq.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
        case "anchor":
        case "tag":
          if (it.value || this.indent <= seq.indent)
            break;
          it.start.push(this.sourceToken);
          return;
        case "seq-item-ind":
          if (this.indent !== seq.indent)
            break;
          if (it.value || includesToken(it.start, "seq-item-ind"))
            seq.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
      }
      if (this.indent > seq.indent) {
        const bv = this.startBlockValue(seq);
        if (bv) {
          this.stack.push(bv);
          return;
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *flowCollection(fc) {
      const it = fc.items[fc.items.length - 1];
      if (this.type === "flow-error-end") {
        let top;
        do {
          yield* this.pop();
          top = this.peek(1);
        } while (top && top.type === "flow-collection");
      } else if (fc.end.length === 0) {
        switch (this.type) {
          case "comma":
          case "explicit-key-ind":
            if (!it || it.sep)
              fc.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
          case "map-value-ind":
            if (!it || it.value)
              fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            return;
          case "space":
          case "comment":
          case "newline":
          case "anchor":
          case "tag":
            if (!it || it.value)
              fc.items.push({ start: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              it.start.push(this.sourceToken);
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (!it || it.value)
              fc.items.push({ start: [], key: fs, sep: [] });
            else if (it.sep)
              this.stack.push(fs);
            else
              Object.assign(it, { key: fs, sep: [] });
            return;
          }
          case "flow-map-end":
          case "flow-seq-end":
            fc.end.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(fc);
        if (bv)
          this.stack.push(bv);
        else {
          yield* this.pop();
          yield* this.step();
        }
      } else {
        const parent = this.peek(2);
        if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
          yield* this.pop();
          yield* this.step();
        } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          fixFlowSeqItems(fc);
          const sep = fc.end.splice(1, fc.end.length);
          sep.push(this.sourceToken);
          const map = {
            type: "block-map",
            offset: fc.offset,
            indent: fc.indent,
            items: [{ start, key: fc, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else {
          yield* this.lineEnd(fc);
        }
      }
    }
    flowScalar(type) {
      if (this.onNewLine) {
        let nl = this.source.indexOf(`
`) + 1;
        while (nl !== 0) {
          this.onNewLine(this.offset + nl);
          nl = this.source.indexOf(`
`, nl) + 1;
        }
      }
      return {
        type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
    }
    startBlockValue(parent) {
      switch (this.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return this.flowScalar(this.type);
        case "block-scalar-header":
          return {
            type: "block-scalar",
            offset: this.offset,
            indent: this.indent,
            props: [this.sourceToken],
            source: ""
          };
        case "flow-map-start":
        case "flow-seq-start":
          return {
            type: "flow-collection",
            offset: this.offset,
            indent: this.indent,
            start: this.sourceToken,
            items: [],
            end: []
          };
        case "seq-item-ind":
          return {
            type: "block-seq",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken] }]
          };
        case "explicit-key-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          start.push(this.sourceToken);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start, explicitKey: true }]
          };
        }
        case "map-value-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start, key: null, sep: [this.sourceToken] }]
          };
        }
      }
      return null;
    }
    atIndentedComment(start, indent) {
      if (this.type !== "comment")
        return false;
      if (this.indent <= indent)
        return false;
      return start.every((st) => st.type === "newline" || st.type === "space");
    }
    *documentEnd(docEnd) {
      if (this.type !== "doc-mode") {
        if (docEnd.end)
          docEnd.end.push(this.sourceToken);
        else
          docEnd.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
      }
    }
    *lineEnd(token) {
      switch (this.type) {
        case "comma":
        case "doc-start":
        case "doc-end":
        case "flow-seq-end":
        case "flow-map-end":
        case "map-value-ind":
          yield* this.pop();
          yield* this.step();
          break;
        case "newline":
          this.onKeyLine = false;
        case "space":
        case "comment":
        default:
          if (token.end)
            token.end.push(this.sourceToken);
          else
            token.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
      }
    }
  }
  exports.Parser = Parser;
});

// node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS((exports) => {
  var composer = require_composer();
  var Document = require_Document();
  var errors = require_errors2();
  var log = require_log();
  var identity = require_identity();
  var lineCounter = require_line_counter();
  var parser = require_parser();
  function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter || null;
    return { lineCounter: lineCounter$1, prettyErrors };
  }
  function parseAllDocuments(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter2)
      for (const doc of docs) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
    if (docs.length > 0)
      return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
  }
  function parseDocument(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options);
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
      if (!doc)
        doc = _doc;
      else if (doc.options.logLevel !== "silent") {
        doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
        break;
      }
    }
    if (prettyErrors && lineCounter2) {
      doc.errors.forEach(errors.prettifyError(source, lineCounter2));
      doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
    }
    return doc;
  }
  function parse(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === "function") {
      _reviver = reviver;
    } else if (options === undefined && reviver && typeof reviver === "object") {
      options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
      return null;
    doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
      if (doc.options.logLevel !== "silent")
        throw doc.errors[0];
      else
        doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
  }
  function stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === undefined && replacer) {
      options = replacer;
    }
    if (typeof options === "string")
      options = options.length;
    if (typeof options === "number") {
      const indent = Math.round(options);
      options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
      const { keepUndefined } = options ?? replacer ?? {};
      if (!keepUndefined)
        return;
    }
    if (identity.isDocument(value) && !_replacer)
      return value.toString(options);
    return new Document.Document(value, _replacer, options).toString(options);
  }
  exports.parse = parse;
  exports.parseAllDocuments = parseAllDocuments;
  exports.parseDocument = parseDocument;
  exports.stringify = stringify;
});

// node_modules/yaml/dist/index.js
var require_dist = __commonJS((exports) => {
  var composer = require_composer();
  var Document = require_Document();
  var Schema = require_Schema();
  var errors = require_errors2();
  var Alias = require_Alias();
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var cst = require_cst();
  var lexer = require_lexer();
  var lineCounter = require_line_counter();
  var parser = require_parser();
  var publicApi = require_public_api();
  var visit = require_visit();
  exports.Composer = composer.Composer;
  exports.Document = Document.Document;
  exports.Schema = Schema.Schema;
  exports.YAMLError = errors.YAMLError;
  exports.YAMLParseError = errors.YAMLParseError;
  exports.YAMLWarning = errors.YAMLWarning;
  exports.Alias = Alias.Alias;
  exports.isAlias = identity.isAlias;
  exports.isCollection = identity.isCollection;
  exports.isDocument = identity.isDocument;
  exports.isMap = identity.isMap;
  exports.isNode = identity.isNode;
  exports.isPair = identity.isPair;
  exports.isScalar = identity.isScalar;
  exports.isSeq = identity.isSeq;
  exports.Pair = Pair.Pair;
  exports.Scalar = Scalar.Scalar;
  exports.YAMLMap = YAMLMap.YAMLMap;
  exports.YAMLSeq = YAMLSeq.YAMLSeq;
  exports.CST = cst;
  exports.Lexer = lexer.Lexer;
  exports.LineCounter = lineCounter.LineCounter;
  exports.Parser = parser.Parser;
  exports.parse = publicApi.parse;
  exports.parseAllDocuments = publicApi.parseAllDocuments;
  exports.parseDocument = publicApi.parseDocument;
  exports.stringify = publicApi.stringify;
  exports.visit = visit.visit;
  exports.visitAsync = visit.visitAsync;
});

// node_modules/@actions/github/lib/context.js
var require_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Context = undefined;
  var fs_1 = __require("fs");
  var os_1 = __require("os");

  class Context {
    constructor() {
      var _a, _b, _c;
      this.payload = {};
      if (process.env.GITHUB_EVENT_PATH) {
        if ((0, fs_1.existsSync)(process.env.GITHUB_EVENT_PATH)) {
          this.payload = JSON.parse((0, fs_1.readFileSync)(process.env.GITHUB_EVENT_PATH, { encoding: "utf8" }));
        } else {
          const path = process.env.GITHUB_EVENT_PATH;
          process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);
        }
      }
      this.eventName = process.env.GITHUB_EVENT_NAME;
      this.sha = process.env.GITHUB_SHA;
      this.ref = process.env.GITHUB_REF;
      this.workflow = process.env.GITHUB_WORKFLOW;
      this.action = process.env.GITHUB_ACTION;
      this.actor = process.env.GITHUB_ACTOR;
      this.job = process.env.GITHUB_JOB;
      this.runAttempt = parseInt(process.env.GITHUB_RUN_ATTEMPT, 10);
      this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
      this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
      this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== undefined ? _a : `https://api.github.com`;
      this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== undefined ? _b : `https://github.com`;
      this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== undefined ? _c : `https://api.github.com/graphql`;
    }
    get issue() {
      const payload = this.payload;
      return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
    }
    get repo() {
      if (process.env.GITHUB_REPOSITORY) {
        const [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
        return { owner, repo };
      }
      if (this.payload.repository) {
        return {
          owner: this.payload.repository.owner.login,
          repo: this.payload.repository.name
        };
      }
      throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
    }
  }
  exports.Context = Context;
});

// node_modules/@actions/github/lib/internal/utils.js
var require_utils3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getApiBaseUrl = exports.getProxyFetch = exports.getProxyAgentDispatcher = exports.getProxyAgent = exports.getAuthString = undefined;
  var httpClient = __importStar(require_lib());
  var undici_1 = require_undici();
  function getAuthString(token, options) {
    if (!token && !options.auth) {
      throw new Error("Parameter token or opts.auth is required");
    } else if (token && options.auth) {
      throw new Error("Parameters token and opts.auth may not both be specified");
    }
    return typeof options.auth === "string" ? options.auth : `token ${token}`;
  }
  exports.getAuthString = getAuthString;
  function getProxyAgent(destinationUrl) {
    const hc = new httpClient.HttpClient;
    return hc.getAgent(destinationUrl);
  }
  exports.getProxyAgent = getProxyAgent;
  function getProxyAgentDispatcher(destinationUrl) {
    const hc = new httpClient.HttpClient;
    return hc.getAgentDispatcher(destinationUrl);
  }
  exports.getProxyAgentDispatcher = getProxyAgentDispatcher;
  function getProxyFetch(destinationUrl) {
    const httpDispatcher = getProxyAgentDispatcher(destinationUrl);
    const proxyFetch = (url, opts) => __awaiter(this, undefined, undefined, function* () {
      return (0, undici_1.fetch)(url, Object.assign(Object.assign({}, opts), { dispatcher: httpDispatcher }));
    });
    return proxyFetch;
  }
  exports.getProxyFetch = getProxyFetch;
  function getApiBaseUrl() {
    return process.env["GITHUB_API_URL"] || "https://api.github.com";
  }
  exports.getApiBaseUrl = getApiBaseUrl;
});

// node_modules/@actions/github/node_modules/@octokit/core/node_modules/universal-user-agent/dist-node/index.js
var require_dist_node = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function getUserAgent() {
    if (typeof navigator === "object" && "userAgent" in navigator) {
      return navigator.userAgent;
    }
    if (typeof process === "object" && process.version !== undefined) {
      return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
    }
    return "<environment undetectable>";
  }
  exports.getUserAgent = getUserAgent;
});

// node_modules/@actions/github/node_modules/@octokit/core/node_modules/before-after-hook/lib/register.js
var require_register = __commonJS((exports, module) => {
  module.exports = register;
  function register(state, name, method, options) {
    if (typeof method !== "function") {
      throw new Error("method for before hook must be a function");
    }
    if (!options) {
      options = {};
    }
    if (Array.isArray(name)) {
      return name.reverse().reduce(function(callback, name2) {
        return register.bind(null, state, name2, callback, options);
      }, method)();
    }
    return Promise.resolve().then(function() {
      if (!state.registry[name]) {
        return method(options);
      }
      return state.registry[name].reduce(function(method2, registered) {
        return registered.hook.bind(null, method2, options);
      }, method)();
    });
  }
});

// node_modules/@actions/github/node_modules/@octokit/core/node_modules/before-after-hook/lib/add.js
var require_add = __commonJS((exports, module) => {
  module.exports = addHook;
  function addHook(state, kind, name, hook) {
    var orig = hook;
    if (!state.registry[name]) {
      state.registry[name] = [];
    }
    if (kind === "before") {
      hook = function(method, options) {
        return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
      };
    }
    if (kind === "after") {
      hook = function(method, options) {
        var result;
        return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
          result = result_;
          return orig(result, options);
        }).then(function() {
          return result;
        });
      };
    }
    if (kind === "error") {
      hook = function(method, options) {
        return Promise.resolve().then(method.bind(null, options)).catch(function(error) {
          return orig(error, options);
        });
      };
    }
    state.registry[name].push({
      hook,
      orig
    });
  }
});

// node_modules/@actions/github/node_modules/@octokit/core/node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS((exports, module) => {
  module.exports = removeHook;
  function removeHook(state, name, method) {
    if (!state.registry[name]) {
      return;
    }
    var index = state.registry[name].map(function(registered) {
      return registered.orig;
    }).indexOf(method);
    if (index === -1) {
      return;
    }
    state.registry[name].splice(index, 1);
  }
});

// node_modules/@actions/github/node_modules/@octokit/core/node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS((exports, module) => {
  var register = require_register();
  var addHook = require_add();
  var removeHook = require_remove();
  var bind = Function.bind;
  var bindable = bind.bind(bind);
  function bindApi(hook, state, name) {
    var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
    hook.api = { remove: removeHookRef };
    hook.remove = removeHookRef;
    ["before", "error", "after", "wrap"].forEach(function(kind) {
      var args = name ? [state, kind, name] : [state, kind];
      hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
    });
  }
  function HookSingular() {
    var singularHookName = "h";
    var singularHookState = {
      registry: {}
    };
    var singularHook = register.bind(null, singularHookState, singularHookName);
    bindApi(singularHook, singularHookState, singularHookName);
    return singularHook;
  }
  function HookCollection() {
    var state = {
      registry: {}
    };
    var hook = register.bind(null, state);
    bindApi(hook, state);
    return hook;
  }
  var collectionHookDeprecationMessageDisplayed = false;
  function Hook() {
    if (!collectionHookDeprecationMessageDisplayed) {
      console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4');
      collectionHookDeprecationMessageDisplayed = true;
    }
    return HookCollection();
  }
  Hook.Singular = HookSingular.bind();
  Hook.Collection = HookCollection.bind();
  module.exports = Hook;
  module.exports.Hook = Hook;
  module.exports.Singular = Hook.Singular;
  module.exports.Collection = Hook.Collection;
});

// node_modules/@octokit/endpoint/node_modules/universal-user-agent/dist-node/index.js
var require_dist_node2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function getUserAgent() {
    if (typeof navigator === "object" && "userAgent" in navigator) {
      return navigator.userAgent;
    }
    if (typeof process === "object" && process.version !== undefined) {
      return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
    }
    return "<environment undetectable>";
  }
  exports.getUserAgent = getUserAgent;
});

// node_modules/@octokit/endpoint/dist-node/index.js
var require_dist_node3 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var dist_src_exports = {};
  __export2(dist_src_exports, {
    endpoint: () => endpoint
  });
  module.exports = __toCommonJS(dist_src_exports);
  var import_universal_user_agent = require_dist_node2();
  var VERSION = "9.0.6";
  var userAgent = `octokit-endpoint.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`;
  var DEFAULTS = {
    method: "GET",
    baseUrl: "https://api.github.com",
    headers: {
      accept: "application/vnd.github.v3+json",
      "user-agent": userAgent
    },
    mediaType: {
      format: ""
    }
  };
  function lowercaseKeys(object) {
    if (!object) {
      return {};
    }
    return Object.keys(object).reduce((newObj, key) => {
      newObj[key.toLowerCase()] = object[key];
      return newObj;
    }, {});
  }
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null)
      return false;
    if (Object.prototype.toString.call(value) !== "[object Object]")
      return false;
    const proto = Object.getPrototypeOf(value);
    if (proto === null)
      return true;
    const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
  }
  function mergeDeep(defaults, options) {
    const result = Object.assign({}, defaults);
    Object.keys(options).forEach((key) => {
      if (isPlainObject(options[key])) {
        if (!(key in defaults))
          Object.assign(result, { [key]: options[key] });
        else
          result[key] = mergeDeep(defaults[key], options[key]);
      } else {
        Object.assign(result, { [key]: options[key] });
      }
    });
    return result;
  }
  function removeUndefinedProperties(obj) {
    for (const key in obj) {
      if (obj[key] === undefined) {
        delete obj[key];
      }
    }
    return obj;
  }
  function merge(defaults, route, options) {
    if (typeof route === "string") {
      let [method, url] = route.split(" ");
      options = Object.assign(url ? { method, url } : { url: method }, options);
    } else {
      options = Object.assign({}, route);
    }
    options.headers = lowercaseKeys(options.headers);
    removeUndefinedProperties(options);
    removeUndefinedProperties(options.headers);
    const mergedOptions = mergeDeep(defaults || {}, options);
    if (options.url === "/graphql") {
      if (defaults && defaults.mediaType.previews?.length) {
        mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
      }
      mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
    }
    return mergedOptions;
  }
  function addQueryParameters(url, parameters) {
    const separator = /\?/.test(url) ? "&" : "?";
    const names = Object.keys(parameters);
    if (names.length === 0) {
      return url;
    }
    return url + separator + names.map((name) => {
      if (name === "q") {
        return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
      }
      return `${name}=${encodeURIComponent(parameters[name])}`;
    }).join("&");
  }
  var urlVariableRegex = /\{[^{}}]+\}/g;
  function removeNonChars(variableName) {
    return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
  }
  function extractUrlVariableNames(url) {
    const matches = url.match(urlVariableRegex);
    if (!matches) {
      return [];
    }
    return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
  }
  function omit(object, keysToOmit) {
    const result = { __proto__: null };
    for (const key of Object.keys(object)) {
      if (keysToOmit.indexOf(key) === -1) {
        result[key] = object[key];
      }
    }
    return result;
  }
  function encodeReserved(str) {
    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
      if (!/%[0-9A-Fa-f]/.test(part)) {
        part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
      }
      return part;
    }).join("");
  }
  function encodeUnreserved(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function encodeValue(operator, value, key) {
    value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
    if (key) {
      return encodeUnreserved(key) + "=" + value;
    } else {
      return value;
    }
  }
  function isDefined(value) {
    return value !== undefined && value !== null;
  }
  function isKeyOperator(operator) {
    return operator === ";" || operator === "&" || operator === "?";
  }
  function getValues(context, operator, key, modifier) {
    var value = context[key], result = [];
    if (isDefined(value) && value !== "") {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        value = value.toString();
        if (modifier && modifier !== "*") {
          value = value.substring(0, parseInt(modifier, 10));
        }
        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
      } else {
        if (modifier === "*") {
          if (Array.isArray(value)) {
            value.filter(isDefined).forEach(function(value2) {
              result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
            });
          } else {
            Object.keys(value).forEach(function(k) {
              if (isDefined(value[k])) {
                result.push(encodeValue(operator, value[k], k));
              }
            });
          }
        } else {
          const tmp = [];
          if (Array.isArray(value)) {
            value.filter(isDefined).forEach(function(value2) {
              tmp.push(encodeValue(operator, value2));
            });
          } else {
            Object.keys(value).forEach(function(k) {
              if (isDefined(value[k])) {
                tmp.push(encodeUnreserved(k));
                tmp.push(encodeValue(operator, value[k].toString()));
              }
            });
          }
          if (isKeyOperator(operator)) {
            result.push(encodeUnreserved(key) + "=" + tmp.join(","));
          } else if (tmp.length !== 0) {
            result.push(tmp.join(","));
          }
        }
      }
    } else {
      if (operator === ";") {
        if (isDefined(value)) {
          result.push(encodeUnreserved(key));
        }
      } else if (value === "" && (operator === "&" || operator === "?")) {
        result.push(encodeUnreserved(key) + "=");
      } else if (value === "") {
        result.push("");
      }
    }
    return result;
  }
  function parseUrl(template) {
    return {
      expand: expand.bind(null, template)
    };
  }
  function expand(template, context) {
    var operators = ["+", "#", ".", "/", ";", "?", "&"];
    template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    });
    if (template === "/") {
      return template;
    } else {
      return template.replace(/\/$/, "");
    }
  }
  function parse(options) {
    let method = options.method.toUpperCase();
    let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
    let headers = Object.assign({}, options.headers);
    let body;
    let parameters = omit(options, [
      "method",
      "baseUrl",
      "url",
      "headers",
      "request",
      "mediaType"
    ]);
    const urlVariableNames = extractUrlVariableNames(url);
    url = parseUrl(url).expand(parameters);
    if (!/^http/.test(url)) {
      url = options.baseUrl + url;
    }
    const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
    const remainingParameters = omit(parameters, omittedParameters);
    const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
    if (!isBinaryRequest) {
      if (options.mediaType.format) {
        headers.accept = headers.accept.split(/,/).map((format) => format.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
      }
      if (url.endsWith("/graphql")) {
        if (options.mediaType.previews?.length) {
          const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
          headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
            const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
            return `application/vnd.github.${preview}-preview${format}`;
          }).join(",");
        }
      }
    }
    if (["GET", "HEAD"].includes(method)) {
      url = addQueryParameters(url, remainingParameters);
    } else {
      if ("data" in remainingParameters) {
        body = remainingParameters.data;
      } else {
        if (Object.keys(remainingParameters).length) {
          body = remainingParameters;
        }
      }
    }
    if (!headers["content-type"] && typeof body !== "undefined") {
      headers["content-type"] = "application/json; charset=utf-8";
    }
    if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
      body = "";
    }
    return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
  }
  function endpointWithDefaults(defaults, route, options) {
    return parse(merge(defaults, route, options));
  }
  function withDefaults(oldDefaults, newDefaults) {
    const DEFAULTS2 = merge(oldDefaults, newDefaults);
    const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
    return Object.assign(endpoint2, {
      DEFAULTS: DEFAULTS2,
      defaults: withDefaults.bind(null, DEFAULTS2),
      merge: merge.bind(null, DEFAULTS2),
      parse
    });
  }
  var endpoint = withDefaults(null, DEFAULTS);
});

// node_modules/@octokit/request/node_modules/universal-user-agent/dist-node/index.js
var require_dist_node4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function getUserAgent() {
    if (typeof navigator === "object" && "userAgent" in navigator) {
      return navigator.userAgent;
    }
    if (typeof process === "object" && process.version !== undefined) {
      return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
    }
    return "<environment undetectable>";
  }
  exports.getUserAgent = getUserAgent;
});

// node_modules/deprecation/dist-node/index.js
var require_dist_node5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class Deprecation extends Error {
    constructor(message) {
      super(message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "Deprecation";
    }
  }
  exports.Deprecation = Deprecation;
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS((exports, module) => {
  module.exports = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS((exports, module) => {
  var wrappy = require_wrappy();
  module.exports = wrappy(once);
  module.exports.strict = wrappy(onceStrict);
  once.proto = once(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
});

// node_modules/@octokit/request/node_modules/@octokit/request-error/dist-node/index.js
var require_dist_node6 = __commonJS((exports, module) => {
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var dist_src_exports = {};
  __export2(dist_src_exports, {
    RequestError: () => RequestError
  });
  module.exports = __toCommonJS(dist_src_exports);
  var import_deprecation = require_dist_node5();
  var import_once = __toESM2(require_once());
  var logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation));
  var logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation));
  var RequestError = class extends Error {
    constructor(message, statusCode, options) {
      super(message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "HttpError";
      this.status = statusCode;
      let headers;
      if ("headers" in options && typeof options.headers !== "undefined") {
        headers = options.headers;
      }
      if ("response" in options) {
        this.response = options.response;
        headers = options.response.headers;
      }
      const requestCopy = Object.assign({}, options.request);
      if (options.request.headers.authorization) {
        requestCopy.headers = Object.assign({}, options.request.headers, {
          authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]")
        });
      }
      requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
      this.request = requestCopy;
      Object.defineProperty(this, "code", {
        get() {
          logOnceCode(new import_deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
          return statusCode;
        }
      });
      Object.defineProperty(this, "headers", {
        get() {
          logOnceHeaders(new import_deprecation.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
          return headers || {};
        }
      });
    }
  };
});

// node_modules/@octokit/request/dist-node/index.js
var require_dist_node7 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var dist_src_exports = {};
  __export2(dist_src_exports, {
    request: () => request
  });
  module.exports = __toCommonJS(dist_src_exports);
  var import_endpoint = require_dist_node3();
  var import_universal_user_agent = require_dist_node4();
  var VERSION = "8.4.1";
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null)
      return false;
    if (Object.prototype.toString.call(value) !== "[object Object]")
      return false;
    const proto = Object.getPrototypeOf(value);
    if (proto === null)
      return true;
    const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
  }
  var import_request_error = require_dist_node6();
  function getBufferResponse(response) {
    return response.arrayBuffer();
  }
  function fetchWrapper(requestOptions) {
    var _a, _b, _c, _d;
    const log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console;
    const parseSuccessResponseBody = ((_a = requestOptions.request) == null ? undefined : _a.parseSuccessResponseBody) !== false;
    if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
      requestOptions.body = JSON.stringify(requestOptions.body);
    }
    let headers = {};
    let status;
    let url;
    let { fetch } = globalThis;
    if ((_b = requestOptions.request) == null ? undefined : _b.fetch) {
      fetch = requestOptions.request.fetch;
    }
    if (!fetch) {
      throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
    }
    return fetch(requestOptions.url, {
      method: requestOptions.method,
      body: requestOptions.body,
      redirect: (_c = requestOptions.request) == null ? undefined : _c.redirect,
      headers: requestOptions.headers,
      signal: (_d = requestOptions.request) == null ? undefined : _d.signal,
      ...requestOptions.body && { duplex: "half" }
    }).then(async (response) => {
      url = response.url;
      status = response.status;
      for (const keyAndValue of response.headers) {
        headers[keyAndValue[0]] = keyAndValue[1];
      }
      if ("deprecation" in headers) {
        const matches = headers.link && headers.link.match(/<([^<>]+)>; rel="deprecation"/);
        const deprecationLink = matches && matches.pop();
        log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
      }
      if (status === 204 || status === 205) {
        return;
      }
      if (requestOptions.method === "HEAD") {
        if (status < 400) {
          return;
        }
        throw new import_request_error.RequestError(response.statusText, status, {
          response: {
            url,
            status,
            headers,
            data: undefined
          },
          request: requestOptions
        });
      }
      if (status === 304) {
        throw new import_request_error.RequestError("Not modified", status, {
          response: {
            url,
            status,
            headers,
            data: await getResponseData(response)
          },
          request: requestOptions
        });
      }
      if (status >= 400) {
        const data = await getResponseData(response);
        const error = new import_request_error.RequestError(toErrorMessage(data), status, {
          response: {
            url,
            status,
            headers,
            data
          },
          request: requestOptions
        });
        throw error;
      }
      return parseSuccessResponseBody ? await getResponseData(response) : response.body;
    }).then((data) => {
      return {
        status,
        url,
        headers,
        data
      };
    }).catch((error) => {
      if (error instanceof import_request_error.RequestError)
        throw error;
      else if (error.name === "AbortError")
        throw error;
      let message = error.message;
      if (error.name === "TypeError" && "cause" in error) {
        if (error.cause instanceof Error) {
          message = error.cause.message;
        } else if (typeof error.cause === "string") {
          message = error.cause;
        }
      }
      throw new import_request_error.RequestError(message, 500, {
        request: requestOptions
      });
    });
  }
  async function getResponseData(response) {
    const contentType = response.headers.get("content-type");
    if (/application\/json/.test(contentType)) {
      return response.json().catch(() => response.text()).catch(() => "");
    }
    if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
      return response.text();
    }
    return getBufferResponse(response);
  }
  function toErrorMessage(data) {
    if (typeof data === "string")
      return data;
    let suffix;
    if ("documentation_url" in data) {
      suffix = ` - ${data.documentation_url}`;
    } else {
      suffix = "";
    }
    if ("message" in data) {
      if (Array.isArray(data.errors)) {
        return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
      }
      return `${data.message}${suffix}`;
    }
    return `Unknown error: ${JSON.stringify(data)}`;
  }
  function withDefaults(oldEndpoint, newDefaults) {
    const endpoint2 = oldEndpoint.defaults(newDefaults);
    const newApi = function(route, parameters) {
      const endpointOptions = endpoint2.merge(route, parameters);
      if (!endpointOptions.request || !endpointOptions.request.hook) {
        return fetchWrapper(endpoint2.parse(endpointOptions));
      }
      const request2 = (route2, parameters2) => {
        return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
      };
      Object.assign(request2, {
        endpoint: endpoint2,
        defaults: withDefaults.bind(null, endpoint2)
      });
      return endpointOptions.request.hook(request2, endpointOptions);
    };
    return Object.assign(newApi, {
      endpoint: endpoint2,
      defaults: withDefaults.bind(null, endpoint2)
    });
  }
  var request = withDefaults(import_endpoint.endpoint, {
    headers: {
      "user-agent": `octokit-request.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`
    }
  });
});

// node_modules/@actions/github/node_modules/@octokit/core/node_modules/@octokit/graphql/dist-node/index.js
var require_dist_node8 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var index_exports = {};
  __export2(index_exports, {
    GraphqlResponseError: () => GraphqlResponseError,
    graphql: () => graphql2,
    withCustomRequest: () => withCustomRequest
  });
  module.exports = __toCommonJS(index_exports);
  var import_request3 = require_dist_node7();
  var import_universal_user_agent = require_dist_node();
  var VERSION = "7.1.1";
  var import_request2 = require_dist_node7();
  var import_request = require_dist_node7();
  function _buildMessageForResponseErrors(data) {
    return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join(`
`);
  }
  var GraphqlResponseError = class extends Error {
    constructor(request2, headers, response) {
      super(_buildMessageForResponseErrors(response));
      this.request = request2;
      this.headers = headers;
      this.response = response;
      this.name = "GraphqlResponseError";
      this.errors = response.errors;
      this.data = response.data;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    }
  };
  var NON_VARIABLE_OPTIONS = [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "query",
    "mediaType"
  ];
  var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
  var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
  function graphql(request2, query, options) {
    if (options) {
      if (typeof query === "string" && "query" in options) {
        return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
      }
      for (const key in options) {
        if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
          continue;
        return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
      }
    }
    const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
    const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
      if (NON_VARIABLE_OPTIONS.includes(key)) {
        result[key] = parsedOptions[key];
        return result;
      }
      if (!result.variables) {
        result.variables = {};
      }
      result.variables[key] = parsedOptions[key];
      return result;
    }, {});
    const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
    if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
      requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
    }
    return request2(requestOptions).then((response) => {
      if (response.data.errors) {
        const headers = {};
        for (const key of Object.keys(response.headers)) {
          headers[key] = response.headers[key];
        }
        throw new GraphqlResponseError(requestOptions, headers, response.data);
      }
      return response.data.data;
    });
  }
  function withDefaults(request2, newDefaults) {
    const newRequest = request2.defaults(newDefaults);
    const newApi = (query, options) => {
      return graphql(newRequest, query, options);
    };
    return Object.assign(newApi, {
      defaults: withDefaults.bind(null, newRequest),
      endpoint: newRequest.endpoint
    });
  }
  var graphql2 = withDefaults(import_request3.request, {
    headers: {
      "user-agent": `octokit-graphql.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`
    },
    method: "POST",
    url: "/graphql"
  });
  function withCustomRequest(customRequest) {
    return withDefaults(customRequest, {
      method: "POST",
      url: "/graphql"
    });
  }
});

// node_modules/@actions/github/node_modules/@octokit/core/node_modules/@octokit/auth-token/dist-node/index.js
var require_dist_node9 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var dist_src_exports = {};
  __export2(dist_src_exports, {
    createTokenAuth: () => createTokenAuth
  });
  module.exports = __toCommonJS(dist_src_exports);
  var REGEX_IS_INSTALLATION_LEGACY = /^v1\./;
  var REGEX_IS_INSTALLATION = /^ghs_/;
  var REGEX_IS_USER_TO_SERVER = /^ghu_/;
  async function auth(token) {
    const isApp = token.split(/\./).length === 3;
    const isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token);
    const isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
    const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
    return {
      type: "token",
      token,
      tokenType
    };
  }
  function withAuthorizationPrefix(token) {
    if (token.split(/\./).length === 3) {
      return `bearer ${token}`;
    }
    return `token ${token}`;
  }
  async function hook(token, request, route, parameters) {
    const endpoint = request.endpoint.merge(route, parameters);
    endpoint.headers.authorization = withAuthorizationPrefix(token);
    return request(endpoint);
  }
  var createTokenAuth = function createTokenAuth2(token) {
    if (!token) {
      throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
    }
    if (typeof token !== "string") {
      throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
    }
    token = token.replace(/^(token|bearer) +/i, "");
    return Object.assign(auth.bind(null, token), {
      hook: hook.bind(null, token)
    });
  };
});

// node_modules/@actions/github/node_modules/@octokit/core/dist-node/index.js
var require_dist_node10 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var index_exports = {};
  __export2(index_exports, {
    Octokit: () => Octokit
  });
  module.exports = __toCommonJS(index_exports);
  var import_universal_user_agent = require_dist_node();
  var import_before_after_hook = require_before_after_hook();
  var import_request = require_dist_node7();
  var import_graphql = require_dist_node8();
  var import_auth_token = require_dist_node9();
  var VERSION = "5.2.1";
  var noop = () => {
  };
  var consoleWarn = console.warn.bind(console);
  var consoleError = console.error.bind(console);
  var userAgentTrail = `octokit-core.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`;
  var Octokit = class {
    static {
      this.VERSION = VERSION;
    }
    static defaults(defaults) {
      const OctokitWithDefaults = class extends this {
        constructor(...args) {
          const options = args[0] || {};
          if (typeof defaults === "function") {
            super(defaults(options));
            return;
          }
          super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
            userAgent: `${options.userAgent} ${defaults.userAgent}`
          } : null));
        }
      };
      return OctokitWithDefaults;
    }
    static {
      this.plugins = [];
    }
    static plugin(...newPlugins) {
      const currentPlugins = this.plugins;
      const NewOctokit = class extends this {
        static {
          this.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin)));
        }
      };
      return NewOctokit;
    }
    constructor(options = {}) {
      const hook = new import_before_after_hook.Collection;
      const requestDefaults = {
        baseUrl: import_request.request.endpoint.DEFAULTS.baseUrl,
        headers: {},
        request: Object.assign({}, options.request, {
          hook: hook.bind(null, "request")
        }),
        mediaType: {
          previews: [],
          format: ""
        }
      };
      requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
      if (options.baseUrl) {
        requestDefaults.baseUrl = options.baseUrl;
      }
      if (options.previews) {
        requestDefaults.mediaType.previews = options.previews;
      }
      if (options.timeZone) {
        requestDefaults.headers["time-zone"] = options.timeZone;
      }
      this.request = import_request.request.defaults(requestDefaults);
      this.graphql = (0, import_graphql.withCustomRequest)(this.request).defaults(requestDefaults);
      this.log = Object.assign({
        debug: noop,
        info: noop,
        warn: consoleWarn,
        error: consoleError
      }, options.log);
      this.hook = hook;
      if (!options.authStrategy) {
        if (!options.auth) {
          this.auth = async () => ({
            type: "unauthenticated"
          });
        } else {
          const auth = (0, import_auth_token.createTokenAuth)(options.auth);
          hook.wrap("request", auth.hook);
          this.auth = auth;
        }
      } else {
        const { authStrategy, ...otherOptions } = options;
        const auth = authStrategy(Object.assign({
          request: this.request,
          log: this.log,
          octokit: this,
          octokitOptions: otherOptions
        }, options.auth));
        hook.wrap("request", auth.hook);
        this.auth = auth;
      }
      const classConstructor = this.constructor;
      for (let i = 0;i < classConstructor.plugins.length; ++i) {
        Object.assign(this, classConstructor.plugins[i](this, options));
      }
    }
  };
});

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js
var require_dist_node11 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var dist_src_exports = {};
  __export2(dist_src_exports, {
    legacyRestEndpointMethods: () => legacyRestEndpointMethods,
    restEndpointMethods: () => restEndpointMethods
  });
  module.exports = __toCommonJS(dist_src_exports);
  var VERSION = "10.4.1";
  var Endpoints = {
    actions: {
      addCustomLabelsToSelfHostedRunnerForOrg: [
        "POST /orgs/{org}/actions/runners/{runner_id}/labels"
      ],
      addCustomLabelsToSelfHostedRunnerForRepo: [
        "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
      ],
      addSelectedRepoToOrgSecret: [
        "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
      ],
      addSelectedRepoToOrgVariable: [
        "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
      ],
      approveWorkflowRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
      ],
      cancelWorkflowRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
      ],
      createEnvironmentVariable: [
        "POST /repositories/{repository_id}/environments/{environment_name}/variables"
      ],
      createOrUpdateEnvironmentSecret: [
        "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
      ],
      createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
      createOrUpdateRepoSecret: [
        "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
      ],
      createOrgVariable: ["POST /orgs/{org}/actions/variables"],
      createRegistrationTokenForOrg: [
        "POST /orgs/{org}/actions/runners/registration-token"
      ],
      createRegistrationTokenForRepo: [
        "POST /repos/{owner}/{repo}/actions/runners/registration-token"
      ],
      createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
      createRemoveTokenForRepo: [
        "POST /repos/{owner}/{repo}/actions/runners/remove-token"
      ],
      createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
      createWorkflowDispatch: [
        "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
      ],
      deleteActionsCacheById: [
        "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
      ],
      deleteActionsCacheByKey: [
        "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
      ],
      deleteArtifact: [
        "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
      ],
      deleteEnvironmentSecret: [
        "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
      ],
      deleteEnvironmentVariable: [
        "DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
      ],
      deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
      deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
      deleteRepoSecret: [
        "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
      ],
      deleteRepoVariable: [
        "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
      ],
      deleteSelfHostedRunnerFromOrg: [
        "DELETE /orgs/{org}/actions/runners/{runner_id}"
      ],
      deleteSelfHostedRunnerFromRepo: [
        "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
      ],
      deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
      deleteWorkflowRunLogs: [
        "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
      ],
      disableSelectedRepositoryGithubActionsOrganization: [
        "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
      ],
      disableWorkflow: [
        "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
      ],
      downloadArtifact: [
        "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
      ],
      downloadJobLogsForWorkflowRun: [
        "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
      ],
      downloadWorkflowRunAttemptLogs: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
      ],
      downloadWorkflowRunLogs: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
      ],
      enableSelectedRepositoryGithubActionsOrganization: [
        "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
      ],
      enableWorkflow: [
        "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
      ],
      forceCancelWorkflowRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
      ],
      generateRunnerJitconfigForOrg: [
        "POST /orgs/{org}/actions/runners/generate-jitconfig"
      ],
      generateRunnerJitconfigForRepo: [
        "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
      ],
      getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
      getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
      getActionsCacheUsageByRepoForOrg: [
        "GET /orgs/{org}/actions/cache/usage-by-repository"
      ],
      getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
      getAllowedActionsOrganization: [
        "GET /orgs/{org}/actions/permissions/selected-actions"
      ],
      getAllowedActionsRepository: [
        "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
      ],
      getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
      getCustomOidcSubClaimForRepo: [
        "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
      ],
      getEnvironmentPublicKey: [
        "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
      ],
      getEnvironmentSecret: [
        "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
      ],
      getEnvironmentVariable: [
        "GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
      ],
      getGithubActionsDefaultWorkflowPermissionsOrganization: [
        "GET /orgs/{org}/actions/permissions/workflow"
      ],
      getGithubActionsDefaultWorkflowPermissionsRepository: [
        "GET /repos/{owner}/{repo}/actions/permissions/workflow"
      ],
      getGithubActionsPermissionsOrganization: [
        "GET /orgs/{org}/actions/permissions"
      ],
      getGithubActionsPermissionsRepository: [
        "GET /repos/{owner}/{repo}/actions/permissions"
      ],
      getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
      getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
      getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
      getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
      getPendingDeploymentsForRun: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
      ],
      getRepoPermissions: [
        "GET /repos/{owner}/{repo}/actions/permissions",
        {},
        { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
      ],
      getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
      getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
      getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
      getReviewsForRun: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
      ],
      getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
      getSelfHostedRunnerForRepo: [
        "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
      ],
      getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
      getWorkflowAccessToRepository: [
        "GET /repos/{owner}/{repo}/actions/permissions/access"
      ],
      getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
      getWorkflowRunAttempt: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
      ],
      getWorkflowRunUsage: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
      ],
      getWorkflowUsage: [
        "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
      ],
      listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
      listEnvironmentSecrets: [
        "GET /repositories/{repository_id}/environments/{environment_name}/secrets"
      ],
      listEnvironmentVariables: [
        "GET /repositories/{repository_id}/environments/{environment_name}/variables"
      ],
      listJobsForWorkflowRun: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
      ],
      listJobsForWorkflowRunAttempt: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
      ],
      listLabelsForSelfHostedRunnerForOrg: [
        "GET /orgs/{org}/actions/runners/{runner_id}/labels"
      ],
      listLabelsForSelfHostedRunnerForRepo: [
        "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
      ],
      listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
      listOrgVariables: ["GET /orgs/{org}/actions/variables"],
      listRepoOrganizationSecrets: [
        "GET /repos/{owner}/{repo}/actions/organization-secrets"
      ],
      listRepoOrganizationVariables: [
        "GET /repos/{owner}/{repo}/actions/organization-variables"
      ],
      listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
      listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
      listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
      listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
      listRunnerApplicationsForRepo: [
        "GET /repos/{owner}/{repo}/actions/runners/downloads"
      ],
      listSelectedReposForOrgSecret: [
        "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
      ],
      listSelectedReposForOrgVariable: [
        "GET /orgs/{org}/actions/variables/{name}/repositories"
      ],
      listSelectedRepositoriesEnabledGithubActionsOrganization: [
        "GET /orgs/{org}/actions/permissions/repositories"
      ],
      listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
      listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
      listWorkflowRunArtifacts: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
      ],
      listWorkflowRuns: [
        "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
      ],
      listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
      reRunJobForWorkflowRun: [
        "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
      ],
      reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
      reRunWorkflowFailedJobs: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
      ],
      removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
        "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
      ],
      removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
        "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
      ],
      removeCustomLabelFromSelfHostedRunnerForOrg: [
        "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
      ],
      removeCustomLabelFromSelfHostedRunnerForRepo: [
        "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
      ],
      removeSelectedRepoFromOrgSecret: [
        "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
      ],
      removeSelectedRepoFromOrgVariable: [
        "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
      ],
      reviewCustomGatesForRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
      ],
      reviewPendingDeploymentsForRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
      ],
      setAllowedActionsOrganization: [
        "PUT /orgs/{org}/actions/permissions/selected-actions"
      ],
      setAllowedActionsRepository: [
        "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
      ],
      setCustomLabelsForSelfHostedRunnerForOrg: [
        "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
      ],
      setCustomLabelsForSelfHostedRunnerForRepo: [
        "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
      ],
      setCustomOidcSubClaimForRepo: [
        "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
      ],
      setGithubActionsDefaultWorkflowPermissionsOrganization: [
        "PUT /orgs/{org}/actions/permissions/workflow"
      ],
      setGithubActionsDefaultWorkflowPermissionsRepository: [
        "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
      ],
      setGithubActionsPermissionsOrganization: [
        "PUT /orgs/{org}/actions/permissions"
      ],
      setGithubActionsPermissionsRepository: [
        "PUT /repos/{owner}/{repo}/actions/permissions"
      ],
      setSelectedReposForOrgSecret: [
        "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
      ],
      setSelectedReposForOrgVariable: [
        "PUT /orgs/{org}/actions/variables/{name}/repositories"
      ],
      setSelectedRepositoriesEnabledGithubActionsOrganization: [
        "PUT /orgs/{org}/actions/permissions/repositories"
      ],
      setWorkflowAccessToRepository: [
        "PUT /repos/{owner}/{repo}/actions/permissions/access"
      ],
      updateEnvironmentVariable: [
        "PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
      ],
      updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
      updateRepoVariable: [
        "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
      ]
    },
    activity: {
      checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
      deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
      deleteThreadSubscription: [
        "DELETE /notifications/threads/{thread_id}/subscription"
      ],
      getFeeds: ["GET /feeds"],
      getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
      getThread: ["GET /notifications/threads/{thread_id}"],
      getThreadSubscriptionForAuthenticatedUser: [
        "GET /notifications/threads/{thread_id}/subscription"
      ],
      listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
      listNotificationsForAuthenticatedUser: ["GET /notifications"],
      listOrgEventsForAuthenticatedUser: [
        "GET /users/{username}/events/orgs/{org}"
      ],
      listPublicEvents: ["GET /events"],
      listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
      listPublicEventsForUser: ["GET /users/{username}/events/public"],
      listPublicOrgEvents: ["GET /orgs/{org}/events"],
      listReceivedEventsForUser: ["GET /users/{username}/received_events"],
      listReceivedPublicEventsForUser: [
        "GET /users/{username}/received_events/public"
      ],
      listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
      listRepoNotificationsForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/notifications"
      ],
      listReposStarredByAuthenticatedUser: ["GET /user/starred"],
      listReposStarredByUser: ["GET /users/{username}/starred"],
      listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
      listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
      listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
      listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
      markNotificationsAsRead: ["PUT /notifications"],
      markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
      markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
      markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
      setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
      setThreadSubscription: [
        "PUT /notifications/threads/{thread_id}/subscription"
      ],
      starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
      unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
    },
    apps: {
      addRepoToInstallation: [
        "PUT /user/installations/{installation_id}/repositories/{repository_id}",
        {},
        { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
      ],
      addRepoToInstallationForAuthenticatedUser: [
        "PUT /user/installations/{installation_id}/repositories/{repository_id}"
      ],
      checkToken: ["POST /applications/{client_id}/token"],
      createFromManifest: ["POST /app-manifests/{code}/conversions"],
      createInstallationAccessToken: [
        "POST /app/installations/{installation_id}/access_tokens"
      ],
      deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
      deleteInstallation: ["DELETE /app/installations/{installation_id}"],
      deleteToken: ["DELETE /applications/{client_id}/token"],
      getAuthenticated: ["GET /app"],
      getBySlug: ["GET /apps/{app_slug}"],
      getInstallation: ["GET /app/installations/{installation_id}"],
      getOrgInstallation: ["GET /orgs/{org}/installation"],
      getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
      getSubscriptionPlanForAccount: [
        "GET /marketplace_listing/accounts/{account_id}"
      ],
      getSubscriptionPlanForAccountStubbed: [
        "GET /marketplace_listing/stubbed/accounts/{account_id}"
      ],
      getUserInstallation: ["GET /users/{username}/installation"],
      getWebhookConfigForApp: ["GET /app/hook/config"],
      getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
      listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
      listAccountsForPlanStubbed: [
        "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
      ],
      listInstallationReposForAuthenticatedUser: [
        "GET /user/installations/{installation_id}/repositories"
      ],
      listInstallationRequestsForAuthenticatedApp: [
        "GET /app/installation-requests"
      ],
      listInstallations: ["GET /app/installations"],
      listInstallationsForAuthenticatedUser: ["GET /user/installations"],
      listPlans: ["GET /marketplace_listing/plans"],
      listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
      listReposAccessibleToInstallation: ["GET /installation/repositories"],
      listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
      listSubscriptionsForAuthenticatedUserStubbed: [
        "GET /user/marketplace_purchases/stubbed"
      ],
      listWebhookDeliveries: ["GET /app/hook/deliveries"],
      redeliverWebhookDelivery: [
        "POST /app/hook/deliveries/{delivery_id}/attempts"
      ],
      removeRepoFromInstallation: [
        "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
        {},
        { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
      ],
      removeRepoFromInstallationForAuthenticatedUser: [
        "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
      ],
      resetToken: ["PATCH /applications/{client_id}/token"],
      revokeInstallationAccessToken: ["DELETE /installation/token"],
      scopeToken: ["POST /applications/{client_id}/token/scoped"],
      suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
      unsuspendInstallation: [
        "DELETE /app/installations/{installation_id}/suspended"
      ],
      updateWebhookConfigForApp: ["PATCH /app/hook/config"]
    },
    billing: {
      getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
      getGithubActionsBillingUser: [
        "GET /users/{username}/settings/billing/actions"
      ],
      getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
      getGithubPackagesBillingUser: [
        "GET /users/{username}/settings/billing/packages"
      ],
      getSharedStorageBillingOrg: [
        "GET /orgs/{org}/settings/billing/shared-storage"
      ],
      getSharedStorageBillingUser: [
        "GET /users/{username}/settings/billing/shared-storage"
      ]
    },
    checks: {
      create: ["POST /repos/{owner}/{repo}/check-runs"],
      createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
      get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
      getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
      listAnnotations: [
        "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
      ],
      listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
      listForSuite: [
        "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
      ],
      listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
      rerequestRun: [
        "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
      ],
      rerequestSuite: [
        "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
      ],
      setSuitesPreferences: [
        "PATCH /repos/{owner}/{repo}/check-suites/preferences"
      ],
      update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
    },
    codeScanning: {
      deleteAnalysis: [
        "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
      ],
      getAlert: [
        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
        {},
        { renamedParameters: { alert_id: "alert_number" } }
      ],
      getAnalysis: [
        "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
      ],
      getCodeqlDatabase: [
        "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
      ],
      getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
      getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
      listAlertInstances: [
        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
      ],
      listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
      listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
      listAlertsInstances: [
        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
        {},
        { renamed: ["codeScanning", "listAlertInstances"] }
      ],
      listCodeqlDatabases: [
        "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
      ],
      listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
      updateAlert: [
        "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
      ],
      updateDefaultSetup: [
        "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
      ],
      uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
    },
    codesOfConduct: {
      getAllCodesOfConduct: ["GET /codes_of_conduct"],
      getConductCode: ["GET /codes_of_conduct/{key}"]
    },
    codespaces: {
      addRepositoryForSecretForAuthenticatedUser: [
        "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
      ],
      addSelectedRepoToOrgSecret: [
        "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
      ],
      checkPermissionsForDevcontainer: [
        "GET /repos/{owner}/{repo}/codespaces/permissions_check"
      ],
      codespaceMachinesForAuthenticatedUser: [
        "GET /user/codespaces/{codespace_name}/machines"
      ],
      createForAuthenticatedUser: ["POST /user/codespaces"],
      createOrUpdateOrgSecret: [
        "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
      ],
      createOrUpdateRepoSecret: [
        "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
      ],
      createOrUpdateSecretForAuthenticatedUser: [
        "PUT /user/codespaces/secrets/{secret_name}"
      ],
      createWithPrForAuthenticatedUser: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
      ],
      createWithRepoForAuthenticatedUser: [
        "POST /repos/{owner}/{repo}/codespaces"
      ],
      deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
      deleteFromOrganization: [
        "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
      ],
      deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
      deleteRepoSecret: [
        "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
      ],
      deleteSecretForAuthenticatedUser: [
        "DELETE /user/codespaces/secrets/{secret_name}"
      ],
      exportForAuthenticatedUser: [
        "POST /user/codespaces/{codespace_name}/exports"
      ],
      getCodespacesForUserInOrg: [
        "GET /orgs/{org}/members/{username}/codespaces"
      ],
      getExportDetailsForAuthenticatedUser: [
        "GET /user/codespaces/{codespace_name}/exports/{export_id}"
      ],
      getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
      getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
      getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
      getPublicKeyForAuthenticatedUser: [
        "GET /user/codespaces/secrets/public-key"
      ],
      getRepoPublicKey: [
        "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
      ],
      getRepoSecret: [
        "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
      ],
      getSecretForAuthenticatedUser: [
        "GET /user/codespaces/secrets/{secret_name}"
      ],
      listDevcontainersInRepositoryForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/codespaces/devcontainers"
      ],
      listForAuthenticatedUser: ["GET /user/codespaces"],
      listInOrganization: [
        "GET /orgs/{org}/codespaces",
        {},
        { renamedParameters: { org_id: "org" } }
      ],
      listInRepositoryForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/codespaces"
      ],
      listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
      listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
      listRepositoriesForSecretForAuthenticatedUser: [
        "GET /user/codespaces/secrets/{secret_name}/repositories"
      ],
      listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
      listSelectedReposForOrgSecret: [
        "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
      ],
      preFlightWithRepoForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/codespaces/new"
      ],
      publishForAuthenticatedUser: [
        "POST /user/codespaces/{codespace_name}/publish"
      ],
      removeRepositoryForSecretForAuthenticatedUser: [
        "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
      ],
      removeSelectedRepoFromOrgSecret: [
        "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
      ],
      repoMachinesForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/codespaces/machines"
      ],
      setRepositoriesForSecretForAuthenticatedUser: [
        "PUT /user/codespaces/secrets/{secret_name}/repositories"
      ],
      setSelectedReposForOrgSecret: [
        "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
      ],
      startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
      stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
      stopInOrganization: [
        "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
      ],
      updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
    },
    copilot: {
      addCopilotSeatsForTeams: [
        "POST /orgs/{org}/copilot/billing/selected_teams"
      ],
      addCopilotSeatsForUsers: [
        "POST /orgs/{org}/copilot/billing/selected_users"
      ],
      cancelCopilotSeatAssignmentForTeams: [
        "DELETE /orgs/{org}/copilot/billing/selected_teams"
      ],
      cancelCopilotSeatAssignmentForUsers: [
        "DELETE /orgs/{org}/copilot/billing/selected_users"
      ],
      getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
      getCopilotSeatDetailsForUser: [
        "GET /orgs/{org}/members/{username}/copilot"
      ],
      listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
    },
    dependabot: {
      addSelectedRepoToOrgSecret: [
        "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
      ],
      createOrUpdateOrgSecret: [
        "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
      ],
      createOrUpdateRepoSecret: [
        "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
      ],
      deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
      deleteRepoSecret: [
        "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
      ],
      getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
      getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
      getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
      getRepoPublicKey: [
        "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
      ],
      getRepoSecret: [
        "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
      ],
      listAlertsForEnterprise: [
        "GET /enterprises/{enterprise}/dependabot/alerts"
      ],
      listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
      listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
      listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
      listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
      listSelectedReposForOrgSecret: [
        "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
      ],
      removeSelectedRepoFromOrgSecret: [
        "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
      ],
      setSelectedReposForOrgSecret: [
        "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
      ],
      updateAlert: [
        "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
      ]
    },
    dependencyGraph: {
      createRepositorySnapshot: [
        "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
      ],
      diffRange: [
        "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
      ],
      exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
    },
    emojis: { get: ["GET /emojis"] },
    gists: {
      checkIsStarred: ["GET /gists/{gist_id}/star"],
      create: ["POST /gists"],
      createComment: ["POST /gists/{gist_id}/comments"],
      delete: ["DELETE /gists/{gist_id}"],
      deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
      fork: ["POST /gists/{gist_id}/forks"],
      get: ["GET /gists/{gist_id}"],
      getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
      getRevision: ["GET /gists/{gist_id}/{sha}"],
      list: ["GET /gists"],
      listComments: ["GET /gists/{gist_id}/comments"],
      listCommits: ["GET /gists/{gist_id}/commits"],
      listForUser: ["GET /users/{username}/gists"],
      listForks: ["GET /gists/{gist_id}/forks"],
      listPublic: ["GET /gists/public"],
      listStarred: ["GET /gists/starred"],
      star: ["PUT /gists/{gist_id}/star"],
      unstar: ["DELETE /gists/{gist_id}/star"],
      update: ["PATCH /gists/{gist_id}"],
      updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
    },
    git: {
      createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
      createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
      createRef: ["POST /repos/{owner}/{repo}/git/refs"],
      createTag: ["POST /repos/{owner}/{repo}/git/tags"],
      createTree: ["POST /repos/{owner}/{repo}/git/trees"],
      deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
      getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
      getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
      getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
      getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
      getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
      listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
      updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
    },
    gitignore: {
      getAllTemplates: ["GET /gitignore/templates"],
      getTemplate: ["GET /gitignore/templates/{name}"]
    },
    interactions: {
      getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
      getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
      getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
      getRestrictionsForYourPublicRepos: [
        "GET /user/interaction-limits",
        {},
        { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
      ],
      removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
      removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
      removeRestrictionsForRepo: [
        "DELETE /repos/{owner}/{repo}/interaction-limits"
      ],
      removeRestrictionsForYourPublicRepos: [
        "DELETE /user/interaction-limits",
        {},
        { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
      ],
      setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
      setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
      setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
      setRestrictionsForYourPublicRepos: [
        "PUT /user/interaction-limits",
        {},
        { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
      ]
    },
    issues: {
      addAssignees: [
        "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
      ],
      addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
      checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
      checkUserCanBeAssignedToIssue: [
        "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
      ],
      create: ["POST /repos/{owner}/{repo}/issues"],
      createComment: [
        "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
      ],
      createLabel: ["POST /repos/{owner}/{repo}/labels"],
      createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
      deleteComment: [
        "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
      ],
      deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
      deleteMilestone: [
        "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
      ],
      get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
      getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
      getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
      getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
      getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
      list: ["GET /issues"],
      listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
      listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
      listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
      listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
      listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
      listEventsForTimeline: [
        "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
      ],
      listForAuthenticatedUser: ["GET /user/issues"],
      listForOrg: ["GET /orgs/{org}/issues"],
      listForRepo: ["GET /repos/{owner}/{repo}/issues"],
      listLabelsForMilestone: [
        "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
      ],
      listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
      listLabelsOnIssue: [
        "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
      ],
      listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
      lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
      removeAllLabels: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
      ],
      removeAssignees: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
      ],
      removeLabel: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
      ],
      setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
      unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
      update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
      updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
      updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
      updateMilestone: [
        "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
      ]
    },
    licenses: {
      get: ["GET /licenses/{license}"],
      getAllCommonlyUsed: ["GET /licenses"],
      getForRepo: ["GET /repos/{owner}/{repo}/license"]
    },
    markdown: {
      render: ["POST /markdown"],
      renderRaw: [
        "POST /markdown/raw",
        { headers: { "content-type": "text/plain; charset=utf-8" } }
      ]
    },
    meta: {
      get: ["GET /meta"],
      getAllVersions: ["GET /versions"],
      getOctocat: ["GET /octocat"],
      getZen: ["GET /zen"],
      root: ["GET /"]
    },
    migrations: {
      cancelImport: [
        "DELETE /repos/{owner}/{repo}/import",
        {},
        {
          deprecated: "octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import"
        }
      ],
      deleteArchiveForAuthenticatedUser: [
        "DELETE /user/migrations/{migration_id}/archive"
      ],
      deleteArchiveForOrg: [
        "DELETE /orgs/{org}/migrations/{migration_id}/archive"
      ],
      downloadArchiveForOrg: [
        "GET /orgs/{org}/migrations/{migration_id}/archive"
      ],
      getArchiveForAuthenticatedUser: [
        "GET /user/migrations/{migration_id}/archive"
      ],
      getCommitAuthors: [
        "GET /repos/{owner}/{repo}/import/authors",
        {},
        {
          deprecated: "octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors"
        }
      ],
      getImportStatus: [
        "GET /repos/{owner}/{repo}/import",
        {},
        {
          deprecated: "octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status"
        }
      ],
      getLargeFiles: [
        "GET /repos/{owner}/{repo}/import/large_files",
        {},
        {
          deprecated: "octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files"
        }
      ],
      getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
      getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
      listForAuthenticatedUser: ["GET /user/migrations"],
      listForOrg: ["GET /orgs/{org}/migrations"],
      listReposForAuthenticatedUser: [
        "GET /user/migrations/{migration_id}/repositories"
      ],
      listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
      listReposForUser: [
        "GET /user/migrations/{migration_id}/repositories",
        {},
        { renamed: ["migrations", "listReposForAuthenticatedUser"] }
      ],
      mapCommitAuthor: [
        "PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
        {},
        {
          deprecated: "octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author"
        }
      ],
      setLfsPreference: [
        "PATCH /repos/{owner}/{repo}/import/lfs",
        {},
        {
          deprecated: "octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference"
        }
      ],
      startForAuthenticatedUser: ["POST /user/migrations"],
      startForOrg: ["POST /orgs/{org}/migrations"],
      startImport: [
        "PUT /repos/{owner}/{repo}/import",
        {},
        {
          deprecated: "octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import"
        }
      ],
      unlockRepoForAuthenticatedUser: [
        "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
      ],
      unlockRepoForOrg: [
        "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
      ],
      updateImport: [
        "PATCH /repos/{owner}/{repo}/import",
        {},
        {
          deprecated: "octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import"
        }
      ]
    },
    oidc: {
      getOidcCustomSubTemplateForOrg: [
        "GET /orgs/{org}/actions/oidc/customization/sub"
      ],
      updateOidcCustomSubTemplateForOrg: [
        "PUT /orgs/{org}/actions/oidc/customization/sub"
      ]
    },
    orgs: {
      addSecurityManagerTeam: [
        "PUT /orgs/{org}/security-managers/teams/{team_slug}"
      ],
      assignTeamToOrgRole: [
        "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
      ],
      assignUserToOrgRole: [
        "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
      ],
      blockUser: ["PUT /orgs/{org}/blocks/{username}"],
      cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
      checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
      checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
      checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
      convertMemberToOutsideCollaborator: [
        "PUT /orgs/{org}/outside_collaborators/{username}"
      ],
      createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
      createInvitation: ["POST /orgs/{org}/invitations"],
      createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
      createOrUpdateCustomPropertiesValuesForRepos: [
        "PATCH /orgs/{org}/properties/values"
      ],
      createOrUpdateCustomProperty: [
        "PUT /orgs/{org}/properties/schema/{custom_property_name}"
      ],
      createWebhook: ["POST /orgs/{org}/hooks"],
      delete: ["DELETE /orgs/{org}"],
      deleteCustomOrganizationRole: [
        "DELETE /orgs/{org}/organization-roles/{role_id}"
      ],
      deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
      enableOrDisableSecurityProductOnAllOrgRepos: [
        "POST /orgs/{org}/{security_product}/{enablement}"
      ],
      get: ["GET /orgs/{org}"],
      getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
      getCustomProperty: [
        "GET /orgs/{org}/properties/schema/{custom_property_name}"
      ],
      getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
      getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
      getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
      getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
      getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
      getWebhookDelivery: [
        "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
      ],
      list: ["GET /organizations"],
      listAppInstallations: ["GET /orgs/{org}/installations"],
      listBlockedUsers: ["GET /orgs/{org}/blocks"],
      listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
      listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
      listForAuthenticatedUser: ["GET /user/orgs"],
      listForUser: ["GET /users/{username}/orgs"],
      listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
      listMembers: ["GET /orgs/{org}/members"],
      listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
      listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
      listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
      listOrgRoles: ["GET /orgs/{org}/organization-roles"],
      listOrganizationFineGrainedPermissions: [
        "GET /orgs/{org}/organization-fine-grained-permissions"
      ],
      listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
      listPatGrantRepositories: [
        "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
      ],
      listPatGrantRequestRepositories: [
        "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
      ],
      listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
      listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
      listPendingInvitations: ["GET /orgs/{org}/invitations"],
      listPublicMembers: ["GET /orgs/{org}/public_members"],
      listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
      listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
      listWebhooks: ["GET /orgs/{org}/hooks"],
      patchCustomOrganizationRole: [
        "PATCH /orgs/{org}/organization-roles/{role_id}"
      ],
      pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
      redeliverWebhookDelivery: [
        "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
      ],
      removeCustomProperty: [
        "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
      ],
      removeMember: ["DELETE /orgs/{org}/members/{username}"],
      removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
      removeOutsideCollaborator: [
        "DELETE /orgs/{org}/outside_collaborators/{username}"
      ],
      removePublicMembershipForAuthenticatedUser: [
        "DELETE /orgs/{org}/public_members/{username}"
      ],
      removeSecurityManagerTeam: [
        "DELETE /orgs/{org}/security-managers/teams/{team_slug}"
      ],
      reviewPatGrantRequest: [
        "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
      ],
      reviewPatGrantRequestsInBulk: [
        "POST /orgs/{org}/personal-access-token-requests"
      ],
      revokeAllOrgRolesTeam: [
        "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
      ],
      revokeAllOrgRolesUser: [
        "DELETE /orgs/{org}/organization-roles/users/{username}"
      ],
      revokeOrgRoleTeam: [
        "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
      ],
      revokeOrgRoleUser: [
        "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
      ],
      setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
      setPublicMembershipForAuthenticatedUser: [
        "PUT /orgs/{org}/public_members/{username}"
      ],
      unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
      update: ["PATCH /orgs/{org}"],
      updateMembershipForAuthenticatedUser: [
        "PATCH /user/memberships/orgs/{org}"
      ],
      updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
      updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
      updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
      updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
    },
    packages: {
      deletePackageForAuthenticatedUser: [
        "DELETE /user/packages/{package_type}/{package_name}"
      ],
      deletePackageForOrg: [
        "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
      ],
      deletePackageForUser: [
        "DELETE /users/{username}/packages/{package_type}/{package_name}"
      ],
      deletePackageVersionForAuthenticatedUser: [
        "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      deletePackageVersionForOrg: [
        "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      deletePackageVersionForUser: [
        "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      getAllPackageVersionsForAPackageOwnedByAnOrg: [
        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
        {},
        { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
      ],
      getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
        "GET /user/packages/{package_type}/{package_name}/versions",
        {},
        {
          renamed: [
            "packages",
            "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
          ]
        }
      ],
      getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
        "GET /user/packages/{package_type}/{package_name}/versions"
      ],
      getAllPackageVersionsForPackageOwnedByOrg: [
        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
      ],
      getAllPackageVersionsForPackageOwnedByUser: [
        "GET /users/{username}/packages/{package_type}/{package_name}/versions"
      ],
      getPackageForAuthenticatedUser: [
        "GET /user/packages/{package_type}/{package_name}"
      ],
      getPackageForOrganization: [
        "GET /orgs/{org}/packages/{package_type}/{package_name}"
      ],
      getPackageForUser: [
        "GET /users/{username}/packages/{package_type}/{package_name}"
      ],
      getPackageVersionForAuthenticatedUser: [
        "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      getPackageVersionForOrganization: [
        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      getPackageVersionForUser: [
        "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      listDockerMigrationConflictingPackagesForAuthenticatedUser: [
        "GET /user/docker/conflicts"
      ],
      listDockerMigrationConflictingPackagesForOrganization: [
        "GET /orgs/{org}/docker/conflicts"
      ],
      listDockerMigrationConflictingPackagesForUser: [
        "GET /users/{username}/docker/conflicts"
      ],
      listPackagesForAuthenticatedUser: ["GET /user/packages"],
      listPackagesForOrganization: ["GET /orgs/{org}/packages"],
      listPackagesForUser: ["GET /users/{username}/packages"],
      restorePackageForAuthenticatedUser: [
        "POST /user/packages/{package_type}/{package_name}/restore{?token}"
      ],
      restorePackageForOrg: [
        "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
      ],
      restorePackageForUser: [
        "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
      ],
      restorePackageVersionForAuthenticatedUser: [
        "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
      ],
      restorePackageVersionForOrg: [
        "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
      ],
      restorePackageVersionForUser: [
        "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
      ]
    },
    projects: {
      addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
      createCard: ["POST /projects/columns/{column_id}/cards"],
      createColumn: ["POST /projects/{project_id}/columns"],
      createForAuthenticatedUser: ["POST /user/projects"],
      createForOrg: ["POST /orgs/{org}/projects"],
      createForRepo: ["POST /repos/{owner}/{repo}/projects"],
      delete: ["DELETE /projects/{project_id}"],
      deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
      deleteColumn: ["DELETE /projects/columns/{column_id}"],
      get: ["GET /projects/{project_id}"],
      getCard: ["GET /projects/columns/cards/{card_id}"],
      getColumn: ["GET /projects/columns/{column_id}"],
      getPermissionForUser: [
        "GET /projects/{project_id}/collaborators/{username}/permission"
      ],
      listCards: ["GET /projects/columns/{column_id}/cards"],
      listCollaborators: ["GET /projects/{project_id}/collaborators"],
      listColumns: ["GET /projects/{project_id}/columns"],
      listForOrg: ["GET /orgs/{org}/projects"],
      listForRepo: ["GET /repos/{owner}/{repo}/projects"],
      listForUser: ["GET /users/{username}/projects"],
      moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
      moveColumn: ["POST /projects/columns/{column_id}/moves"],
      removeCollaborator: [
        "DELETE /projects/{project_id}/collaborators/{username}"
      ],
      update: ["PATCH /projects/{project_id}"],
      updateCard: ["PATCH /projects/columns/cards/{card_id}"],
      updateColumn: ["PATCH /projects/columns/{column_id}"]
    },
    pulls: {
      checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
      create: ["POST /repos/{owner}/{repo}/pulls"],
      createReplyForReviewComment: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
      ],
      createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
      createReviewComment: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
      ],
      deletePendingReview: [
        "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
      ],
      deleteReviewComment: [
        "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
      ],
      dismissReview: [
        "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
      ],
      get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
      getReview: [
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
      ],
      getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
      list: ["GET /repos/{owner}/{repo}/pulls"],
      listCommentsForReview: [
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
      ],
      listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
      listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
      listRequestedReviewers: [
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
      ],
      listReviewComments: [
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
      ],
      listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
      listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
      merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
      removeRequestedReviewers: [
        "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
      ],
      requestReviewers: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
      ],
      submitReview: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
      ],
      update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
      updateBranch: [
        "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
      ],
      updateReview: [
        "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
      ],
      updateReviewComment: [
        "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
      ]
    },
    rateLimit: { get: ["GET /rate_limit"] },
    reactions: {
      createForCommitComment: [
        "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
      ],
      createForIssue: [
        "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
      ],
      createForIssueComment: [
        "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
      ],
      createForPullRequestReviewComment: [
        "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
      ],
      createForRelease: [
        "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
      ],
      createForTeamDiscussionCommentInOrg: [
        "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
      ],
      createForTeamDiscussionInOrg: [
        "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
      ],
      deleteForCommitComment: [
        "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
      ],
      deleteForIssue: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
      ],
      deleteForIssueComment: [
        "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
      ],
      deleteForPullRequestComment: [
        "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
      ],
      deleteForRelease: [
        "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
      ],
      deleteForTeamDiscussion: [
        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
      ],
      deleteForTeamDiscussionComment: [
        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
      ],
      listForCommitComment: [
        "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
      ],
      listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
      listForIssueComment: [
        "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
      ],
      listForPullRequestReviewComment: [
        "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
      ],
      listForRelease: [
        "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
      ],
      listForTeamDiscussionCommentInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
      ],
      listForTeamDiscussionInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
      ]
    },
    repos: {
      acceptInvitation: [
        "PATCH /user/repository_invitations/{invitation_id}",
        {},
        { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
      ],
      acceptInvitationForAuthenticatedUser: [
        "PATCH /user/repository_invitations/{invitation_id}"
      ],
      addAppAccessRestrictions: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
        {},
        { mapToData: "apps" }
      ],
      addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
      addStatusCheckContexts: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
        {},
        { mapToData: "contexts" }
      ],
      addTeamAccessRestrictions: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
        {},
        { mapToData: "teams" }
      ],
      addUserAccessRestrictions: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
        {},
        { mapToData: "users" }
      ],
      cancelPagesDeployment: [
        "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
      ],
      checkAutomatedSecurityFixes: [
        "GET /repos/{owner}/{repo}/automated-security-fixes"
      ],
      checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
      checkVulnerabilityAlerts: [
        "GET /repos/{owner}/{repo}/vulnerability-alerts"
      ],
      codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
      compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
      compareCommitsWithBasehead: [
        "GET /repos/{owner}/{repo}/compare/{basehead}"
      ],
      createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
      createCommitComment: [
        "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
      ],
      createCommitSignatureProtection: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
      ],
      createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
      createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
      createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
      createDeploymentBranchPolicy: [
        "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
      ],
      createDeploymentProtectionRule: [
        "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
      ],
      createDeploymentStatus: [
        "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
      ],
      createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
      createForAuthenticatedUser: ["POST /user/repos"],
      createFork: ["POST /repos/{owner}/{repo}/forks"],
      createInOrg: ["POST /orgs/{org}/repos"],
      createOrUpdateCustomPropertiesValues: [
        "PATCH /repos/{owner}/{repo}/properties/values"
      ],
      createOrUpdateEnvironment: [
        "PUT /repos/{owner}/{repo}/environments/{environment_name}"
      ],
      createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
      createOrgRuleset: ["POST /orgs/{org}/rulesets"],
      createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
      createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
      createRelease: ["POST /repos/{owner}/{repo}/releases"],
      createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
      createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
      createUsingTemplate: [
        "POST /repos/{template_owner}/{template_repo}/generate"
      ],
      createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
      declineInvitation: [
        "DELETE /user/repository_invitations/{invitation_id}",
        {},
        { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
      ],
      declineInvitationForAuthenticatedUser: [
        "DELETE /user/repository_invitations/{invitation_id}"
      ],
      delete: ["DELETE /repos/{owner}/{repo}"],
      deleteAccessRestrictions: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
      ],
      deleteAdminBranchProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
      ],
      deleteAnEnvironment: [
        "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
      ],
      deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
      deleteBranchProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
      ],
      deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
      deleteCommitSignatureProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
      ],
      deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
      deleteDeployment: [
        "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
      ],
      deleteDeploymentBranchPolicy: [
        "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
      ],
      deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
      deleteInvitation: [
        "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
      ],
      deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
      deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
      deletePullRequestReviewProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
      ],
      deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
      deleteReleaseAsset: [
        "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
      ],
      deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
      deleteTagProtection: [
        "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
      ],
      deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
      disableAutomatedSecurityFixes: [
        "DELETE /repos/{owner}/{repo}/automated-security-fixes"
      ],
      disableDeploymentProtectionRule: [
        "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
      ],
      disablePrivateVulnerabilityReporting: [
        "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
      ],
      disableVulnerabilityAlerts: [
        "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
      ],
      downloadArchive: [
        "GET /repos/{owner}/{repo}/zipball/{ref}",
        {},
        { renamed: ["repos", "downloadZipballArchive"] }
      ],
      downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
      downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
      enableAutomatedSecurityFixes: [
        "PUT /repos/{owner}/{repo}/automated-security-fixes"
      ],
      enablePrivateVulnerabilityReporting: [
        "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
      ],
      enableVulnerabilityAlerts: [
        "PUT /repos/{owner}/{repo}/vulnerability-alerts"
      ],
      generateReleaseNotes: [
        "POST /repos/{owner}/{repo}/releases/generate-notes"
      ],
      get: ["GET /repos/{owner}/{repo}"],
      getAccessRestrictions: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
      ],
      getAdminBranchProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
      ],
      getAllDeploymentProtectionRules: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
      ],
      getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
      getAllStatusCheckContexts: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
      ],
      getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
      getAppsWithAccessToProtectedBranch: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
      ],
      getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
      getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
      getBranchProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection"
      ],
      getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
      getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
      getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
      getCollaboratorPermissionLevel: [
        "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
      ],
      getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
      getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
      getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
      getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
      getCommitSignatureProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
      ],
      getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
      getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
      getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
      getCustomDeploymentProtectionRule: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
      ],
      getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
      getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
      getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
      getDeploymentBranchPolicy: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
      ],
      getDeploymentStatus: [
        "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
      ],
      getEnvironment: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}"
      ],
      getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
      getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
      getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
      getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
      getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
      getOrgRulesets: ["GET /orgs/{org}/rulesets"],
      getPages: ["GET /repos/{owner}/{repo}/pages"],
      getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
      getPagesDeployment: [
        "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
      ],
      getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
      getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
      getPullRequestReviewProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
      ],
      getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
      getReadme: ["GET /repos/{owner}/{repo}/readme"],
      getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
      getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
      getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
      getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
      getRepoRuleSuite: [
        "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
      ],
      getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
      getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
      getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
      getStatusChecksProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
      ],
      getTeamsWithAccessToProtectedBranch: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
      ],
      getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
      getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
      getUsersWithAccessToProtectedBranch: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
      ],
      getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
      getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
      getWebhookConfigForRepo: [
        "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
      ],
      getWebhookDelivery: [
        "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
      ],
      listActivities: ["GET /repos/{owner}/{repo}/activity"],
      listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
      listBranches: ["GET /repos/{owner}/{repo}/branches"],
      listBranchesForHeadCommit: [
        "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
      ],
      listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
      listCommentsForCommit: [
        "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
      ],
      listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
      listCommitStatusesForRef: [
        "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
      ],
      listCommits: ["GET /repos/{owner}/{repo}/commits"],
      listContributors: ["GET /repos/{owner}/{repo}/contributors"],
      listCustomDeploymentRuleIntegrations: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
      ],
      listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
      listDeploymentBranchPolicies: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
      ],
      listDeploymentStatuses: [
        "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
      ],
      listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
      listForAuthenticatedUser: ["GET /user/repos"],
      listForOrg: ["GET /orgs/{org}/repos"],
      listForUser: ["GET /users/{username}/repos"],
      listForks: ["GET /repos/{owner}/{repo}/forks"],
      listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
      listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
      listLanguages: ["GET /repos/{owner}/{repo}/languages"],
      listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
      listPublic: ["GET /repositories"],
      listPullRequestsAssociatedWithCommit: [
        "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
      ],
      listReleaseAssets: [
        "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
      ],
      listReleases: ["GET /repos/{owner}/{repo}/releases"],
      listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
      listTags: ["GET /repos/{owner}/{repo}/tags"],
      listTeams: ["GET /repos/{owner}/{repo}/teams"],
      listWebhookDeliveries: [
        "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
      ],
      listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
      merge: ["POST /repos/{owner}/{repo}/merges"],
      mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
      pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
      redeliverWebhookDelivery: [
        "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
      ],
      removeAppAccessRestrictions: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
        {},
        { mapToData: "apps" }
      ],
      removeCollaborator: [
        "DELETE /repos/{owner}/{repo}/collaborators/{username}"
      ],
      removeStatusCheckContexts: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
        {},
        { mapToData: "contexts" }
      ],
      removeStatusCheckProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
      ],
      removeTeamAccessRestrictions: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
        {},
        { mapToData: "teams" }
      ],
      removeUserAccessRestrictions: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
        {},
        { mapToData: "users" }
      ],
      renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
      replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
      requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
      setAdminBranchProtection: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
      ],
      setAppAccessRestrictions: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
        {},
        { mapToData: "apps" }
      ],
      setStatusCheckContexts: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
        {},
        { mapToData: "contexts" }
      ],
      setTeamAccessRestrictions: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
        {},
        { mapToData: "teams" }
      ],
      setUserAccessRestrictions: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
        {},
        { mapToData: "users" }
      ],
      testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
      transfer: ["POST /repos/{owner}/{repo}/transfer"],
      update: ["PATCH /repos/{owner}/{repo}"],
      updateBranchProtection: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
      ],
      updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
      updateDeploymentBranchPolicy: [
        "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
      ],
      updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
      updateInvitation: [
        "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
      ],
      updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
      updatePullRequestReviewProtection: [
        "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
      ],
      updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
      updateReleaseAsset: [
        "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
      ],
      updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
      updateStatusCheckPotection: [
        "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
        {},
        { renamed: ["repos", "updateStatusCheckProtection"] }
      ],
      updateStatusCheckProtection: [
        "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
      ],
      updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
      updateWebhookConfigForRepo: [
        "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
      ],
      uploadReleaseAsset: [
        "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
        { baseUrl: "https://uploads.github.com" }
      ]
    },
    search: {
      code: ["GET /search/code"],
      commits: ["GET /search/commits"],
      issuesAndPullRequests: ["GET /search/issues"],
      labels: ["GET /search/labels"],
      repos: ["GET /search/repositories"],
      topics: ["GET /search/topics"],
      users: ["GET /search/users"]
    },
    secretScanning: {
      getAlert: [
        "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
      ],
      listAlertsForEnterprise: [
        "GET /enterprises/{enterprise}/secret-scanning/alerts"
      ],
      listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
      listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
      listLocationsForAlert: [
        "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
      ],
      updateAlert: [
        "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
      ]
    },
    securityAdvisories: {
      createFork: [
        "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
      ],
      createPrivateVulnerabilityReport: [
        "POST /repos/{owner}/{repo}/security-advisories/reports"
      ],
      createRepositoryAdvisory: [
        "POST /repos/{owner}/{repo}/security-advisories"
      ],
      createRepositoryAdvisoryCveRequest: [
        "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
      ],
      getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
      getRepositoryAdvisory: [
        "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
      ],
      listGlobalAdvisories: ["GET /advisories"],
      listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
      listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
      updateRepositoryAdvisory: [
        "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
      ]
    },
    teams: {
      addOrUpdateMembershipForUserInOrg: [
        "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
      ],
      addOrUpdateProjectPermissionsInOrg: [
        "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"
      ],
      addOrUpdateRepoPermissionsInOrg: [
        "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
      ],
      checkPermissionsForProjectInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"
      ],
      checkPermissionsForRepoInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
      ],
      create: ["POST /orgs/{org}/teams"],
      createDiscussionCommentInOrg: [
        "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
      ],
      createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
      deleteDiscussionCommentInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
      ],
      deleteDiscussionInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
      ],
      deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
      getByName: ["GET /orgs/{org}/teams/{team_slug}"],
      getDiscussionCommentInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
      ],
      getDiscussionInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
      ],
      getMembershipForUserInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
      ],
      list: ["GET /orgs/{org}/teams"],
      listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
      listDiscussionCommentsInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
      ],
      listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
      listForAuthenticatedUser: ["GET /user/teams"],
      listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
      listPendingInvitationsInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/invitations"
      ],
      listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
      listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
      removeMembershipForUserInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
      ],
      removeProjectInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"
      ],
      removeRepoInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
      ],
      updateDiscussionCommentInOrg: [
        "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
      ],
      updateDiscussionInOrg: [
        "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
      ],
      updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
    },
    users: {
      addEmailForAuthenticated: [
        "POST /user/emails",
        {},
        { renamed: ["users", "addEmailForAuthenticatedUser"] }
      ],
      addEmailForAuthenticatedUser: ["POST /user/emails"],
      addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
      block: ["PUT /user/blocks/{username}"],
      checkBlocked: ["GET /user/blocks/{username}"],
      checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
      checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
      createGpgKeyForAuthenticated: [
        "POST /user/gpg_keys",
        {},
        { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
      ],
      createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
      createPublicSshKeyForAuthenticated: [
        "POST /user/keys",
        {},
        { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
      ],
      createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
      createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
      deleteEmailForAuthenticated: [
        "DELETE /user/emails",
        {},
        { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
      ],
      deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
      deleteGpgKeyForAuthenticated: [
        "DELETE /user/gpg_keys/{gpg_key_id}",
        {},
        { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
      ],
      deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
      deletePublicSshKeyForAuthenticated: [
        "DELETE /user/keys/{key_id}",
        {},
        { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
      ],
      deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
      deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
      deleteSshSigningKeyForAuthenticatedUser: [
        "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
      ],
      follow: ["PUT /user/following/{username}"],
      getAuthenticated: ["GET /user"],
      getByUsername: ["GET /users/{username}"],
      getContextForUser: ["GET /users/{username}/hovercard"],
      getGpgKeyForAuthenticated: [
        "GET /user/gpg_keys/{gpg_key_id}",
        {},
        { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
      ],
      getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
      getPublicSshKeyForAuthenticated: [
        "GET /user/keys/{key_id}",
        {},
        { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
      ],
      getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
      getSshSigningKeyForAuthenticatedUser: [
        "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
      ],
      list: ["GET /users"],
      listBlockedByAuthenticated: [
        "GET /user/blocks",
        {},
        { renamed: ["users", "listBlockedByAuthenticatedUser"] }
      ],
      listBlockedByAuthenticatedUser: ["GET /user/blocks"],
      listEmailsForAuthenticated: [
        "GET /user/emails",
        {},
        { renamed: ["users", "listEmailsForAuthenticatedUser"] }
      ],
      listEmailsForAuthenticatedUser: ["GET /user/emails"],
      listFollowedByAuthenticated: [
        "GET /user/following",
        {},
        { renamed: ["users", "listFollowedByAuthenticatedUser"] }
      ],
      listFollowedByAuthenticatedUser: ["GET /user/following"],
      listFollowersForAuthenticatedUser: ["GET /user/followers"],
      listFollowersForUser: ["GET /users/{username}/followers"],
      listFollowingForUser: ["GET /users/{username}/following"],
      listGpgKeysForAuthenticated: [
        "GET /user/gpg_keys",
        {},
        { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
      ],
      listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
      listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
      listPublicEmailsForAuthenticated: [
        "GET /user/public_emails",
        {},
        { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
      ],
      listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
      listPublicKeysForUser: ["GET /users/{username}/keys"],
      listPublicSshKeysForAuthenticated: [
        "GET /user/keys",
        {},
        { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
      ],
      listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
      listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
      listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
      listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
      listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
      setPrimaryEmailVisibilityForAuthenticated: [
        "PATCH /user/email/visibility",
        {},
        { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
      ],
      setPrimaryEmailVisibilityForAuthenticatedUser: [
        "PATCH /user/email/visibility"
      ],
      unblock: ["DELETE /user/blocks/{username}"],
      unfollow: ["DELETE /user/following/{username}"],
      updateAuthenticated: ["PATCH /user"]
    }
  };
  var endpoints_default = Endpoints;
  var endpointMethodsMap = /* @__PURE__ */ new Map;
  for (const [scope, endpoints] of Object.entries(endpoints_default)) {
    for (const [methodName, endpoint] of Object.entries(endpoints)) {
      const [route, defaults, decorations] = endpoint;
      const [method, url] = route.split(/ /);
      const endpointDefaults = Object.assign({
        method,
        url
      }, defaults);
      if (!endpointMethodsMap.has(scope)) {
        endpointMethodsMap.set(scope, /* @__PURE__ */ new Map);
      }
      endpointMethodsMap.get(scope).set(methodName, {
        scope,
        methodName,
        endpointDefaults,
        decorations
      });
    }
  }
  var handler = {
    has({ scope }, methodName) {
      return endpointMethodsMap.get(scope).has(methodName);
    },
    getOwnPropertyDescriptor(target, methodName) {
      return {
        value: this.get(target, methodName),
        configurable: true,
        writable: true,
        enumerable: true
      };
    },
    defineProperty(target, methodName, descriptor) {
      Object.defineProperty(target.cache, methodName, descriptor);
      return true;
    },
    deleteProperty(target, methodName) {
      delete target.cache[methodName];
      return true;
    },
    ownKeys({ scope }) {
      return [...endpointMethodsMap.get(scope).keys()];
    },
    set(target, methodName, value) {
      return target.cache[methodName] = value;
    },
    get({ octokit, scope, cache }, methodName) {
      if (cache[methodName]) {
        return cache[methodName];
      }
      const method = endpointMethodsMap.get(scope).get(methodName);
      if (!method) {
        return;
      }
      const { endpointDefaults, decorations } = method;
      if (decorations) {
        cache[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
      } else {
        cache[methodName] = octokit.request.defaults(endpointDefaults);
      }
      return cache[methodName];
    }
  };
  function endpointsToMethods(octokit) {
    const newMethods = {};
    for (const scope of endpointMethodsMap.keys()) {
      newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);
    }
    return newMethods;
  }
  function decorate(octokit, scope, methodName, defaults, decorations) {
    const requestWithDefaults = octokit.request.defaults(defaults);
    function withDecorations(...args) {
      let options = requestWithDefaults.endpoint.merge(...args);
      if (decorations.mapToData) {
        options = Object.assign({}, options, {
          data: options[decorations.mapToData],
          [decorations.mapToData]: undefined
        });
        return requestWithDefaults(options);
      }
      if (decorations.renamed) {
        const [newScope, newMethodName] = decorations.renamed;
        octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
      }
      if (decorations.deprecated) {
        octokit.log.warn(decorations.deprecated);
      }
      if (decorations.renamedParameters) {
        const options2 = requestWithDefaults.endpoint.merge(...args);
        for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
          if (name in options2) {
            octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);
            if (!(alias in options2)) {
              options2[alias] = options2[name];
            }
            delete options2[name];
          }
        }
        return requestWithDefaults(options2);
      }
      return requestWithDefaults(...args);
    }
    return Object.assign(withDecorations, requestWithDefaults);
  }
  function restEndpointMethods(octokit) {
    const api = endpointsToMethods(octokit);
    return {
      rest: api
    };
  }
  restEndpointMethods.VERSION = VERSION;
  function legacyRestEndpointMethods(octokit) {
    const api = endpointsToMethods(octokit);
    return {
      ...api,
      rest: api
    };
  }
  legacyRestEndpointMethods.VERSION = VERSION;
});

// node_modules/@octokit/plugin-paginate-rest/dist-node/index.js
var require_dist_node12 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var dist_src_exports = {};
  __export2(dist_src_exports, {
    composePaginateRest: () => composePaginateRest,
    isPaginatingEndpoint: () => isPaginatingEndpoint,
    paginateRest: () => paginateRest,
    paginatingEndpoints: () => paginatingEndpoints
  });
  module.exports = __toCommonJS(dist_src_exports);
  var VERSION = "9.2.2";
  function normalizePaginatedListResponse(response) {
    if (!response.data) {
      return {
        ...response,
        data: []
      };
    }
    const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
    if (!responseNeedsNormalization)
      return response;
    const incompleteResults = response.data.incomplete_results;
    const repositorySelection = response.data.repository_selection;
    const totalCount = response.data.total_count;
    delete response.data.incomplete_results;
    delete response.data.repository_selection;
    delete response.data.total_count;
    const namespaceKey = Object.keys(response.data)[0];
    const data = response.data[namespaceKey];
    response.data = data;
    if (typeof incompleteResults !== "undefined") {
      response.data.incomplete_results = incompleteResults;
    }
    if (typeof repositorySelection !== "undefined") {
      response.data.repository_selection = repositorySelection;
    }
    response.data.total_count = totalCount;
    return response;
  }
  function iterator(octokit, route, parameters) {
    const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
    const requestMethod = typeof route === "function" ? route : octokit.request;
    const method = options.method;
    const headers = options.headers;
    let url = options.url;
    return {
      [Symbol.asyncIterator]: () => ({
        async next() {
          if (!url)
            return { done: true };
          try {
            const response = await requestMethod({ method, url, headers });
            const normalizedResponse = normalizePaginatedListResponse(response);
            url = ((normalizedResponse.headers.link || "").match(/<([^<>]+)>;\s*rel="next"/) || [])[1];
            return { value: normalizedResponse };
          } catch (error) {
            if (error.status !== 409)
              throw error;
            url = "";
            return {
              value: {
                status: 200,
                headers: {},
                data: []
              }
            };
          }
        }
      })
    };
  }
  function paginate(octokit, route, parameters, mapFn) {
    if (typeof parameters === "function") {
      mapFn = parameters;
      parameters = undefined;
    }
    return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
  }
  function gather(octokit, results, iterator2, mapFn) {
    return iterator2.next().then((result) => {
      if (result.done) {
        return results;
      }
      let earlyExit = false;
      function done() {
        earlyExit = true;
      }
      results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
      if (earlyExit) {
        return results;
      }
      return gather(octokit, results, iterator2, mapFn);
    });
  }
  var composePaginateRest = Object.assign(paginate, {
    iterator
  });
  var paginatingEndpoints = [
    "GET /advisories",
    "GET /app/hook/deliveries",
    "GET /app/installation-requests",
    "GET /app/installations",
    "GET /assignments/{assignment_id}/accepted_assignments",
    "GET /classrooms",
    "GET /classrooms/{classroom_id}/assignments",
    "GET /enterprises/{enterprise}/dependabot/alerts",
    "GET /enterprises/{enterprise}/secret-scanning/alerts",
    "GET /events",
    "GET /gists",
    "GET /gists/public",
    "GET /gists/starred",
    "GET /gists/{gist_id}/comments",
    "GET /gists/{gist_id}/commits",
    "GET /gists/{gist_id}/forks",
    "GET /installation/repositories",
    "GET /issues",
    "GET /licenses",
    "GET /marketplace_listing/plans",
    "GET /marketplace_listing/plans/{plan_id}/accounts",
    "GET /marketplace_listing/stubbed/plans",
    "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
    "GET /networks/{owner}/{repo}/events",
    "GET /notifications",
    "GET /organizations",
    "GET /orgs/{org}/actions/cache/usage-by-repository",
    "GET /orgs/{org}/actions/permissions/repositories",
    "GET /orgs/{org}/actions/runners",
    "GET /orgs/{org}/actions/secrets",
    "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/actions/variables",
    "GET /orgs/{org}/actions/variables/{name}/repositories",
    "GET /orgs/{org}/blocks",
    "GET /orgs/{org}/code-scanning/alerts",
    "GET /orgs/{org}/codespaces",
    "GET /orgs/{org}/codespaces/secrets",
    "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/copilot/billing/seats",
    "GET /orgs/{org}/dependabot/alerts",
    "GET /orgs/{org}/dependabot/secrets",
    "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/events",
    "GET /orgs/{org}/failed_invitations",
    "GET /orgs/{org}/hooks",
    "GET /orgs/{org}/hooks/{hook_id}/deliveries",
    "GET /orgs/{org}/installations",
    "GET /orgs/{org}/invitations",
    "GET /orgs/{org}/invitations/{invitation_id}/teams",
    "GET /orgs/{org}/issues",
    "GET /orgs/{org}/members",
    "GET /orgs/{org}/members/{username}/codespaces",
    "GET /orgs/{org}/migrations",
    "GET /orgs/{org}/migrations/{migration_id}/repositories",
    "GET /orgs/{org}/organization-roles/{role_id}/teams",
    "GET /orgs/{org}/organization-roles/{role_id}/users",
    "GET /orgs/{org}/outside_collaborators",
    "GET /orgs/{org}/packages",
    "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
    "GET /orgs/{org}/personal-access-token-requests",
    "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
    "GET /orgs/{org}/personal-access-tokens",
    "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
    "GET /orgs/{org}/projects",
    "GET /orgs/{org}/properties/values",
    "GET /orgs/{org}/public_members",
    "GET /orgs/{org}/repos",
    "GET /orgs/{org}/rulesets",
    "GET /orgs/{org}/rulesets/rule-suites",
    "GET /orgs/{org}/secret-scanning/alerts",
    "GET /orgs/{org}/security-advisories",
    "GET /orgs/{org}/teams",
    "GET /orgs/{org}/teams/{team_slug}/discussions",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
    "GET /orgs/{org}/teams/{team_slug}/invitations",
    "GET /orgs/{org}/teams/{team_slug}/members",
    "GET /orgs/{org}/teams/{team_slug}/projects",
    "GET /orgs/{org}/teams/{team_slug}/repos",
    "GET /orgs/{org}/teams/{team_slug}/teams",
    "GET /projects/columns/{column_id}/cards",
    "GET /projects/{project_id}/collaborators",
    "GET /projects/{project_id}/columns",
    "GET /repos/{owner}/{repo}/actions/artifacts",
    "GET /repos/{owner}/{repo}/actions/caches",
    "GET /repos/{owner}/{repo}/actions/organization-secrets",
    "GET /repos/{owner}/{repo}/actions/organization-variables",
    "GET /repos/{owner}/{repo}/actions/runners",
    "GET /repos/{owner}/{repo}/actions/runs",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
    "GET /repos/{owner}/{repo}/actions/secrets",
    "GET /repos/{owner}/{repo}/actions/variables",
    "GET /repos/{owner}/{repo}/actions/workflows",
    "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
    "GET /repos/{owner}/{repo}/activity",
    "GET /repos/{owner}/{repo}/assignees",
    "GET /repos/{owner}/{repo}/branches",
    "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
    "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
    "GET /repos/{owner}/{repo}/code-scanning/alerts",
    "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
    "GET /repos/{owner}/{repo}/code-scanning/analyses",
    "GET /repos/{owner}/{repo}/codespaces",
    "GET /repos/{owner}/{repo}/codespaces/devcontainers",
    "GET /repos/{owner}/{repo}/codespaces/secrets",
    "GET /repos/{owner}/{repo}/collaborators",
    "GET /repos/{owner}/{repo}/comments",
    "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/commits",
    "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
    "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
    "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
    "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
    "GET /repos/{owner}/{repo}/commits/{ref}/status",
    "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
    "GET /repos/{owner}/{repo}/contributors",
    "GET /repos/{owner}/{repo}/dependabot/alerts",
    "GET /repos/{owner}/{repo}/dependabot/secrets",
    "GET /repos/{owner}/{repo}/deployments",
    "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
    "GET /repos/{owner}/{repo}/environments",
    "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
    "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
    "GET /repos/{owner}/{repo}/events",
    "GET /repos/{owner}/{repo}/forks",
    "GET /repos/{owner}/{repo}/hooks",
    "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
    "GET /repos/{owner}/{repo}/invitations",
    "GET /repos/{owner}/{repo}/issues",
    "GET /repos/{owner}/{repo}/issues/comments",
    "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/issues/events",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
    "GET /repos/{owner}/{repo}/keys",
    "GET /repos/{owner}/{repo}/labels",
    "GET /repos/{owner}/{repo}/milestones",
    "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
    "GET /repos/{owner}/{repo}/notifications",
    "GET /repos/{owner}/{repo}/pages/builds",
    "GET /repos/{owner}/{repo}/projects",
    "GET /repos/{owner}/{repo}/pulls",
    "GET /repos/{owner}/{repo}/pulls/comments",
    "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
    "GET /repos/{owner}/{repo}/releases",
    "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
    "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
    "GET /repos/{owner}/{repo}/rules/branches/{branch}",
    "GET /repos/{owner}/{repo}/rulesets",
    "GET /repos/{owner}/{repo}/rulesets/rule-suites",
    "GET /repos/{owner}/{repo}/secret-scanning/alerts",
    "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
    "GET /repos/{owner}/{repo}/security-advisories",
    "GET /repos/{owner}/{repo}/stargazers",
    "GET /repos/{owner}/{repo}/subscribers",
    "GET /repos/{owner}/{repo}/tags",
    "GET /repos/{owner}/{repo}/teams",
    "GET /repos/{owner}/{repo}/topics",
    "GET /repositories",
    "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
    "GET /repositories/{repository_id}/environments/{environment_name}/variables",
    "GET /search/code",
    "GET /search/commits",
    "GET /search/issues",
    "GET /search/labels",
    "GET /search/repositories",
    "GET /search/topics",
    "GET /search/users",
    "GET /teams/{team_id}/discussions",
    "GET /teams/{team_id}/discussions/{discussion_number}/comments",
    "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
    "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
    "GET /teams/{team_id}/invitations",
    "GET /teams/{team_id}/members",
    "GET /teams/{team_id}/projects",
    "GET /teams/{team_id}/repos",
    "GET /teams/{team_id}/teams",
    "GET /user/blocks",
    "GET /user/codespaces",
    "GET /user/codespaces/secrets",
    "GET /user/emails",
    "GET /user/followers",
    "GET /user/following",
    "GET /user/gpg_keys",
    "GET /user/installations",
    "GET /user/installations/{installation_id}/repositories",
    "GET /user/issues",
    "GET /user/keys",
    "GET /user/marketplace_purchases",
    "GET /user/marketplace_purchases/stubbed",
    "GET /user/memberships/orgs",
    "GET /user/migrations",
    "GET /user/migrations/{migration_id}/repositories",
    "GET /user/orgs",
    "GET /user/packages",
    "GET /user/packages/{package_type}/{package_name}/versions",
    "GET /user/public_emails",
    "GET /user/repos",
    "GET /user/repository_invitations",
    "GET /user/social_accounts",
    "GET /user/ssh_signing_keys",
    "GET /user/starred",
    "GET /user/subscriptions",
    "GET /user/teams",
    "GET /users",
    "GET /users/{username}/events",
    "GET /users/{username}/events/orgs/{org}",
    "GET /users/{username}/events/public",
    "GET /users/{username}/followers",
    "GET /users/{username}/following",
    "GET /users/{username}/gists",
    "GET /users/{username}/gpg_keys",
    "GET /users/{username}/keys",
    "GET /users/{username}/orgs",
    "GET /users/{username}/packages",
    "GET /users/{username}/projects",
    "GET /users/{username}/received_events",
    "GET /users/{username}/received_events/public",
    "GET /users/{username}/repos",
    "GET /users/{username}/social_accounts",
    "GET /users/{username}/ssh_signing_keys",
    "GET /users/{username}/starred",
    "GET /users/{username}/subscriptions"
  ];
  function isPaginatingEndpoint(arg) {
    if (typeof arg === "string") {
      return paginatingEndpoints.includes(arg);
    } else {
      return false;
    }
  }
  function paginateRest(octokit) {
    return {
      paginate: Object.assign(paginate.bind(null, octokit), {
        iterator: iterator.bind(null, octokit)
      })
    };
  }
  paginateRest.VERSION = VERSION;
});

// node_modules/@actions/github/lib/utils.js
var require_utils4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = undefined;
  var Context = __importStar(require_context());
  var Utils = __importStar(require_utils3());
  var core_1 = require_dist_node10();
  var plugin_rest_endpoint_methods_1 = require_dist_node11();
  var plugin_paginate_rest_1 = require_dist_node12();
  exports.context = new Context.Context;
  var baseUrl = Utils.getApiBaseUrl();
  exports.defaults = {
    baseUrl,
    request: {
      agent: Utils.getProxyAgent(baseUrl),
      fetch: Utils.getProxyFetch(baseUrl)
    }
  };
  exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
  function getOctokitOptions(token, options) {
    const opts = Object.assign({}, options || {});
    const auth = Utils.getAuthString(token, opts);
    if (auth) {
      opts.auth = auth;
    }
    return opts;
  }
  exports.getOctokitOptions = getOctokitOptions;
});

// node_modules/@actions/github/lib/github.js
var require_github = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOctokit = exports.context = undefined;
  var Context = __importStar(require_context());
  var utils_1 = require_utils4();
  exports.context = new Context.Context;
  function getOctokit(token, options, ...additionalPlugins) {
    const GitHubWithPlugins = utils_1.GitHub.plugin(...additionalPlugins);
    return new GitHubWithPlugins((0, utils_1.getOctokitOptions)(token, options));
  }
  exports.getOctokit = getOctokit;
});

// node_modules/strftime/strftime.js
var require_strftime = __commonJS((exports, module) => {
  (function() {
    var Locales = {
      de_DE: {
        identifier: "de-DE",
        days: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
        shortDays: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
        months: ["Januar", "Februar", "Mrz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
        shortMonths: ["Jan", "Feb", "Mr", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
        AM: "AM",
        PM: "PM",
        am: "am",
        pm: "pm",
        formats: {
          c: "%a %d %b %Y %X %Z",
          D: "%d.%m.%Y",
          F: "%Y-%m-%d",
          R: "%H:%M",
          r: "%I:%M:%S %p",
          T: "%H:%M:%S",
          v: "%e-%b-%Y",
          X: "%T",
          x: "%D"
        }
      },
      en_CA: {
        identifier: "en-CA",
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        ordinalSuffixes: [
          "st",
          "nd",
          "rd",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "st",
          "nd",
          "rd",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "st"
        ],
        AM: "AM",
        PM: "PM",
        am: "am",
        pm: "pm",
        formats: {
          c: "%a %d %b %Y %X %Z",
          D: "%d/%m/%y",
          F: "%Y-%m-%d",
          R: "%H:%M",
          r: "%I:%M:%S %p",
          T: "%H:%M:%S",
          v: "%e-%b-%Y",
          X: "%r",
          x: "%D"
        }
      },
      en_US: {
        identifier: "en-US",
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        ordinalSuffixes: [
          "st",
          "nd",
          "rd",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "st",
          "nd",
          "rd",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "th",
          "st"
        ],
        AM: "AM",
        PM: "PM",
        am: "am",
        pm: "pm",
        formats: {
          c: "%a %d %b %Y %X %Z",
          D: "%m/%d/%y",
          F: "%Y-%m-%d",
          R: "%H:%M",
          r: "%I:%M:%S %p",
          T: "%H:%M:%S",
          v: "%e-%b-%Y",
          X: "%r",
          x: "%D"
        }
      },
      es_MX: {
        identifier: "es-MX",
        days: ["domingo", "lunes", "martes", "mircoles", "jueves", "viernes", "sbado"],
        shortDays: ["dom", "lun", "mar", "mi", "jue", "vie", "sb"],
        months: ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"],
        shortMonths: ["ene", "feb", "mar", "abr", "may", "jun", "jul", "ago", "sep", "oct", "nov", "dic"],
        AM: "AM",
        PM: "PM",
        am: "am",
        pm: "pm",
        formats: {
          c: "%a %d %b %Y %X %Z",
          D: "%d/%m/%Y",
          F: "%Y-%m-%d",
          R: "%H:%M",
          r: "%I:%M:%S %p",
          T: "%H:%M:%S",
          v: "%e-%b-%Y",
          X: "%T",
          x: "%D"
        }
      },
      fr_FR: {
        identifier: "fr-FR",
        days: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
        shortDays: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
        months: ["janvier", "fvrier", "mars", "avril", "mai", "juin", "juillet", "aot", "septembre", "octobre", "novembre", "dcembre"],
        shortMonths: ["janv.", "fvr.", "mars", "avril", "mai", "juin", "juil.", "aot", "sept.", "oct.", "nov.", "dc."],
        AM: "AM",
        PM: "PM",
        am: "am",
        pm: "pm",
        formats: {
          c: "%a %d %b %Y %X %Z",
          D: "%d/%m/%Y",
          F: "%Y-%m-%d",
          R: "%H:%M",
          r: "%I:%M:%S %p",
          T: "%H:%M:%S",
          v: "%e-%b-%Y",
          X: "%T",
          x: "%D"
        }
      },
      it_IT: {
        identifier: "it-IT",
        days: ["domenica", "luned", "marted", "mercoled", "gioved", "venerd", "sabato"],
        shortDays: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"],
        months: ["gennaio", "febbraio", "marzo", "aprile", "maggio", "giugno", "luglio", "agosto", "settembre", "ottobre", "novembre", "dicembre"],
        shortMonths: ["gen", "feb", "mar", "apr", "mag", "giu", "lug", "ago", "set", "ott", "nov", "dic"],
        AM: "AM",
        PM: "PM",
        am: "am",
        pm: "pm",
        formats: {
          c: "%a %d %b %Y %X %Z",
          D: "%d/%m/%Y",
          F: "%Y-%m-%d",
          R: "%H:%M",
          r: "%I:%M:%S %p",
          T: "%H:%M:%S",
          v: "%e-%b-%Y",
          X: "%T",
          x: "%D"
        }
      },
      nl_NL: {
        identifier: "nl-NL",
        days: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"],
        shortDays: ["zo", "ma", "di", "wo", "do", "vr", "za"],
        months: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
        shortMonths: ["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec"],
        AM: "AM",
        PM: "PM",
        am: "am",
        pm: "pm",
        formats: {
          c: "%a %d %b %Y %X %Z",
          D: "%d-%m-%y",
          F: "%Y-%m-%d",
          R: "%H:%M",
          r: "%I:%M:%S %p",
          T: "%H:%M:%S",
          v: "%e-%b-%Y",
          X: "%T",
          x: "%D"
        }
      },
      pt_BR: {
        identifier: "pt-BR",
        days: ["domingo", "segunda", "tera", "quarta", "quinta", "sexta", "sbado"],
        shortDays: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sb"],
        months: ["janeiro", "fevereiro", "maro", "abril", "maio", "junho", "julho", "agosto", "setembro", "outubro", "novembro", "dezembro"],
        shortMonths: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"],
        AM: "AM",
        PM: "PM",
        am: "am",
        pm: "pm",
        formats: {
          c: "%a %d %b %Y %X %Z",
          D: "%d-%m-%Y",
          F: "%Y-%m-%d",
          R: "%H:%M",
          r: "%I:%M:%S %p",
          T: "%H:%M:%S",
          v: "%e-%b-%Y",
          X: "%T",
          x: "%D"
        }
      },
      ru_RU: {
        identifier: "ru-RU",
        days: ["", "", "", "", "", "", ""],
        shortDays: ["", "", "", "", "", "", ""],
        months: ["", "", "", "", "", "", "", "", "", "", "", ""],
        shortMonths: ["", "", "", "", "", "", "", "", "", "", "", ""],
        AM: "AM",
        PM: "PM",
        am: "am",
        pm: "pm",
        formats: {
          c: "%a %d %b %Y %X",
          D: "%d.%m.%y",
          F: "%Y-%m-%d",
          R: "%H:%M",
          r: "%I:%M:%S %p",
          T: "%H:%M:%S",
          v: "%e-%b-%Y",
          X: "%T",
          x: "%D"
        }
      },
      tr_TR: {
        identifier: "tr-TR",
        days: ["Pazar", "Pazartesi", "Sal", "aramba", "Perembe", "Cuma", "Cumartesi"],
        shortDays: ["Paz", "Pzt", "Sal", "r", "Pr", "Cum", "Cts"],
        months: ["Ocak", "ubat", "Mart", "Nisan", "Mays", "Haziran", "Temmuz", "Austos", "Eyll", "Ekim", "Kasm", "Aralk"],
        shortMonths: ["Oca", "ub", "Mar", "Nis", "May", "Haz", "Tem", "Au", "Eyl", "Eki", "Kas", "Ara"],
        AM: "",
        PM: "S",
        am: "",
        pm: "S",
        formats: {
          c: "%a %d %b %Y %X %Z",
          D: "%d-%m-%Y",
          F: "%Y-%m-%d",
          R: "%H:%M",
          r: "%I:%M:%S %p",
          T: "%H:%M:%S",
          v: "%e-%b-%Y",
          X: "%T",
          x: "%D"
        }
      },
      zh_CN: {
        identifier: "zh-CN",
        days: ["", "", "", "", "", "", ""],
        shortDays: ["", "", "", "", "", "", ""],
        months: ["", "", "", "", "", "", "", "", "", "", "", ""],
        shortMonths: ["", "", "", "", "", "", "", "", "", "", "", ""],
        AM: "",
        PM: "",
        am: "",
        pm: "",
        formats: {
          c: "%a %d %b %Y %X %Z",
          D: "%d/%m/%y",
          F: "%Y-%m-%d",
          R: "%H:%M",
          r: "%I:%M:%S %p",
          T: "%H:%M:%S",
          v: "%e-%b-%Y",
          X: "%r",
          x: "%D"
        }
      }
    };
    var DefaultLocale = Locales["en_US"], defaultStrftime = new Strftime(DefaultLocale, 0, false), isCommonJS = typeof module !== "undefined", namespace;
    if (isCommonJS) {
      namespace = module.exports = defaultStrftime;
    } else {
      namespace = function() {
        return this || (1, eval)("this");
      }();
      namespace.strftime = defaultStrftime;
    }
    if (typeof Date.now !== "function") {
      Date.now = function() {
        return +new Date;
      };
    }
    function Strftime(locale, customTimezoneOffset, useUtcTimezone) {
      var _locale = locale || DefaultLocale, _customTimezoneOffset = customTimezoneOffset || 0, _useUtcBasedDate = useUtcTimezone || false, _cachedDateTimestamp = 0, _cachedDate;
      function _strftime(format, date) {
        var timestamp;
        if (!date) {
          var currentTimestamp = Date.now();
          if (currentTimestamp > _cachedDateTimestamp) {
            _cachedDateTimestamp = currentTimestamp;
            _cachedDate = new Date(_cachedDateTimestamp);
            timestamp = _cachedDateTimestamp;
            if (_useUtcBasedDate) {
              _cachedDate = new Date(_cachedDateTimestamp + getTimestampToUtcOffsetFor(_cachedDate) + _customTimezoneOffset);
            }
          } else {
            timestamp = _cachedDateTimestamp;
          }
          date = _cachedDate;
        } else {
          timestamp = date.getTime();
          if (_useUtcBasedDate) {
            var utcOffset = getTimestampToUtcOffsetFor(date);
            date = new Date(timestamp + utcOffset + _customTimezoneOffset);
            if (getTimestampToUtcOffsetFor(date) !== utcOffset) {
              var newUTCOffset = getTimestampToUtcOffsetFor(date);
              date = new Date(timestamp + newUTCOffset + _customTimezoneOffset);
            }
          }
        }
        return _processFormat(format, date, _locale, timestamp);
      }
      function _processFormat(format, date, locale2, timestamp) {
        var resultString = "", padding = null, isInScope = false, length = format.length, extendedTZ = false;
        for (var i = 0;i < length; i++) {
          var currentCharCode = format.charCodeAt(i);
          if (isInScope === true) {
            if (currentCharCode === 45) {
              padding = "";
              continue;
            } else if (currentCharCode === 95) {
              padding = " ";
              continue;
            } else if (currentCharCode === 48) {
              padding = "0";
              continue;
            } else if (currentCharCode === 58) {
              if (extendedTZ) {
                warn("[WARNING] detected use of unsupported %:: or %::: modifiers to strftime");
              }
              extendedTZ = true;
              continue;
            }
            switch (currentCharCode) {
              case 37:
                resultString += "%";
                break;
              case 65:
                resultString += locale2.days[date.getDay()];
                break;
              case 66:
                resultString += locale2.months[date.getMonth()];
                break;
              case 67:
                resultString += padTill2(Math.floor(date.getFullYear() / 100), padding);
                break;
              case 68:
                resultString += _processFormat(locale2.formats.D, date, locale2, timestamp);
                break;
              case 70:
                resultString += _processFormat(locale2.formats.F, date, locale2, timestamp);
                break;
              case 72:
                resultString += padTill2(date.getHours(), padding);
                break;
              case 73:
                resultString += padTill2(hours12(date.getHours()), padding);
                break;
              case 76:
                resultString += padTill3(Math.floor(timestamp % 1000));
                break;
              case 77:
                resultString += padTill2(date.getMinutes(), padding);
                break;
              case 80:
                resultString += date.getHours() < 12 ? locale2.am : locale2.pm;
                break;
              case 82:
                resultString += _processFormat(locale2.formats.R, date, locale2, timestamp);
                break;
              case 83:
                resultString += padTill2(date.getSeconds(), padding);
                break;
              case 84:
                resultString += _processFormat(locale2.formats.T, date, locale2, timestamp);
                break;
              case 85:
                resultString += padTill2(weekNumber(date, "sunday"), padding);
                break;
              case 87:
                resultString += padTill2(weekNumber(date, "monday"), padding);
                break;
              case 88:
                resultString += _processFormat(locale2.formats.X, date, locale2, timestamp);
                break;
              case 89:
                resultString += date.getFullYear();
                break;
              case 90:
                if (_useUtcBasedDate && _customTimezoneOffset === 0) {
                  resultString += "GMT";
                } else {
                  var tzName = getTimezoneName(date);
                  resultString += tzName || "";
                }
                break;
              case 97:
                resultString += locale2.shortDays[date.getDay()];
                break;
              case 98:
                resultString += locale2.shortMonths[date.getMonth()];
                break;
              case 99:
                resultString += _processFormat(locale2.formats.c, date, locale2, timestamp);
                break;
              case 100:
                resultString += padTill2(date.getDate(), padding);
                break;
              case 101:
                resultString += padTill2(date.getDate(), padding == null ? " " : padding);
                break;
              case 104:
                resultString += locale2.shortMonths[date.getMonth()];
                break;
              case 106:
                var y = new Date(date.getFullYear(), 0, 1);
                var day = Math.ceil((date.getTime() - y.getTime()) / (1000 * 60 * 60 * 24));
                resultString += padTill3(day);
                break;
              case 107:
                resultString += padTill2(date.getHours(), padding == null ? " " : padding);
                break;
              case 108:
                resultString += padTill2(hours12(date.getHours()), padding == null ? " " : padding);
                break;
              case 109:
                resultString += padTill2(date.getMonth() + 1, padding);
                break;
              case 110:
                resultString += `
`;
                break;
              case 111:
                var day = date.getDate();
                if (locale2.ordinalSuffixes) {
                  resultString += String(day) + (locale2.ordinalSuffixes[day - 1] || ordinal(day));
                } else {
                  resultString += String(day) + ordinal(day);
                }
                break;
              case 112:
                resultString += date.getHours() < 12 ? locale2.AM : locale2.PM;
                break;
              case 114:
                resultString += _processFormat(locale2.formats.r, date, locale2, timestamp);
                break;
              case 115:
                resultString += Math.floor(timestamp / 1000);
                break;
              case 116:
                resultString += "\t";
                break;
              case 117:
                var day = date.getDay();
                resultString += day === 0 ? 7 : day;
                break;
              case 118:
                resultString += _processFormat(locale2.formats.v, date, locale2, timestamp);
                break;
              case 119:
                resultString += date.getDay();
                break;
              case 120:
                resultString += _processFormat(locale2.formats.x, date, locale2, timestamp);
                break;
              case 121:
                resultString += padTill2(date.getFullYear() % 100, padding);
                break;
              case 122:
                if (_useUtcBasedDate && _customTimezoneOffset === 0) {
                  resultString += extendedTZ ? "+00:00" : "+0000";
                } else {
                  var off;
                  if (_customTimezoneOffset !== 0) {
                    off = _customTimezoneOffset / (60 * 1000);
                  } else {
                    off = -date.getTimezoneOffset();
                  }
                  var sign = off < 0 ? "-" : "+";
                  var sep = extendedTZ ? ":" : "";
                  var hours = Math.floor(Math.abs(off / 60));
                  var mins = Math.abs(off % 60);
                  resultString += sign + padTill2(hours) + sep + padTill2(mins);
                }
                break;
              default:
                if (isInScope) {
                  resultString += "%";
                }
                resultString += format[i];
                break;
            }
            padding = null;
            isInScope = false;
            continue;
          }
          if (currentCharCode === 37) {
            isInScope = true;
            continue;
          }
          resultString += format[i];
        }
        return resultString;
      }
      var strftime = _strftime;
      strftime.localize = function(locale2) {
        return new Strftime(locale2 || _locale, _customTimezoneOffset, _useUtcBasedDate);
      };
      strftime.localizeByIdentifier = function(localeIdentifier) {
        var locale2 = Locales[localeIdentifier];
        if (!locale2) {
          warn('[WARNING] No locale found with identifier "' + localeIdentifier + '".');
          return strftime;
        }
        return strftime.localize(locale2);
      };
      strftime.timezone = function(timezone) {
        var customTimezoneOffset2 = _customTimezoneOffset;
        var useUtcBasedDate = _useUtcBasedDate;
        var timezoneType = typeof timezone;
        if (timezoneType === "number" || timezoneType === "string") {
          useUtcBasedDate = true;
          if (timezoneType === "string") {
            var sign = timezone[0] === "-" ? -1 : 1, hours = parseInt(timezone.slice(1, 3), 10), minutes = parseInt(timezone.slice(3, 5), 10);
            customTimezoneOffset2 = sign * (60 * hours + minutes) * 60 * 1000;
          } else if (timezoneType === "number") {
            customTimezoneOffset2 = timezone * 60 * 1000;
          }
        }
        return new Strftime(_locale, customTimezoneOffset2, useUtcBasedDate);
      };
      strftime.utc = function() {
        return new Strftime(_locale, _customTimezoneOffset, true);
      };
      return strftime;
    }
    function padTill2(numberToPad, paddingChar) {
      if (paddingChar === "" || numberToPad > 9) {
        return "" + numberToPad;
      }
      if (paddingChar == null) {
        paddingChar = "0";
      }
      return paddingChar + numberToPad;
    }
    function padTill3(numberToPad) {
      if (numberToPad > 99) {
        return numberToPad;
      }
      if (numberToPad > 9) {
        return "0" + numberToPad;
      }
      return "00" + numberToPad;
    }
    function hours12(hour) {
      if (hour === 0) {
        return 12;
      } else if (hour > 12) {
        return hour - 12;
      }
      return hour;
    }
    function weekNumber(date, firstWeekday) {
      firstWeekday = firstWeekday || "sunday";
      var weekday = date.getDay();
      if (firstWeekday === "monday") {
        if (weekday === 0)
          weekday = 6;
        else
          weekday--;
      }
      var firstDayOfYearUtc = Date.UTC(date.getFullYear(), 0, 1), dateUtc = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()), yday = Math.floor((dateUtc - firstDayOfYearUtc) / 86400000), weekNum = (yday + 7 - weekday) / 7;
      return Math.floor(weekNum);
    }
    function ordinal(number) {
      var i = number % 10;
      var ii = number % 100;
      if (ii >= 11 && ii <= 13 || i === 0 || i >= 4) {
        return "th";
      }
      switch (i) {
        case 1:
          return "st";
        case 2:
          return "nd";
        case 3:
          return "rd";
      }
    }
    function getTimestampToUtcOffsetFor(date) {
      return (date.getTimezoneOffset() || 0) * 60000;
    }
    function getTimezoneName(date, localeIdentifier) {
      return getShortTimezoneName(date, localeIdentifier) || getDefaultTimezoneName(date);
    }
    function getShortTimezoneName(date, localeIdentifier) {
      if (localeIdentifier == null)
        return null;
      var tzString = date.toLocaleString(localeIdentifier, { timeZoneName: "short" }).match(/\s([\w]+)$/);
      return tzString && tzString[1];
    }
    function getDefaultTimezoneName(date) {
      var tzString = date.toString().match(/\(([\w\s]+)\)/);
      return tzString && tzString[1];
    }
    function warn(message) {
      if (typeof console !== "undefined" && typeof console.warn == "function") {
        console.warn(message);
      }
    }
  })();
});

// node_modules/@deno/shim-deno/dist/deno/stable/variables/errors.js
var require_errors3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WriteZero = exports.UnexpectedEof = exports.TimedOut = exports.PermissionDenied = exports.NotFound = exports.NotConnected = exports.InvalidData = exports.Interrupted = exports.Http = exports.ConnectionReset = exports.ConnectionRefused = exports.ConnectionAborted = exports.Busy = exports.BrokenPipe = exports.BadResource = exports.AlreadyExists = exports.AddrNotAvailable = exports.AddrInUse = undefined;

  class AddrInUse extends Error {
  }
  exports.AddrInUse = AddrInUse;

  class AddrNotAvailable extends Error {
  }
  exports.AddrNotAvailable = AddrNotAvailable;

  class AlreadyExists extends Error {
  }
  exports.AlreadyExists = AlreadyExists;

  class BadResource extends Error {
  }
  exports.BadResource = BadResource;

  class BrokenPipe extends Error {
  }
  exports.BrokenPipe = BrokenPipe;

  class Busy extends Error {
  }
  exports.Busy = Busy;

  class ConnectionAborted extends Error {
  }
  exports.ConnectionAborted = ConnectionAborted;

  class ConnectionRefused extends Error {
  }
  exports.ConnectionRefused = ConnectionRefused;

  class ConnectionReset extends Error {
  }
  exports.ConnectionReset = ConnectionReset;

  class Http extends Error {
  }
  exports.Http = Http;

  class Interrupted extends Error {
  }
  exports.Interrupted = Interrupted;

  class InvalidData extends Error {
  }
  exports.InvalidData = InvalidData;

  class NotConnected extends Error {
  }
  exports.NotConnected = NotConnected;

  class NotFound extends Error {
    constructor() {
      super(...arguments);
      this.code = "ENOENT";
    }
  }
  exports.NotFound = NotFound;

  class PermissionDenied extends Error {
  }
  exports.PermissionDenied = PermissionDenied;

  class TimedOut extends Error {
  }
  exports.TimedOut = TimedOut;

  class UnexpectedEof extends Error {
  }
  exports.UnexpectedEof = UnexpectedEof;

  class WriteZero extends Error {
  }
  exports.WriteZero = WriteZero;
});

// node_modules/@deno/shim-deno/dist/deno/internal/errorMap.js
var require_errorMap = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var errors = __importStar(require_errors3());
  var mapper = (Ctor) => (err) => Object.assign(new Ctor(err.message), {
    stack: err.stack
  });
  var map = {
    EEXIST: mapper(errors.AlreadyExists),
    ENOENT: mapper(errors.NotFound),
    EBADF: mapper(errors.BadResource)
  };
  var isNodeErr = (e) => {
    return e instanceof Error && "code" in e;
  };
  function mapError(e) {
    var _a;
    if (!isNodeErr(e))
      return e;
    return ((_a = map[e.code]) === null || _a === undefined ? undefined : _a.call(map, e)) || e;
  }
  exports.default = mapError;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/stat.js
var require_stat = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stat = exports.denoifyFileInfo = undefined;
  var promises_1 = __require("node:fs/promises");
  var os = __importStar(__require("node:os"));
  var errorMap_js_1 = __importDefault(require_errorMap());
  var isWindows = os.platform() === "win32";
  function denoifyFileInfo(s) {
    return {
      atime: s.atime,
      birthtime: s.birthtime,
      blksize: isWindows ? null : s.blksize,
      blocks: isWindows ? null : s.blocks,
      dev: s.dev,
      gid: isWindows ? null : s.gid,
      ino: isWindows ? null : s.ino,
      isDirectory: s.isDirectory(),
      isFile: s.isFile(),
      isSymlink: s.isSymbolicLink(),
      isBlockDevice: isWindows ? null : s.isBlockDevice(),
      isCharDevice: isWindows ? null : s.isCharacterDevice(),
      isFifo: isWindows ? null : s.isFIFO(),
      isSocket: isWindows ? null : s.isSocket(),
      mode: isWindows ? null : s.mode,
      mtime: s.mtime,
      nlink: isWindows ? null : s.nlink,
      rdev: isWindows ? null : s.rdev,
      size: s.size,
      uid: isWindows ? null : s.uid
    };
  }
  exports.denoifyFileInfo = denoifyFileInfo;
  var stat = async (path2) => {
    try {
      return denoifyFileInfo(await (0, promises_1.stat)(path2));
    } catch (e) {
      throw (0, errorMap_js_1.default)(e);
    }
  };
  exports.stat = stat;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/fstat.js
var require_fstat = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fstat = undefined;
  var fs2 = __importStar(__require("fs"));
  var util_1 = __require("util");
  var stat_js_1 = require_stat();
  var errorMap_js_1 = __importDefault(require_errorMap());
  var nodeFstat = (0, util_1.promisify)(fs2.fstat);
  var fstat = async function(fd) {
    try {
      return (0, stat_js_1.denoifyFileInfo)(await nodeFstat(fd));
    } catch (err) {
      throw (0, errorMap_js_1.default)(err);
    }
  };
  exports.fstat = fstat;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/fstatSync.js
var require_fstatSync = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fstatSync = undefined;
  var fs_1 = __require("fs");
  var stat_js_1 = require_stat();
  var errorMap_js_1 = __importDefault(require_errorMap());
  var fstatSync = function fstatSync(fd) {
    try {
      return (0, stat_js_1.denoifyFileInfo)((0, fs_1.fstatSync)(fd));
    } catch (err) {
      throw (0, errorMap_js_1.default)(err);
    }
  };
  exports.fstatSync = fstatSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/ftruncate.js
var require_ftruncate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ftruncate = undefined;
  var fs_1 = __require("fs");
  var util_1 = __require("util");
  var _ftruncate = (0, util_1.promisify)(fs_1.ftruncate);
  exports.ftruncate = _ftruncate;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/ftruncateSync.js
var require_ftruncateSync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ftruncateSync = undefined;
  var fs_1 = __require("fs");
  exports.ftruncateSync = fs_1.ftruncateSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/fdatasync.js
var require_fdatasync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fdatasync = undefined;
  var fs_1 = __require("fs");
  var util_1 = __require("util");
  var _fdatasync = (0, util_1.promisify)(fs_1.fdatasync);
  exports.fdatasync = _fdatasync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/fdatasyncSync.js
var require_fdatasyncSync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fdatasyncSync = undefined;
  var fs_1 = __require("fs");
  exports.fdatasyncSync = fs_1.fdatasyncSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/read.js
var require_read = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.read = undefined;
  var util_1 = __require("util");
  var fs_1 = __require("fs");
  var _read = (0, util_1.promisify)(fs_1.read);
  var read = async function read(rid, buffer) {
    if (buffer == null) {
      throw new TypeError("Buffer must not be null.");
    }
    if (buffer.length === 0) {
      return 0;
    }
    const { bytesRead } = await _read(rid, buffer, 0, buffer.length, null);
    return bytesRead === 0 ? null : bytesRead;
  };
  exports.read = read;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/readSync.js
var require_readSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readSync = undefined;
  var fs2 = __importStar(__require("fs"));
  var readSync = (fd, buffer) => {
    const bytesRead = fs2.readSync(fd, buffer);
    return bytesRead === 0 ? null : bytesRead;
  };
  exports.readSync = readSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/write.js
var require_write = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.write = undefined;
  var fs2 = __importStar(__require("fs"));
  var util_1 = __require("util");
  var nodeWrite = (0, util_1.promisify)(fs2.write);
  var write = async (fd, data) => {
    const { bytesWritten } = await nodeWrite(fd, data);
    return bytesWritten;
  };
  exports.write = write;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/writeSync.js
var require_writeSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.writeSync = undefined;
  var fs2 = __importStar(__require("fs"));
  exports.writeSync = fs2.writeSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/classes/FsFile.js
var require_FsFile = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var _a;
  var _b;
  var _c;
  var _d;
  var _FsFile_closed;
  var _FsFile_readableStream;
  var _FsFile_writableStream;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.File = exports.FsFile = undefined;
  var fs2 = __importStar(__require("node:fs"));
  var stream = __importStar(__require("node:stream"));
  var fstat_js_1 = require_fstat();
  var fstatSync_js_1 = require_fstatSync();
  var ftruncate_js_1 = require_ftruncate();
  var ftruncateSync_js_1 = require_ftruncateSync();
  var fdatasync_js_1 = require_fdatasync();
  var fdatasyncSync_js_1 = require_fdatasyncSync();
  var read_js_1 = require_read();
  var readSync_js_1 = require_readSync();
  var write_js_1 = require_write();
  var writeSync_js_1 = require_writeSync();
  (_a = (_c = Symbol).dispose) !== null && _a !== undefined || (_c.dispose = Symbol("Symbol.dispose"));
  (_b = (_d = Symbol).asyncDispose) !== null && _b !== undefined || (_d.asyncDispose = Symbol("Symbol.asyncDispose"));

  class FsFile {
    constructor(rid) {
      this.rid = rid;
      _FsFile_closed.set(this, false);
      _FsFile_readableStream.set(this, undefined);
      _FsFile_writableStream.set(this, undefined);
    }
    [(_FsFile_closed = new WeakMap, _FsFile_readableStream = new WeakMap, _FsFile_writableStream = new WeakMap, Symbol.dispose)]() {
      if (!__classPrivateFieldGet(this, _FsFile_closed, "f")) {
        this.close();
      }
    }
    async write(p) {
      return await (0, write_js_1.write)(this.rid, p);
    }
    writeSync(p) {
      return (0, writeSync_js_1.writeSync)(this.rid, p);
    }
    async truncate(len) {
      await (0, ftruncate_js_1.ftruncate)(this.rid, len);
    }
    truncateSync(len) {
      return (0, ftruncateSync_js_1.ftruncateSync)(this.rid, len);
    }
    read(p) {
      return (0, read_js_1.read)(this.rid, p);
    }
    readSync(p) {
      return (0, readSync_js_1.readSync)(this.rid, p);
    }
    seek(_offset, _whence) {
      throw new Error("Method not implemented.");
    }
    seekSync(_offset, _whence) {
      throw new Error("Method not implemented.");
    }
    async stat() {
      return await (0, fstat_js_1.fstat)(this.rid);
    }
    statSync() {
      return (0, fstatSync_js_1.fstatSync)(this.rid);
    }
    sync() {
      throw new Error("Method not implemented.");
    }
    syncSync() {
      throw new Error("Method not implemented.");
    }
    syncData() {
      return (0, fdatasync_js_1.fdatasync)(this.rid);
    }
    syncDataSync() {
      return (0, fdatasyncSync_js_1.fdatasyncSync)(this.rid);
    }
    utime(_atime, _mtime) {
      throw new Error("Method not implemented.");
    }
    utimeSync(_atime, _mtime) {
      throw new Error("Method not implemented.");
    }
    close() {
      __classPrivateFieldSet(this, _FsFile_closed, true, "f");
      fs2.closeSync(this.rid);
    }
    get readable() {
      if (__classPrivateFieldGet(this, _FsFile_readableStream, "f") == null) {
        const nodeStream = fs2.createReadStream(null, {
          fd: this.rid,
          autoClose: false
        });
        __classPrivateFieldSet(this, _FsFile_readableStream, stream.Readable.toWeb(nodeStream), "f");
      }
      return __classPrivateFieldGet(this, _FsFile_readableStream, "f");
    }
    get writable() {
      if (__classPrivateFieldGet(this, _FsFile_writableStream, "f") == null) {
        const nodeStream = fs2.createWriteStream(null, {
          fd: this.rid,
          autoClose: false
        });
        __classPrivateFieldSet(this, _FsFile_writableStream, stream.Writable.toWeb(nodeStream), "f");
      }
      return __classPrivateFieldGet(this, _FsFile_writableStream, "f");
    }
  }
  exports.FsFile = FsFile;
  var File2 = FsFile;
  exports.File = File2;
});

// node_modules/@deno/shim-deno/dist/deno/stable/classes/PermissionStatus.js
var require_PermissionStatus = __commonJS((exports) => {
  var _a;
  var _b;
  var _c;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PermissionStatus = undefined;
  (_a = (_c = globalThis).EventTarget) !== null && _a !== undefined || (_c.EventTarget = (_b = __require("events").EventTarget) !== null && _b !== undefined ? _b : null);

  class PermissionStatus extends EventTarget {
    constructor(state) {
      super();
      this.state = state;
      this.onchange = null;
      this.partial = false;
    }
  }
  exports.PermissionStatus = PermissionStatus;
});

// node_modules/@deno/shim-deno/dist/deno/stable/classes/Permissions.js
var require_Permissions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Permissions = undefined;
  var PermissionStatus_js_1 = require_PermissionStatus();

  class Permissions {
    query(desc) {
      return Promise.resolve(this.querySync(desc));
    }
    querySync(_desc) {
      return new PermissionStatus_js_1.PermissionStatus("granted");
    }
    revoke(desc) {
      return Promise.resolve(this.revokeSync(desc));
    }
    revokeSync(_desc) {
      return new PermissionStatus_js_1.PermissionStatus("denied");
    }
    request(desc) {
      return this.query(desc);
    }
    requestSync(desc) {
      return this.querySync(desc);
    }
  }
  exports.Permissions = Permissions;
});

// node_modules/@deno/shim-deno/dist/deno/stable/classes.js
var require_classes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PermissionStatus = exports.Permissions = exports.FsFile = exports.File = undefined;
  var FsFile_js_1 = require_FsFile();
  Object.defineProperty(exports, "File", { enumerable: true, get: function() {
    return FsFile_js_1.File;
  } });
  Object.defineProperty(exports, "FsFile", { enumerable: true, get: function() {
    return FsFile_js_1.FsFile;
  } });
  var Permissions_js_1 = require_Permissions();
  Object.defineProperty(exports, "Permissions", { enumerable: true, get: function() {
    return Permissions_js_1.Permissions;
  } });
  var PermissionStatus_js_1 = require_PermissionStatus();
  Object.defineProperty(exports, "PermissionStatus", { enumerable: true, get: function() {
    return PermissionStatus_js_1.PermissionStatus;
  } });
});

// node_modules/@deno/shim-deno/dist/deno/stable/enums/SeekMode.js
var require_SeekMode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SeekMode = undefined;
  var SeekMode;
  (function(SeekMode2) {
    SeekMode2[SeekMode2["Start"] = 0] = "Start";
    SeekMode2[SeekMode2["Current"] = 1] = "Current";
    SeekMode2[SeekMode2["End"] = 2] = "End";
  })(SeekMode || (exports.SeekMode = SeekMode = {}));
});

// node_modules/@deno/shim-deno/dist/deno/stable/enums.js
var require_enums = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SeekMode = undefined;
  var SeekMode_js_1 = require_SeekMode();
  Object.defineProperty(exports, "SeekMode", { enumerable: true, get: function() {
    return SeekMode_js_1.SeekMode;
  } });
});

// node_modules/@deno/shim-deno/dist/deno/stable/variables/build.js
var require_build = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.build = undefined;
  var os = __importStar(__require("os"));
  exports.build = {
    arch: "x86_64",
    os: ((p) => p === "win32" ? "windows" : p === "darwin" ? "darwin" : "linux")(os.platform()),
    vendor: "pc",
    target: ((p) => p === "win32" ? "x86_64-pc-windows-msvc" : p === "darwin" ? "x86_64-apple-darwin" : "x86_64-unknown-linux-gnu")(os.platform())
  };
});

// node_modules/@deno/shim-deno/dist/deno/stable/variables/customInspect.js
var require_customInspect = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.customInspect = undefined;
  exports.customInspect = Symbol.for("nodejs.util.inspect.custom");
});

// node_modules/@deno/shim-deno/dist/deno/stable/variables/env.js
var require_env = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.env = undefined;
  exports.env = {
    get(key) {
      assertValidKey(key);
      return process.env[key];
    },
    set(key, value) {
      assertValidKey(key);
      assertValidValue(value);
      process.env[key] = value;
    },
    has(key) {
      assertValidKey(key);
      return key in process.env;
    },
    delete(key) {
      assertValidKey(key);
      delete process.env[key];
    },
    toObject() {
      return { ...process.env };
    }
  };
  var invalidKeyChars = ["=", "\x00"].map((c) => c.charCodeAt(0));
  var invalidValueChar = 0;
  function assertValidKey(key) {
    if (key.length === 0) {
      throw new TypeError("Key is an empty string.");
    }
    for (let i = 0;i < key.length; i++) {
      if (invalidKeyChars.includes(key.charCodeAt(i))) {
        const char = key.charCodeAt(i) === 0 ? "\\0" : key[i];
        throw new TypeError(`Key contains invalid characters: "${char}"`);
      }
    }
  }
  function assertValidValue(value) {
    for (let i = 0;i < value.length; i++) {
      if (value.charCodeAt(i) === invalidValueChar) {
        throw new TypeError('Value contains invalid characters: "\\0"');
      }
    }
  }
});

// node_modules/@deno/shim-deno/dist/deno/stable/variables/mainModule.js
var require_mainModule = __commonJS((exports) => {
  var __dirname = "/Users/amymanny/Code/rollup-n-up-n-up/node_modules/@deno/shim-deno/dist/deno/stable/variables";
  var _a;
  var _b;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mainModule = undefined;
  var path_1 = __require("path");
  var url_1 = __require("url");
  exports.mainModule = (0, url_1.pathToFileURL)((_b = (_a = __require.main) === null || _a === undefined ? undefined : _a.filename) !== null && _b !== undefined ? _b : (0, path_1.join)(__dirname, "$deno$repl.ts")).href;
});

// node_modules/@deno/shim-deno/dist/deno/stable/variables/metrics.js
var require_metrics = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.metrics = undefined;
  var metrics = function metrics() {
    return {
      opsDispatched: 0,
      opsDispatchedSync: 0,
      opsDispatchedAsync: 0,
      opsDispatchedAsyncUnref: 0,
      opsCompleted: 0,
      opsCompletedSync: 0,
      opsCompletedAsync: 0,
      opsCompletedAsyncUnref: 0,
      bytesSentControl: 0,
      bytesSentData: 0,
      bytesReceived: 0,
      ops: {}
    };
  };
  exports.metrics = metrics;
});

// node_modules/@deno/shim-deno/dist/deno/stable/variables/noColor.js
var require_noColor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.noColor = undefined;
  exports.noColor = process.env.NO_COLOR !== undefined;
});

// node_modules/@deno/shim-deno/dist/deno/stable/variables/permissions.js
var require_permissions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.permissions = undefined;
  var Permissions_js_1 = require_Permissions();
  exports.permissions = new Permissions_js_1.Permissions;
});

// node_modules/@deno/shim-deno/dist/deno/stable/variables/pid.js
var require_pid = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pid = undefined;
  exports.pid = process.pid;
});

// node_modules/@deno/shim-deno/dist/deno/stable/variables/ppid.js
var require_ppid = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ppid = undefined;
  exports.ppid = process.ppid;
});

// node_modules/@deno/shim-deno/dist/deno/stable/variables/resources.js
var require_resources = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resources = undefined;
  var resources = function resources() {
    console.warn([
      "Deno.resources() shim returns a dummy object that does not update.",
      "If you think this is a mistake, raise an issue at https://github.com/denoland/node_deno_shims/issues"
    ].join(`
`));
    return {};
  };
  exports.resources = resources;
});

// node_modules/@deno/shim-deno/dist/deno/stable/variables/std.js
var require_std = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stderr = exports.stdout = exports.stdin = undefined;
  var node_stream_1 = __importDefault(__require("node:stream"));
  var node_tty_1 = __importDefault(__require("node:tty"));
  var readSync_js_1 = require_readSync();
  var writeSync_js_1 = require_writeSync();
  function chain(fn, cleanup) {
    let prev;
    return function _fn(...args) {
      const curr = (prev || Promise.resolve()).then(() => fn(...args)).finally(cleanup || (() => {
      })).then((result) => {
        if (prev === curr)
          prev = undefined;
        return result;
      });
      return prev = curr;
    };
  }
  var stdinReadable;
  exports.stdin = {
    rid: 0,
    isTerminal() {
      return node_tty_1.default.isatty(this.rid);
    },
    read: chain((p) => {
      return new Promise((resolve, reject) => {
        process.stdin.resume();
        process.stdin.on("error", onerror);
        process.stdin.once("readable", () => {
          var _a;
          process.stdin.off("error", onerror);
          const data = (_a = process.stdin.read(p.length)) !== null && _a !== undefined ? _a : process.stdin.read();
          if (data) {
            p.set(data);
            resolve(data.length > 0 ? data.length : null);
          } else {
            resolve(null);
          }
        });
        function onerror(error) {
          reject(error);
          process.stdin.off("error", onerror);
        }
      });
    }, () => process.stdin.pause()),
    get readable() {
      if (stdinReadable == null) {
        stdinReadable = node_stream_1.default.Readable.toWeb(process.stdin);
      }
      return stdinReadable;
    },
    readSync(buffer) {
      return (0, readSync_js_1.readSync)(this.rid, buffer);
    },
    close() {
      process.stdin.destroy();
    },
    setRaw(mode, options) {
      if (options === null || options === undefined ? undefined : options.cbreak) {
        throw new Error("The cbreak option is not implemented.");
      }
      process.stdin.setRawMode(mode);
    }
  };
  var stdoutWritable;
  exports.stdout = {
    rid: 1,
    isTerminal() {
      return node_tty_1.default.isatty(this.rid);
    },
    write: chain((p) => {
      return new Promise((resolve) => {
        const result = process.stdout.write(p);
        if (!result) {
          process.stdout.once("drain", () => resolve(p.length));
        } else {
          resolve(p.length);
        }
      });
    }),
    get writable() {
      if (stdoutWritable == null) {
        stdoutWritable = node_stream_1.default.Writable.toWeb(process.stdout);
      }
      return stdoutWritable;
    },
    writeSync(data) {
      return (0, writeSync_js_1.writeSync)(this.rid, data);
    },
    close() {
      process.stdout.destroy();
    }
  };
  var stderrWritable;
  exports.stderr = {
    rid: 2,
    isTerminal() {
      return node_tty_1.default.isatty(this.rid);
    },
    write: chain((p) => {
      return new Promise((resolve) => {
        const result = process.stderr.write(p);
        if (!result) {
          process.stderr.once("drain", () => resolve(p.length));
        } else {
          resolve(p.length);
        }
      });
    }),
    get writable() {
      if (stderrWritable == null) {
        stderrWritable = node_stream_1.default.Writable.toWeb(process.stderr);
      }
      return stderrWritable;
    },
    writeSync(data) {
      return (0, writeSync_js_1.writeSync)(this.rid, data);
    },
    close() {
      process.stderr.destroy();
    }
  };
});

// node_modules/@deno/shim-deno/dist/deno/internal/version.js
var require_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.typescript = exports.deno = undefined;
  exports.deno = "1.40.3";
  exports.typescript = "5.3.3";
});

// node_modules/@deno/shim-deno/dist/deno/stable/variables/version.js
var require_version2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = undefined;
  var version_js_1 = require_version();
  exports.version = {
    deno: version_js_1.deno,
    typescript: version_js_1.typescript,
    v8: process.versions.v8
  };
});

// node_modules/@deno/shim-deno/dist/deno/stable/variables.js
var require_variables = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.version = exports.resources = exports.ppid = exports.pid = exports.permissions = exports.noColor = exports.metrics = exports.mainModule = exports.errors = exports.env = exports.customInspect = exports.build = undefined;
  var build_js_1 = require_build();
  Object.defineProperty(exports, "build", { enumerable: true, get: function() {
    return build_js_1.build;
  } });
  var customInspect_js_1 = require_customInspect();
  Object.defineProperty(exports, "customInspect", { enumerable: true, get: function() {
    return customInspect_js_1.customInspect;
  } });
  var env_js_1 = require_env();
  Object.defineProperty(exports, "env", { enumerable: true, get: function() {
    return env_js_1.env;
  } });
  exports.errors = __importStar(require_errors3());
  var mainModule_js_1 = require_mainModule();
  Object.defineProperty(exports, "mainModule", { enumerable: true, get: function() {
    return mainModule_js_1.mainModule;
  } });
  var metrics_js_1 = require_metrics();
  Object.defineProperty(exports, "metrics", { enumerable: true, get: function() {
    return metrics_js_1.metrics;
  } });
  var noColor_js_1 = require_noColor();
  Object.defineProperty(exports, "noColor", { enumerable: true, get: function() {
    return noColor_js_1.noColor;
  } });
  var permissions_js_1 = require_permissions();
  Object.defineProperty(exports, "permissions", { enumerable: true, get: function() {
    return permissions_js_1.permissions;
  } });
  var pid_js_1 = require_pid();
  Object.defineProperty(exports, "pid", { enumerable: true, get: function() {
    return pid_js_1.pid;
  } });
  var ppid_js_1 = require_ppid();
  Object.defineProperty(exports, "ppid", { enumerable: true, get: function() {
    return ppid_js_1.ppid;
  } });
  var resources_js_1 = require_resources();
  Object.defineProperty(exports, "resources", { enumerable: true, get: function() {
    return resources_js_1.resources;
  } });
  __exportStar(require_std(), exports);
  var version_js_1 = require_version2();
  Object.defineProperty(exports, "version", { enumerable: true, get: function() {
    return version_js_1.version;
  } });
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/addSignalListener.js
var require_addSignalListener = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.addSignalListener = undefined;
  var process_1 = __importDefault(__require("process"));
  function denoSignalToNodeJs(signal) {
    if (signal === "SIGEMT") {
      throw new Error("SIGEMT is not supported");
    }
    return signal;
  }
  var addSignalListener = (signal, handler) => {
    process_1.default.addListener(denoSignalToNodeJs(signal), handler);
  };
  exports.addSignalListener = addSignalListener;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/chdir.js
var require_chdir = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.chdir = undefined;
  var url_1 = __require("url");
  var errorMap_js_1 = __importDefault(require_errorMap());
  var variables_js_1 = require_variables();
  var chdir = function(path2) {
    try {
      return process.chdir(path2 instanceof URL ? (0, url_1.fileURLToPath)(path2) : path2);
    } catch (error) {
      if ((error === null || error === undefined ? undefined : error.code) === "ENOENT") {
        throw new variables_js_1.errors.NotFound(`No such file or directory (os error 2), chdir '${path2}'`);
      }
      throw (0, errorMap_js_1.default)(error);
    }
  };
  exports.chdir = chdir;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/chmod.js
var require_chmod = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.chmod = undefined;
  var fs2 = __importStar(__require("fs/promises"));
  exports.chmod = fs2.chmod;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/chmodSync.js
var require_chmodSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.chmodSync = undefined;
  var fs2 = __importStar(__require("fs"));
  exports.chmodSync = fs2.chmodSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/chown.js
var require_chown = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.chown = undefined;
  var fs2 = __importStar(__require("fs/promises"));
  var chown = async (path2, uid, gid) => await fs2.chown(path2, uid !== null && uid !== undefined ? uid : -1, gid !== null && gid !== undefined ? gid : -1);
  exports.chown = chown;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/chownSync.js
var require_chownSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.chownSync = undefined;
  var fs2 = __importStar(__require("fs"));
  var chownSync = (path2, uid, gid) => fs2.chownSync(path2, uid !== null && uid !== undefined ? uid : -1, gid !== null && gid !== undefined ? gid : -1);
  exports.chownSync = chownSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/close.js
var require_close = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.close = undefined;
  var fs2 = __importStar(__require("fs"));
  exports.close = fs2.closeSync;
});

// node_modules/@deno/shim-deno/dist/deno/internal/Conn.js
var require_Conn = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Conn_socket;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TlsConn = exports.Conn = undefined;
  var net_1 = __require("net");
  var FsFile_js_1 = require_FsFile();

  class Conn extends FsFile_js_1.FsFile {
    constructor(rid, localAddr, remoteAddr, socket) {
      super(rid);
      this.rid = rid;
      this.localAddr = localAddr;
      this.remoteAddr = remoteAddr;
      _Conn_socket.set(this, undefined);
      __classPrivateFieldSet(this, _Conn_socket, socket || new net_1.Socket({ fd: rid }), "f");
    }
    [(_Conn_socket = new WeakMap, Symbol.dispose)]() {
      this.close();
    }
    async closeWrite() {
      await new Promise((resolve) => __classPrivateFieldGet(this, _Conn_socket, "f").end(resolve));
    }
    setNoDelay(enable) {
      __classPrivateFieldGet(this, _Conn_socket, "f").setNoDelay(enable);
    }
    setKeepAlive(enable) {
      __classPrivateFieldGet(this, _Conn_socket, "f").setKeepAlive(enable);
    }
    ref() {
      __classPrivateFieldGet(this, _Conn_socket, "f").ref();
    }
    unref() {
      __classPrivateFieldGet(this, _Conn_socket, "f").unref();
    }
  }
  exports.Conn = Conn;

  class TlsConn extends Conn {
    handshake() {
      console.warn("@deno/shim-deno: Handshake is not supported.");
      return Promise.resolve({
        alpnProtocol: null
      });
    }
  }
  exports.TlsConn = TlsConn;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/connect.js
var require_connect2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.connect = undefined;
  var net_1 = __require("net");
  var Conn_js_1 = require_Conn();
  var connect = function connect(options) {
    if (options.transport === "unix") {
      throw new Error("Unstable UnixConnectOptions is not implemented");
    }
    const { transport = "tcp", hostname = "127.0.0.1", port } = options;
    if (transport !== "tcp") {
      throw new Error("Deno.connect is only implemented for transport: tcp");
    }
    const socket = (0, net_1.createConnection)({ port, host: hostname });
    socket.on("error", (err) => console.error(err));
    return new Promise((resolve) => {
      socket.once("connect", () => {
        const rid = socket._handle.fd;
        const localAddr = {
          hostname: socket.localAddress,
          port: socket.localPort,
          transport: "tcp"
        };
        const remoteAddr = {
          hostname: socket.remoteAddress,
          port: socket.remotePort,
          transport: "tcp"
        };
        resolve(new Conn_js_1.Conn(rid, localAddr, remoteAddr, socket));
      });
    });
  };
  exports.connect = connect;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/readTextFile.js
var require_readTextFile = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readTextFile = undefined;
  var promises_1 = __require("fs/promises");
  var errorMap_js_1 = __importDefault(require_errorMap());
  var readTextFile = async (path2, { signal } = {}) => {
    try {
      return await (0, promises_1.readFile)(path2, { encoding: "utf8", signal });
    } catch (e) {
      throw (0, errorMap_js_1.default)(e);
    }
  };
  exports.readTextFile = readTextFile;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/connectTls.js
var require_connectTls = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.connectTls = undefined;
  var tls_1 = __require("tls");
  var Conn_js_1 = require_Conn();
  var readTextFile_js_1 = require_readTextFile();
  var connectTls = async function connectTls({ port, hostname = "127.0.0.1", certFile }) {
    const cert = certFile && await (0, readTextFile_js_1.readTextFile)(certFile);
    const socket = (0, tls_1.connect)({ port, host: hostname, cert });
    return new Promise((resolve) => {
      socket.on("connect", () => {
        const rid = socket._handle.fd;
        const localAddr = {
          hostname: socket.localAddress,
          port: socket.localPort,
          transport: "tcp"
        };
        const remoteAddr = {
          hostname: socket.remoteAddress,
          port: socket.remotePort,
          transport: "tcp"
        };
        resolve(new Conn_js_1.TlsConn(rid, localAddr, remoteAddr, socket));
      });
    });
  };
  exports.connectTls = connectTls;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/consoleSize.js
var require_consoleSize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.consoleSize = undefined;
  var consoleSize = function consoleSize() {
    const pipes = [process.stderr, process.stdout];
    for (const pipe of pipes) {
      if (pipe.columns != null) {
        const { columns, rows } = pipe;
        return { columns, rows };
      }
    }
    throw new Error("The handle is invalid.");
  };
  exports.consoleSize = consoleSize;
});

// node_modules/@deno/shim-deno/dist/deno/internal/consts.js
var require_consts = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_BUFFER_SIZE = undefined;
  exports.DEFAULT_BUFFER_SIZE = 32 * 1024;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/copy.js
var require_copy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.copy = undefined;
  var consts_js_1 = require_consts();
  var copy = async function copy(src, dst, options) {
    var _a;
    let n = 0;
    const bufSize = (_a = options === null || options === undefined ? undefined : options.bufSize) !== null && _a !== undefined ? _a : consts_js_1.DEFAULT_BUFFER_SIZE;
    const b = new Uint8Array(bufSize);
    let gotEOF = false;
    while (gotEOF === false) {
      const result = await src.read(b);
      if (result === null) {
        gotEOF = true;
      } else {
        let nwritten = 0;
        while (nwritten < result) {
          nwritten += await dst.write(b.subarray(nwritten, result));
        }
        n += nwritten;
      }
    }
    return n;
  };
  exports.copy = copy;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/copyFile.js
var require_copyFile = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.copyFile = undefined;
  var fs2 = __importStar(__require("fs/promises"));
  var errorMap_js_1 = __importDefault(require_errorMap());
  var errors = __importStar(require_errors3());
  var copyFile = async (src, dest) => {
    try {
      await fs2.copyFile(src, dest);
    } catch (error) {
      if ((error === null || error === undefined ? undefined : error.code) === "ENOENT") {
        throw new errors.NotFound(`File not found, copy '${src}' -> '${dest}'`);
      }
      throw (0, errorMap_js_1.default)(error);
    }
  };
  exports.copyFile = copyFile;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/copyFileSync.js
var require_copyFileSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.copyFileSync = undefined;
  var fs2 = __importStar(__require("fs"));
  var errorMap_js_1 = __importDefault(require_errorMap());
  var errors = __importStar(require_errors3());
  var copyFileSync = (src, dest) => {
    try {
      fs2.copyFileSync(src, dest);
    } catch (error) {
      if ((error === null || error === undefined ? undefined : error.code) === "ENOENT") {
        throw new errors.NotFound(`File not found, copy '${src}' -> '${dest}'`);
      }
      throw (0, errorMap_js_1.default)(error);
    }
  };
  exports.copyFileSync = copyFileSync;
});

// node_modules/@deno/shim-deno/dist/deno/internal/fs_flags.js
var require_fs_flags = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getFsFlag = exports.getCreationFlag = exports.getAccessFlag = undefined;
  var errors = __importStar(require_errors3());
  var fs_1 = __require("fs");
  var os_1 = __importDefault(__require("os"));
  var { O_APPEND, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY } = fs_1.constants;
  function getAccessFlag(opts) {
    if (opts.read && !opts.write && !opts.append)
      return O_RDONLY;
    if (!opts.read && opts.write && !opts.append)
      return O_WRONLY;
    if (opts.read && opts.write && !opts.append)
      return O_RDWR;
    if (!opts.read && opts.append)
      return O_WRONLY | O_APPEND;
    if (opts.read && opts.append)
      return O_RDWR | O_APPEND;
    if (!opts.read && !opts.write && !opts.append) {
      throw new errors.BadResource("EINVAL: One of 'read', 'write', 'append' is required to open file.");
    }
    throw new errors.BadResource("EINVAL: Invalid fs flags.");
  }
  exports.getAccessFlag = getAccessFlag;
  function getCreationFlag(opts) {
    if (!opts.write && !opts.append) {
      if (opts.truncate || opts.create || opts.createNew) {
        throw new errors.BadResource("EINVAL: One of 'write', 'append' is required to 'truncate', 'create' or 'createNew' file.");
      }
    }
    if (opts.append) {
      if (opts.truncate && !opts.createNew) {
        throw new errors.BadResource("EINVAL: unexpected 'truncate': true and 'createNew': false when 'append' is true.");
      }
    }
    if (!opts.create && !opts.truncate && !opts.createNew)
      return 0;
    if (opts.create && !opts.truncate && !opts.createNew)
      return O_CREAT;
    if (!opts.create && opts.truncate && !opts.createNew) {
      if (os_1.default.platform() === "win32") {
        return O_CREAT | O_TRUNC;
      } else {
        return O_TRUNC;
      }
    }
    if (opts.create && opts.truncate && !opts.createNew) {
      return O_CREAT | O_TRUNC;
    }
    if (opts.createNew)
      return O_CREAT | O_EXCL;
    throw new errors.BadResource("EINVAL: Invalid fs flags.");
  }
  exports.getCreationFlag = getCreationFlag;
  function getFsFlag(flags) {
    return getAccessFlag(flags) | getCreationFlag(flags);
  }
  exports.getFsFlag = getFsFlag;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/open.js
var require_open = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.open = undefined;
  var fs_1 = __require("fs");
  var util_1 = __require("util");
  var FsFile_js_1 = require_FsFile();
  var fs_flags_js_1 = require_fs_flags();
  var errorMap_js_1 = __importDefault(require_errorMap());
  var nodeOpen = (0, util_1.promisify)(fs_1.open);
  var open = async function open(path2, { read, write, append, truncate, create, createNew, mode = 438 } = {
    read: true
  }) {
    const flagMode = (0, fs_flags_js_1.getFsFlag)({
      read,
      write,
      append,
      truncate,
      create,
      createNew
    });
    try {
      const fd = await nodeOpen(path2, flagMode, mode);
      return new FsFile_js_1.File(fd);
    } catch (err) {
      throw (0, errorMap_js_1.default)(err);
    }
  };
  exports.open = open;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/create.js
var require_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.create = undefined;
  var open_js_1 = require_open();
  var create = async function create(path2) {
    return await (0, open_js_1.open)(path2, { write: true, create: true, truncate: true });
  };
  exports.create = create;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/openSync.js
var require_openSync = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.openSync = undefined;
  var fs_1 = __require("fs");
  var FsFile_js_1 = require_FsFile();
  var fs_flags_js_1 = require_fs_flags();
  var errorMap_js_1 = __importDefault(require_errorMap());
  var openSync = function openSync(path2, { read, write, append, truncate, create, createNew, mode = 438 } = {
    read: true
  }) {
    const flagMode = (0, fs_flags_js_1.getFsFlag)({
      read,
      write,
      append,
      truncate,
      create,
      createNew
    });
    try {
      const fd = (0, fs_1.openSync)(path2, flagMode, mode);
      return new FsFile_js_1.File(fd);
    } catch (err) {
      throw (0, errorMap_js_1.default)(err);
    }
  };
  exports.openSync = openSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/createSync.js
var require_createSync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createSync = undefined;
  var openSync_js_1 = require_openSync();
  var createSync = function createSync(path2) {
    return (0, openSync_js_1.openSync)(path2, {
      create: true,
      truncate: true,
      read: true,
      write: true
    });
  };
  exports.createSync = createSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/cwd.js
var require_cwd = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cwd = undefined;
  exports.cwd = process.cwd;
});

// node_modules/@deno/shim-deno/node_modules/which/node_modules/isexe/dist/cjs/posix.js
var require_posix = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sync = exports.isexe = undefined;
  var fs_1 = __require("fs");
  var promises_1 = __require("fs/promises");
  var isexe = async (path2, options = {}) => {
    const { ignoreErrors = false } = options;
    try {
      return checkStat(await (0, promises_1.stat)(path2), options);
    } catch (e) {
      const er = e;
      if (ignoreErrors || er.code === "EACCES")
        return false;
      throw er;
    }
  };
  exports.isexe = isexe;
  var sync = (path2, options = {}) => {
    const { ignoreErrors = false } = options;
    try {
      return checkStat((0, fs_1.statSync)(path2), options);
    } catch (e) {
      const er = e;
      if (ignoreErrors || er.code === "EACCES")
        return false;
      throw er;
    }
  };
  exports.sync = sync;
  var checkStat = (stat, options) => stat.isFile() && checkMode(stat, options);
  var checkMode = (stat, options) => {
    const myUid = options.uid ?? process.getuid?.();
    const myGroups = options.groups ?? process.getgroups?.() ?? [];
    const myGid = options.gid ?? process.getgid?.() ?? myGroups[0];
    if (myUid === undefined || myGid === undefined) {
      throw new Error("cannot get uid or gid");
    }
    const groups = new Set([myGid, ...myGroups]);
    const mod = stat.mode;
    const uid = stat.uid;
    const gid = stat.gid;
    const u = parseInt("100", 8);
    const g = parseInt("010", 8);
    const o = parseInt("001", 8);
    const ug = u | g;
    return !!(mod & o || mod & g && groups.has(gid) || mod & u && uid === myUid || mod & ug && myUid === 0);
  };
});

// node_modules/@deno/shim-deno/node_modules/which/node_modules/isexe/dist/cjs/win32.js
var require_win32 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sync = exports.isexe = undefined;
  var fs_1 = __require("fs");
  var promises_1 = __require("fs/promises");
  var isexe = async (path2, options = {}) => {
    const { ignoreErrors = false } = options;
    try {
      return checkStat(await (0, promises_1.stat)(path2), path2, options);
    } catch (e) {
      const er = e;
      if (ignoreErrors || er.code === "EACCES")
        return false;
      throw er;
    }
  };
  exports.isexe = isexe;
  var sync = (path2, options = {}) => {
    const { ignoreErrors = false } = options;
    try {
      return checkStat((0, fs_1.statSync)(path2), path2, options);
    } catch (e) {
      const er = e;
      if (ignoreErrors || er.code === "EACCES")
        return false;
      throw er;
    }
  };
  exports.sync = sync;
  var checkPathExt = (path2, options) => {
    const { pathExt = process.env.PATHEXT || "" } = options;
    const peSplit = pathExt.split(";");
    if (peSplit.indexOf("") !== -1) {
      return true;
    }
    for (let i = 0;i < peSplit.length; i++) {
      const p = peSplit[i].toLowerCase();
      const ext = path2.substring(path2.length - p.length).toLowerCase();
      if (p && ext === p) {
        return true;
      }
    }
    return false;
  };
  var checkStat = (stat, path2, options) => stat.isFile() && checkPathExt(path2, options);
});

// node_modules/@deno/shim-deno/node_modules/which/node_modules/isexe/dist/cjs/options.js
var require_options = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@deno/shim-deno/node_modules/which/node_modules/isexe/dist/cjs/index.js
var require_cjs = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sync = exports.isexe = exports.posix = exports.win32 = undefined;
  var posix = __importStar(require_posix());
  exports.posix = posix;
  var win32 = __importStar(require_win32());
  exports.win32 = win32;
  __exportStar(require_options(), exports);
  var platform = process.env._ISEXE_TEST_PLATFORM_ || process.platform;
  var impl = platform === "win32" ? win32 : posix;
  exports.isexe = impl.isexe;
  exports.sync = impl.sync;
});

// node_modules/@deno/shim-deno/node_modules/which/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var { isexe, sync: isexeSync } = require_cjs();
  var { join, delimiter, sep, posix } = __require("path");
  var isWindows = process.platform === "win32";
  var rSlash = new RegExp(`[${posix.sep}${sep === posix.sep ? "" : sep}]`.replace(/(\\)/g, "\\$1"));
  var rRel = new RegExp(`^\\.${rSlash.source}`);
  var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
  var getPathInfo = (cmd, {
    path: optPath = process.env.PATH,
    pathExt: optPathExt = process.env.PATHEXT,
    delimiter: optDelimiter = delimiter
  }) => {
    const pathEnv = cmd.match(rSlash) ? [""] : [
      ...isWindows ? [process.cwd()] : [],
      ...(optPath || "").split(optDelimiter)
    ];
    if (isWindows) {
      const pathExtExe = optPathExt || [".EXE", ".CMD", ".BAT", ".COM"].join(optDelimiter);
      const pathExt = pathExtExe.split(optDelimiter).flatMap((item) => [item, item.toLowerCase()]);
      if (cmd.includes(".") && pathExt[0] !== "") {
        pathExt.unshift("");
      }
      return { pathEnv, pathExt, pathExtExe };
    }
    return { pathEnv, pathExt: [""] };
  };
  var getPathPart = (raw, cmd) => {
    const pathPart = /^".*"$/.test(raw) ? raw.slice(1, -1) : raw;
    const prefix = !pathPart && rRel.test(cmd) ? cmd.slice(0, 2) : "";
    return prefix + join(pathPart, cmd);
  };
  var which = async (cmd, opt = {}) => {
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    for (const envPart of pathEnv) {
      const p = getPathPart(envPart, cmd);
      for (const ext of pathExt) {
        const withExt = p + ext;
        const is = await isexe(withExt, { pathExt: pathExtExe, ignoreErrors: true });
        if (is) {
          if (!opt.all) {
            return withExt;
          }
          found.push(withExt);
        }
      }
    }
    if (opt.all && found.length) {
      return found;
    }
    if (opt.nothrow) {
      return null;
    }
    throw getNotFoundError(cmd);
  };
  var whichSync = (cmd, opt = {}) => {
    const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
    const found = [];
    for (const pathEnvPart of pathEnv) {
      const p = getPathPart(pathEnvPart, cmd);
      for (const ext of pathExt) {
        const withExt = p + ext;
        const is = isexeSync(withExt, { pathExt: pathExtExe, ignoreErrors: true });
        if (is) {
          if (!opt.all) {
            return withExt;
          }
          found.push(withExt);
        }
      }
    }
    if (opt.all && found.length) {
      return found;
    }
    if (opt.nothrow) {
      return null;
    }
    throw getNotFoundError(cmd);
  };
  module.exports = which;
  which.sync = whichSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/execPath.js
var require_execPath = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.execPath = undefined;
  var which_1 = __importDefault(require_lib2());
  var execPath = () => which_1.default.sync("deno");
  exports.execPath = execPath;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/exit.js
var require_exit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exit = undefined;
  var exit = function exit(code) {
    return process.exit(code);
  };
  exports.exit = exit;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/fsync.js
var require_fsync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fsync = undefined;
  var fs_1 = __require("fs");
  var util_1 = __require("util");
  var fsync = function fsync(rid) {
    return (0, util_1.promisify)(fs_1.fsync)(rid);
  };
  exports.fsync = fsync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/fsyncSync.js
var require_fsyncSync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fsyncSync = undefined;
  var fs_1 = __require("fs");
  var fsyncSync = function fsyncSync(rid) {
    return (0, fs_1.fsyncSync)(rid);
  };
  exports.fsyncSync = fsyncSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/gid.js
var require_gid = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.gid = undefined;
  var process_1 = __importDefault(__require("process"));
  exports.gid = (_a = process_1.default.getgid) !== null && _a !== undefined ? _a : () => null;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/hostname.js
var require_hostname = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hostname = undefined;
  var os = __importStar(__require("os"));
  var hostname = function hostname() {
    return os.hostname();
  };
  exports.hostname = hostname;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/inspect.js
var require_inspect = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.inspect = undefined;
  var util = __importStar(__require("util"));
  var inspect = (value, options = {}) => util.inspect(value, options);
  exports.inspect = inspect;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/kill.js
var require_kill = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.kill = undefined;
  var os_1 = __importDefault(__require("os"));
  var process_1 = __importDefault(__require("process"));
  var kill = function(pid, signo) {
    if (pid < 0 && os_1.default.platform() === "win32") {
      throw new TypeError("Invalid pid");
    }
    process_1.default.kill(pid, signo);
  };
  exports.kill = kill;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/link.js
var require_link = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.link = undefined;
  var fs2 = __importStar(__require("fs/promises"));
  exports.link = fs2.link;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/linkSync.js
var require_linkSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.linkSync = undefined;
  var fs2 = __importStar(__require("fs"));
  exports.linkSync = fs2.linkSync;
});

// node_modules/@deno/shim-deno/dist/deno/internal/Listener.js
var require_Listener = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _Listener_listener;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Listener = undefined;
  var close_js_1 = require_close();
  var errors = __importStar(require_errors3());

  class Listener {
    constructor(rid, addr, listener) {
      this.rid = rid;
      this.addr = addr;
      _Listener_listener.set(this, undefined);
      __classPrivateFieldSet(this, _Listener_listener, listener, "f");
    }
    [(_Listener_listener = new WeakMap, Symbol.dispose)]() {
      this.close();
    }
    async accept() {
      if (!__classPrivateFieldGet(this, _Listener_listener, "f")) {
        throw new errors.BadResource("Listener not initialised");
      }
      const result = await __classPrivateFieldGet(this, _Listener_listener, "f").next();
      if (result.done) {
        throw new errors.BadResource("Server not listening");
      }
      return result.value;
    }
    async next() {
      let conn;
      try {
        conn = await this.accept();
      } catch (error) {
        if (error instanceof errors.BadResource) {
          return { value: undefined, done: true };
        }
        throw error;
      }
      return { value: conn, done: false };
    }
    return(value) {
      this.close();
      return Promise.resolve({ value, done: true });
    }
    close() {
      (0, close_js_1.close)(this.rid);
    }
    ref() {
      throw new Error("Not implemented");
    }
    unref() {
      throw new Error("Not implemented");
    }
    [Symbol.asyncIterator]() {
      return this;
    }
  }
  exports.Listener = Listener;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/listen.js
var require_listen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.listen = undefined;
  var net_1 = __require("net");
  var Conn_js_1 = require_Conn();
  var Listener_js_1 = require_Listener();
  async function* _listen(server, waitFor) {
    await waitFor;
    while (server.listening) {
      yield new Promise((resolve) => server.once("connection", (socket) => {
        socket.on("error", (err) => console.error(err));
        const rid = socket._handle.fd;
        const localAddr = {
          hostname: socket.localAddress,
          port: socket.localPort,
          transport: "tcp"
        };
        const remoteAddr = {
          hostname: socket.remoteAddress,
          port: socket.remotePort,
          transport: "tcp"
        };
        resolve(new Conn_js_1.Conn(rid, localAddr, remoteAddr));
      }));
    }
  }
  var listen = function listen(options) {
    if (options.transport === "unix") {
      throw new Error("Unstable UnixListenOptions is not implemented");
    }
    const { port, hostname = "0.0.0.0", transport = "tcp" } = options;
    if (transport !== "tcp") {
      throw new Error("Deno.listen is only implemented for transport: tcp");
    }
    const server = (0, net_1.createServer)();
    const waitFor = new Promise((resolve) => server.listen(port, hostname, resolve));
    const listener = new Listener_js_1.Listener(server._handle.fd, {
      hostname,
      port,
      transport: "tcp"
    }, _listen(server, waitFor));
    return listener;
  };
  exports.listen = listen;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/readTextFileSync.js
var require_readTextFileSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readTextFileSync = undefined;
  var fs2 = __importStar(__require("fs"));
  var errorMap_js_1 = __importDefault(require_errorMap());
  var readTextFileSync = function(path2) {
    try {
      return fs2.readFileSync(path2, "utf8");
    } catch (e) {
      throw (0, errorMap_js_1.default)(e);
    }
  };
  exports.readTextFileSync = readTextFileSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/listenTls.js
var require_listenTls = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.listenTls = undefined;
  var tls_1 = __require("tls");
  var Conn_js_1 = require_Conn();
  var Listener_js_1 = require_Listener();
  var readTextFileSync_js_1 = require_readTextFileSync();
  async function* _listen(server, waitFor) {
    await waitFor;
    while (server.listening) {
      yield new Promise((resolve) => server.once("secureConnection", (socket) => {
        socket.on("error", (err) => console.error(err));
        const rid = socket._handle.fd;
        const localAddr = {
          hostname: socket.localAddress,
          port: socket.localPort,
          transport: "tcp"
        };
        const remoteAddr = {
          hostname: socket.remoteAddress,
          port: socket.remotePort,
          transport: "tcp"
        };
        resolve(new Conn_js_1.TlsConn(rid, localAddr, remoteAddr));
      }));
    }
  }
  var listenTls = function listen({ port, hostname = "0.0.0.0", transport = "tcp", certFile, keyFile }) {
    if (transport !== "tcp") {
      throw new Error("Deno.listen is only implemented for transport: tcp");
    }
    const [cert, key] = [certFile, keyFile].map((f) => f == null ? undefined : (0, readTextFileSync_js_1.readTextFileSync)(f));
    const server = (0, tls_1.createServer)({ cert, key });
    const waitFor = new Promise((resolve) => server.listen(port, hostname, resolve));
    const listener = new Listener_js_1.Listener(server._handle.fd, {
      hostname,
      port,
      transport: "tcp"
    }, _listen(server, waitFor));
    return listener;
  };
  exports.listenTls = listenTls;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/loadavg.js
var require_loadavg = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.loadavg = undefined;
  var os = __importStar(__require("os"));
  var loadavg = function loadavg() {
    return os.loadavg();
  };
  exports.loadavg = loadavg;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/lstat.js
var require_lstat = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lstat = undefined;
  var fs2 = __importStar(__require("fs/promises"));
  var stat_js_1 = require_stat();
  var errorMap_js_1 = __importDefault(require_errorMap());
  var lstat = async (path2) => {
    try {
      return (0, stat_js_1.denoifyFileInfo)(await fs2.lstat(path2));
    } catch (e) {
      throw (0, errorMap_js_1.default)(e);
    }
  };
  exports.lstat = lstat;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/lstatSync.js
var require_lstatSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lstatSync = undefined;
  var fs2 = __importStar(__require("fs"));
  var stat_js_1 = require_stat();
  var errorMap_js_1 = __importDefault(require_errorMap());
  var lstatSync = (path2) => {
    try {
      return (0, stat_js_1.denoifyFileInfo)(fs2.lstatSync(path2));
    } catch (err) {
      throw (0, errorMap_js_1.default)(err);
    }
  };
  exports.lstatSync = lstatSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/makeTempDir.js
var require_makeTempDir = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.makeTempDir = undefined;
  var promises_1 = __require("fs/promises");
  var path_1 = __require("path");
  var os_1 = __require("os");
  var makeTempDir = function makeTempDir({ prefix = "" } = {}) {
    return (0, promises_1.mkdtemp)((0, path_1.join)((0, os_1.tmpdir)(), prefix || "/"));
  };
  exports.makeTempDir = makeTempDir;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/makeTempDirSync.js
var require_makeTempDirSync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.makeTempDirSync = undefined;
  var fs_1 = __require("fs");
  var path_1 = __require("path");
  var os_1 = __require("os");
  var makeTempDirSync = function makeTempDirSync({ prefix = "" } = {}) {
    return (0, fs_1.mkdtempSync)((0, path_1.join)((0, os_1.tmpdir)(), prefix || "/"));
  };
  exports.makeTempDirSync = makeTempDirSync;
});

// node_modules/@deno/shim-deno/dist/deno/internal/random_id.js
var require_random_id = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomId = undefined;
  var randomId = () => {
    const n = (Math.random() * 1048575 * 1e6).toString(16);
    return "" + n.slice(0, 6);
  };
  exports.randomId = randomId;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/writeTextFile.js
var require_writeTextFile = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.writeTextFile = undefined;
  var fs2 = __importStar(__require("fs/promises"));
  var errorMap_js_1 = __importDefault(require_errorMap());
  var fs_flags_js_1 = require_fs_flags();
  var writeTextFile = async function writeTextFile(path2, data, { append = false, create = true, createNew = false, mode, signal } = {}) {
    const truncate = create && !append;
    const flag = (0, fs_flags_js_1.getFsFlag)({
      append,
      create,
      createNew,
      truncate,
      write: true
    });
    try {
      await fs2.writeFile(path2, data, { flag, mode, signal });
      if (mode !== undefined)
        await fs2.chmod(path2, mode);
    } catch (error) {
      throw (0, errorMap_js_1.default)(error);
    }
  };
  exports.writeTextFile = writeTextFile;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/makeTempFile.js
var require_makeTempFile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.makeTempFile = undefined;
  var os_1 = __require("os");
  var path_1 = __require("path");
  var random_id_js_1 = require_random_id();
  var writeTextFile_js_1 = require_writeTextFile();
  var makeTempFile = async function makeTempFile({ prefix = "" } = {}) {
    const name = (0, path_1.join)((0, os_1.tmpdir)(), prefix, (0, random_id_js_1.randomId)());
    await (0, writeTextFile_js_1.writeTextFile)(name, "");
    return name;
  };
  exports.makeTempFile = makeTempFile;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/writeTextFileSync.js
var require_writeTextFileSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.writeTextFileSync = undefined;
  var fs2 = __importStar(__require("fs"));
  var errorMap_js_1 = __importDefault(require_errorMap());
  var writeTextFileSync = (path2, data, { append = false, create = true, mode } = {}) => {
    const flag = create ? append ? "a" : "w" : "r+";
    try {
      fs2.writeFileSync(path2, data, { flag, mode });
      if (mode !== undefined)
        fs2.chmodSync(path2, mode);
    } catch (error) {
      throw (0, errorMap_js_1.default)(error);
    }
  };
  exports.writeTextFileSync = writeTextFileSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/makeTempFileSync.js
var require_makeTempFileSync = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.makeTempFileSync = undefined;
  var os_1 = __require("os");
  var path_1 = __require("path");
  var random_id_js_1 = require_random_id();
  var writeTextFileSync_js_1 = require_writeTextFileSync();
  var makeTempFileSync = function makeTempFileSync({ prefix = "" } = {}) {
    const name = (0, path_1.join)((0, os_1.tmpdir)(), prefix, (0, random_id_js_1.randomId)());
    (0, writeTextFileSync_js_1.writeTextFileSync)(name, "");
    return name;
  };
  exports.makeTempFileSync = makeTempFileSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/memoryUsage.js
var require_memoryUsage = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.memoryUsage = undefined;
  exports.memoryUsage = process.memoryUsage;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/mkdir.js
var require_mkdir = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mkdir = undefined;
  var promises_1 = __require("fs/promises");
  var errorMap_js_1 = __importDefault(require_errorMap());
  var variables_js_1 = require_variables();
  var mkdir = async function mkdir(path2, options) {
    try {
      await (0, promises_1.mkdir)(path2, options);
    } catch (error) {
      if ((error === null || error === undefined ? undefined : error.code) === "EEXIST") {
        throw new variables_js_1.errors.AlreadyExists(`File exists (os error 17), mkdir '${path2}'`);
      }
      throw (0, errorMap_js_1.default)(error);
    }
  };
  exports.mkdir = mkdir;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/mkdirSync.js
var require_mkdirSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mkdirSync = undefined;
  var fs2 = __importStar(__require("fs"));
  var errorMap_js_1 = __importDefault(require_errorMap());
  var variables_js_1 = require_variables();
  var mkdirSync = (path2, options) => {
    try {
      fs2.mkdirSync(path2, options);
    } catch (error) {
      if ((error === null || error === undefined ? undefined : error.code) === "EEXIST") {
        throw new variables_js_1.errors.AlreadyExists(`File exists (os error 17), mkdir '${path2}'`);
      }
      throw (0, errorMap_js_1.default)(error);
    }
  };
  exports.mkdirSync = mkdirSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/osRelease.js
var require_osRelease = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.osRelease = undefined;
  var os_1 = __require("os");
  var osRelease = function osRelease() {
    return (0, os_1.release)();
  };
  exports.osRelease = osRelease;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/osUptime.js
var require_osUptime = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.osUptime = undefined;
  var os_1 = __require("os");
  var osUptime = function osUptime() {
    return (0, os_1.uptime)();
  };
  exports.osUptime = osUptime;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/readDir.js
var require_readDir = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readDir = undefined;
  var promises_1 = __require("fs/promises");
  var errorMap_js_1 = __importDefault(require_errorMap());
  var readDir = async function* readDir(path2) {
    try {
      for await (const e of await (0, promises_1.opendir)(String(path2))) {
        const ent = {
          name: e.name,
          isFile: e.isFile(),
          isDirectory: e.isDirectory(),
          isSymlink: e.isSymbolicLink()
        };
        yield ent;
      }
    } catch (e) {
      throw (0, errorMap_js_1.default)(e);
    }
  };
  exports.readDir = readDir;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/readDirSync.js
var require_readDirSync = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readDirSync = undefined;
  var fs_1 = __require("fs");
  var errorMap_js_1 = __importDefault(require_errorMap());
  var readDirSync = function* readDir(path2) {
    try {
      for (const e of (0, fs_1.readdirSync)(String(path2), { withFileTypes: true })) {
        const ent = {
          name: e.name,
          isFile: e.isFile(),
          isDirectory: e.isDirectory(),
          isSymlink: e.isSymbolicLink()
        };
        yield ent;
      }
    } catch (e) {
      throw (0, errorMap_js_1.default)(e);
    }
  };
  exports.readDirSync = readDirSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/readFile.js
var require_readFile = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readFile = undefined;
  var promises_1 = __require("fs/promises");
  var errorMap_js_1 = __importDefault(require_errorMap());
  var readFile = async function readFile(path2, { signal } = {}) {
    try {
      const buf = await (0, promises_1.readFile)(path2, { signal });
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
    } catch (e) {
      throw (0, errorMap_js_1.default)(e);
    }
  };
  exports.readFile = readFile;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/readFileSync.js
var require_readFileSync = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readFileSync = undefined;
  var fs_1 = __require("fs");
  var errorMap_js_1 = __importDefault(require_errorMap());
  var readFileSync = function readFileSync(path2) {
    try {
      const buf = (0, fs_1.readFileSync)(path2);
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
    } catch (e) {
      throw (0, errorMap_js_1.default)(e);
    }
  };
  exports.readFileSync = readFileSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/readLink.js
var require_readLink = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readLink = undefined;
  var fs2 = __importStar(__require("fs/promises"));
  exports.readLink = fs2.readlink;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/readLinkSync.js
var require_readLinkSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readLinkSync = undefined;
  var fs2 = __importStar(__require("fs"));
  exports.readLinkSync = fs2.readlinkSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/realPath.js
var require_realPath = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.realPath = undefined;
  var fs2 = __importStar(__require("fs/promises"));
  exports.realPath = fs2.realpath;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/realPathSync.js
var require_realPathSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.realPathSync = undefined;
  var fs2 = __importStar(__require("fs"));
  exports.realPathSync = fs2.realpathSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/remove.js
var require_remove2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.remove = undefined;
  var promises_1 = __require("fs/promises");
  var remove = async function remove(path2, options = {}) {
    const innerOptions = options.recursive ? { recursive: true, force: true } : {};
    try {
      return await (0, promises_1.rm)(path2, innerOptions);
    } catch (err) {
      if (err.code === "ERR_FS_EISDIR") {
        return await (0, promises_1.rmdir)(path2, innerOptions);
      } else {
        throw err;
      }
    }
  };
  exports.remove = remove;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/removeSignalListener.js
var require_removeSignalListener = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.removeSignalListener = undefined;
  var process_1 = __importDefault(__require("process"));
  var removeSignalListener = (signal, handler) => {
    process_1.default.removeListener(signal, handler);
  };
  exports.removeSignalListener = removeSignalListener;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/removeSync.js
var require_removeSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.removeSync = undefined;
  var fs2 = __importStar(__require("fs"));
  var removeSync = (path2, options = {}) => {
    const innerOptions = options.recursive ? { recursive: true, force: true } : {};
    try {
      fs2.rmSync(path2, innerOptions);
    } catch (err) {
      if (err.code === "ERR_FS_EISDIR") {
        fs2.rmdirSync(path2, innerOptions);
      } else {
        throw err;
      }
    }
  };
  exports.removeSync = removeSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/rename.js
var require_rename = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.rename = undefined;
  var promises_1 = __require("fs/promises");
  var rename = function rename(oldpath, newpath) {
    return (0, promises_1.rename)(oldpath, newpath);
  };
  exports.rename = rename;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/renameSync.js
var require_renameSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.renameSync = undefined;
  var fs2 = __importStar(__require("fs"));
  exports.renameSync = fs2.renameSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/resolveDns.js
var require_resolveDns = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveDns = undefined;
  var dns_1 = __importDefault(__require("dns"));
  var resolveDns = function resolveDns(query, recordType, options) {
    if (options) {
      throw Error(`resolveDns option not implemnted yet`);
    }
    switch (recordType) {
      case "A":
      case "AAAA":
      case "CNAME":
      case "NS":
      case "PTR":
        return new Promise((resolve, reject) => {
          dns_1.default.resolve(query, recordType, (err, addresses) => {
            if (err) {
              reject(err);
            } else {
              resolve(addresses);
            }
          });
        });
      case "ANAME":
      case "CAA":
      case "MX":
      case "NAPTR":
      case "SOA":
      case "SRV":
      case "TXT":
      default:
        throw Error(`resolveDns type ${recordType} not implemnted yet`);
    }
  };
  exports.resolveDns = resolveDns;
});

// node_modules/@deno/shim-deno/dist/deno/internal/streams.js
var require_streams = __commonJS((exports) => {
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _BufferStreamReader_instances;
  var _BufferStreamReader_stream;
  var _BufferStreamReader_error;
  var _BufferStreamReader_ended;
  var _BufferStreamReader_pendingActions;
  var _BufferStreamReader_runPendingActions;
  var _StreamWriter_stream;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StreamWriter = exports.BufferStreamReader = undefined;

  class BufferStreamReader {
    constructor(stream) {
      _BufferStreamReader_instances.add(this);
      _BufferStreamReader_stream.set(this, undefined);
      _BufferStreamReader_error.set(this, undefined);
      _BufferStreamReader_ended.set(this, false);
      _BufferStreamReader_pendingActions.set(this, []);
      __classPrivateFieldSet(this, _BufferStreamReader_stream, stream, "f");
      __classPrivateFieldGet(this, _BufferStreamReader_stream, "f").pause();
      __classPrivateFieldGet(this, _BufferStreamReader_stream, "f").on("error", (error) => {
        __classPrivateFieldSet(this, _BufferStreamReader_error, error, "f");
        __classPrivateFieldGet(this, _BufferStreamReader_instances, "m", _BufferStreamReader_runPendingActions).call(this);
      });
      __classPrivateFieldGet(this, _BufferStreamReader_stream, "f").on("readable", () => {
        __classPrivateFieldGet(this, _BufferStreamReader_instances, "m", _BufferStreamReader_runPendingActions).call(this);
      });
      __classPrivateFieldGet(this, _BufferStreamReader_stream, "f").on("end", () => {
        __classPrivateFieldSet(this, _BufferStreamReader_ended, true, "f");
        __classPrivateFieldGet(this, _BufferStreamReader_instances, "m", _BufferStreamReader_runPendingActions).call(this);
      });
    }
    readAll() {
      return new Promise((resolve, reject) => {
        const chunks = [];
        const action = () => {
          if (__classPrivateFieldGet(this, _BufferStreamReader_error, "f")) {
            reject(__classPrivateFieldGet(this, _BufferStreamReader_error, "f"));
            return;
          }
          const buffer = __classPrivateFieldGet(this, _BufferStreamReader_stream, "f").read();
          if (buffer != null) {
            chunks.push(buffer);
            __classPrivateFieldGet(this, _BufferStreamReader_pendingActions, "f").push(action);
          } else if (__classPrivateFieldGet(this, _BufferStreamReader_ended, "f")) {
            const result = Buffer.concat(chunks);
            resolve(result);
          } else {
            __classPrivateFieldGet(this, _BufferStreamReader_pendingActions, "f").push(action);
          }
        };
        action();
      });
    }
    read(p) {
      return new Promise((resolve, reject) => {
        const action = () => {
          if (__classPrivateFieldGet(this, _BufferStreamReader_error, "f")) {
            reject(__classPrivateFieldGet(this, _BufferStreamReader_error, "f"));
            return;
          }
          const readBuffer = __classPrivateFieldGet(this, _BufferStreamReader_stream, "f").read(p.byteLength);
          if (readBuffer && readBuffer.byteLength > 0) {
            readBuffer.copy(p, 0, 0, readBuffer.byteLength);
            resolve(readBuffer.byteLength);
            return;
          }
          if (__classPrivateFieldGet(this, _BufferStreamReader_ended, "f")) {
            resolve(null);
          } else {
            __classPrivateFieldGet(this, _BufferStreamReader_pendingActions, "f").push(action);
          }
        };
        action();
      });
    }
  }
  exports.BufferStreamReader = BufferStreamReader;
  _BufferStreamReader_stream = new WeakMap, _BufferStreamReader_error = new WeakMap, _BufferStreamReader_ended = new WeakMap, _BufferStreamReader_pendingActions = new WeakMap, _BufferStreamReader_instances = new WeakSet, _BufferStreamReader_runPendingActions = function _BufferStreamReader_runPendingActions() {
    const errors = [];
    for (const action of __classPrivateFieldGet(this, _BufferStreamReader_pendingActions, "f").splice(0)) {
      try {
        action();
      } catch (err) {
        errors.push(err);
      }
    }
    if (errors.length > 0) {
      throw errors.length > 1 ? new globalThis.AggregateError(errors) : errors[0];
    }
  };

  class StreamWriter {
    constructor(stream) {
      _StreamWriter_stream.set(this, undefined);
      __classPrivateFieldSet(this, _StreamWriter_stream, stream, "f");
    }
    write(p) {
      return new Promise((resolve, reject) => {
        __classPrivateFieldGet(this, _StreamWriter_stream, "f").write(p, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve(p.byteLength);
          }
        });
      });
    }
  }
  exports.StreamWriter = StreamWriter;
  _StreamWriter_stream = new WeakMap;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/run.js
var require_run = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
    if (kind === "m")
      throw new TypeError("Private method is not writable");
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
    if (kind === "a" && !f)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  var _Process_process;
  var _Process_stderr;
  var _Process_stdout;
  var _Process_stdin;
  var _Process_status;
  var _Process_receivedStatus;
  var _ProcessReadStream_stream;
  var _ProcessReadStream_bufferStreamReader;
  var _ProcessReadStream_closed;
  var _ProcessWriteStream_stream;
  var _ProcessWriteStream_streamWriter;
  var _ProcessWriteStream_closed;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Process = exports.run = undefined;
  var child_process_1 = __importDefault(__require("child_process"));
  var fs_1 = __importDefault(__require("fs"));
  var os_1 = __importDefault(__require("os"));
  var url_1 = __importDefault(__require("url"));
  var events_1 = __require("events");
  var which_1 = __importDefault(require_lib2());
  var streams_js_1 = require_streams();
  var errors = __importStar(require_errors3());
  var run = function run(options) {
    const [cmd, ...args] = options.cmd;
    if (options.cwd && !fs_1.default.existsSync(options.cwd)) {
      throw new Error("The directory name is invalid.");
    }
    const commandName = getCmd(cmd);
    if (!which_1.default.sync(commandName, { nothrow: true })) {
      throw new errors.NotFound("The system cannot find the file specified.");
    }
    const process2 = child_process_1.default.spawn(commandName, args, {
      cwd: options.cwd,
      env: getEnv(options),
      uid: options.uid,
      gid: options.gid,
      shell: false,
      stdio: [
        getStdio(options.stdin, "in"),
        getStdio(options.stdout, "out"),
        getStdio(options.stderr, "out")
      ]
    });
    return new Process(process2);
  };
  exports.run = run;
  function getStdio(value, kind) {
    if (value === "inherit" || value == null) {
      return "inherit";
    } else if (value === "piped") {
      return "pipe";
    } else if (value === "null") {
      return "ignore";
    } else if (typeof value === "number") {
      switch (kind) {
        case "in":
          return fs_1.default.createReadStream(null, { fd: value });
        case "out":
          return fs_1.default.createWriteStream(null, { fd: value });
        default: {
          const _assertNever = kind;
          throw new Error("Unreachable.");
        }
      }
    } else {
      const _assertNever = value;
      throw new Error("Unknown value.");
    }
  }
  function getCmd(firstArg) {
    if (firstArg instanceof URL) {
      return url_1.default.fileURLToPath(firstArg);
    } else {
      return firstArg;
    }
  }
  function getEnv(options) {
    var _a;
    const env = (_a = options.env) !== null && _a !== undefined ? _a : {};
    for (const name in process.env) {
      if (!Object.prototype.hasOwnProperty.call(env, name)) {
        if (options.clearEnv) {
          if (os_1.default.platform() === "win32") {
            env[name] = "";
          } else {
            delete env[name];
          }
        } else {
          env[name] = process.env[name];
        }
      }
    }
    return env;
  }

  class Process {
    constructor(process2) {
      var _a, _b, _c;
      _Process_process.set(this, undefined);
      _Process_stderr.set(this, undefined);
      _Process_stdout.set(this, undefined);
      _Process_stdin.set(this, undefined);
      _Process_status.set(this, undefined);
      _Process_receivedStatus.set(this, false);
      __classPrivateFieldSet(this, _Process_process, process2, "f");
      __classPrivateFieldSet(this, _Process_stdout, (_a = ProcessReadStream.fromNullable(__classPrivateFieldGet(this, _Process_process, "f").stdout)) !== null && _a !== undefined ? _a : null, "f");
      __classPrivateFieldSet(this, _Process_stderr, (_b = ProcessReadStream.fromNullable(__classPrivateFieldGet(this, _Process_process, "f").stderr)) !== null && _b !== undefined ? _b : null, "f");
      __classPrivateFieldSet(this, _Process_stdin, (_c = ProcessWriteStream.fromNullable(__classPrivateFieldGet(this, _Process_process, "f").stdin)) !== null && _c !== undefined ? _c : null, "f");
      __classPrivateFieldSet(this, _Process_status, (0, events_1.once)(process2, "exit"), "f");
    }
    get rid() {
      return NaN;
    }
    get pid() {
      return __classPrivateFieldGet(this, _Process_process, "f").pid;
    }
    get stdin() {
      return __classPrivateFieldGet(this, _Process_stdin, "f");
    }
    get stdout() {
      return __classPrivateFieldGet(this, _Process_stdout, "f");
    }
    get stderr() {
      return __classPrivateFieldGet(this, _Process_stderr, "f");
    }
    async status() {
      const [receivedCode, signalName] = await __classPrivateFieldGet(this, _Process_status, "f");
      const signal = signalName ? os_1.default.constants.signals[signalName] : receivedCode > 128 ? receivedCode - 128 : undefined;
      const code = receivedCode != null ? receivedCode : signal != null ? 128 + signal : undefined;
      const success = code === 0;
      __classPrivateFieldSet(this, _Process_receivedStatus, true, "f");
      return { code, signal, success };
    }
    async output() {
      if (!__classPrivateFieldGet(this, _Process_stdout, "f")) {
        throw new TypeError("stdout was not piped");
      }
      const result = await __classPrivateFieldGet(this, _Process_stdout, "f").readAll();
      __classPrivateFieldGet(this, _Process_stdout, "f").close();
      return result;
    }
    async stderrOutput() {
      if (!__classPrivateFieldGet(this, _Process_stderr, "f")) {
        throw new TypeError("stderr was not piped");
      }
      const result = await __classPrivateFieldGet(this, _Process_stderr, "f").readAll();
      __classPrivateFieldGet(this, _Process_stderr, "f").close();
      return result;
    }
    close() {
      __classPrivateFieldGet(this, _Process_process, "f").unref();
      __classPrivateFieldGet(this, _Process_process, "f").kill();
    }
    kill(signo = "SIGTERM") {
      if (__classPrivateFieldGet(this, _Process_receivedStatus, "f")) {
        throw new errors.NotFound("entity not found");
      }
      __classPrivateFieldGet(this, _Process_process, "f").kill(signo);
    }
  }
  exports.Process = Process;
  _Process_process = new WeakMap, _Process_stderr = new WeakMap, _Process_stdout = new WeakMap, _Process_stdin = new WeakMap, _Process_status = new WeakMap, _Process_receivedStatus = new WeakMap;

  class ProcessReadStream {
    constructor(stream) {
      _ProcessReadStream_stream.set(this, undefined);
      _ProcessReadStream_bufferStreamReader.set(this, undefined);
      _ProcessReadStream_closed.set(this, false);
      __classPrivateFieldSet(this, _ProcessReadStream_stream, stream, "f");
      __classPrivateFieldSet(this, _ProcessReadStream_bufferStreamReader, new streams_js_1.BufferStreamReader(stream), "f");
    }
    static fromNullable(stream) {
      return stream ? new ProcessReadStream(stream) : undefined;
    }
    readAll() {
      if (__classPrivateFieldGet(this, _ProcessReadStream_closed, "f")) {
        return Promise.resolve(new Uint8Array(0));
      } else {
        return __classPrivateFieldGet(this, _ProcessReadStream_bufferStreamReader, "f").readAll();
      }
    }
    read(p) {
      if (__classPrivateFieldGet(this, _ProcessReadStream_closed, "f")) {
        return Promise.resolve(null);
      } else {
        return __classPrivateFieldGet(this, _ProcessReadStream_bufferStreamReader, "f").read(p);
      }
    }
    close() {
      __classPrivateFieldSet(this, _ProcessReadStream_closed, true, "f");
      __classPrivateFieldGet(this, _ProcessReadStream_stream, "f").destroy();
    }
    get readable() {
      throw new Error("Not implemented.");
    }
    get writable() {
      throw new Error("Not implemented.");
    }
  }
  _ProcessReadStream_stream = new WeakMap, _ProcessReadStream_bufferStreamReader = new WeakMap, _ProcessReadStream_closed = new WeakMap;

  class ProcessWriteStream {
    constructor(stream) {
      _ProcessWriteStream_stream.set(this, undefined);
      _ProcessWriteStream_streamWriter.set(this, undefined);
      _ProcessWriteStream_closed.set(this, false);
      __classPrivateFieldSet(this, _ProcessWriteStream_stream, stream, "f");
      __classPrivateFieldSet(this, _ProcessWriteStream_streamWriter, new streams_js_1.StreamWriter(stream), "f");
    }
    static fromNullable(stream) {
      return stream ? new ProcessWriteStream(stream) : undefined;
    }
    write(p) {
      if (__classPrivateFieldGet(this, _ProcessWriteStream_closed, "f")) {
        return Promise.resolve(0);
      } else {
        return __classPrivateFieldGet(this, _ProcessWriteStream_streamWriter, "f").write(p);
      }
    }
    close() {
      __classPrivateFieldSet(this, _ProcessWriteStream_closed, true, "f");
      __classPrivateFieldGet(this, _ProcessWriteStream_stream, "f").end();
    }
  }
  _ProcessWriteStream_stream = new WeakMap, _ProcessWriteStream_streamWriter = new WeakMap, _ProcessWriteStream_closed = new WeakMap;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/shutdown.js
var require_shutdown = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shutdown = undefined;
  var net_1 = __require("net");
  var shutdown = async function shutdown(rid) {
    await new Promise((resolve) => new net_1.Socket({ fd: rid }).end(resolve));
  };
  exports.shutdown = shutdown;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/statSync.js
var require_statSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.statSync = undefined;
  var fs2 = __importStar(__require("fs"));
  var stat_js_1 = require_stat();
  var errorMap_js_1 = __importDefault(require_errorMap());
  var statSync = (path2) => {
    try {
      return (0, stat_js_1.denoifyFileInfo)(fs2.statSync(path2));
    } catch (err) {
      throw (0, errorMap_js_1.default)(err);
    }
  };
  exports.statSync = statSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/symlink.js
var require_symlink = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.symlink = undefined;
  var fs2 = __importStar(__require("fs/promises"));
  var symlink = async (oldpath, newpath, options) => await fs2.symlink(oldpath, newpath, options === null || options === undefined ? undefined : options.type);
  exports.symlink = symlink;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/symlinkSync.js
var require_symlinkSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.symlinkSync = undefined;
  var fs2 = __importStar(__require("fs"));
  var symlinkSync = (oldpath, newpath, options) => fs2.symlinkSync(oldpath, newpath, options === null || options === undefined ? undefined : options.type);
  exports.symlinkSync = symlinkSync;
});

// node_modules/@deno/shim-deno-test/dist/definitions.js
var require_definitions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.testDefinitions = undefined;
  exports.testDefinitions = [];
});

// node_modules/@deno/shim-deno-test/dist/test.js
var require_test = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.test = undefined;
  var definitions_js_1 = require_definitions();
  exports.test = Object.assign(function test() {
    handleDefinition(arguments);
  }, {
    ignore() {
      handleDefinition(arguments, { ignore: true });
    },
    only() {
      handleDefinition(arguments, { only: true });
    }
  });
  function handleDefinition(args, additional) {
    var _a, _b;
    let testDef;
    const firstArg = args[0];
    const secondArg = args[1];
    const thirdArg = args[2];
    if (typeof firstArg === "string") {
      if (typeof secondArg === "object") {
        if (typeof thirdArg === "function") {
          if (secondArg.fn != null) {
            throw new TypeError("Unexpected 'fn' field in options, test function is already provided as the third argument.");
          }
        }
        if (secondArg.name != null) {
          throw new TypeError("Unexpected 'name' field in options, test name is already provided as the first argument.");
        }
        testDef = { name: firstArg, fn: thirdArg, ...secondArg };
      } else {
        testDef = { name: firstArg, fn: secondArg };
      }
    } else if (firstArg instanceof Function) {
      if (firstArg.name.length === 0) {
        throw new TypeError("The test function must have a name");
      }
      testDef = { fn: firstArg, name: firstArg.name };
      if (secondArg != null) {
        throw new TypeError("Unexpected second argument to Deno.test()");
      }
    } else if (typeof firstArg === "object") {
      testDef = { ...firstArg };
      if (typeof secondArg === "function") {
        testDef.fn = secondArg;
        if (firstArg.fn != null) {
          throw new TypeError("Unexpected 'fn' field in options, test function is already provided as the second argument.");
        }
        if (testDef.name == null) {
          if (secondArg.name.length === 0) {
            throw new TypeError("The test function must have a name");
          }
          testDef.name = secondArg.name;
        }
      } else {
        if (typeof firstArg.fn !== "function") {
          throw new TypeError("Expected 'fn' field in the first argument to be a test function.");
        }
      }
    } else {
      throw new TypeError("Unknown test overload");
    }
    if (typeof testDef.fn !== "function") {
      throw new TypeError("Missing test function");
    }
    if (((_b = (_a = testDef.name) === null || _a === undefined ? undefined : _a.length) !== null && _b !== undefined ? _b : 0) === 0) {
      throw new TypeError("The test name can't be empty");
    }
    if (additional === null || additional === undefined ? undefined : additional.ignore) {
      testDef.ignore = true;
    }
    if (additional === null || additional === undefined ? undefined : additional.only) {
      testDef.only = true;
    }
    definitions_js_1.testDefinitions.push(testDef);
  }
});

// node_modules/@deno/shim-deno-test/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.testDefinitions = exports.Deno = undefined;
  exports.Deno = require_test();
  __exportStar(require_test(), exports);
  var definitions_js_1 = require_definitions();
  Object.defineProperty(exports, "testDefinitions", { enumerable: true, get: function() {
    return definitions_js_1.testDefinitions;
  } });
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/test.js
var require_test2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.test = undefined;
  var shim_deno_test_1 = require_dist2();
  Object.defineProperty(exports, "test", { enumerable: true, get: function() {
    return shim_deno_test_1.test;
  } });
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/truncate.js
var require_truncate = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.truncate = undefined;
  var fs2 = __importStar(__require("fs/promises"));
  var errorMap_js_1 = __importDefault(require_errorMap());
  var variables_js_1 = require_variables();
  var truncate = async (name, len) => {
    try {
      return await fs2.truncate(name, len);
    } catch (error) {
      if ((error === null || error === undefined ? undefined : error.code) === "ENOENT") {
        throw new variables_js_1.errors.NotFound(`No such file or directory (os error 2), truncate '${name}'`);
      }
      throw (0, errorMap_js_1.default)(error);
    }
  };
  exports.truncate = truncate;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/truncateSync.js
var require_truncateSync = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.truncateSync = undefined;
  var fs2 = __importStar(__require("fs"));
  var errorMap_js_1 = __importDefault(require_errorMap());
  var variables_js_1 = require_variables();
  var truncateSync = (name, len) => {
    try {
      return fs2.truncateSync(name, len);
    } catch (error) {
      if ((error === null || error === undefined ? undefined : error.code) === "ENOENT") {
        throw new variables_js_1.errors.NotFound(`No such file or directory (os error 2), truncate '${name}'`);
      }
      throw (0, errorMap_js_1.default)(error);
    }
  };
  exports.truncateSync = truncateSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/uid.js
var require_uid = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  var _a;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uid = undefined;
  var process_1 = __importDefault(__require("process"));
  exports.uid = (_a = process_1.default.getuid) !== null && _a !== undefined ? _a : () => null;
});

// node_modules/@deno/shim-deno/dist/deno/internal/iterutil.js
var require_iterutil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = exports.filterAsync = exports.mapAsync = exports.map = undefined;
  function* map(iter, f) {
    for (const i of iter) {
      yield f(i);
    }
  }
  exports.map = map;
  async function* mapAsync(iter, f) {
    for await (const i of iter) {
      yield f(i);
    }
  }
  exports.mapAsync = mapAsync;
  async function* filterAsync(iter, filter) {
    for await (const i of iter) {
      if (filter(i)) {
        yield i;
      }
    }
  }
  exports.filterAsync = filterAsync;
  async function* merge(iterables) {
    const racers = new Map(map(map(iterables, (iter) => iter[Symbol.asyncIterator]()), (iter) => [iter, iter.next()]));
    while (racers.size > 0) {
      const winner = await Promise.race(map(racers.entries(), ([iter, prom]) => prom.then((result) => ({ result, iter }))));
      if (winner.result.done) {
        racers.delete(winner.iter);
      } else {
        yield await winner.result.value;
        racers.set(winner.iter, winner.iter.next());
      }
    }
  }
  exports.merge = merge;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/watchFs.js
var require_watchFs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.watchFs = undefined;
  var promises_1 = __require("fs/promises");
  var path_1 = __require("path");
  var iterutil_js_1 = require_iterutil();
  var watchFs = function watchFs(paths, options = { recursive: true }) {
    paths = Array.isArray(paths) ? paths : [paths];
    const ac = new AbortController;
    const { signal } = ac;
    const rid = -1;
    const masterWatcher = (0, iterutil_js_1.merge)(paths.map((path2) => (0, iterutil_js_1.mapAsync)((0, iterutil_js_1.filterAsync)((0, promises_1.watch)(path2, { recursive: options === null || options === undefined ? undefined : options.recursive, signal }), (info) => info.filename != null), (info) => ({
      kind: "modify",
      paths: [(0, path_1.resolve)(path2, info.filename)]
    }))));
    function close() {
      ac.abort();
    }
    return Object.assign(masterWatcher, {
      rid,
      close,
      [Symbol.dispose]: close
    });
  };
  exports.watchFs = watchFs;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/writeFile.js
var require_writeFile = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.writeFile = undefined;
  var fs2 = __importStar(__require("fs/promises"));
  var errorMap_js_1 = __importDefault(require_errorMap());
  var fs_flags_js_1 = require_fs_flags();
  var writeFile = async function writeFile(path2, data, { append = false, create = true, createNew = false, mode, signal } = {}) {
    const truncate = create && !append;
    const flag = (0, fs_flags_js_1.getFsFlag)({ append, create, createNew, truncate, write: true });
    try {
      await fs2.writeFile(path2, data, { flag, signal });
      if (mode != null)
        await fs2.chmod(path2, mode);
    } catch (error) {
      throw (0, errorMap_js_1.default)(error);
    }
  };
  exports.writeFile = writeFile;
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions/writeFileSync.js
var require_writeFileSync = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.writeFileSync = undefined;
  var os_1 = __require("os");
  var openSync_js_1 = require_openSync();
  var errorMap_js_1 = __importDefault(require_errorMap());
  var statSync_js_1 = require_statSync();
  var chmodSync_js_1 = require_chmodSync();
  var writeFileSync = function writeFileSync(path2, data, options = {}) {
    try {
      if (options.create !== undefined) {
        const create = !!options.create;
        if (!create) {
          (0, statSync_js_1.statSync)(path2);
        }
      }
      const openOptions = {
        write: true,
        create: true,
        createNew: options.createNew,
        append: !!options.append,
        truncate: !options.append
      };
      const file = (0, openSync_js_1.openSync)(path2, openOptions);
      if (options.mode !== undefined && options.mode !== null && (0, os_1.platform)() !== "win32") {
        (0, chmodSync_js_1.chmodSync)(path2, options.mode);
      }
      let nwritten = 0;
      while (nwritten < data.length) {
        nwritten += file.writeSync(data.subarray(nwritten));
      }
      file.close();
    } catch (e) {
      throw (0, errorMap_js_1.default)(e);
    }
  };
  exports.writeFileSync = writeFileSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/variables/args.js
var require_args = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.args = undefined;
  exports.args = process.argv.slice(2);
});

// node_modules/@deno/shim-deno/dist/deno/stable/functions.js
var require_functions = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.read = exports.osUptime = exports.osRelease = exports.openSync = exports.open = exports.mkdirSync = exports.mkdir = exports.memoryUsage = exports.makeTempFileSync = exports.makeTempFile = exports.makeTempDirSync = exports.makeTempDir = exports.lstatSync = exports.lstat = exports.loadavg = exports.listenTls = exports.listen = exports.linkSync = exports.link = exports.kill = exports.inspect = exports.hostname = exports.gid = exports.ftruncateSync = exports.ftruncate = exports.fsyncSync = exports.fsync = exports.fstatSync = exports.fstat = exports.fdatasyncSync = exports.fdatasync = exports.exit = exports.execPath = exports.cwd = exports.createSync = exports.create = exports.copyFileSync = exports.copyFile = exports.copy = exports.consoleSize = exports.connectTls = exports.connect = exports.close = exports.chownSync = exports.chown = exports.chmodSync = exports.chmod = exports.chdir = exports.addSignalListener = exports.isatty = undefined;
  exports.utimeSync = exports.utime = exports.futimeSync = exports.futime = exports.args = exports.writeTextFileSync = exports.writeTextFile = exports.writeSync = exports.writeFileSync = exports.writeFile = exports.write = exports.watchFs = exports.uid = exports.truncateSync = exports.truncate = exports.test = exports.symlinkSync = exports.symlink = exports.statSync = exports.stat = exports.shutdown = exports.run = exports.Process = exports.resolveDns = exports.renameSync = exports.rename = exports.removeSync = exports.removeSignalListener = exports.remove = exports.realPathSync = exports.realPath = exports.readTextFileSync = exports.readTextFile = exports.readSync = exports.readLinkSync = exports.readLink = exports.readFileSync = exports.readFile = exports.readDirSync = exports.readDir = undefined;
  var fs_1 = __importDefault(__require("fs"));
  var errorMap_js_1 = __importDefault(require_errorMap());
  var variables_js_1 = require_variables();
  var tty_1 = __require("tty");
  Object.defineProperty(exports, "isatty", { enumerable: true, get: function() {
    return tty_1.isatty;
  } });
  var addSignalListener_js_1 = require_addSignalListener();
  Object.defineProperty(exports, "addSignalListener", { enumerable: true, get: function() {
    return addSignalListener_js_1.addSignalListener;
  } });
  var chdir_js_1 = require_chdir();
  Object.defineProperty(exports, "chdir", { enumerable: true, get: function() {
    return chdir_js_1.chdir;
  } });
  var chmod_js_1 = require_chmod();
  Object.defineProperty(exports, "chmod", { enumerable: true, get: function() {
    return chmod_js_1.chmod;
  } });
  var chmodSync_js_1 = require_chmodSync();
  Object.defineProperty(exports, "chmodSync", { enumerable: true, get: function() {
    return chmodSync_js_1.chmodSync;
  } });
  var chown_js_1 = require_chown();
  Object.defineProperty(exports, "chown", { enumerable: true, get: function() {
    return chown_js_1.chown;
  } });
  var chownSync_js_1 = require_chownSync();
  Object.defineProperty(exports, "chownSync", { enumerable: true, get: function() {
    return chownSync_js_1.chownSync;
  } });
  var close_js_1 = require_close();
  Object.defineProperty(exports, "close", { enumerable: true, get: function() {
    return close_js_1.close;
  } });
  var connect_js_1 = require_connect2();
  Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
    return connect_js_1.connect;
  } });
  var connectTls_js_1 = require_connectTls();
  Object.defineProperty(exports, "connectTls", { enumerable: true, get: function() {
    return connectTls_js_1.connectTls;
  } });
  var consoleSize_js_1 = require_consoleSize();
  Object.defineProperty(exports, "consoleSize", { enumerable: true, get: function() {
    return consoleSize_js_1.consoleSize;
  } });
  var copy_js_1 = require_copy();
  Object.defineProperty(exports, "copy", { enumerable: true, get: function() {
    return copy_js_1.copy;
  } });
  var copyFile_js_1 = require_copyFile();
  Object.defineProperty(exports, "copyFile", { enumerable: true, get: function() {
    return copyFile_js_1.copyFile;
  } });
  var copyFileSync_js_1 = require_copyFileSync();
  Object.defineProperty(exports, "copyFileSync", { enumerable: true, get: function() {
    return copyFileSync_js_1.copyFileSync;
  } });
  var create_js_1 = require_create();
  Object.defineProperty(exports, "create", { enumerable: true, get: function() {
    return create_js_1.create;
  } });
  var createSync_js_1 = require_createSync();
  Object.defineProperty(exports, "createSync", { enumerable: true, get: function() {
    return createSync_js_1.createSync;
  } });
  var cwd_js_1 = require_cwd();
  Object.defineProperty(exports, "cwd", { enumerable: true, get: function() {
    return cwd_js_1.cwd;
  } });
  var execPath_js_1 = require_execPath();
  Object.defineProperty(exports, "execPath", { enumerable: true, get: function() {
    return execPath_js_1.execPath;
  } });
  var exit_js_1 = require_exit();
  Object.defineProperty(exports, "exit", { enumerable: true, get: function() {
    return exit_js_1.exit;
  } });
  var fdatasync_js_1 = require_fdatasync();
  Object.defineProperty(exports, "fdatasync", { enumerable: true, get: function() {
    return fdatasync_js_1.fdatasync;
  } });
  var fdatasyncSync_js_1 = require_fdatasyncSync();
  Object.defineProperty(exports, "fdatasyncSync", { enumerable: true, get: function() {
    return fdatasyncSync_js_1.fdatasyncSync;
  } });
  var fstat_js_1 = require_fstat();
  Object.defineProperty(exports, "fstat", { enumerable: true, get: function() {
    return fstat_js_1.fstat;
  } });
  var fstatSync_js_1 = require_fstatSync();
  Object.defineProperty(exports, "fstatSync", { enumerable: true, get: function() {
    return fstatSync_js_1.fstatSync;
  } });
  var fsync_js_1 = require_fsync();
  Object.defineProperty(exports, "fsync", { enumerable: true, get: function() {
    return fsync_js_1.fsync;
  } });
  var fsyncSync_js_1 = require_fsyncSync();
  Object.defineProperty(exports, "fsyncSync", { enumerable: true, get: function() {
    return fsyncSync_js_1.fsyncSync;
  } });
  var ftruncate_js_1 = require_ftruncate();
  Object.defineProperty(exports, "ftruncate", { enumerable: true, get: function() {
    return ftruncate_js_1.ftruncate;
  } });
  var ftruncateSync_js_1 = require_ftruncateSync();
  Object.defineProperty(exports, "ftruncateSync", { enumerable: true, get: function() {
    return ftruncateSync_js_1.ftruncateSync;
  } });
  var gid_js_1 = require_gid();
  Object.defineProperty(exports, "gid", { enumerable: true, get: function() {
    return gid_js_1.gid;
  } });
  var hostname_js_1 = require_hostname();
  Object.defineProperty(exports, "hostname", { enumerable: true, get: function() {
    return hostname_js_1.hostname;
  } });
  var inspect_js_1 = require_inspect();
  Object.defineProperty(exports, "inspect", { enumerable: true, get: function() {
    return inspect_js_1.inspect;
  } });
  var kill_js_1 = require_kill();
  Object.defineProperty(exports, "kill", { enumerable: true, get: function() {
    return kill_js_1.kill;
  } });
  var link_js_1 = require_link();
  Object.defineProperty(exports, "link", { enumerable: true, get: function() {
    return link_js_1.link;
  } });
  var linkSync_js_1 = require_linkSync();
  Object.defineProperty(exports, "linkSync", { enumerable: true, get: function() {
    return linkSync_js_1.linkSync;
  } });
  var listen_js_1 = require_listen();
  Object.defineProperty(exports, "listen", { enumerable: true, get: function() {
    return listen_js_1.listen;
  } });
  var listenTls_js_1 = require_listenTls();
  Object.defineProperty(exports, "listenTls", { enumerable: true, get: function() {
    return listenTls_js_1.listenTls;
  } });
  var loadavg_js_1 = require_loadavg();
  Object.defineProperty(exports, "loadavg", { enumerable: true, get: function() {
    return loadavg_js_1.loadavg;
  } });
  var lstat_js_1 = require_lstat();
  Object.defineProperty(exports, "lstat", { enumerable: true, get: function() {
    return lstat_js_1.lstat;
  } });
  var lstatSync_js_1 = require_lstatSync();
  Object.defineProperty(exports, "lstatSync", { enumerable: true, get: function() {
    return lstatSync_js_1.lstatSync;
  } });
  var makeTempDir_js_1 = require_makeTempDir();
  Object.defineProperty(exports, "makeTempDir", { enumerable: true, get: function() {
    return makeTempDir_js_1.makeTempDir;
  } });
  var makeTempDirSync_js_1 = require_makeTempDirSync();
  Object.defineProperty(exports, "makeTempDirSync", { enumerable: true, get: function() {
    return makeTempDirSync_js_1.makeTempDirSync;
  } });
  var makeTempFile_js_1 = require_makeTempFile();
  Object.defineProperty(exports, "makeTempFile", { enumerable: true, get: function() {
    return makeTempFile_js_1.makeTempFile;
  } });
  var makeTempFileSync_js_1 = require_makeTempFileSync();
  Object.defineProperty(exports, "makeTempFileSync", { enumerable: true, get: function() {
    return makeTempFileSync_js_1.makeTempFileSync;
  } });
  var memoryUsage_js_1 = require_memoryUsage();
  Object.defineProperty(exports, "memoryUsage", { enumerable: true, get: function() {
    return memoryUsage_js_1.memoryUsage;
  } });
  var mkdir_js_1 = require_mkdir();
  Object.defineProperty(exports, "mkdir", { enumerable: true, get: function() {
    return mkdir_js_1.mkdir;
  } });
  var mkdirSync_js_1 = require_mkdirSync();
  Object.defineProperty(exports, "mkdirSync", { enumerable: true, get: function() {
    return mkdirSync_js_1.mkdirSync;
  } });
  var open_js_1 = require_open();
  Object.defineProperty(exports, "open", { enumerable: true, get: function() {
    return open_js_1.open;
  } });
  var openSync_js_1 = require_openSync();
  Object.defineProperty(exports, "openSync", { enumerable: true, get: function() {
    return openSync_js_1.openSync;
  } });
  var osRelease_js_1 = require_osRelease();
  Object.defineProperty(exports, "osRelease", { enumerable: true, get: function() {
    return osRelease_js_1.osRelease;
  } });
  var osUptime_js_1 = require_osUptime();
  Object.defineProperty(exports, "osUptime", { enumerable: true, get: function() {
    return osUptime_js_1.osUptime;
  } });
  var read_js_1 = require_read();
  Object.defineProperty(exports, "read", { enumerable: true, get: function() {
    return read_js_1.read;
  } });
  var readDir_js_1 = require_readDir();
  Object.defineProperty(exports, "readDir", { enumerable: true, get: function() {
    return readDir_js_1.readDir;
  } });
  var readDirSync_js_1 = require_readDirSync();
  Object.defineProperty(exports, "readDirSync", { enumerable: true, get: function() {
    return readDirSync_js_1.readDirSync;
  } });
  var readFile_js_1 = require_readFile();
  Object.defineProperty(exports, "readFile", { enumerable: true, get: function() {
    return readFile_js_1.readFile;
  } });
  var readFileSync_js_1 = require_readFileSync();
  Object.defineProperty(exports, "readFileSync", { enumerable: true, get: function() {
    return readFileSync_js_1.readFileSync;
  } });
  var readLink_js_1 = require_readLink();
  Object.defineProperty(exports, "readLink", { enumerable: true, get: function() {
    return readLink_js_1.readLink;
  } });
  var readLinkSync_js_1 = require_readLinkSync();
  Object.defineProperty(exports, "readLinkSync", { enumerable: true, get: function() {
    return readLinkSync_js_1.readLinkSync;
  } });
  var readSync_js_1 = require_readSync();
  Object.defineProperty(exports, "readSync", { enumerable: true, get: function() {
    return readSync_js_1.readSync;
  } });
  var readTextFile_js_1 = require_readTextFile();
  Object.defineProperty(exports, "readTextFile", { enumerable: true, get: function() {
    return readTextFile_js_1.readTextFile;
  } });
  var readTextFileSync_js_1 = require_readTextFileSync();
  Object.defineProperty(exports, "readTextFileSync", { enumerable: true, get: function() {
    return readTextFileSync_js_1.readTextFileSync;
  } });
  var realPath_js_1 = require_realPath();
  Object.defineProperty(exports, "realPath", { enumerable: true, get: function() {
    return realPath_js_1.realPath;
  } });
  var realPathSync_js_1 = require_realPathSync();
  Object.defineProperty(exports, "realPathSync", { enumerable: true, get: function() {
    return realPathSync_js_1.realPathSync;
  } });
  var remove_js_1 = require_remove2();
  Object.defineProperty(exports, "remove", { enumerable: true, get: function() {
    return remove_js_1.remove;
  } });
  var removeSignalListener_js_1 = require_removeSignalListener();
  Object.defineProperty(exports, "removeSignalListener", { enumerable: true, get: function() {
    return removeSignalListener_js_1.removeSignalListener;
  } });
  var removeSync_js_1 = require_removeSync();
  Object.defineProperty(exports, "removeSync", { enumerable: true, get: function() {
    return removeSync_js_1.removeSync;
  } });
  var rename_js_1 = require_rename();
  Object.defineProperty(exports, "rename", { enumerable: true, get: function() {
    return rename_js_1.rename;
  } });
  var renameSync_js_1 = require_renameSync();
  Object.defineProperty(exports, "renameSync", { enumerable: true, get: function() {
    return renameSync_js_1.renameSync;
  } });
  var resolveDns_js_1 = require_resolveDns();
  Object.defineProperty(exports, "resolveDns", { enumerable: true, get: function() {
    return resolveDns_js_1.resolveDns;
  } });
  var run_js_1 = require_run();
  Object.defineProperty(exports, "Process", { enumerable: true, get: function() {
    return run_js_1.Process;
  } });
  Object.defineProperty(exports, "run", { enumerable: true, get: function() {
    return run_js_1.run;
  } });
  var shutdown_js_1 = require_shutdown();
  Object.defineProperty(exports, "shutdown", { enumerable: true, get: function() {
    return shutdown_js_1.shutdown;
  } });
  var stat_js_1 = require_stat();
  Object.defineProperty(exports, "stat", { enumerable: true, get: function() {
    return stat_js_1.stat;
  } });
  var statSync_js_1 = require_statSync();
  Object.defineProperty(exports, "statSync", { enumerable: true, get: function() {
    return statSync_js_1.statSync;
  } });
  var symlink_js_1 = require_symlink();
  Object.defineProperty(exports, "symlink", { enumerable: true, get: function() {
    return symlink_js_1.symlink;
  } });
  var symlinkSync_js_1 = require_symlinkSync();
  Object.defineProperty(exports, "symlinkSync", { enumerable: true, get: function() {
    return symlinkSync_js_1.symlinkSync;
  } });
  var test_js_1 = require_test2();
  Object.defineProperty(exports, "test", { enumerable: true, get: function() {
    return test_js_1.test;
  } });
  var truncate_js_1 = require_truncate();
  Object.defineProperty(exports, "truncate", { enumerable: true, get: function() {
    return truncate_js_1.truncate;
  } });
  var truncateSync_js_1 = require_truncateSync();
  Object.defineProperty(exports, "truncateSync", { enumerable: true, get: function() {
    return truncateSync_js_1.truncateSync;
  } });
  var uid_js_1 = require_uid();
  Object.defineProperty(exports, "uid", { enumerable: true, get: function() {
    return uid_js_1.uid;
  } });
  var watchFs_js_1 = require_watchFs();
  Object.defineProperty(exports, "watchFs", { enumerable: true, get: function() {
    return watchFs_js_1.watchFs;
  } });
  var write_js_1 = require_write();
  Object.defineProperty(exports, "write", { enumerable: true, get: function() {
    return write_js_1.write;
  } });
  var writeFile_js_1 = require_writeFile();
  Object.defineProperty(exports, "writeFile", { enumerable: true, get: function() {
    return writeFile_js_1.writeFile;
  } });
  var writeFileSync_js_1 = require_writeFileSync();
  Object.defineProperty(exports, "writeFileSync", { enumerable: true, get: function() {
    return writeFileSync_js_1.writeFileSync;
  } });
  var writeSync_js_1 = require_writeSync();
  Object.defineProperty(exports, "writeSync", { enumerable: true, get: function() {
    return writeSync_js_1.writeSync;
  } });
  var writeTextFile_js_1 = require_writeTextFile();
  Object.defineProperty(exports, "writeTextFile", { enumerable: true, get: function() {
    return writeTextFile_js_1.writeTextFile;
  } });
  var writeTextFileSync_js_1 = require_writeTextFileSync();
  Object.defineProperty(exports, "writeTextFileSync", { enumerable: true, get: function() {
    return writeTextFileSync_js_1.writeTextFileSync;
  } });
  var args_js_1 = require_args();
  Object.defineProperty(exports, "args", { enumerable: true, get: function() {
    return args_js_1.args;
  } });
  var futime = async function(rid, atime, mtime) {
    try {
      await new Promise((resolve, reject) => {
        fs_1.default.futimes(rid, atime, mtime, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    } catch (error) {
      throw (0, errorMap_js_1.default)(error);
    }
  };
  exports.futime = futime;
  var futimeSync = function(rid, atime, mtime) {
    try {
      fs_1.default.futimesSync(rid, atime, mtime);
    } catch (error) {
      throw (0, errorMap_js_1.default)(error);
    }
  };
  exports.futimeSync = futimeSync;
  var utime = async function(path2, atime, mtime) {
    try {
      await fs_1.default.promises.utimes(path2, atime, mtime);
    } catch (error) {
      if ((error === null || error === undefined ? undefined : error.code) === "ENOENT") {
        throw new variables_js_1.errors.NotFound(`No such file or directory (os error 2), utime '${path2}'`);
      }
      throw (0, errorMap_js_1.default)(error);
    }
  };
  exports.utime = utime;
  var utimeSync = function(path2, atime, mtime) {
    try {
      fs_1.default.utimesSync(path2, atime, mtime);
    } catch (error) {
      if ((error === null || error === undefined ? undefined : error.code) === "ENOENT") {
        throw new variables_js_1.errors.NotFound(`No such file or directory (os error 2), utime '${path2}'`);
      }
      throw (0, errorMap_js_1.default)(error);
    }
  };
  exports.utimeSync = utimeSync;
});

// node_modules/@deno/shim-deno/dist/deno/stable/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@deno/shim-deno/dist/deno/stable/main.js
var require_main3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_classes(), exports);
  __exportStar(require_enums(), exports);
  __exportStar(require_functions(), exports);
  __exportStar(require_types(), exports);
  __exportStar(require_variables(), exports);
});

// node_modules/@deno/shim-deno/dist/deno.js
var require_deno = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_main3(), exports);
});

// node_modules/@deno/shim-deno/dist/index.js
var require_dist3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deno = undefined;
  exports.Deno = __importStar(require_deno());
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values2;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  var __rewriteRelativeImportExtension;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v2) {
        return exports2[id] = previous ? previous(id, v2) : v2;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    __extends = function(d2, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __);
    };
    __assign = Object.assign || function(t2) {
      for (var s2, i2 = 1, n2 = arguments.length;i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t2[p2] = s2[p2];
      }
      return t2;
    };
    __rest = function(s2, e2) {
      var t2 = {};
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s2[p2];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2);i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
            t2[p2[i2]] = s2[p2[i2]];
        }
      return t2;
    };
    __decorate = function(decorators, target, key, desc) {
      var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r2 = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i2 = decorators.length - 1;i2 >= 0; i2--)
          if (d2 = decorators[i2])
            r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
      return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f2) {
        if (f2 !== undefined && typeof f2 !== "function")
          throw new TypeError("Function expected");
        return f2;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _2, done = false;
      for (var i2 = decorators.length - 1;i2 >= 0; i2--) {
        var context2 = {};
        for (var p2 in contextIn)
          context2[p2] = p2 === "access" ? {} : contextIn[p2];
        for (var p2 in contextIn.access)
          context2.access[p2] = contextIn.access[p2];
        context2.addInitializer = function(f2) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f2 || null));
        };
        var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_2 = accept(result.get))
            descriptor.get = _2;
          if (_2 = accept(result.set))
            descriptor.set = _2;
          if (_2 = accept(result.init))
            initializers.unshift(_2);
        } else if (_2 = accept(result)) {
          if (kind === "field")
            initializers.unshift(_2);
          else
            descriptor[key] = _2;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i2 = 0;i2 < initializers.length; i2++) {
        value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x2) {
      return typeof x2 === "symbol" ? x2 : "".concat(x2);
    };
    __setFunctionName = function(f2, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f2, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve5) {
          resolve5(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve5, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t2[0] & 1)
          throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f2, y2, t2, g2 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g2.next = verb(0), g2["throw"] = verb(1), g2["return"] = verb(2), typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n2) {
        return function(v2) {
          return step([n2, v2]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
          try {
            if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
              return t2;
            if (y2 = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t2[1]) {
                  _2.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _2.label < t2[2]) {
                  _2.label = t2[2];
                  _2.ops.push(op);
                  break;
                }
                if (t2[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e2) {
            op = [6, e2];
            y2 = 0;
          } finally {
            f2 = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m2, o2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2))
          __createBinding(o2, m2, p2);
    };
    __createBinding = Object.create ? function(o2, m2, k2, k22) {
      if (k22 === undefined)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === undefined)
        k22 = k2;
      o2[k22] = m2[k2];
    };
    __values2 = function(o2) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
      if (m2)
        return m2.call(o2);
      if (o2 && typeof o2.length === "number")
        return {
          next: function() {
            if (o2 && i2 >= o2.length)
              o2 = undefined;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o2, n2) {
      var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m2)
        return o2;
      var i2 = m2.call(o2), r2, ar = [], e2;
      try {
        while ((n2 === undefined || n2-- > 0) && !(r2 = i2.next()).done)
          ar.push(r2.value);
      } catch (error) {
        e2 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"]))
            m2.call(i2);
        } finally {
          if (e2)
            throw e2.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i2 = 0;i2 < arguments.length; i2++)
        ar = ar.concat(__read(arguments[i2]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s2 = 0, i2 = 0, il = arguments.length;i2 < il; i2++)
        s2 += arguments[i2].length;
      for (var r2 = Array(s2), k2 = 0, i2 = 0;i2 < il; i2++)
        for (var a2 = arguments[i2], j2 = 0, jl = a2.length;j2 < jl; j2++, k2++)
          r2[k2] = a2[j2];
      return r2;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from.length, ar;i2 < l2; i2++) {
          if (ar || !(i2 in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i2);
            ar[i2] = from[i2];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v2) {
      return this instanceof __await ? (this.v = v2, this) : new __await(v2);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
      return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2;
      function awaitReturn(f2) {
        return function(v2) {
          return Promise.resolve(v2).then(f2, reject);
        };
      }
      function verb(n2, f2) {
        if (g2[n2]) {
          i2[n2] = function(v2) {
            return new Promise(function(a2, b2) {
              q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
            });
          };
          if (f2)
            i2[n2] = f2(i2[n2]);
        }
      }
      function resume(n2, v2) {
        try {
          step(g2[n2](v2));
        } catch (e2) {
          settle(q2[0][3], e2);
        }
      }
      function step(r2) {
        r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f2, v2) {
        if (f2(v2), q2.shift(), q2.length)
          resume(q2[0][0], q2[0][1]);
      }
    };
    __asyncDelegator = function(o2) {
      var i2, p2;
      return i2 = {}, verb("next"), verb("throw", function(e2) {
        throw e2;
      }), verb("return"), i2[Symbol.iterator] = function() {
        return this;
      }, i2;
      function verb(n2, f2) {
        i2[n2] = o2[n2] ? function(v2) {
          return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: false } : f2 ? f2(v2) : v2;
        } : f2;
      }
    };
    __asyncValues = function(o2) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m2 = o2[Symbol.asyncIterator], i2;
      return m2 ? m2.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n2) {
        i2[n2] = o2[n2] && function(v2) {
          return new Promise(function(resolve5, reject) {
            v2 = o2[n2](v2), settle(resolve5, reject, v2.done, v2.value);
          });
        };
      }
      function settle(resolve5, reject, d2, v2) {
        Promise.resolve(v2).then(function(v3) {
          resolve5({ value: v3, done: d2 });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    };
    var ownKeys = function(o2) {
      ownKeys = Object.getOwnPropertyNames || function(o3) {
        var ar = [];
        for (var k2 in o3)
          if (Object.prototype.hasOwnProperty.call(o3, k2))
            ar[ar.length] = k2;
        return ar;
      };
      return ownKeys(o2);
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 = ownKeys(mod), i2 = 0;i2 < k2.length; i2++)
          if (k2[i2] !== "default")
            __createBinding(result, mod, k2[i2]);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f2) {
      if (kind === "a" && !f2)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f2)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e2) {
              return Promise.reject(e2);
            }
          };
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e2 = new Error(message);
      return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
    };
    __disposeResources = function(env) {
      function fail(e2) {
        env.error = env.hasError ? new _SuppressedError(e2, env.error, "An error was suppressed during disposal.") : e2;
        env.hasError = true;
      }
      var r2, s2 = 0;
      function next() {
        while (r2 = env.stack.pop()) {
          try {
            if (!r2.async && s2 === 1)
              return s2 = 0, env.stack.push(r2), Promise.resolve().then(next);
            if (r2.dispose) {
              var result = r2.dispose.call(r2.value);
              if (r2.async)
                return s2 |= 2, Promise.resolve(result).then(next, function(e2) {
                  fail(e2);
                  return next();
                });
            } else
              s2 |= 1;
          } catch (e2) {
            fail(e2);
          }
        }
        if (s2 === 1)
          return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    __rewriteRelativeImportExtension = function(path2, preserveJsx) {
      if (typeof path2 === "string" && /^\.\.?\//.test(path2)) {
        return path2.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m2, tsx, d2, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d2 && (!ext || !cm) ? m2 : d2 + ext + "." + cm.toLowerCase() + "js";
        });
      }
      return path2;
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values2);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
    exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
  });
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s2 = 1000;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w2 = d2 * 7;
  var y2 = d2 * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse5(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse5(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n2 = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n2 * y2;
      case "weeks":
      case "week":
      case "w":
        return n2 * w2;
      case "days":
      case "day":
      case "d":
        return n2 * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n2 * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n2 * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n2 * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n2;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d2) {
      return Math.round(ms / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms / s2) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d2) {
      return plural(ms, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural(ms, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural(ms, msAbs, s2, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n2, name) {
    var isPlural = msAbs >= n2 * 1.5;
    return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable2;
    createDebug.enable = enable2;
    createDebug.enabled = enabled2;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy2;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i2 = 0;i2 < namespace.length; i2++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i2);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format5) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format5];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend2;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v2) => {
          enableOverride = v2;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable2(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable2() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled2(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy2() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m2;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c2 = "color: " + this.color;
    args.splice(1, 0, c2, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c2);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r2;
    try {
      r2 = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r2 && typeof process !== "undefined" && "env" in process) {
      r2 = process.env.DEBUG;
    }
    return r2;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v2) {
    try {
      return JSON.stringify(v2);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var os2 = __require("os");
  var tty = __require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os2.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util2 = __require("util");
  exports.init = init;
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util2.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k2) => {
      return k2.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c2 = this.color;
      const colorCode = "\x1B[3" + (c2 < 8 ? c2 : "8;5;" + c2);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log2(...args) {
    return process.stderr.write(util2.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i2 = 0;i2 < keys.length; i2++) {
      debug.inspectOpts[keys[i2]] = exports.inspectOpts[keys[i2]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/agent-base/dist/helpers.js
var require_helpers = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.req = exports.json = exports.toBuffer = undefined;
  var http2 = __importStar2(__require("http"));
  var https2 = __importStar2(__require("https"));
  async function toBuffer(stream) {
    let length = 0;
    const chunks = [];
    for await (const chunk of stream) {
      length += chunk.length;
      chunks.push(chunk);
    }
    return Buffer.concat(chunks, length);
  }
  exports.toBuffer = toBuffer;
  async function json(stream) {
    const buf = await toBuffer(stream);
    const str = buf.toString("utf8");
    try {
      return JSON.parse(str);
    } catch (_err) {
      const err = _err;
      err.message += ` (input: ${str})`;
      throw err;
    }
  }
  exports.json = json;
  function req(url, opts = {}) {
    const href = typeof url === "string" ? url : url.href;
    const req2 = (href.startsWith("https:") ? https2 : http2).request(url, opts);
    const promise = new Promise((resolve5, reject) => {
      req2.once("response", resolve5).once("error", reject).end();
    });
    req2.then = promise.then.bind(promise);
    return req2;
  }
  exports.req = req;
});

// node_modules/agent-base/dist/index.js
var require_dist4 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __exportStar2 = exports && exports.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding2(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Agent = undefined;
  var net = __importStar2(__require("net"));
  var http2 = __importStar2(__require("http"));
  var https_1 = __require("https");
  __exportStar2(require_helpers(), exports);
  var INTERNAL = Symbol("AgentBaseInternalState");

  class Agent3 extends http2.Agent {
    constructor(opts) {
      super(opts);
      this[INTERNAL] = {};
    }
    isSecureEndpoint(options) {
      if (options) {
        if (typeof options.secureEndpoint === "boolean") {
          return options.secureEndpoint;
        }
        if (typeof options.protocol === "string") {
          return options.protocol === "https:";
        }
      }
      const { stack } = new Error;
      if (typeof stack !== "string")
        return false;
      return stack.split(`
`).some((l2) => l2.indexOf("(https.js:") !== -1 || l2.indexOf("node:https:") !== -1);
    }
    incrementSockets(name) {
      if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
        return null;
      }
      if (!this.sockets[name]) {
        this.sockets[name] = [];
      }
      const fakeSocket = new net.Socket({ writable: false });
      this.sockets[name].push(fakeSocket);
      this.totalSocketCount++;
      return fakeSocket;
    }
    decrementSockets(name, socket) {
      if (!this.sockets[name] || socket === null) {
        return;
      }
      const sockets = this.sockets[name];
      const index = sockets.indexOf(socket);
      if (index !== -1) {
        sockets.splice(index, 1);
        this.totalSocketCount--;
        if (sockets.length === 0) {
          delete this.sockets[name];
        }
      }
    }
    getName(options) {
      const secureEndpoint = typeof options.secureEndpoint === "boolean" ? options.secureEndpoint : this.isSecureEndpoint(options);
      if (secureEndpoint) {
        return https_1.Agent.prototype.getName.call(this, options);
      }
      return super.getName(options);
    }
    createSocket(req, options, cb) {
      const connectOpts = {
        ...options,
        secureEndpoint: this.isSecureEndpoint(options)
      };
      const name = this.getName(connectOpts);
      const fakeSocket = this.incrementSockets(name);
      Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
        this.decrementSockets(name, fakeSocket);
        if (socket instanceof http2.Agent) {
          try {
            return socket.addRequest(req, connectOpts);
          } catch (err) {
            return cb(err);
          }
        }
        this[INTERNAL].currentSocket = socket;
        super.createSocket(req, options, cb);
      }, (err) => {
        this.decrementSockets(name, fakeSocket);
        cb(err);
      });
    }
    createConnection() {
      const socket = this[INTERNAL].currentSocket;
      this[INTERNAL].currentSocket = undefined;
      if (!socket) {
        throw new Error("No socket was returned in the `connect()` function");
      }
      return socket;
    }
    get defaultPort() {
      return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(v2) {
      if (this[INTERNAL]) {
        this[INTERNAL].defaultPort = v2;
      }
    }
    get protocol() {
      return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(v2) {
      if (this[INTERNAL]) {
        this[INTERNAL].protocol = v2;
      }
    }
  }
  exports.Agent = Agent3;
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS((exports) => {
  var __importDefault2 = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseProxyResponse = undefined;
  var debug_1 = __importDefault2(require_src());
  var debug = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
  function parseProxyResponse(socket) {
    return new Promise((resolve5, reject) => {
      let buffersLength = 0;
      const buffers = [];
      function read() {
        const b2 = socket.read();
        if (b2)
          ondata(b2);
        else
          socket.once("readable", read);
      }
      function cleanup() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("readable", read);
      }
      function onend() {
        cleanup();
        debug("onend");
        reject(new Error("Proxy connection ended before receiving CONNECT response"));
      }
      function onerror(err) {
        cleanup();
        debug("onerror %o", err);
        reject(err);
      }
      function ondata(b2) {
        buffers.push(b2);
        buffersLength += b2.length;
        const buffered = Buffer.concat(buffers, buffersLength);
        const endOfHeaders = buffered.indexOf(`\r
\r
`);
        if (endOfHeaders === -1) {
          debug("have not received end of HTTP headers yet...");
          read();
          return;
        }
        const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split(`\r
`);
        const firstLine = headerParts.shift();
        if (!firstLine) {
          socket.destroy();
          return reject(new Error("No header received from proxy CONNECT response"));
        }
        const firstLineParts = firstLine.split(" ");
        const statusCode = +firstLineParts[1];
        const statusText = firstLineParts.slice(2).join(" ");
        const headers = {};
        for (const header of headerParts) {
          if (!header)
            continue;
          const firstColon = header.indexOf(":");
          if (firstColon === -1) {
            socket.destroy();
            return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
          }
          const key = header.slice(0, firstColon).toLowerCase();
          const value = header.slice(firstColon + 1).trimStart();
          const current = headers[key];
          if (typeof current === "string") {
            headers[key] = [current, value];
          } else if (Array.isArray(current)) {
            current.push(value);
          } else {
            headers[key] = value;
          }
        }
        debug("got proxy server response: %o %o", firstLine, headers);
        cleanup();
        resolve5({
          connect: {
            statusCode,
            statusText,
            headers
          },
          buffered
        });
      }
      socket.on("error", onerror);
      socket.on("end", onend);
      read();
    });
  }
  exports.parseProxyResponse = parseProxyResponse;
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist5 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault2 = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpsProxyAgent = undefined;
  var net = __importStar2(__require("net"));
  var tls = __importStar2(__require("tls"));
  var assert_1 = __importDefault2(__require("assert"));
  var debug_1 = __importDefault2(require_src());
  var agent_base_1 = require_dist4();
  var url_1 = __require("url");
  var parse_proxy_response_1 = require_parse_proxy_response();
  var debug = (0, debug_1.default)("https-proxy-agent");
  var setServernameFromNonIpHost = (options) => {
    if (options.servername === undefined && options.host && !net.isIP(options.host)) {
      return {
        ...options,
        servername: options.host
      };
    }
    return options;
  };

  class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(proxy, opts) {
      super(opts);
      this.options = { path: undefined };
      this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
      this.proxyHeaders = opts?.headers ?? {};
      debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
      const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ALPNProtocols: ["http/1.1"],
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    async connect(req, opts) {
      const { proxy } = this;
      if (!opts.host) {
        throw new TypeError('No "host" provided');
      }
      let socket;
      if (proxy.protocol === "https:") {
        debug("Creating `tls.Socket`: %o", this.connectOpts);
        socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
      } else {
        debug("Creating `net.Socket`: %o", this.connectOpts);
        socket = net.connect(this.connectOpts);
      }
      const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
      let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
      if (proxy.username || proxy.password) {
        const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
        headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
      }
      headers.Host = `${host}:${opts.port}`;
      if (!headers["Proxy-Connection"]) {
        headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      }
      for (const name of Object.keys(headers)) {
        payload += `${name}: ${headers[name]}\r
`;
      }
      const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
      socket.write(`${payload}\r
`);
      const { connect, buffered } = await proxyResponsePromise;
      req.emit("proxyConnect", connect);
      this.emit("proxyConnect", connect, req);
      if (connect.statusCode === 200) {
        req.once("socket", resume);
        if (opts.secureEndpoint) {
          debug("Upgrading socket connection to TLS");
          return tls.connect({
            ...omit(setServernameFromNonIpHost(opts), "host", "path", "port"),
            socket
          });
        }
        return socket;
      }
      socket.destroy();
      const fakeSocket = new net.Socket({ writable: false });
      fakeSocket.readable = true;
      req.once("socket", (s2) => {
        debug("Replaying proxy buffer for failed request");
        (0, assert_1.default)(s2.listenerCount("data") > 0);
        s2.push(buffered);
        s2.push(null);
      });
      return fakeSocket;
    }
  }
  HttpsProxyAgent.protocols = ["http", "https"];
  exports.HttpsProxyAgent = HttpsProxyAgent;
  function resume(socket) {
    socket.resume();
  }
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
});

// node_modules/http-proxy-agent/dist/index.js
var require_dist6 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault2 = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpProxyAgent = undefined;
  var net = __importStar2(__require("net"));
  var tls = __importStar2(__require("tls"));
  var debug_1 = __importDefault2(require_src());
  var events_1 = __require("events");
  var agent_base_1 = require_dist4();
  var url_1 = __require("url");
  var debug = (0, debug_1.default)("http-proxy-agent");

  class HttpProxyAgent extends agent_base_1.Agent {
    constructor(proxy, opts) {
      super(opts);
      this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
      this.proxyHeaders = opts?.headers ?? {};
      debug("Creating new HttpProxyAgent instance: %o", this.proxy.href);
      const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
      const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    addRequest(req, opts) {
      req._header = null;
      this.setRequestProps(req, opts);
      super.addRequest(req, opts);
    }
    setRequestProps(req, opts) {
      const { proxy } = this;
      const protocol = opts.secureEndpoint ? "https:" : "http:";
      const hostname = req.getHeader("host") || "localhost";
      const base = `${protocol}//${hostname}`;
      const url = new url_1.URL(req.path, base);
      if (opts.port !== 80) {
        url.port = String(opts.port);
      }
      req.path = String(url);
      const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      if (proxy.username || proxy.password) {
        const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
        headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
      }
      if (!headers["Proxy-Connection"]) {
        headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      }
      for (const name of Object.keys(headers)) {
        const value = headers[name];
        if (value) {
          req.setHeader(name, value);
        }
      }
    }
    async connect(req, opts) {
      req._header = null;
      if (!req.path.includes("://")) {
        this.setRequestProps(req, opts);
      }
      let first;
      let endOfHeaders;
      debug("Regenerating stored HTTP header string for request");
      req._implicitHeader();
      if (req.outputData && req.outputData.length > 0) {
        debug("Patching connection write() output buffer with updated header");
        first = req.outputData[0].data;
        endOfHeaders = first.indexOf(`\r
\r
`) + 4;
        req.outputData[0].data = req._header + first.substring(endOfHeaders);
        debug("Output buffer: %o", req.outputData[0].data);
      }
      let socket;
      if (this.proxy.protocol === "https:") {
        debug("Creating `tls.Socket`: %o", this.connectOpts);
        socket = tls.connect(this.connectOpts);
      } else {
        debug("Creating `net.Socket`: %o", this.connectOpts);
        socket = net.connect(this.connectOpts);
      }
      await (0, events_1.once)(socket, "connect");
      return socket;
    }
  }
  HttpProxyAgent.protocols = ["http", "https"];
  exports.HttpProxyAgent = HttpProxyAgent;
  function omit(obj, ...keys) {
    const ret = {};
    let key;
    for (key in obj) {
      if (!keys.includes(key)) {
        ret[key] = obj[key];
      }
    }
    return ret;
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/state.js
var require_state = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.state = undefined;
  exports.state = {
    instrumenterImplementation: undefined
  };
});

// node_modules/@actions/glob/lib/internal-glob-options-helper.js
var require_internal_glob_options_helper = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOptions = undefined;
  var core = __importStar2(require_core());
  function getOptions(copy) {
    const result = {
      followSymbolicLinks: true,
      implicitDescendants: true,
      omitBrokenSymbolicLinks: true
    };
    if (copy) {
      if (typeof copy.followSymbolicLinks === "boolean") {
        result.followSymbolicLinks = copy.followSymbolicLinks;
        core.debug(`followSymbolicLinks '${result.followSymbolicLinks}'`);
      }
      if (typeof copy.implicitDescendants === "boolean") {
        result.implicitDescendants = copy.implicitDescendants;
        core.debug(`implicitDescendants '${result.implicitDescendants}'`);
      }
      if (typeof copy.omitBrokenSymbolicLinks === "boolean") {
        result.omitBrokenSymbolicLinks = copy.omitBrokenSymbolicLinks;
        core.debug(`omitBrokenSymbolicLinks '${result.omitBrokenSymbolicLinks}'`);
      }
    }
    return result;
  }
  exports.getOptions = getOptions;
});

// node_modules/@actions/glob/lib/internal-path-helper.js
var require_internal_path_helper = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault2 = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.safeTrimTrailingSeparator = exports.normalizeSeparators = exports.hasRoot = exports.hasAbsoluteRoot = exports.ensureAbsoluteRoot = exports.dirname = undefined;
  var path2 = __importStar2(__require("path"));
  var assert_1 = __importDefault2(__require("assert"));
  var IS_WINDOWS = process.platform === "win32";
  function dirname5(p2) {
    p2 = safeTrimTrailingSeparator(p2);
    if (IS_WINDOWS && /^\\\\[^\\]+(\\[^\\]+)?$/.test(p2)) {
      return p2;
    }
    let result = path2.dirname(p2);
    if (IS_WINDOWS && /^\\\\[^\\]+\\[^\\]+\\$/.test(result)) {
      result = safeTrimTrailingSeparator(result);
    }
    return result;
  }
  exports.dirname = dirname5;
  function ensureAbsoluteRoot(root, itemPath) {
    assert_1.default(root, `ensureAbsoluteRoot parameter 'root' must not be empty`);
    assert_1.default(itemPath, `ensureAbsoluteRoot parameter 'itemPath' must not be empty`);
    if (hasAbsoluteRoot(itemPath)) {
      return itemPath;
    }
    if (IS_WINDOWS) {
      if (itemPath.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
        let cwd = process.cwd();
        assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
        if (itemPath[0].toUpperCase() === cwd[0].toUpperCase()) {
          if (itemPath.length === 2) {
            return `${itemPath[0]}:\\${cwd.substr(3)}`;
          } else {
            if (!cwd.endsWith("\\")) {
              cwd += "\\";
            }
            return `${itemPath[0]}:\\${cwd.substr(3)}${itemPath.substr(2)}`;
          }
        } else {
          return `${itemPath[0]}:\\${itemPath.substr(2)}`;
        }
      } else if (normalizeSeparators(itemPath).match(/^\\$|^\\[^\\]/)) {
        const cwd = process.cwd();
        assert_1.default(cwd.match(/^[A-Z]:\\/i), `Expected current directory to start with an absolute drive root. Actual '${cwd}'`);
        return `${cwd[0]}:\\${itemPath.substr(1)}`;
      }
    }
    assert_1.default(hasAbsoluteRoot(root), `ensureAbsoluteRoot parameter 'root' must have an absolute root`);
    if (root.endsWith("/") || IS_WINDOWS && root.endsWith("\\")) {
    } else {
      root += path2.sep;
    }
    return root + itemPath;
  }
  exports.ensureAbsoluteRoot = ensureAbsoluteRoot;
  function hasAbsoluteRoot(itemPath) {
    assert_1.default(itemPath, `hasAbsoluteRoot parameter 'itemPath' must not be empty`);
    itemPath = normalizeSeparators(itemPath);
    if (IS_WINDOWS) {
      return itemPath.startsWith("\\\\") || /^[A-Z]:\\/i.test(itemPath);
    }
    return itemPath.startsWith("/");
  }
  exports.hasAbsoluteRoot = hasAbsoluteRoot;
  function hasRoot(itemPath) {
    assert_1.default(itemPath, `isRooted parameter 'itemPath' must not be empty`);
    itemPath = normalizeSeparators(itemPath);
    if (IS_WINDOWS) {
      return itemPath.startsWith("\\") || /^[A-Z]:/i.test(itemPath);
    }
    return itemPath.startsWith("/");
  }
  exports.hasRoot = hasRoot;
  function normalizeSeparators(p2) {
    p2 = p2 || "";
    if (IS_WINDOWS) {
      p2 = p2.replace(/\//g, "\\");
      const isUnc = /^\\\\+[^\\]/.test(p2);
      return (isUnc ? "\\" : "") + p2.replace(/\\\\+/g, "\\");
    }
    return p2.replace(/\/\/+/g, "/");
  }
  exports.normalizeSeparators = normalizeSeparators;
  function safeTrimTrailingSeparator(p2) {
    if (!p2) {
      return "";
    }
    p2 = normalizeSeparators(p2);
    if (!p2.endsWith(path2.sep)) {
      return p2;
    }
    if (p2 === path2.sep) {
      return p2;
    }
    if (IS_WINDOWS && /^[A-Z]:\\$/i.test(p2)) {
      return p2;
    }
    return p2.substr(0, p2.length - 1);
  }
  exports.safeTrimTrailingSeparator = safeTrimTrailingSeparator;
});

// node_modules/@actions/glob/lib/internal-match-kind.js
var require_internal_match_kind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MatchKind = undefined;
  var MatchKind;
  (function(MatchKind2) {
    MatchKind2[MatchKind2["None"] = 0] = "None";
    MatchKind2[MatchKind2["Directory"] = 1] = "Directory";
    MatchKind2[MatchKind2["File"] = 2] = "File";
    MatchKind2[MatchKind2["All"] = 3] = "All";
  })(MatchKind = exports.MatchKind || (exports.MatchKind = {}));
});

// node_modules/@actions/glob/lib/internal-pattern-helper.js
var require_internal_pattern_helper = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.partialMatch = exports.match = exports.getSearchPaths = undefined;
  var pathHelper = __importStar2(require_internal_path_helper());
  var internal_match_kind_1 = require_internal_match_kind();
  var IS_WINDOWS = process.platform === "win32";
  function getSearchPaths(patterns) {
    patterns = patterns.filter((x2) => !x2.negate);
    const searchPathMap = {};
    for (const pattern of patterns) {
      const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
      searchPathMap[key] = "candidate";
    }
    const result = [];
    for (const pattern of patterns) {
      const key = IS_WINDOWS ? pattern.searchPath.toUpperCase() : pattern.searchPath;
      if (searchPathMap[key] === "included") {
        continue;
      }
      let foundAncestor = false;
      let tempKey = key;
      let parent = pathHelper.dirname(tempKey);
      while (parent !== tempKey) {
        if (searchPathMap[parent]) {
          foundAncestor = true;
          break;
        }
        tempKey = parent;
        parent = pathHelper.dirname(tempKey);
      }
      if (!foundAncestor) {
        result.push(pattern.searchPath);
        searchPathMap[key] = "included";
      }
    }
    return result;
  }
  exports.getSearchPaths = getSearchPaths;
  function match(patterns, itemPath) {
    let result = internal_match_kind_1.MatchKind.None;
    for (const pattern of patterns) {
      if (pattern.negate) {
        result &= ~pattern.match(itemPath);
      } else {
        result |= pattern.match(itemPath);
      }
    }
    return result;
  }
  exports.match = match;
  function partialMatch(patterns, itemPath) {
    return patterns.some((x2) => !x2.negate && x2.partialMatch(itemPath));
  }
  exports.partialMatch = partialMatch;
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS((exports, module) => {
  module.exports = function(xs, fn2) {
    var res = [];
    for (var i2 = 0;i2 < xs.length; i2++) {
      var x2 = fn2(xs[i2], i2);
      if (isArray(x2))
        res.push.apply(res, x2);
      else
        res.push(x2);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS((exports, module) => {
  module.exports = balanced;
  function balanced(a2, b2, str) {
    if (a2 instanceof RegExp)
      a2 = maybeMatch(a2, str);
    if (b2 instanceof RegExp)
      b2 = maybeMatch(b2, str);
    var r2 = range(a2, b2, str);
    return r2 && {
      start: r2[0],
      end: r2[1],
      pre: str.slice(0, r2[0]),
      body: str.slice(r2[0] + a2.length, r2[1]),
      post: str.slice(r2[1] + b2.length)
    };
  }
  function maybeMatch(reg, str) {
    var m2 = str.match(reg);
    return m2 ? m2[0] : null;
  }
  balanced.range = range;
  function range(a2, b2, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a2);
    var bi = str.indexOf(b2, ai + 1);
    var i2 = ai;
    if (ai >= 0 && bi > 0) {
      if (a2 === b2) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i2 >= 0 && !result) {
        if (i2 == ai) {
          begs.push(i2);
          ai = str.indexOf(a2, i2 + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b2, i2 + 1);
        }
        i2 = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS((exports, module) => {
  var concatMap = require_concat_map();
  var balanced = require_balanced_match();
  module.exports = expandTop;
  var escSlash = "\x00SLASH" + Math.random() + "\x00";
  var escOpen = "\x00OPEN" + Math.random() + "\x00";
  var escClose = "\x00CLOSE" + Math.random() + "\x00";
  var escComma = "\x00COMMA" + Math.random() + "\x00";
  var escPeriod = "\x00PERIOD" + Math.random() + "\x00";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m2 = balanced("{", "}", str);
    if (!m2)
      return str.split(",");
    var pre = m2.pre;
    var body = m2.body;
    var post = m2.post;
    var p2 = pre.split(",");
    p2[p2.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p2[p2.length - 1] += postParts.shift();
      p2.push.apply(p2, postParts);
    }
    parts.push.apply(parts, p2);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand7(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i2, y2) {
    return i2 <= y2;
  }
  function gte(i2, y2) {
    return i2 >= y2;
  }
  function expand7(str, isTop) {
    var expansions = [];
    var m2 = balanced("{", "}", str);
    if (!m2 || /\$$/.test(m2.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m2.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m2.post.match(/,.*\}/)) {
        str = m2.pre + "{" + m2.body + escClose + m2.post;
        return expand7(str);
      }
      return [str];
    }
    var n2;
    if (isSequence) {
      n2 = m2.body.split(/\.\./);
    } else {
      n2 = parseCommaParts(m2.body);
      if (n2.length === 1) {
        n2 = expand7(n2[0], false).map(embrace);
        if (n2.length === 1) {
          var post = m2.post.length ? expand7(m2.post, false) : [""];
          return post.map(function(p2) {
            return m2.pre + n2[0] + p2;
          });
        }
      }
    }
    var pre = m2.pre;
    var post = m2.post.length ? expand7(m2.post, false) : [""];
    var N2;
    if (isSequence) {
      var x2 = numeric(n2[0]);
      var y2 = numeric(n2[1]);
      var width = Math.max(n2[0].length, n2[1].length);
      var incr = n2.length == 3 ? Math.abs(numeric(n2[2])) : 1;
      var test = lte;
      var reverse = y2 < x2;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n2.some(isPadded);
      N2 = [];
      for (var i2 = x2;test(i2, y2); i2 += incr) {
        var c2;
        if (isAlphaSequence) {
          c2 = String.fromCharCode(i2);
          if (c2 === "\\")
            c2 = "";
        } else {
          c2 = String(i2);
          if (pad) {
            var need = width - c2.length;
            if (need > 0) {
              var z2 = new Array(need + 1).join("0");
              if (i2 < 0)
                c2 = "-" + z2 + c2.slice(1);
              else
                c2 = z2 + c2;
            }
          }
        }
        N2.push(c2);
      }
    } else {
      N2 = concatMap(n2, function(el) {
        return expand7(el, false);
      });
    }
    for (var j2 = 0;j2 < N2.length; j2++) {
      for (var k2 = 0;k2 < post.length; k2++) {
        var expansion = pre + N2[j2] + post[k2];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS((exports, module) => {
  module.exports = minimatch;
  minimatch.Minimatch = Minimatch;
  var path2 = function() {
    try {
      return __require("path");
    } catch (e2) {
    }
  }() || {
    sep: "/"
  };
  minimatch.sep = path2.sep;
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand7 = require_brace_expansion();
  var plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s2) {
    return s2.split("").reduce(function(set3, c2) {
      set3[c2] = true;
      return set3;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch.filter = filter;
  function filter(pattern, options) {
    options = options || {};
    return function(p2, i2, list) {
      return minimatch(p2, pattern, options);
    };
  }
  function ext(a2, b2) {
    b2 = b2 || {};
    var t2 = {};
    Object.keys(a2).forEach(function(k2) {
      t2[k2] = a2[k2];
    });
    Object.keys(b2).forEach(function(k2) {
      t2[k2] = b2[k2];
    });
    return t2;
  }
  minimatch.defaults = function(def) {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    var orig = minimatch;
    var m2 = function minimatch(p2, pattern, options) {
      return orig(p2, pattern, ext(def, options));
    };
    m2.Minimatch = function Minimatch(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    };
    m2.Minimatch.defaults = function defaults(options) {
      return orig.defaults(ext(def, options)).Minimatch;
    };
    m2.filter = function filter(pattern, options) {
      return orig.filter(pattern, ext(def, options));
    };
    m2.defaults = function defaults(options) {
      return orig.defaults(ext(def, options));
    };
    m2.makeRe = function makeRe(pattern, options) {
      return orig.makeRe(pattern, ext(def, options));
    };
    m2.braceExpand = function braceExpand(pattern, options) {
      return orig.braceExpand(pattern, ext(def, options));
    };
    m2.match = function(list, pattern, options) {
      return orig.match(list, pattern, ext(def, options));
    };
    return m2;
  };
  Minimatch.defaults = function(def) {
    return minimatch.defaults(def).Minimatch;
  };
  function minimatch(p2, pattern, options) {
    assertValidPattern(pattern);
    if (!options)
      options = {};
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options).match(p2);
  }
  function Minimatch(pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options);
    }
    assertValidPattern(pattern);
    if (!options)
      options = {};
    pattern = pattern.trim();
    if (!options.allowWindowsEscape && path2.sep !== "/") {
      pattern = pattern.split(path2.sep).join("/");
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.make();
  }
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    var pattern = this.pattern;
    var options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set3 = this.globSet = this.braceExpand();
    if (options.debug)
      this.debug = function debug() {
        console.error.apply(console, arguments);
      };
    this.debug(this.pattern, set3);
    set3 = this.globParts = set3.map(function(s2) {
      return s2.split(slashSplit);
    });
    this.debug(this.pattern, set3);
    set3 = set3.map(function(s2, si, set4) {
      return s2.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set3);
    set3 = set3.filter(function(s2) {
      return s2.indexOf(false) === -1;
    });
    this.debug(this.pattern, set3);
    this.set = set3;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate)
      return;
    for (var i2 = 0, l2 = pattern.length;i2 < l2 && pattern.charAt(i2) === "!"; i2++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options) {
    if (!options) {
      if (this instanceof Minimatch) {
        options = this.options;
      } else {
        options = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    assertValidPattern(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return expand7(pattern);
  }
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = function(pattern) {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  Minimatch.prototype.parse = parse11;
  var SUBPARSE = {};
  function parse11(pattern, isSub) {
    assertValidPattern(pattern);
    var options = this.options;
    if (pattern === "**") {
      if (!options.noglobstar)
        return GLOBSTAR;
      else
        pattern = "*";
    }
    if (pattern === "")
      return "";
    var re2 = "";
    var hasMagic = !!options.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re2 += star;
            hasMagic = true;
            break;
          case "?":
            re2 += qmark;
            hasMagic = true;
            break;
          default:
            re2 += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re2);
        stateChar = false;
      }
    }
    for (var i2 = 0, len = pattern.length, c2;i2 < len && (c2 = pattern.charAt(i2)); i2++) {
      this.debug("%s\t%s %s %j", pattern, i2, re2, c2);
      if (escaping && reSpecials[c2]) {
        re2 += "\\" + c2;
        escaping = false;
        continue;
      }
      switch (c2) {
        case "/": {
          return false;
        }
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s\t%s %s %j <-- stateChar", pattern, i2, re2, c2);
          if (inClass) {
            this.debug("  in class");
            if (c2 === "!" && i2 === classStart + 1)
              c2 = "^";
            re2 += c2;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c2;
          if (options.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re2 += "(";
            continue;
          }
          if (!stateChar) {
            re2 += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i2 - 1,
            reStart: re2.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re2 += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re2);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re2 += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re2 += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re2.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re2 += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re2 += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re2 += "\\" + c2;
            continue;
          }
          inClass = true;
          classStart = i2;
          reClassStart = re2.length;
          re2 += c2;
          continue;
        case "]":
          if (i2 === classStart + 1 || !inClass) {
            re2 += "\\" + c2;
            escaping = false;
            continue;
          }
          var cs = pattern.substring(classStart + 1, i2);
          try {
            RegExp("[" + cs + "]");
          } catch (er) {
            var sp = this.parse(cs, SUBPARSE);
            re2 = re2.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }
          hasMagic = true;
          inClass = false;
          re2 += c2;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c2] && !(c2 === "^" && inClass)) {
            re2 += "\\";
          }
          re2 += c2;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re2 = re2.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop();pl; pl = patternListStack.pop()) {
      var tail = re2.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re2, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug(`tail=%j
   %s`, tail, tail, pl, re2);
      var t2 = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re2 = re2.slice(0, pl.reStart) + t2 + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re2 += "\\\\";
    }
    var addPatternStart = false;
    switch (re2.charAt(0)) {
      case "[":
      case ".":
      case "(":
        addPatternStart = true;
    }
    for (var n2 = negativeLists.length - 1;n2 > -1; n2--) {
      var nl = negativeLists[n2];
      var nlBefore = re2.slice(0, nl.reStart);
      var nlFirst = re2.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re2.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re2.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i2 = 0;i2 < openParensBefore; i2++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re2 = newRe;
    }
    if (re2 !== "" && hasMagic) {
      re2 = "(?=.)" + re2;
    }
    if (addPatternStart) {
      re2 = patternStart + re2;
    }
    if (isSub === SUBPARSE) {
      return [re2, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re2 + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re2;
    return regExp;
  }
  minimatch.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set3 = this.set;
    if (!set3.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? "i" : "";
    var re2 = set3.map(function(pattern) {
      return pattern.map(function(p2) {
        return p2 === GLOBSTAR ? twoStar : typeof p2 === "string" ? regExpEscape(p2) : p2._src;
      }).join("\\/");
    }).join("|");
    re2 = "^(?:" + re2 + ")$";
    if (this.negate)
      re2 = "^(?!" + re2 + ").*$";
    try {
      this.regexp = new RegExp(re2, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch.match = function(list, pattern, options) {
    options = options || {};
    var mm = new Minimatch(pattern, options);
    list = list.filter(function(f2) {
      return mm.match(f2);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = function match(f2, partial) {
    if (typeof partial === "undefined")
      partial = this.partial;
    this.debug("match", f2, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f2 === "";
    if (f2 === "/" && partial)
      return true;
    var options = this.options;
    if (path2.sep !== "/") {
      f2 = f2.split(path2.sep).join("/");
    }
    f2 = f2.split(slashSplit);
    this.debug(this.pattern, "split", f2);
    var set3 = this.set;
    this.debug(this.pattern, "set", set3);
    var filename;
    var i2;
    for (i2 = f2.length - 1;i2 >= 0; i2--) {
      filename = f2[i2];
      if (filename)
        break;
    }
    for (i2 = 0;i2 < set3.length; i2++) {
      var pattern = set3[i2];
      var file = f2;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options.flipNegate)
      return false;
    return this.negate;
  };
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug("matchOne", { this: this, file, pattern });
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length;fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p2 = pattern[pi];
      var f2 = file[fi];
      this.debug(pattern, p2, f2);
      if (p2 === false)
        return false;
      if (p2 === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p2, f2]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (;fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug(`
globstar while`, file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug(`
>>> no match, partial?`, file, fr, pattern, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p2 === "string") {
        hit = f2 === p2;
        this.debug("string match", p2, f2, hit);
      } else {
        hit = f2.match(p2);
        this.debug("pattern match", p2, f2, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    }
    throw new Error("wtf?");
  };
  function globUnescape(s2) {
    return s2.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s2) {
    return s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
});

// node_modules/@actions/glob/lib/internal-path.js
var require_internal_path = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault2 = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Path = undefined;
  var path2 = __importStar2(__require("path"));
  var pathHelper = __importStar2(require_internal_path_helper());
  var assert_1 = __importDefault2(__require("assert"));
  var IS_WINDOWS = process.platform === "win32";

  class Path {
    constructor(itemPath) {
      this.segments = [];
      if (typeof itemPath === "string") {
        assert_1.default(itemPath, `Parameter 'itemPath' must not be empty`);
        itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
        if (!pathHelper.hasRoot(itemPath)) {
          this.segments = itemPath.split(path2.sep);
        } else {
          let remaining = itemPath;
          let dir = pathHelper.dirname(remaining);
          while (dir !== remaining) {
            const basename5 = path2.basename(remaining);
            this.segments.unshift(basename5);
            remaining = dir;
            dir = pathHelper.dirname(remaining);
          }
          this.segments.unshift(remaining);
        }
      } else {
        assert_1.default(itemPath.length > 0, `Parameter 'itemPath' must not be an empty array`);
        for (let i2 = 0;i2 < itemPath.length; i2++) {
          let segment = itemPath[i2];
          assert_1.default(segment, `Parameter 'itemPath' must not contain any empty segments`);
          segment = pathHelper.normalizeSeparators(itemPath[i2]);
          if (i2 === 0 && pathHelper.hasRoot(segment)) {
            segment = pathHelper.safeTrimTrailingSeparator(segment);
            assert_1.default(segment === pathHelper.dirname(segment), `Parameter 'itemPath' root segment contains information for multiple segments`);
            this.segments.push(segment);
          } else {
            assert_1.default(!segment.includes(path2.sep), `Parameter 'itemPath' contains unexpected path separators`);
            this.segments.push(segment);
          }
        }
      }
    }
    toString() {
      let result = this.segments[0];
      let skipSlash = result.endsWith(path2.sep) || IS_WINDOWS && /^[A-Z]:$/i.test(result);
      for (let i2 = 1;i2 < this.segments.length; i2++) {
        if (skipSlash) {
          skipSlash = false;
        } else {
          result += path2.sep;
        }
        result += this.segments[i2];
      }
      return result;
    }
  }
  exports.Path = Path;
});

// node_modules/@actions/glob/lib/internal-pattern.js
var require_internal_pattern = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __importDefault2 = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Pattern = undefined;
  var os3 = __importStar2(__require("os"));
  var path2 = __importStar2(__require("path"));
  var pathHelper = __importStar2(require_internal_path_helper());
  var assert_1 = __importDefault2(__require("assert"));
  var minimatch_1 = require_minimatch();
  var internal_match_kind_1 = require_internal_match_kind();
  var internal_path_1 = require_internal_path();
  var IS_WINDOWS = process.platform === "win32";

  class Pattern {
    constructor(patternOrNegate, isImplicitPattern = false, segments, homedir) {
      this.negate = false;
      let pattern;
      if (typeof patternOrNegate === "string") {
        pattern = patternOrNegate.trim();
      } else {
        segments = segments || [];
        assert_1.default(segments.length, `Parameter 'segments' must not empty`);
        const root = Pattern.getLiteral(segments[0]);
        assert_1.default(root && pathHelper.hasAbsoluteRoot(root), `Parameter 'segments' first element must be a root path`);
        pattern = new internal_path_1.Path(segments).toString().trim();
        if (patternOrNegate) {
          pattern = `!${pattern}`;
        }
      }
      while (pattern.startsWith("!")) {
        this.negate = !this.negate;
        pattern = pattern.substr(1).trim();
      }
      pattern = Pattern.fixupPattern(pattern, homedir);
      this.segments = new internal_path_1.Path(pattern).segments;
      this.trailingSeparator = pathHelper.normalizeSeparators(pattern).endsWith(path2.sep);
      pattern = pathHelper.safeTrimTrailingSeparator(pattern);
      let foundGlob = false;
      const searchSegments = this.segments.map((x2) => Pattern.getLiteral(x2)).filter((x2) => !foundGlob && !(foundGlob = x2 === ""));
      this.searchPath = new internal_path_1.Path(searchSegments).toString();
      this.rootRegExp = new RegExp(Pattern.regExpEscape(searchSegments[0]), IS_WINDOWS ? "i" : "");
      this.isImplicitPattern = isImplicitPattern;
      const minimatchOptions = {
        dot: true,
        nobrace: true,
        nocase: IS_WINDOWS,
        nocomment: true,
        noext: true,
        nonegate: true
      };
      pattern = IS_WINDOWS ? pattern.replace(/\\/g, "/") : pattern;
      this.minimatch = new minimatch_1.Minimatch(pattern, minimatchOptions);
    }
    match(itemPath) {
      if (this.segments[this.segments.length - 1] === "**") {
        itemPath = pathHelper.normalizeSeparators(itemPath);
        if (!itemPath.endsWith(path2.sep) && this.isImplicitPattern === false) {
          itemPath = `${itemPath}${path2.sep}`;
        }
      } else {
        itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
      }
      if (this.minimatch.match(itemPath)) {
        return this.trailingSeparator ? internal_match_kind_1.MatchKind.Directory : internal_match_kind_1.MatchKind.All;
      }
      return internal_match_kind_1.MatchKind.None;
    }
    partialMatch(itemPath) {
      itemPath = pathHelper.safeTrimTrailingSeparator(itemPath);
      if (pathHelper.dirname(itemPath) === itemPath) {
        return this.rootRegExp.test(itemPath);
      }
      return this.minimatch.matchOne(itemPath.split(IS_WINDOWS ? /\\+/ : /\/+/), this.minimatch.set[0], true);
    }
    static globEscape(s2) {
      return (IS_WINDOWS ? s2 : s2.replace(/\\/g, "\\\\")).replace(/(\[)(?=[^/]+\])/g, "[[]").replace(/\?/g, "[?]").replace(/\*/g, "[*]");
    }
    static fixupPattern(pattern, homedir) {
      assert_1.default(pattern, "pattern cannot be empty");
      const literalSegments = new internal_path_1.Path(pattern).segments.map((x2) => Pattern.getLiteral(x2));
      assert_1.default(literalSegments.every((x2, i2) => (x2 !== "." || i2 === 0) && x2 !== ".."), `Invalid pattern '${pattern}'. Relative pathing '.' and '..' is not allowed.`);
      assert_1.default(!pathHelper.hasRoot(pattern) || literalSegments[0], `Invalid pattern '${pattern}'. Root segment must not contain globs.`);
      pattern = pathHelper.normalizeSeparators(pattern);
      if (pattern === "." || pattern.startsWith(`.${path2.sep}`)) {
        pattern = Pattern.globEscape(process.cwd()) + pattern.substr(1);
      } else if (pattern === "~" || pattern.startsWith(`~${path2.sep}`)) {
        homedir = homedir || os3.homedir();
        assert_1.default(homedir, "Unable to determine HOME directory");
        assert_1.default(pathHelper.hasAbsoluteRoot(homedir), `Expected HOME directory to be a rooted path. Actual '${homedir}'`);
        pattern = Pattern.globEscape(homedir) + pattern.substr(1);
      } else if (IS_WINDOWS && (pattern.match(/^[A-Z]:$/i) || pattern.match(/^[A-Z]:[^\\]/i))) {
        let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", pattern.substr(0, 2));
        if (pattern.length > 2 && !root.endsWith("\\")) {
          root += "\\";
        }
        pattern = Pattern.globEscape(root) + pattern.substr(2);
      } else if (IS_WINDOWS && (pattern === "\\" || pattern.match(/^\\[^\\]/))) {
        let root = pathHelper.ensureAbsoluteRoot("C:\\dummy-root", "\\");
        if (!root.endsWith("\\")) {
          root += "\\";
        }
        pattern = Pattern.globEscape(root) + pattern.substr(1);
      } else {
        pattern = pathHelper.ensureAbsoluteRoot(Pattern.globEscape(process.cwd()), pattern);
      }
      return pathHelper.normalizeSeparators(pattern);
    }
    static getLiteral(segment) {
      let literal = "";
      for (let i2 = 0;i2 < segment.length; i2++) {
        const c2 = segment[i2];
        if (c2 === "\\" && !IS_WINDOWS && i2 + 1 < segment.length) {
          literal += segment[++i2];
          continue;
        } else if (c2 === "*" || c2 === "?") {
          return "";
        } else if (c2 === "[" && i2 + 1 < segment.length) {
          let set3 = "";
          let closed = -1;
          for (let i22 = i2 + 1;i22 < segment.length; i22++) {
            const c22 = segment[i22];
            if (c22 === "\\" && !IS_WINDOWS && i22 + 1 < segment.length) {
              set3 += segment[++i22];
              continue;
            } else if (c22 === "]") {
              closed = i22;
              break;
            } else {
              set3 += c22;
            }
          }
          if (closed >= 0) {
            if (set3.length > 1) {
              return "";
            }
            if (set3) {
              literal += set3;
              i2 = closed;
              continue;
            }
          }
        }
        literal += c2;
      }
      return literal;
    }
    static regExpEscape(s2) {
      return s2.replace(/[[\\^$.|?*+()]/g, "\\$&");
    }
  }
  exports.Pattern = Pattern;
});

// node_modules/@actions/glob/lib/internal-search-state.js
var require_internal_search_state = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SearchState = undefined;

  class SearchState {
    constructor(path2, level) {
      this.path = path2;
      this.level = level;
    }
  }
  exports.SearchState = SearchState;
});

// node_modules/@actions/glob/lib/internal-globber.js
var require_internal_globber = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve5, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __asyncValues2 = exports && exports.__asyncValues || function(o2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o2[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n2) {
      i2[n2] = o2[n2] && function(v2) {
        return new Promise(function(resolve5, reject) {
          v2 = o2[n2](v2), settle(resolve5, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve5, reject, d2, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve5({ value: v3, done: d2 });
      }, reject);
    }
  };
  var __await2 = exports && exports.__await || function(v2) {
    return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
  };
  var __asyncGenerator2 = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function verb(n2) {
      if (g2[n2])
        i2[n2] = function(v2) {
          return new Promise(function(a2, b2) {
            q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
          });
        };
    }
    function resume(n2, v2) {
      try {
        step(g2[n2](v2));
      } catch (e2) {
        settle(q2[0][3], e2);
      }
    }
    function step(r2) {
      r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f2, v2) {
      if (f2(v2), q2.shift(), q2.length)
        resume(q2[0][0], q2[0][1]);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultGlobber = undefined;
  var core = __importStar2(require_core());
  var fs2 = __importStar2(__require("fs"));
  var globOptionsHelper = __importStar2(require_internal_glob_options_helper());
  var path2 = __importStar2(__require("path"));
  var patternHelper = __importStar2(require_internal_pattern_helper());
  var internal_match_kind_1 = require_internal_match_kind();
  var internal_pattern_1 = require_internal_pattern();
  var internal_search_state_1 = require_internal_search_state();
  var IS_WINDOWS = process.platform === "win32";

  class DefaultGlobber {
    constructor(options) {
      this.patterns = [];
      this.searchPaths = [];
      this.options = globOptionsHelper.getOptions(options);
    }
    getSearchPaths() {
      return this.searchPaths.slice();
    }
    glob() {
      var e_1, _a3;
      return __awaiter2(this, undefined, undefined, function* () {
        const result = [];
        try {
          for (var _b2 = __asyncValues2(this.globGenerator()), _c2;_c2 = yield _b2.next(), !_c2.done; ) {
            const itemPath = _c2.value;
            result.push(itemPath);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a3 = _b2.return))
              yield _a3.call(_b2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return result;
      });
    }
    globGenerator() {
      return __asyncGenerator2(this, arguments, function* globGenerator_1() {
        const options = globOptionsHelper.getOptions(this.options);
        const patterns = [];
        for (const pattern of this.patterns) {
          patterns.push(pattern);
          if (options.implicitDescendants && (pattern.trailingSeparator || pattern.segments[pattern.segments.length - 1] !== "**")) {
            patterns.push(new internal_pattern_1.Pattern(pattern.negate, true, pattern.segments.concat("**")));
          }
        }
        const stack = [];
        for (const searchPath of patternHelper.getSearchPaths(patterns)) {
          core.debug(`Search path '${searchPath}'`);
          try {
            yield __await2(fs2.promises.lstat(searchPath));
          } catch (err) {
            if (err.code === "ENOENT") {
              continue;
            }
            throw err;
          }
          stack.unshift(new internal_search_state_1.SearchState(searchPath, 1));
        }
        const traversalChain = [];
        while (stack.length) {
          const item = stack.pop();
          const match = patternHelper.match(patterns, item.path);
          const partialMatch = !!match || patternHelper.partialMatch(patterns, item.path);
          if (!match && !partialMatch) {
            continue;
          }
          const stats = yield __await2(DefaultGlobber.stat(item, options, traversalChain));
          if (!stats) {
            continue;
          }
          if (stats.isDirectory()) {
            if (match & internal_match_kind_1.MatchKind.Directory) {
              yield yield __await2(item.path);
            } else if (!partialMatch) {
              continue;
            }
            const childLevel = item.level + 1;
            const childItems = (yield __await2(fs2.promises.readdir(item.path))).map((x2) => new internal_search_state_1.SearchState(path2.join(item.path, x2), childLevel));
            stack.push(...childItems.reverse());
          } else if (match & internal_match_kind_1.MatchKind.File) {
            yield yield __await2(item.path);
          }
        }
      });
    }
    static create(patterns, options) {
      return __awaiter2(this, undefined, undefined, function* () {
        const result = new DefaultGlobber(options);
        if (IS_WINDOWS) {
          patterns = patterns.replace(/\r\n/g, `
`);
          patterns = patterns.replace(/\r/g, `
`);
        }
        const lines = patterns.split(`
`).map((x2) => x2.trim());
        for (const line of lines) {
          if (!line || line.startsWith("#")) {
            continue;
          } else {
            result.patterns.push(new internal_pattern_1.Pattern(line));
          }
        }
        result.searchPaths.push(...patternHelper.getSearchPaths(result.patterns));
        return result;
      });
    }
    static stat(item, options, traversalChain) {
      return __awaiter2(this, undefined, undefined, function* () {
        let stats;
        if (options.followSymbolicLinks) {
          try {
            stats = yield fs2.promises.stat(item.path);
          } catch (err) {
            if (err.code === "ENOENT") {
              if (options.omitBrokenSymbolicLinks) {
                core.debug(`Broken symlink '${item.path}'`);
                return;
              }
              throw new Error(`No information found for the path '${item.path}'. This may indicate a broken symbolic link.`);
            }
            throw err;
          }
        } else {
          stats = yield fs2.promises.lstat(item.path);
        }
        if (stats.isDirectory() && options.followSymbolicLinks) {
          const realPath = yield fs2.promises.realpath(item.path);
          while (traversalChain.length >= item.level) {
            traversalChain.pop();
          }
          if (traversalChain.some((x2) => x2 === realPath)) {
            core.debug(`Symlink cycle detected for path '${item.path}' and realpath '${realPath}'`);
            return;
          }
          traversalChain.push(realPath);
        }
        return stats;
      });
    }
  }
  exports.DefaultGlobber = DefaultGlobber;
});

// node_modules/@actions/glob/lib/glob.js
var require_glob = __commonJS((exports) => {
  var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve5, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.create = undefined;
  var internal_globber_1 = require_internal_globber();
  function create(patterns, options) {
    return __awaiter2(this, undefined, undefined, function* () {
      return yield internal_globber_1.DefaultGlobber.create(patterns, options);
    });
  }
  exports.create = create;
});

// node_modules/semver/semver.js
var require_semver = __commonJS((exports, module) => {
  exports = module.exports = SemVer;
  var debug;
  if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
    debug = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      args.unshift("SEMVER");
      console.log.apply(console, args);
    };
  } else {
    debug = function() {
    };
  }
  exports.SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var re2 = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var t2 = exports.tokens = {};
  var R2 = 0;
  function tok(n2) {
    t2[n2] = R2++;
  }
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  function makeSafeRe(value) {
    for (var i3 = 0;i3 < safeRegexReplacements.length; i3++) {
      var token = safeRegexReplacements[i3][0];
      var max = safeRegexReplacements[i3][1];
      value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
    }
    return value;
  }
  tok("NUMERICIDENTIFIER");
  src[t2.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  tok("NUMERICIDENTIFIERLOOSE");
  src[t2.NUMERICIDENTIFIERLOOSE] = "\\d+";
  tok("NONNUMERICIDENTIFIER");
  src[t2.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
  tok("MAINVERSION");
  src[t2.MAINVERSION] = "(" + src[t2.NUMERICIDENTIFIER] + ")\\." + "(" + src[t2.NUMERICIDENTIFIER] + ")\\." + "(" + src[t2.NUMERICIDENTIFIER] + ")";
  tok("MAINVERSIONLOOSE");
  src[t2.MAINVERSIONLOOSE] = "(" + src[t2.NUMERICIDENTIFIERLOOSE] + ")\\." + "(" + src[t2.NUMERICIDENTIFIERLOOSE] + ")\\." + "(" + src[t2.NUMERICIDENTIFIERLOOSE] + ")";
  tok("PRERELEASEIDENTIFIER");
  src[t2.PRERELEASEIDENTIFIER] = "(?:" + src[t2.NUMERICIDENTIFIER] + "|" + src[t2.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASEIDENTIFIERLOOSE");
  src[t2.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t2.NUMERICIDENTIFIERLOOSE] + "|" + src[t2.NONNUMERICIDENTIFIER] + ")";
  tok("PRERELEASE");
  src[t2.PRERELEASE] = "(?:-(" + src[t2.PRERELEASEIDENTIFIER] + "(?:\\." + src[t2.PRERELEASEIDENTIFIER] + ")*))";
  tok("PRERELEASELOOSE");
  src[t2.PRERELEASELOOSE] = "(?:-?(" + src[t2.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t2.PRERELEASEIDENTIFIERLOOSE] + ")*))";
  tok("BUILDIDENTIFIER");
  src[t2.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
  tok("BUILD");
  src[t2.BUILD] = "(?:\\+(" + src[t2.BUILDIDENTIFIER] + "(?:\\." + src[t2.BUILDIDENTIFIER] + ")*))";
  tok("FULL");
  tok("FULLPLAIN");
  src[t2.FULLPLAIN] = "v?" + src[t2.MAINVERSION] + src[t2.PRERELEASE] + "?" + src[t2.BUILD] + "?";
  src[t2.FULL] = "^" + src[t2.FULLPLAIN] + "$";
  tok("LOOSEPLAIN");
  src[t2.LOOSEPLAIN] = "[v=\\s]*" + src[t2.MAINVERSIONLOOSE] + src[t2.PRERELEASELOOSE] + "?" + src[t2.BUILD] + "?";
  tok("LOOSE");
  src[t2.LOOSE] = "^" + src[t2.LOOSEPLAIN] + "$";
  tok("GTLT");
  src[t2.GTLT] = "((?:<|>)?=?)";
  tok("XRANGEIDENTIFIERLOOSE");
  src[t2.XRANGEIDENTIFIERLOOSE] = src[t2.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  tok("XRANGEIDENTIFIER");
  src[t2.XRANGEIDENTIFIER] = src[t2.NUMERICIDENTIFIER] + "|x|X|\\*";
  tok("XRANGEPLAIN");
  src[t2.XRANGEPLAIN] = "[v=\\s]*(" + src[t2.XRANGEIDENTIFIER] + ")" + "(?:\\.(" + src[t2.XRANGEIDENTIFIER] + ")" + "(?:\\.(" + src[t2.XRANGEIDENTIFIER] + ")" + "(?:" + src[t2.PRERELEASE] + ")?" + src[t2.BUILD] + "?" + ")?)?";
  tok("XRANGEPLAINLOOSE");
  src[t2.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t2.XRANGEIDENTIFIERLOOSE] + ")" + "(?:\\.(" + src[t2.XRANGEIDENTIFIERLOOSE] + ")" + "(?:\\.(" + src[t2.XRANGEIDENTIFIERLOOSE] + ")" + "(?:" + src[t2.PRERELEASELOOSE] + ")?" + src[t2.BUILD] + "?" + ")?)?";
  tok("XRANGE");
  src[t2.XRANGE] = "^" + src[t2.GTLT] + "\\s*" + src[t2.XRANGEPLAIN] + "$";
  tok("XRANGELOOSE");
  src[t2.XRANGELOOSE] = "^" + src[t2.GTLT] + "\\s*" + src[t2.XRANGEPLAINLOOSE] + "$";
  tok("COERCE");
  src[t2.COERCE] = "(^|[^\\d])" + "(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})" + "(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?" + "(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?" + "(?:$|[^\\d])";
  tok("COERCERTL");
  re2[t2.COERCERTL] = new RegExp(src[t2.COERCE], "g");
  safeRe[t2.COERCERTL] = new RegExp(makeSafeRe(src[t2.COERCE]), "g");
  tok("LONETILDE");
  src[t2.LONETILDE] = "(?:~>?)";
  tok("TILDETRIM");
  src[t2.TILDETRIM] = "(\\s*)" + src[t2.LONETILDE] + "\\s+";
  re2[t2.TILDETRIM] = new RegExp(src[t2.TILDETRIM], "g");
  safeRe[t2.TILDETRIM] = new RegExp(makeSafeRe(src[t2.TILDETRIM]), "g");
  var tildeTrimReplace = "$1~";
  tok("TILDE");
  src[t2.TILDE] = "^" + src[t2.LONETILDE] + src[t2.XRANGEPLAIN] + "$";
  tok("TILDELOOSE");
  src[t2.TILDELOOSE] = "^" + src[t2.LONETILDE] + src[t2.XRANGEPLAINLOOSE] + "$";
  tok("LONECARET");
  src[t2.LONECARET] = "(?:\\^)";
  tok("CARETTRIM");
  src[t2.CARETTRIM] = "(\\s*)" + src[t2.LONECARET] + "\\s+";
  re2[t2.CARETTRIM] = new RegExp(src[t2.CARETTRIM], "g");
  safeRe[t2.CARETTRIM] = new RegExp(makeSafeRe(src[t2.CARETTRIM]), "g");
  var caretTrimReplace = "$1^";
  tok("CARET");
  src[t2.CARET] = "^" + src[t2.LONECARET] + src[t2.XRANGEPLAIN] + "$";
  tok("CARETLOOSE");
  src[t2.CARETLOOSE] = "^" + src[t2.LONECARET] + src[t2.XRANGEPLAINLOOSE] + "$";
  tok("COMPARATORLOOSE");
  src[t2.COMPARATORLOOSE] = "^" + src[t2.GTLT] + "\\s*(" + src[t2.LOOSEPLAIN] + ")$|^$";
  tok("COMPARATOR");
  src[t2.COMPARATOR] = "^" + src[t2.GTLT] + "\\s*(" + src[t2.FULLPLAIN] + ")$|^$";
  tok("COMPARATORTRIM");
  src[t2.COMPARATORTRIM] = "(\\s*)" + src[t2.GTLT] + "\\s*(" + src[t2.LOOSEPLAIN] + "|" + src[t2.XRANGEPLAIN] + ")";
  re2[t2.COMPARATORTRIM] = new RegExp(src[t2.COMPARATORTRIM], "g");
  safeRe[t2.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t2.COMPARATORTRIM]), "g");
  var comparatorTrimReplace = "$1$2$3";
  tok("HYPHENRANGE");
  src[t2.HYPHENRANGE] = "^\\s*(" + src[t2.XRANGEPLAIN] + ")" + "\\s+-\\s+" + "(" + src[t2.XRANGEPLAIN] + ")" + "\\s*$";
  tok("HYPHENRANGELOOSE");
  src[t2.HYPHENRANGELOOSE] = "^\\s*(" + src[t2.XRANGEPLAINLOOSE] + ")" + "\\s+-\\s+" + "(" + src[t2.XRANGEPLAINLOOSE] + ")" + "\\s*$";
  tok("STAR");
  src[t2.STAR] = "(<|>)?=?\\s*\\*";
  for (i2 = 0;i2 < R2; i2++) {
    debug(i2, src[i2]);
    if (!re2[i2]) {
      re2[i2] = new RegExp(src[i2]);
      safeRe[i2] = new RegExp(makeSafeRe(src[i2]));
    }
  }
  var i2;
  exports.parse = parse11;
  function parse11(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version !== "string") {
      return null;
    }
    if (version.length > MAX_LENGTH) {
      return null;
    }
    var r2 = options.loose ? safeRe[t2.LOOSE] : safeRe[t2.FULL];
    if (!r2.test(version)) {
      return null;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      return null;
    }
  }
  exports.valid = valid;
  function valid(version, options) {
    var v2 = parse11(version, options);
    return v2 ? v2.version : null;
  }
  exports.clean = clean;
  function clean(version, options) {
    var s2 = parse11(version.trim().replace(/^[=v]+/, ""), options);
    return s2 ? s2.version : null;
  }
  exports.SemVer = SemVer;
  function SemVer(version, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === options.loose) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== "string") {
      throw new TypeError("Invalid Version: " + version);
    }
    if (version.length > MAX_LENGTH) {
      throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
    }
    if (!(this instanceof SemVer)) {
      return new SemVer(version, options);
    }
    debug("SemVer", version, options);
    this.options = options;
    this.loose = !!options.loose;
    var m2 = version.trim().match(options.loose ? safeRe[t2.LOOSE] : safeRe[t2.FULL]);
    if (!m2) {
      throw new TypeError("Invalid Version: " + version);
    }
    this.raw = version;
    this.major = +m2[1];
    this.minor = +m2[2];
    this.patch = +m2[3];
    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError("Invalid major version");
    }
    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError("Invalid minor version");
    }
    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError("Invalid patch version");
    }
    if (!m2[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m2[4].split(".").map(function(id) {
        if (/^[0-9]+$/.test(id)) {
          var num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }
        return id;
      });
    }
    this.build = m2[5] ? m2[5].split(".") : [];
    this.format();
  }
  SemVer.prototype.format = function() {
    this.version = this.major + "." + this.minor + "." + this.patch;
    if (this.prerelease.length) {
      this.version += "-" + this.prerelease.join(".");
    }
    return this.version;
  };
  SemVer.prototype.toString = function() {
    return this.version;
  };
  SemVer.prototype.compare = function(other) {
    debug("SemVer.compare", this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return this.compareMain(other) || this.comparePre(other);
  };
  SemVer.prototype.compareMain = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  };
  SemVer.prototype.comparePre = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }
    var i3 = 0;
    do {
      var a2 = this.prerelease[i3];
      var b2 = other.prerelease[i3];
      debug("prerelease compare", i3, a2, b2);
      if (a2 === undefined && b2 === undefined) {
        return 0;
      } else if (b2 === undefined) {
        return 1;
      } else if (a2 === undefined) {
        return -1;
      } else if (a2 === b2) {
        continue;
      } else {
        return compareIdentifiers(a2, b2);
      }
    } while (++i3);
  };
  SemVer.prototype.compareBuild = function(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }
    var i3 = 0;
    do {
      var a2 = this.build[i3];
      var b2 = other.build[i3];
      debug("prerelease compare", i3, a2, b2);
      if (a2 === undefined && b2 === undefined) {
        return 0;
      } else if (b2 === undefined) {
        return 1;
      } else if (a2 === undefined) {
        return -1;
      } else if (a2 === b2) {
        continue;
      } else {
        return compareIdentifiers(a2, b2);
      }
    } while (++i3);
  };
  SemVer.prototype.inc = function(release3, identifier) {
    switch (release3) {
      case "premajor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc("pre", identifier);
        break;
      case "preminor":
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc("pre", identifier);
        break;
      case "prepatch":
        this.prerelease.length = 0;
        this.inc("patch", identifier);
        this.inc("pre", identifier);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) {
          this.inc("patch", identifier);
        }
        this.inc("pre", identifier);
        break;
      case "major":
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break;
      case "patch":
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          var i3 = this.prerelease.length;
          while (--i3 >= 0) {
            if (typeof this.prerelease[i3] === "number") {
              this.prerelease[i3]++;
              i3 = -2;
            }
          }
          if (i3 === -1) {
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break;
      default:
        throw new Error("invalid increment argument: " + release3);
    }
    this.format();
    this.raw = this.version;
    return this;
  };
  exports.inc = inc;
  function inc(version, release3, loose, identifier) {
    if (typeof loose === "string") {
      identifier = loose;
      loose = undefined;
    }
    try {
      return new SemVer(version, loose).inc(release3, identifier).version;
    } catch (er) {
      return null;
    }
  }
  exports.diff = diff;
  function diff(version1, version2) {
    if (eq(version1, version2)) {
      return null;
    } else {
      var v1 = parse11(version1);
      var v2 = parse11(version2);
      var prefix = "";
      if (v1.prerelease.length || v2.prerelease.length) {
        prefix = "pre";
        var defaultResult = "prerelease";
      }
      for (var key in v1) {
        if (key === "major" || key === "minor" || key === "patch") {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }
      return defaultResult;
    }
  }
  exports.compareIdentifiers = compareIdentifiers;
  var numeric = /^[0-9]+$/;
  function compareIdentifiers(a2, b2) {
    var anum = numeric.test(a2);
    var bnum = numeric.test(b2);
    if (anum && bnum) {
      a2 = +a2;
      b2 = +b2;
    }
    return a2 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b2 ? -1 : 1;
  }
  exports.rcompareIdentifiers = rcompareIdentifiers;
  function rcompareIdentifiers(a2, b2) {
    return compareIdentifiers(b2, a2);
  }
  exports.major = major;
  function major(a2, loose) {
    return new SemVer(a2, loose).major;
  }
  exports.minor = minor;
  function minor(a2, loose) {
    return new SemVer(a2, loose).minor;
  }
  exports.patch = patch;
  function patch(a2, loose) {
    return new SemVer(a2, loose).patch;
  }
  exports.compare = compare;
  function compare(a2, b2, loose) {
    return new SemVer(a2, loose).compare(new SemVer(b2, loose));
  }
  exports.compareLoose = compareLoose;
  function compareLoose(a2, b2) {
    return compare(a2, b2, true);
  }
  exports.compareBuild = compareBuild;
  function compareBuild(a2, b2, loose) {
    var versionA = new SemVer(a2, loose);
    var versionB = new SemVer(b2, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  }
  exports.rcompare = rcompare;
  function rcompare(a2, b2, loose) {
    return compare(b2, a2, loose);
  }
  exports.sort = sort;
  function sort(list, loose) {
    return list.sort(function(a2, b2) {
      return exports.compareBuild(a2, b2, loose);
    });
  }
  exports.rsort = rsort;
  function rsort(list, loose) {
    return list.sort(function(a2, b2) {
      return exports.compareBuild(b2, a2, loose);
    });
  }
  exports.gt = gt;
  function gt(a2, b2, loose) {
    return compare(a2, b2, loose) > 0;
  }
  exports.lt = lt;
  function lt(a2, b2, loose) {
    return compare(a2, b2, loose) < 0;
  }
  exports.eq = eq;
  function eq(a2, b2, loose) {
    return compare(a2, b2, loose) === 0;
  }
  exports.neq = neq;
  function neq(a2, b2, loose) {
    return compare(a2, b2, loose) !== 0;
  }
  exports.gte = gte;
  function gte(a2, b2, loose) {
    return compare(a2, b2, loose) >= 0;
  }
  exports.lte = lte;
  function lte(a2, b2, loose) {
    return compare(a2, b2, loose) <= 0;
  }
  exports.cmp = cmp;
  function cmp(a2, op, b2, loose) {
    switch (op) {
      case "===":
        if (typeof a2 === "object")
          a2 = a2.version;
        if (typeof b2 === "object")
          b2 = b2.version;
        return a2 === b2;
      case "!==":
        if (typeof a2 === "object")
          a2 = a2.version;
        if (typeof b2 === "object")
          b2 = b2.version;
        return a2 !== b2;
      case "":
      case "=":
      case "==":
        return eq(a2, b2, loose);
      case "!=":
        return neq(a2, b2, loose);
      case ">":
        return gt(a2, b2, loose);
      case ">=":
        return gte(a2, b2, loose);
      case "<":
        return lt(a2, b2, loose);
      case "<=":
        return lte(a2, b2, loose);
      default:
        throw new TypeError("Invalid operator: " + op);
    }
  }
  exports.Comparator = Comparator;
  function Comparator(comp, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp;
      } else {
        comp = comp.value;
      }
    }
    if (!(this instanceof Comparator)) {
      return new Comparator(comp, options);
    }
    comp = comp.trim().split(/\s+/).join(" ");
    debug("comparator", comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);
    if (this.semver === ANY) {
      this.value = "";
    } else {
      this.value = this.operator + this.semver.version;
    }
    debug("comp", this);
  }
  var ANY = {};
  Comparator.prototype.parse = function(comp) {
    var r2 = this.options.loose ? safeRe[t2.COMPARATORLOOSE] : safeRe[t2.COMPARATOR];
    var m2 = comp.match(r2);
    if (!m2) {
      throw new TypeError("Invalid comparator: " + comp);
    }
    this.operator = m2[1] !== undefined ? m2[1] : "";
    if (this.operator === "=") {
      this.operator = "";
    }
    if (!m2[2]) {
      this.semver = ANY;
    } else {
      this.semver = new SemVer(m2[2], this.options.loose);
    }
  };
  Comparator.prototype.toString = function() {
    return this.value;
  };
  Comparator.prototype.test = function(version) {
    debug("Comparator.test", version, this.options.loose);
    if (this.semver === ANY || version === ANY) {
      return true;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    return cmp(version, this.operator, this.semver, this.options);
  };
  Comparator.prototype.intersects = function(comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError("a Comparator is required");
    }
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    var rangeTmp;
    if (this.operator === "") {
      if (this.value === "") {
        return true;
      }
      rangeTmp = new Range(comp.value, options);
      return satisfies(this.value, rangeTmp, options);
    } else if (comp.operator === "") {
      if (comp.value === "") {
        return true;
      }
      rangeTmp = new Range(this.value, options);
      return satisfies(comp.semver, rangeTmp, options);
    }
    var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
    var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
    var sameSemVer = this.semver.version === comp.semver.version;
    var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
    var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
    var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
    return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
  };
  exports.Range = Range;
  function Range(range, options) {
    if (!options || typeof options !== "object") {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (range instanceof Range) {
      if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
        return range;
      } else {
        return new Range(range.raw, options);
      }
    }
    if (range instanceof Comparator) {
      return new Range(range.value, options);
    }
    if (!(this instanceof Range)) {
      return new Range(range, options);
    }
    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;
    this.raw = range.trim().split(/\s+/).join(" ");
    this.set = this.raw.split("||").map(function(range2) {
      return this.parseRange(range2.trim());
    }, this).filter(function(c2) {
      return c2.length;
    });
    if (!this.set.length) {
      throw new TypeError("Invalid SemVer Range: " + this.raw);
    }
    this.format();
  }
  Range.prototype.format = function() {
    this.range = this.set.map(function(comps) {
      return comps.join(" ").trim();
    }).join("||").trim();
    return this.range;
  };
  Range.prototype.toString = function() {
    return this.range;
  };
  Range.prototype.parseRange = function(range) {
    var loose = this.options.loose;
    var hr = loose ? safeRe[t2.HYPHENRANGELOOSE] : safeRe[t2.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug("hyphen replace", range);
    range = range.replace(safeRe[t2.COMPARATORTRIM], comparatorTrimReplace);
    debug("comparator trim", range, safeRe[t2.COMPARATORTRIM]);
    range = range.replace(safeRe[t2.TILDETRIM], tildeTrimReplace);
    range = range.replace(safeRe[t2.CARETTRIM], caretTrimReplace);
    range = range.split(/\s+/).join(" ");
    var compRe = loose ? safeRe[t2.COMPARATORLOOSE] : safeRe[t2.COMPARATOR];
    var set3 = range.split(" ").map(function(comp) {
      return parseComparator(comp, this.options);
    }, this).join(" ").split(/\s+/);
    if (this.options.loose) {
      set3 = set3.filter(function(comp) {
        return !!comp.match(compRe);
      });
    }
    set3 = set3.map(function(comp) {
      return new Comparator(comp, this.options);
    }, this);
    return set3;
  };
  Range.prototype.intersects = function(range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError("a Range is required");
    }
    return this.set.some(function(thisComparators) {
      return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
        return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
          return rangeComparators.every(function(rangeComparator) {
            return thisComparator.intersects(rangeComparator, options);
          });
        });
      });
    });
  };
  function isSatisfiable(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every(function(otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  }
  exports.toComparators = toComparators;
  function toComparators(range, options) {
    return new Range(range, options).set.map(function(comp) {
      return comp.map(function(c2) {
        return c2.value;
      }).join(" ").trim().split(" ");
    });
  }
  function parseComparator(comp, options) {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  }
  function isX(id) {
    return !id || id.toLowerCase() === "x" || id === "*";
  }
  function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceTilde(comp2, options);
    }).join(" ");
  }
  function replaceTilde(comp, options) {
    var r2 = options.loose ? safeRe[t2.TILDELOOSE] : safeRe[t2.TILDE];
    return comp.replace(r2, function(_2, M2, m2, p2, pr) {
      debug("tilde", comp, _2, M2, m2, p2, pr);
      var ret;
      if (isX(M2)) {
        ret = "";
      } else if (isX(m2)) {
        ret = ">=" + M2 + ".0.0 <" + (+M2 + 1) + ".0.0";
      } else if (isX(p2)) {
        ret = ">=" + M2 + "." + m2 + ".0 <" + M2 + "." + (+m2 + 1) + ".0";
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = ">=" + M2 + "." + m2 + "." + p2 + "-" + pr + " <" + M2 + "." + (+m2 + 1) + ".0";
      } else {
        ret = ">=" + M2 + "." + m2 + "." + p2 + " <" + M2 + "." + (+m2 + 1) + ".0";
      }
      debug("tilde return", ret);
      return ret;
    });
  }
  function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function(comp2) {
      return replaceCaret(comp2, options);
    }).join(" ");
  }
  function replaceCaret(comp, options) {
    debug("caret", comp, options);
    var r2 = options.loose ? safeRe[t2.CARETLOOSE] : safeRe[t2.CARET];
    return comp.replace(r2, function(_2, M2, m2, p2, pr) {
      debug("caret", comp, _2, M2, m2, p2, pr);
      var ret;
      if (isX(M2)) {
        ret = "";
      } else if (isX(m2)) {
        ret = ">=" + M2 + ".0.0 <" + (+M2 + 1) + ".0.0";
      } else if (isX(p2)) {
        if (M2 === "0") {
          ret = ">=" + M2 + "." + m2 + ".0 <" + M2 + "." + (+m2 + 1) + ".0";
        } else {
          ret = ">=" + M2 + "." + m2 + ".0 <" + (+M2 + 1) + ".0.0";
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M2 === "0") {
          if (m2 === "0") {
            ret = ">=" + M2 + "." + m2 + "." + p2 + "-" + pr + " <" + M2 + "." + m2 + "." + (+p2 + 1);
          } else {
            ret = ">=" + M2 + "." + m2 + "." + p2 + "-" + pr + " <" + M2 + "." + (+m2 + 1) + ".0";
          }
        } else {
          ret = ">=" + M2 + "." + m2 + "." + p2 + "-" + pr + " <" + (+M2 + 1) + ".0.0";
        }
      } else {
        debug("no pr");
        if (M2 === "0") {
          if (m2 === "0") {
            ret = ">=" + M2 + "." + m2 + "." + p2 + " <" + M2 + "." + m2 + "." + (+p2 + 1);
          } else {
            ret = ">=" + M2 + "." + m2 + "." + p2 + " <" + M2 + "." + (+m2 + 1) + ".0";
          }
        } else {
          ret = ">=" + M2 + "." + m2 + "." + p2 + " <" + (+M2 + 1) + ".0.0";
        }
      }
      debug("caret return", ret);
      return ret;
    });
  }
  function replaceXRanges(comp, options) {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map(function(comp2) {
      return replaceXRange(comp2, options);
    }).join(" ");
  }
  function replaceXRange(comp, options) {
    comp = comp.trim();
    var r2 = options.loose ? safeRe[t2.XRANGELOOSE] : safeRe[t2.XRANGE];
    return comp.replace(r2, function(ret, gtlt, M2, m2, p2, pr) {
      debug("xRange", comp, ret, gtlt, M2, m2, p2, pr);
      var xM = isX(M2);
      var xm = xM || isX(m2);
      var xp = xm || isX(p2);
      var anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p2 = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M2 = +M2 + 1;
            m2 = 0;
            p2 = 0;
          } else {
            m2 = +m2 + 1;
            p2 = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M2 = +M2 + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        ret = gtlt + M2 + "." + m2 + "." + p2 + pr;
      } else if (xm) {
        ret = ">=" + M2 + ".0.0" + pr + " <" + (+M2 + 1) + ".0.0" + pr;
      } else if (xp) {
        ret = ">=" + M2 + "." + m2 + ".0" + pr + " <" + M2 + "." + (+m2 + 1) + ".0" + pr;
      }
      debug("xRange return", ret);
      return ret;
    });
  }
  function replaceStars(comp, options) {
    debug("replaceStars", comp, options);
    return comp.trim().replace(safeRe[t2.STAR], "");
  }
  function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = ">=" + fM + ".0.0";
    } else if (isX(fp)) {
      from = ">=" + fM + "." + fm + ".0";
    } else {
      from = ">=" + from;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = "<" + (+tM + 1) + ".0.0";
    } else if (isX(tp)) {
      to = "<" + tM + "." + (+tm + 1) + ".0";
    } else if (tpr) {
      to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
    } else {
      to = "<=" + to;
    }
    return (from + " " + to).trim();
  }
  Range.prototype.test = function(version) {
    if (!version) {
      return false;
    }
    if (typeof version === "string") {
      try {
        version = new SemVer(version, this.options);
      } catch (er) {
        return false;
      }
    }
    for (var i3 = 0;i3 < this.set.length; i3++) {
      if (testSet(this.set[i3], version, this.options)) {
        return true;
      }
    }
    return false;
  };
  function testSet(set3, version, options) {
    for (var i3 = 0;i3 < set3.length; i3++) {
      if (!set3[i3].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (i3 = 0;i3 < set3.length; i3++) {
        debug(set3[i3].semver);
        if (set3[i3].semver === ANY) {
          continue;
        }
        if (set3[i3].semver.prerelease.length > 0) {
          var allowed = set3[i3].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  }
  exports.satisfies = satisfies;
  function satisfies(version, range, options) {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  }
  exports.maxSatisfying = maxSatisfying;
  function maxSatisfying(versions3, range, options) {
    var max = null;
    var maxSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions3.forEach(function(v2) {
      if (rangeObj.test(v2)) {
        if (!max || maxSV.compare(v2) === -1) {
          max = v2;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  }
  exports.minSatisfying = minSatisfying;
  function minSatisfying(versions3, range, options) {
    var min = null;
    var minSV = null;
    try {
      var rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions3.forEach(function(v2) {
      if (rangeObj.test(v2)) {
        if (!min || minSV.compare(v2) === 1) {
          min = v2;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  }
  exports.minVersion = minVersion;
  function minVersion(range, loose) {
    range = new Range(range, loose);
    var minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (var i3 = 0;i3 < range.set.length; ++i3) {
      var comparators = range.set[i3];
      comparators.forEach(function(comparator) {
        var compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!minver || gt(minver, compver)) {
              minver = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  }
  exports.validRange = validRange;
  function validRange(range, options) {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  }
  exports.ltr = ltr;
  function ltr(version, range, options) {
    return outside(version, range, "<", options);
  }
  exports.gtr = gtr;
  function gtr(version, range, options) {
    return outside(version, range, ">", options);
  }
  exports.outside = outside;
  function outside(version, range, hilo, options) {
    version = new SemVer(version, options);
    range = new Range(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (var i3 = 0;i3 < range.set.length; ++i3) {
      var comparators = range.set[i3];
      var high = null;
      var low = null;
      comparators.forEach(function(comparator) {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  }
  exports.prerelease = prerelease;
  function prerelease(version, options) {
    var parsed = parse11(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  }
  exports.intersects = intersects;
  function intersects(r1, r2, options) {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2);
  }
  exports.coerce = coerce;
  function coerce(version, options) {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    var match = null;
    if (!options.rtl) {
      match = version.match(safeRe[t2.COERCE]);
    } else {
      var next;
      while ((next = safeRe[t2.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        safeRe[t2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }
      safeRe[t2.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    return parse11(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
  }
});

// node_modules/@actions/cache/lib/internal/constants.js
var require_constants6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CacheFileSizeLimit = exports.ManifestFilename = exports.TarFilename = exports.SystemTarPathOnWindows = exports.GnuTarPathOnWindows = exports.SocketTimeout = exports.DefaultRetryDelay = exports.DefaultRetryAttempts = exports.ArchiveToolType = exports.CompressionMethod = exports.CacheFilename = undefined;
  var CacheFilename;
  (function(CacheFilename2) {
    CacheFilename2["Gzip"] = "cache.tgz";
    CacheFilename2["Zstd"] = "cache.tzst";
  })(CacheFilename || (exports.CacheFilename = CacheFilename = {}));
  var CompressionMethod;
  (function(CompressionMethod2) {
    CompressionMethod2["Gzip"] = "gzip";
    CompressionMethod2["ZstdWithoutLong"] = "zstd-without-long";
    CompressionMethod2["Zstd"] = "zstd";
  })(CompressionMethod || (exports.CompressionMethod = CompressionMethod = {}));
  var ArchiveToolType;
  (function(ArchiveToolType2) {
    ArchiveToolType2["GNU"] = "gnu";
    ArchiveToolType2["BSD"] = "bsd";
  })(ArchiveToolType || (exports.ArchiveToolType = ArchiveToolType = {}));
  exports.DefaultRetryAttempts = 2;
  exports.DefaultRetryDelay = 5000;
  exports.SocketTimeout = 5000;
  exports.GnuTarPathOnWindows = `${process.env["PROGRAMFILES"]}\\Git\\usr\\bin\\tar.exe`;
  exports.SystemTarPathOnWindows = `${process.env["SYSTEMDRIVE"]}\\Windows\\System32\\tar.exe`;
  exports.TarFilename = "cache.tar";
  exports.ManifestFilename = "manifest.txt";
  exports.CacheFileSizeLimit = 10 * Math.pow(1024, 3);
});

// node_modules/@actions/cache/lib/internal/cacheUtils.js
var require_cacheUtils = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve5, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __asyncValues2 = exports && exports.__asyncValues || function(o2) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m2 = o2[Symbol.asyncIterator], i2;
    return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n2) {
      i2[n2] = o2[n2] && function(v2) {
        return new Promise(function(resolve5, reject) {
          v2 = o2[n2](v2), settle(resolve5, reject, v2.done, v2.value);
        });
      };
    }
    function settle(resolve5, reject, d2, v2) {
      Promise.resolve(v2).then(function(v3) {
        resolve5({ value: v3, done: d2 });
      }, reject);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRuntimeToken = exports.getCacheVersion = exports.assertDefined = exports.getGnuTarPathOnWindows = exports.getCacheFileName = exports.getCompressionMethod = exports.unlinkFile = exports.resolvePaths = exports.getArchiveFileSizeInBytes = exports.createTempDirectory = undefined;
  var core = __importStar2(require_core());
  var exec = __importStar2(require_exec());
  var glob = __importStar2(require_glob());
  var io = __importStar2(require_io());
  var crypto = __importStar2(__require("crypto"));
  var fs2 = __importStar2(__require("fs"));
  var path2 = __importStar2(__require("path"));
  var semver = __importStar2(require_semver());
  var util2 = __importStar2(__require("util"));
  var constants_1 = require_constants6();
  var versionSalt = "1.0";
  function createTempDirectory() {
    return __awaiter2(this, undefined, undefined, function* () {
      const IS_WINDOWS = process.platform === "win32";
      let tempDirectory = process.env["RUNNER_TEMP"] || "";
      if (!tempDirectory) {
        let baseLocation;
        if (IS_WINDOWS) {
          baseLocation = process.env["USERPROFILE"] || "C:\\";
        } else {
          if (process.platform === "darwin") {
            baseLocation = "/Users";
          } else {
            baseLocation = "/home";
          }
        }
        tempDirectory = path2.join(baseLocation, "actions", "temp");
      }
      const dest = path2.join(tempDirectory, crypto.randomUUID());
      yield io.mkdirP(dest);
      return dest;
    });
  }
  exports.createTempDirectory = createTempDirectory;
  function getArchiveFileSizeInBytes(filePath) {
    return fs2.statSync(filePath).size;
  }
  exports.getArchiveFileSizeInBytes = getArchiveFileSizeInBytes;
  function resolvePaths(patterns) {
    var _a3, e_1, _b2, _c2;
    var _d2;
    return __awaiter2(this, undefined, undefined, function* () {
      const paths = [];
      const workspace = (_d2 = process.env["GITHUB_WORKSPACE"]) !== null && _d2 !== undefined ? _d2 : process.cwd();
      const globber = yield glob.create(patterns.join(`
`), {
        implicitDescendants: false
      });
      try {
        for (var _e2 = true, _f = __asyncValues2(globber.globGenerator()), _g;_g = yield _f.next(), _a3 = _g.done, !_a3; _e2 = true) {
          _c2 = _g.value;
          _e2 = false;
          const file = _c2;
          const relativeFile = path2.relative(workspace, file).replace(new RegExp(`\\${path2.sep}`, "g"), "/");
          core.debug(`Matched: ${relativeFile}`);
          if (relativeFile === "") {
            paths.push(".");
          } else {
            paths.push(`${relativeFile}`);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_e2 && !_a3 && (_b2 = _f.return))
            yield _b2.call(_f);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return paths;
    });
  }
  exports.resolvePaths = resolvePaths;
  function unlinkFile(filePath) {
    return __awaiter2(this, undefined, undefined, function* () {
      return util2.promisify(fs2.unlink)(filePath);
    });
  }
  exports.unlinkFile = unlinkFile;
  function getVersion(app, additionalArgs = []) {
    return __awaiter2(this, undefined, undefined, function* () {
      let versionOutput = "";
      additionalArgs.push("--version");
      core.debug(`Checking ${app} ${additionalArgs.join(" ")}`);
      try {
        yield exec.exec(`${app}`, additionalArgs, {
          ignoreReturnCode: true,
          silent: true,
          listeners: {
            stdout: (data) => versionOutput += data.toString(),
            stderr: (data) => versionOutput += data.toString()
          }
        });
      } catch (err) {
        core.debug(err.message);
      }
      versionOutput = versionOutput.trim();
      core.debug(versionOutput);
      return versionOutput;
    });
  }
  function getCompressionMethod() {
    return __awaiter2(this, undefined, undefined, function* () {
      const versionOutput = yield getVersion("zstd", ["--quiet"]);
      const version = semver.clean(versionOutput);
      core.debug(`zstd version: ${version}`);
      if (versionOutput === "") {
        return constants_1.CompressionMethod.Gzip;
      } else {
        return constants_1.CompressionMethod.ZstdWithoutLong;
      }
    });
  }
  exports.getCompressionMethod = getCompressionMethod;
  function getCacheFileName(compressionMethod) {
    return compressionMethod === constants_1.CompressionMethod.Gzip ? constants_1.CacheFilename.Gzip : constants_1.CacheFilename.Zstd;
  }
  exports.getCacheFileName = getCacheFileName;
  function getGnuTarPathOnWindows() {
    return __awaiter2(this, undefined, undefined, function* () {
      if (fs2.existsSync(constants_1.GnuTarPathOnWindows)) {
        return constants_1.GnuTarPathOnWindows;
      }
      const versionOutput = yield getVersion("tar");
      return versionOutput.toLowerCase().includes("gnu tar") ? io.which("tar") : "";
    });
  }
  exports.getGnuTarPathOnWindows = getGnuTarPathOnWindows;
  function assertDefined(name, value) {
    if (value === undefined) {
      throw Error(`Expected ${name} but value was undefiend`);
    }
    return value;
  }
  exports.assertDefined = assertDefined;
  function getCacheVersion(paths, compressionMethod, enableCrossOsArchive = false) {
    const components = paths.slice();
    if (compressionMethod) {
      components.push(compressionMethod);
    }
    if (process.platform === "win32" && !enableCrossOsArchive) {
      components.push("windows-only");
    }
    components.push(versionSalt);
    return crypto.createHash("sha256").update(components.join("|")).digest("hex");
  }
  exports.getCacheVersion = getCacheVersion;
  function getRuntimeToken() {
    const token = process.env["ACTIONS_RUNTIME_TOKEN"];
    if (!token) {
      throw new Error("Unable to get the ACTIONS_RUNTIME_TOKEN env variable");
    }
    return token;
  }
  exports.getRuntimeToken = getRuntimeToken;
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/abort-controller/AbortError.js
var require_AbortError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;

  class AbortError3 extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  }
  exports.AbortError = AbortError3;
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/log.js
var require_log2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.log = log2;
  var tslib_1 = require_tslib();
  var node_os_1 = __require("node:os");
  var node_util_1 = tslib_1.__importDefault(__require("node:util"));
  var process5 = tslib_1.__importStar(__require("node:process"));
  function log2(message, ...args) {
    process5.stderr.write(`${node_util_1.default.format(message, ...args)}${node_os_1.EOL}`);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/debug.js
var require_debug = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var log_js_1 = require_log2();
  var debugEnvVariable2 = typeof process !== "undefined" && process.env && process.env.DEBUG || undefined;
  var enabledString2;
  var enabledNamespaces2 = [];
  var skippedNamespaces2 = [];
  var debuggers2 = [];
  if (debugEnvVariable2) {
    enable2(debugEnvVariable2);
  }
  var debugObj2 = Object.assign((namespace) => {
    return createDebugger2(namespace);
  }, {
    enable: enable2,
    enabled: enabled2,
    disable: disable2,
    log: log_js_1.log
  });
  function enable2(namespaces) {
    enabledString2 = namespaces;
    enabledNamespaces2 = [];
    skippedNamespaces2 = [];
    const wildcard = /\*/g;
    const namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
    for (const ns of namespaceList) {
      if (ns.startsWith("-")) {
        skippedNamespaces2.push(new RegExp(`^${ns.substr(1)}$`));
      } else {
        enabledNamespaces2.push(new RegExp(`^${ns}$`));
      }
    }
    for (const instance of debuggers2) {
      instance.enabled = enabled2(instance.namespace);
    }
  }
  function enabled2(namespace) {
    if (namespace.endsWith("*")) {
      return true;
    }
    for (const skipped of skippedNamespaces2) {
      if (skipped.test(namespace)) {
        return false;
      }
    }
    for (const enabledNamespace of enabledNamespaces2) {
      if (enabledNamespace.test(namespace)) {
        return true;
      }
    }
    return false;
  }
  function disable2() {
    const result = enabledString2 || "";
    enable2("");
    return result;
  }
  function createDebugger2(namespace) {
    const newDebugger = Object.assign(debug, {
      enabled: enabled2(namespace),
      destroy: destroy2,
      log: debugObj2.log,
      namespace,
      extend: extend2
    });
    function debug(...args) {
      if (!newDebugger.enabled) {
        return;
      }
      if (args.length > 0) {
        args[0] = `${namespace} ${args[0]}`;
      }
      newDebugger.log(...args);
    }
    debuggers2.push(newDebugger);
    return newDebugger;
  }
  function destroy2() {
    const index = debuggers2.indexOf(this);
    if (index >= 0) {
      debuggers2.splice(index, 1);
      return true;
    }
    return false;
  }
  function extend2(namespace) {
    const newDebugger = createDebugger2(`${this.namespace}:${namespace}`);
    newDebugger.log = this.log;
    return newDebugger;
  }
  exports.default = debugObj2;
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/logger.js
var require_logger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeSpecRuntimeLogger = undefined;
  exports.createLoggerContext = createLoggerContext2;
  exports.setLogLevel = setLogLevel2;
  exports.getLogLevel = getLogLevel;
  exports.createClientLogger = createClientLogger3;
  var tslib_1 = require_tslib();
  var debug_js_1 = tslib_1.__importDefault(require_debug());
  var TYPESPEC_RUNTIME_LOG_LEVELS2 = ["verbose", "info", "warning", "error"];
  var levelMap2 = {
    verbose: 400,
    info: 300,
    warning: 200,
    error: 100
  };
  function patchLogMethod2(parent, child) {
    child.log = (...args) => {
      parent.log(...args);
    };
  }
  function isTypeSpecRuntimeLogLevel2(level) {
    return TYPESPEC_RUNTIME_LOG_LEVELS2.includes(level);
  }
  function createLoggerContext2(options) {
    const registeredLoggers = new Set;
    const logLevelFromEnv = typeof process !== "undefined" && process.env && process.env[options.logLevelEnvVarName] || undefined;
    let logLevel;
    const clientLogger = (0, debug_js_1.default)(options.namespace);
    clientLogger.log = (...args) => {
      debug_js_1.default.log(...args);
    };
    if (logLevelFromEnv) {
      if (isTypeSpecRuntimeLogLevel2(logLevelFromEnv)) {
        setLogLevel2(logLevelFromEnv);
      } else {
        console.error(`${options.logLevelEnvVarName} set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS2.join(", ")}.`);
      }
    }
    function shouldEnable(logger4) {
      return Boolean(logLevel && levelMap2[logger4.level] <= levelMap2[logLevel]);
    }
    function createLogger(parent, level) {
      const logger4 = Object.assign(parent.extend(level), {
        level
      });
      patchLogMethod2(parent, logger4);
      if (shouldEnable(logger4)) {
        const enabledNamespaces2 = debug_js_1.default.disable();
        debug_js_1.default.enable(enabledNamespaces2 + "," + logger4.namespace);
      }
      registeredLoggers.add(logger4);
      return logger4;
    }
    return {
      setLogLevel(level) {
        if (level && !isTypeSpecRuntimeLogLevel2(level)) {
          throw new Error(`Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS2.join(",")}`);
        }
        logLevel = level;
        const enabledNamespaces2 = [];
        for (const logger4 of registeredLoggers) {
          if (shouldEnable(logger4)) {
            enabledNamespaces2.push(logger4.namespace);
          }
        }
        debug_js_1.default.enable(enabledNamespaces2.join(","));
      },
      getLogLevel() {
        return logLevel;
      },
      createClientLogger(namespace) {
        const clientRootLogger = clientLogger.extend(namespace);
        patchLogMethod2(clientLogger, clientRootLogger);
        return {
          error: createLogger(clientRootLogger, "error"),
          warning: createLogger(clientRootLogger, "warning"),
          info: createLogger(clientRootLogger, "info"),
          verbose: createLogger(clientRootLogger, "verbose")
        };
      },
      logger: clientLogger
    };
  }
  var context5 = createLoggerContext2({
    logLevelEnvVarName: "TYPESPEC_RUNTIME_LOG_LEVEL",
    namespace: "typeSpecRuntime"
  });
  exports.TypeSpecRuntimeLogger = context5.logger;
  function setLogLevel2(logLevel) {
    context5.setLogLevel(logLevel);
  }
  function getLogLevel() {
    return context5.getLogLevel();
  }
  function createClientLogger3(namespace) {
    return context5.createClientLogger(namespace);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/httpHeaders.js
var require_httpHeaders = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHttpHeaders = createHttpHeaders2;
  function normalizeName2(name) {
    return name.toLowerCase();
  }
  function* headerIterator2(map) {
    for (const entry of map.values()) {
      yield [entry.name, entry.value];
    }
  }

  class HttpHeadersImpl2 {
    constructor(rawHeaders) {
      this._headersMap = new Map;
      if (rawHeaders) {
        for (const headerName of Object.keys(rawHeaders)) {
          this.set(headerName, rawHeaders[headerName]);
        }
      }
    }
    set(name, value) {
      this._headersMap.set(normalizeName2(name), { name, value: String(value).trim() });
    }
    get(name) {
      var _a3;
      return (_a3 = this._headersMap.get(normalizeName2(name))) === null || _a3 === undefined ? undefined : _a3.value;
    }
    has(name) {
      return this._headersMap.has(normalizeName2(name));
    }
    delete(name) {
      this._headersMap.delete(normalizeName2(name));
    }
    toJSON(options = {}) {
      const result = {};
      if (options.preserveCase) {
        for (const entry of this._headersMap.values()) {
          result[entry.name] = entry.value;
        }
      } else {
        for (const [normalizedName, entry] of this._headersMap) {
          result[normalizedName] = entry.value;
        }
      }
      return result;
    }
    toString() {
      return JSON.stringify(this.toJSON({ preserveCase: true }));
    }
    [Symbol.iterator]() {
      return headerIterator2(this._headersMap);
    }
  }
  function createHttpHeaders2(rawHeaders) {
    return new HttpHeadersImpl2(rawHeaders);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/schemes.js
var require_schemes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/oauth2Flows.js
var require_oauth2Flows = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/uuidUtils.js
var require_uuidUtils = __commonJS((exports) => {
  var _a3;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomUUID = randomUUID2;
  var node_crypto_1 = __require("node:crypto");
  var uuidFunction2 = typeof ((_a3 = globalThis === null || globalThis === undefined ? undefined : globalThis.crypto) === null || _a3 === undefined ? undefined : _a3.randomUUID) === "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : node_crypto_1.randomUUID;
  function randomUUID2() {
    return uuidFunction2();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/pipelineRequest.js
var require_pipelineRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createPipelineRequest = createPipelineRequest2;
  var httpHeaders_js_1 = require_httpHeaders();
  var uuidUtils_js_1 = require_uuidUtils();

  class PipelineRequestImpl2 {
    constructor(options) {
      var _a3, _b2, _c2, _d2, _e2, _f, _g;
      this.url = options.url;
      this.body = options.body;
      this.headers = (_a3 = options.headers) !== null && _a3 !== undefined ? _a3 : (0, httpHeaders_js_1.createHttpHeaders)();
      this.method = (_b2 = options.method) !== null && _b2 !== undefined ? _b2 : "GET";
      this.timeout = (_c2 = options.timeout) !== null && _c2 !== undefined ? _c2 : 0;
      this.multipartBody = options.multipartBody;
      this.formData = options.formData;
      this.disableKeepAlive = (_d2 = options.disableKeepAlive) !== null && _d2 !== undefined ? _d2 : false;
      this.proxySettings = options.proxySettings;
      this.streamResponseStatusCodes = options.streamResponseStatusCodes;
      this.withCredentials = (_e2 = options.withCredentials) !== null && _e2 !== undefined ? _e2 : false;
      this.abortSignal = options.abortSignal;
      this.onUploadProgress = options.onUploadProgress;
      this.onDownloadProgress = options.onDownloadProgress;
      this.requestId = options.requestId || (0, uuidUtils_js_1.randomUUID)();
      this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== undefined ? _f : false;
      this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== undefined ? _g : false;
      this.requestOverrides = options.requestOverrides;
    }
  }
  function createPipelineRequest2(options) {
    return new PipelineRequestImpl2(options);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/pipeline.js
var require_pipeline = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createEmptyPipeline = createEmptyPipeline3;
  var ValidPhaseNames2 = new Set(["Deserialize", "Serialize", "Retry", "Sign"]);

  class HttpPipeline2 {
    constructor(policies) {
      var _a3;
      this._policies = [];
      this._policies = (_a3 = policies === null || policies === undefined ? undefined : policies.slice(0)) !== null && _a3 !== undefined ? _a3 : [];
      this._orderedPolicies = undefined;
    }
    addPolicy(policy, options = {}) {
      if (options.phase && options.afterPhase) {
        throw new Error("Policies inside a phase cannot specify afterPhase.");
      }
      if (options.phase && !ValidPhaseNames2.has(options.phase)) {
        throw new Error(`Invalid phase name: ${options.phase}`);
      }
      if (options.afterPhase && !ValidPhaseNames2.has(options.afterPhase)) {
        throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
      }
      this._policies.push({
        policy,
        options
      });
      this._orderedPolicies = undefined;
    }
    removePolicy(options) {
      const removedPolicies = [];
      this._policies = this._policies.filter((policyDescriptor) => {
        if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
          removedPolicies.push(policyDescriptor.policy);
          return false;
        } else {
          return true;
        }
      });
      this._orderedPolicies = undefined;
      return removedPolicies;
    }
    sendRequest(httpClient, request9) {
      const policies = this.getOrderedPolicies();
      const pipeline = policies.reduceRight((next, policy) => {
        return (req) => {
          return policy.sendRequest(req, next);
        };
      }, (req) => httpClient.sendRequest(req));
      return pipeline(request9);
    }
    getOrderedPolicies() {
      if (!this._orderedPolicies) {
        this._orderedPolicies = this.orderPolicies();
      }
      return this._orderedPolicies;
    }
    clone() {
      return new HttpPipeline2(this._policies);
    }
    static create() {
      return new HttpPipeline2;
    }
    orderPolicies() {
      const result = [];
      const policyMap = new Map;
      function createPhase(name) {
        return {
          name,
          policies: new Set,
          hasRun: false,
          hasAfterPolicies: false
        };
      }
      const serializePhase = createPhase("Serialize");
      const noPhase = createPhase("None");
      const deserializePhase = createPhase("Deserialize");
      const retryPhase = createPhase("Retry");
      const signPhase = createPhase("Sign");
      const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
      function getPhase(phase) {
        if (phase === "Retry") {
          return retryPhase;
        } else if (phase === "Serialize") {
          return serializePhase;
        } else if (phase === "Deserialize") {
          return deserializePhase;
        } else if (phase === "Sign") {
          return signPhase;
        } else {
          return noPhase;
        }
      }
      for (const descriptor of this._policies) {
        const policy = descriptor.policy;
        const options = descriptor.options;
        const policyName = policy.name;
        if (policyMap.has(policyName)) {
          throw new Error("Duplicate policy names not allowed in pipeline");
        }
        const node = {
          policy,
          dependsOn: new Set,
          dependants: new Set
        };
        if (options.afterPhase) {
          node.afterPhase = getPhase(options.afterPhase);
          node.afterPhase.hasAfterPolicies = true;
        }
        policyMap.set(policyName, node);
        const phase = getPhase(options.phase);
        phase.policies.add(node);
      }
      for (const descriptor of this._policies) {
        const { policy, options } = descriptor;
        const policyName = policy.name;
        const node = policyMap.get(policyName);
        if (!node) {
          throw new Error(`Missing node for policy ${policyName}`);
        }
        if (options.afterPolicies) {
          for (const afterPolicyName of options.afterPolicies) {
            const afterNode = policyMap.get(afterPolicyName);
            if (afterNode) {
              node.dependsOn.add(afterNode);
              afterNode.dependants.add(node);
            }
          }
        }
        if (options.beforePolicies) {
          for (const beforePolicyName of options.beforePolicies) {
            const beforeNode = policyMap.get(beforePolicyName);
            if (beforeNode) {
              beforeNode.dependsOn.add(node);
              node.dependants.add(beforeNode);
            }
          }
        }
      }
      function walkPhase(phase) {
        phase.hasRun = true;
        for (const node of phase.policies) {
          if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
            continue;
          }
          if (node.dependsOn.size === 0) {
            result.push(node.policy);
            for (const dependant of node.dependants) {
              dependant.dependsOn.delete(node);
            }
            policyMap.delete(node.policy.name);
            phase.policies.delete(node);
          }
        }
      }
      function walkPhases() {
        for (const phase of orderedPhases) {
          walkPhase(phase);
          if (phase.policies.size > 0 && phase !== noPhase) {
            if (!noPhase.hasRun) {
              walkPhase(noPhase);
            }
            return;
          }
          if (phase.hasAfterPolicies) {
            walkPhase(noPhase);
          }
        }
      }
      let iteration = 0;
      while (policyMap.size > 0) {
        iteration++;
        const initialResultLength = result.length;
        walkPhases();
        if (result.length <= initialResultLength && iteration > 1) {
          throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
        }
      }
      return result;
    }
  }
  function createEmptyPipeline3() {
    return HttpPipeline2.create();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/object.js
var require_object = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isObject = isObject3;
  function isObject3(input) {
    return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/error.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isError = isError3;
  var object_js_1 = require_object();
  function isError3(e2) {
    if ((0, object_js_1.isObject)(e2)) {
      const hasName = typeof e2.name === "string";
      const hasMessage = typeof e2.message === "string";
      return hasName && hasMessage;
    }
    return false;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/inspect.js
var require_inspect2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.custom = undefined;
  var node_util_1 = __require("node:util");
  exports.custom = node_util_1.inspect.custom;
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/sanitizer.js
var require_sanitizer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Sanitizer = undefined;
  var object_js_1 = require_object();
  var RedactedString2 = "REDACTED";
  var defaultAllowedHeaderNames2 = [
    "x-ms-client-request-id",
    "x-ms-return-client-request-id",
    "x-ms-useragent",
    "x-ms-correlation-request-id",
    "x-ms-request-id",
    "client-request-id",
    "ms-cv",
    "return-client-request-id",
    "traceparent",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Origin",
    "Accept",
    "Accept-Encoding",
    "Cache-Control",
    "Connection",
    "Content-Length",
    "Content-Type",
    "Date",
    "ETag",
    "Expires",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "Last-Modified",
    "Pragma",
    "Request-Id",
    "Retry-After",
    "Server",
    "Transfer-Encoding",
    "User-Agent",
    "WWW-Authenticate"
  ];
  var defaultAllowedQueryParameters2 = ["api-version"];

  class Sanitizer2 {
    constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
      allowedHeaderNames = defaultAllowedHeaderNames2.concat(allowedHeaderNames);
      allowedQueryParameters = defaultAllowedQueryParameters2.concat(allowedQueryParameters);
      this.allowedHeaderNames = new Set(allowedHeaderNames.map((n2) => n2.toLowerCase()));
      this.allowedQueryParameters = new Set(allowedQueryParameters.map((p2) => p2.toLowerCase()));
    }
    sanitize(obj) {
      const seen = new Set;
      return JSON.stringify(obj, (key, value) => {
        if (value instanceof Error) {
          return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
        }
        if (key === "headers") {
          return this.sanitizeHeaders(value);
        } else if (key === "url") {
          return this.sanitizeUrl(value);
        } else if (key === "query") {
          return this.sanitizeQuery(value);
        } else if (key === "body") {
          return;
        } else if (key === "response") {
          return;
        } else if (key === "operationSpec") {
          return;
        } else if (Array.isArray(value) || (0, object_js_1.isObject)(value)) {
          if (seen.has(value)) {
            return "[Circular]";
          }
          seen.add(value);
        }
        return value;
      }, 2);
    }
    sanitizeUrl(value) {
      if (typeof value !== "string" || value === null || value === "") {
        return value;
      }
      const url = new URL(value);
      if (!url.search) {
        return value;
      }
      for (const [key] of url.searchParams) {
        if (!this.allowedQueryParameters.has(key.toLowerCase())) {
          url.searchParams.set(key, RedactedString2);
        }
      }
      return url.toString();
    }
    sanitizeHeaders(obj) {
      const sanitized = {};
      for (const key of Object.keys(obj)) {
        if (this.allowedHeaderNames.has(key.toLowerCase())) {
          sanitized[key] = obj[key];
        } else {
          sanitized[key] = RedactedString2;
        }
      }
      return sanitized;
    }
    sanitizeQuery(value) {
      if (typeof value !== "object" || value === null) {
        return value;
      }
      const sanitized = {};
      for (const k2 of Object.keys(value)) {
        if (this.allowedQueryParameters.has(k2.toLowerCase())) {
          sanitized[k2] = value[k2];
        } else {
          sanitized[k2] = RedactedString2;
        }
      }
      return sanitized;
    }
  }
  exports.Sanitizer = Sanitizer2;
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/restError.js
var require_restError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RestError = undefined;
  exports.isRestError = isRestError3;
  var error_js_1 = require_error();
  var inspect_js_1 = require_inspect2();
  var sanitizer_js_1 = require_sanitizer();
  var errorSanitizer2 = new sanitizer_js_1.Sanitizer;

  class RestError3 extends Error {
    constructor(message, options = {}) {
      super(message);
      this.name = "RestError";
      this.code = options.code;
      this.statusCode = options.statusCode;
      Object.defineProperty(this, "request", { value: options.request, enumerable: false });
      Object.defineProperty(this, "response", { value: options.response, enumerable: false });
      Object.defineProperty(this, inspect_js_1.custom, {
        value: () => {
          return `RestError: ${this.message} 
 ${errorSanitizer2.sanitize(Object.assign(Object.assign({}, this), { request: this.request, response: this.response }))}`;
        },
        enumerable: false
      });
      Object.setPrototypeOf(this, RestError3.prototype);
    }
  }
  exports.RestError = RestError3;
  RestError3.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
  RestError3.PARSE_ERROR = "PARSE_ERROR";
  function isRestError3(e2) {
    if (e2 instanceof RestError3) {
      return true;
    }
    return (0, error_js_1.isError)(e2) && e2.name === "RestError";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/bytesEncoding.js
var require_bytesEncoding = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uint8ArrayToString = uint8ArrayToString2;
  exports.stringToUint8Array = stringToUint8Array2;
  function uint8ArrayToString2(bytes, format5) {
    return Buffer.from(bytes).toString(format5);
  }
  function stringToUint8Array2(value, format5) {
    return Buffer.from(value, format5);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/log.js
var require_log3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = undefined;
  var logger_js_1 = require_logger();
  exports.logger = (0, logger_js_1.createClientLogger)("ts-http-runtime");
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/nodeHttpClient.js
var require_nodeHttpClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getBodyLength = getBodyLength2;
  exports.createNodeHttpClient = createNodeHttpClient2;
  var tslib_1 = require_tslib();
  var http2 = tslib_1.__importStar(__require("node:http"));
  var https2 = tslib_1.__importStar(__require("node:https"));
  var zlib2 = tslib_1.__importStar(__require("node:zlib"));
  var node_stream_1 = __require("node:stream");
  var AbortError_js_1 = require_AbortError();
  var httpHeaders_js_1 = require_httpHeaders();
  var restError_js_1 = require_restError();
  var log_js_1 = require_log3();
  var sanitizer_js_1 = require_sanitizer();
  var DEFAULT_TLS_SETTINGS2 = {};
  function isReadableStream3(body) {
    return body && typeof body.pipe === "function";
  }
  function isStreamComplete2(stream) {
    if (stream.readable === false) {
      return Promise.resolve();
    }
    return new Promise((resolve5) => {
      const handler2 = () => {
        resolve5();
        stream.removeListener("close", handler2);
        stream.removeListener("end", handler2);
        stream.removeListener("error", handler2);
      };
      stream.on("close", handler2);
      stream.on("end", handler2);
      stream.on("error", handler2);
    });
  }
  function isArrayBuffer2(body) {
    return body && typeof body.byteLength === "number";
  }

  class ReportTransform2 extends node_stream_1.Transform {
    _transform(chunk, _encoding, callback) {
      this.push(chunk);
      this.loadedBytes += chunk.length;
      try {
        this.progressCallback({ loadedBytes: this.loadedBytes });
        callback();
      } catch (e2) {
        callback(e2);
      }
    }
    constructor(progressCallback) {
      super();
      this.loadedBytes = 0;
      this.progressCallback = progressCallback;
    }
  }

  class NodeHttpClient2 {
    constructor() {
      this.cachedHttpsAgents = new WeakMap;
    }
    async sendRequest(request9) {
      var _a3, _b2, _c2;
      const abortController = new AbortController;
      let abortListener;
      if (request9.abortSignal) {
        if (request9.abortSignal.aborted) {
          throw new AbortError_js_1.AbortError("The operation was aborted. Request has already been canceled.");
        }
        abortListener = (event) => {
          if (event.type === "abort") {
            abortController.abort();
          }
        };
        request9.abortSignal.addEventListener("abort", abortListener);
      }
      let timeoutId;
      if (request9.timeout > 0) {
        timeoutId = setTimeout(() => {
          const sanitizer = new sanitizer_js_1.Sanitizer;
          log_js_1.logger.info(`request to '${sanitizer.sanitizeUrl(request9.url)}' timed out. canceling...`);
          abortController.abort();
        }, request9.timeout);
      }
      const acceptEncoding = request9.headers.get("Accept-Encoding");
      const shouldDecompress = (acceptEncoding === null || acceptEncoding === undefined ? undefined : acceptEncoding.includes("gzip")) || (acceptEncoding === null || acceptEncoding === undefined ? undefined : acceptEncoding.includes("deflate"));
      let body = typeof request9.body === "function" ? request9.body() : request9.body;
      if (body && !request9.headers.has("Content-Length")) {
        const bodyLength = getBodyLength2(body);
        if (bodyLength !== null) {
          request9.headers.set("Content-Length", bodyLength);
        }
      }
      let responseStream;
      try {
        if (body && request9.onUploadProgress) {
          const onUploadProgress = request9.onUploadProgress;
          const uploadReportStream = new ReportTransform2(onUploadProgress);
          uploadReportStream.on("error", (e2) => {
            log_js_1.logger.error("Error in upload progress", e2);
          });
          if (isReadableStream3(body)) {
            body.pipe(uploadReportStream);
          } else {
            uploadReportStream.end(body);
          }
          body = uploadReportStream;
        }
        const res = await this.makeRequest(request9, abortController, body);
        if (timeoutId !== undefined) {
          clearTimeout(timeoutId);
        }
        const headers = getResponseHeaders2(res);
        const status = (_a3 = res.statusCode) !== null && _a3 !== undefined ? _a3 : 0;
        const response = {
          status,
          headers,
          request: request9
        };
        if (request9.method === "HEAD") {
          res.resume();
          return response;
        }
        responseStream = shouldDecompress ? getDecodedResponseStream2(res, headers) : res;
        const onDownloadProgress = request9.onDownloadProgress;
        if (onDownloadProgress) {
          const downloadReportStream = new ReportTransform2(onDownloadProgress);
          downloadReportStream.on("error", (e2) => {
            log_js_1.logger.error("Error in download progress", e2);
          });
          responseStream.pipe(downloadReportStream);
          responseStream = downloadReportStream;
        }
        if (((_b2 = request9.streamResponseStatusCodes) === null || _b2 === undefined ? undefined : _b2.has(Number.POSITIVE_INFINITY)) || ((_c2 = request9.streamResponseStatusCodes) === null || _c2 === undefined ? undefined : _c2.has(response.status))) {
          response.readableStreamBody = responseStream;
        } else {
          response.bodyAsText = await streamToText2(responseStream);
        }
        return response;
      } finally {
        if (request9.abortSignal && abortListener) {
          let uploadStreamDone = Promise.resolve();
          if (isReadableStream3(body)) {
            uploadStreamDone = isStreamComplete2(body);
          }
          let downloadStreamDone = Promise.resolve();
          if (isReadableStream3(responseStream)) {
            downloadStreamDone = isStreamComplete2(responseStream);
          }
          Promise.all([uploadStreamDone, downloadStreamDone]).then(() => {
            var _a4;
            if (abortListener) {
              (_a4 = request9.abortSignal) === null || _a4 === undefined || _a4.removeEventListener("abort", abortListener);
            }
          }).catch((e2) => {
            log_js_1.logger.warning("Error when cleaning up abortListener on httpRequest", e2);
          });
        }
      }
    }
    makeRequest(request9, abortController, body) {
      var _a3;
      const url = new URL(request9.url);
      const isInsecure = url.protocol !== "https:";
      if (isInsecure && !request9.allowInsecureConnection) {
        throw new Error(`Cannot connect to ${request9.url} while allowInsecureConnection is false.`);
      }
      const agent = (_a3 = request9.agent) !== null && _a3 !== undefined ? _a3 : this.getOrCreateAgent(request9, isInsecure);
      const options = Object.assign({ agent, hostname: url.hostname, path: `${url.pathname}${url.search}`, port: url.port, method: request9.method, headers: request9.headers.toJSON({ preserveCase: true }) }, request9.requestOverrides);
      return new Promise((resolve5, reject) => {
        const req = isInsecure ? http2.request(options, resolve5) : https2.request(options, resolve5);
        req.once("error", (err) => {
          var _a4;
          reject(new restError_js_1.RestError(err.message, { code: (_a4 = err.code) !== null && _a4 !== undefined ? _a4 : restError_js_1.RestError.REQUEST_SEND_ERROR, request: request9 }));
        });
        abortController.signal.addEventListener("abort", () => {
          const abortError = new AbortError_js_1.AbortError("The operation was aborted. Rejecting from abort signal callback while making request.");
          req.destroy(abortError);
          reject(abortError);
        });
        if (body && isReadableStream3(body)) {
          body.pipe(req);
        } else if (body) {
          if (typeof body === "string" || Buffer.isBuffer(body)) {
            req.end(body);
          } else if (isArrayBuffer2(body)) {
            req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
          } else {
            log_js_1.logger.error("Unrecognized body type", body);
            reject(new restError_js_1.RestError("Unrecognized body type"));
          }
        } else {
          req.end();
        }
      });
    }
    getOrCreateAgent(request9, isInsecure) {
      var _a3;
      const disableKeepAlive = request9.disableKeepAlive;
      if (isInsecure) {
        if (disableKeepAlive) {
          return http2.globalAgent;
        }
        if (!this.cachedHttpAgent) {
          this.cachedHttpAgent = new http2.Agent({ keepAlive: true });
        }
        return this.cachedHttpAgent;
      } else {
        if (disableKeepAlive && !request9.tlsSettings) {
          return https2.globalAgent;
        }
        const tlsSettings = (_a3 = request9.tlsSettings) !== null && _a3 !== undefined ? _a3 : DEFAULT_TLS_SETTINGS2;
        let agent = this.cachedHttpsAgents.get(tlsSettings);
        if (agent && agent.options.keepAlive === !disableKeepAlive) {
          return agent;
        }
        log_js_1.logger.info("No cached TLS Agent exist, creating a new Agent");
        agent = new https2.Agent(Object.assign({
          keepAlive: !disableKeepAlive
        }, tlsSettings));
        this.cachedHttpsAgents.set(tlsSettings, agent);
        return agent;
      }
    }
  }
  function getResponseHeaders2(res) {
    const headers = (0, httpHeaders_js_1.createHttpHeaders)();
    for (const header of Object.keys(res.headers)) {
      const value = res.headers[header];
      if (Array.isArray(value)) {
        if (value.length > 0) {
          headers.set(header, value[0]);
        }
      } else if (value) {
        headers.set(header, value);
      }
    }
    return headers;
  }
  function getDecodedResponseStream2(stream, headers) {
    const contentEncoding = headers.get("Content-Encoding");
    if (contentEncoding === "gzip") {
      const unzip = zlib2.createGunzip();
      stream.pipe(unzip);
      return unzip;
    } else if (contentEncoding === "deflate") {
      const inflate = zlib2.createInflate();
      stream.pipe(inflate);
      return inflate;
    }
    return stream;
  }
  function streamToText2(stream) {
    return new Promise((resolve5, reject) => {
      const buffer = [];
      stream.on("data", (chunk) => {
        if (Buffer.isBuffer(chunk)) {
          buffer.push(chunk);
        } else {
          buffer.push(Buffer.from(chunk));
        }
      });
      stream.on("end", () => {
        resolve5(Buffer.concat(buffer).toString("utf8"));
      });
      stream.on("error", (e2) => {
        if (e2 && (e2 === null || e2 === undefined ? undefined : e2.name) === "AbortError") {
          reject(e2);
        } else {
          reject(new restError_js_1.RestError(`Error reading response as text: ${e2.message}`, {
            code: restError_js_1.RestError.PARSE_ERROR
          }));
        }
      });
    });
  }
  function getBodyLength2(body) {
    if (!body) {
      return 0;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (isReadableStream3(body)) {
      return null;
    } else if (isArrayBuffer2(body)) {
      return body.byteLength;
    } else if (typeof body === "string") {
      return Buffer.from(body).length;
    } else {
      return null;
    }
  }
  function createNodeHttpClient2() {
    return new NodeHttpClient2;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/defaultHttpClient.js
var require_defaultHttpClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDefaultHttpClient = createDefaultHttpClient3;
  var nodeHttpClient_js_1 = require_nodeHttpClient();
  function createDefaultHttpClient3() {
    return (0, nodeHttpClient_js_1.createNodeHttpClient)();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/logPolicy.js
var require_logPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logPolicyName = undefined;
  exports.logPolicy = logPolicy3;
  var log_js_1 = require_log3();
  var sanitizer_js_1 = require_sanitizer();
  exports.logPolicyName = "logPolicy";
  function logPolicy3(options = {}) {
    var _a3;
    const logger4 = (_a3 = options.logger) !== null && _a3 !== undefined ? _a3 : log_js_1.logger.info;
    const sanitizer = new sanitizer_js_1.Sanitizer({
      additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
      additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
    });
    return {
      name: exports.logPolicyName,
      async sendRequest(request9, next) {
        if (!logger4.enabled) {
          return next(request9);
        }
        logger4(`Request: ${sanitizer.sanitize(request9)}`);
        const response = await next(request9);
        logger4(`Response status code: ${response.status}`);
        logger4(`Headers: ${sanitizer.sanitize(response.headers)}`);
        return response;
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/redirectPolicy.js
var require_redirectPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.redirectPolicyName = undefined;
  exports.redirectPolicy = redirectPolicy3;
  exports.redirectPolicyName = "redirectPolicy";
  var allowedRedirect2 = ["GET", "HEAD"];
  function redirectPolicy3(options = {}) {
    const { maxRetries = 20 } = options;
    return {
      name: exports.redirectPolicyName,
      async sendRequest(request9, next) {
        const response = await next(request9);
        return handleRedirect2(next, response, maxRetries);
      }
    };
  }
  async function handleRedirect2(next, response, maxRetries, currentRetries = 0) {
    const { request: request9, status, headers } = response;
    const locationHeader = headers.get("location");
    if (locationHeader && (status === 300 || status === 301 && allowedRedirect2.includes(request9.method) || status === 302 && allowedRedirect2.includes(request9.method) || status === 303 && request9.method === "POST" || status === 307) && currentRetries < maxRetries) {
      const url = new URL(locationHeader, request9.url);
      request9.url = url.toString();
      if (status === 303) {
        request9.method = "GET";
        request9.headers.delete("Content-Length");
        delete request9.body;
      }
      request9.headers.delete("Authorization");
      const res = await next(request9);
      return handleRedirect2(next, res, maxRetries, currentRetries + 1);
    }
    return response;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/userAgentPlatform.js
var require_userAgentPlatform = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHeaderName = getHeaderName3;
  exports.setPlatformSpecificData = setPlatformSpecificData3;
  var tslib_1 = require_tslib();
  var os3 = tslib_1.__importStar(__require("node:os"));
  var process5 = tslib_1.__importStar(__require("node:process"));
  function getHeaderName3() {
    return "User-Agent";
  }
  async function setPlatformSpecificData3(map) {
    if (process5 && process5.versions) {
      const versions3 = process5.versions;
      if (versions3.bun) {
        map.set("Bun", versions3.bun);
      } else if (versions3.deno) {
        map.set("Deno", versions3.deno);
      } else if (versions3.node) {
        map.set("Node", versions3.node);
      }
    }
    map.set("OS", `(${os3.arch()}-${os3.type()}-${os3.release()})`);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/constants.js
var require_constants7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_RETRY_POLICY_COUNT = exports.SDK_VERSION = undefined;
  exports.SDK_VERSION = "0.2.2";
  exports.DEFAULT_RETRY_POLICY_COUNT = 3;
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/userAgent.js
var require_userAgent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getUserAgentHeaderName = getUserAgentHeaderName3;
  exports.getUserAgentValue = getUserAgentValue3;
  var userAgentPlatform_js_1 = require_userAgentPlatform();
  var constants_js_1 = require_constants7();
  function getUserAgentString3(telemetryInfo) {
    const parts = [];
    for (const [key, value] of telemetryInfo) {
      const token = value ? `${key}/${value}` : key;
      parts.push(token);
    }
    return parts.join(" ");
  }
  function getUserAgentHeaderName3() {
    return (0, userAgentPlatform_js_1.getHeaderName)();
  }
  async function getUserAgentValue3(prefix) {
    const runtimeInfo = new Map;
    runtimeInfo.set("ts-http-runtime", constants_js_1.SDK_VERSION);
    await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
    const defaultAgent = getUserAgentString3(runtimeInfo);
    const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
    return userAgentValue;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/userAgentPolicy.js
var require_userAgentPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.userAgentPolicyName = undefined;
  exports.userAgentPolicy = userAgentPolicy3;
  var userAgent_js_1 = require_userAgent();
  var UserAgentHeaderName3 = (0, userAgent_js_1.getUserAgentHeaderName)();
  exports.userAgentPolicyName = "userAgentPolicy";
  function userAgentPolicy3(options = {}) {
    const userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
    return {
      name: exports.userAgentPolicyName,
      async sendRequest(request9, next) {
        if (!request9.headers.has(UserAgentHeaderName3)) {
          request9.headers.set(UserAgentHeaderName3, await userAgentValue);
        }
        return next(request9);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/decompressResponsePolicy.js
var require_decompressResponsePolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decompressResponsePolicyName = undefined;
  exports.decompressResponsePolicy = decompressResponsePolicy3;
  exports.decompressResponsePolicyName = "decompressResponsePolicy";
  function decompressResponsePolicy3() {
    return {
      name: exports.decompressResponsePolicyName,
      async sendRequest(request9, next) {
        if (request9.method !== "HEAD") {
          request9.headers.set("Accept-Encoding", "gzip,deflate");
        }
        return next(request9);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/random.js
var require_random = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRandomIntegerInclusive = getRandomIntegerInclusive2;
  function getRandomIntegerInclusive2(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    const offset = Math.floor(Math.random() * (max - min + 1));
    return offset + min;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/delay.js
var require_delay = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.calculateRetryDelay = calculateRetryDelay2;
  var random_js_1 = require_random();
  function calculateRetryDelay2(retryAttempt, config) {
    const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
    const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
    const retryAfterInMs = clampedDelay / 2 + (0, random_js_1.getRandomIntegerInclusive)(0, clampedDelay / 2);
    return { retryAfterInMs };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/helpers.js
var require_helpers2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delay = delay3;
  exports.parseHeaderValueAsNumber = parseHeaderValueAsNumber2;
  var AbortError_js_1 = require_AbortError();
  var StandardAbortMessage3 = "The operation was aborted.";
  function delay3(delayInMs, value, options) {
    return new Promise((resolve5, reject) => {
      let timer = undefined;
      let onAborted = undefined;
      const rejectOnAbort = () => {
        return reject(new AbortError_js_1.AbortError((options === null || options === undefined ? undefined : options.abortErrorMsg) ? options === null || options === undefined ? undefined : options.abortErrorMsg : StandardAbortMessage3));
      };
      const removeListeners = () => {
        if ((options === null || options === undefined ? undefined : options.abortSignal) && onAborted) {
          options.abortSignal.removeEventListener("abort", onAborted);
        }
      };
      onAborted = () => {
        if (timer) {
          clearTimeout(timer);
        }
        removeListeners();
        return rejectOnAbort();
      };
      if ((options === null || options === undefined ? undefined : options.abortSignal) && options.abortSignal.aborted) {
        return rejectOnAbort();
      }
      timer = setTimeout(() => {
        removeListeners();
        resolve5(value);
      }, delayInMs);
      if (options === null || options === undefined ? undefined : options.abortSignal) {
        options.abortSignal.addEventListener("abort", onAborted);
      }
    });
  }
  function parseHeaderValueAsNumber2(response, headerName) {
    const value = response.headers.get(headerName);
    if (!value)
      return;
    const valueAsNum = Number(value);
    if (Number.isNaN(valueAsNum))
      return;
    return valueAsNum;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/retryStrategies/throttlingRetryStrategy.js
var require_throttlingRetryStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isThrottlingRetryResponse = isThrottlingRetryResponse2;
  exports.throttlingRetryStrategy = throttlingRetryStrategy2;
  var helpers_js_1 = require_helpers2();
  var RetryAfterHeader2 = "Retry-After";
  var AllRetryAfterHeaders2 = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader2];
  function getRetryAfterInMs2(response) {
    if (!(response && [429, 503].includes(response.status)))
      return;
    try {
      for (const header of AllRetryAfterHeaders2) {
        const retryAfterValue = (0, helpers_js_1.parseHeaderValueAsNumber)(response, header);
        if (retryAfterValue === 0 || retryAfterValue) {
          const multiplyingFactor = header === RetryAfterHeader2 ? 1000 : 1;
          return retryAfterValue * multiplyingFactor;
        }
      }
      const retryAfterHeader = response.headers.get(RetryAfterHeader2);
      if (!retryAfterHeader)
        return;
      const date = Date.parse(retryAfterHeader);
      const diff = date - Date.now();
      return Number.isFinite(diff) ? Math.max(0, diff) : undefined;
    } catch (_a3) {
      return;
    }
  }
  function isThrottlingRetryResponse2(response) {
    return Number.isFinite(getRetryAfterInMs2(response));
  }
  function throttlingRetryStrategy2() {
    return {
      name: "throttlingRetryStrategy",
      retry({ response }) {
        const retryAfterInMs = getRetryAfterInMs2(response);
        if (!Number.isFinite(retryAfterInMs)) {
          return { skipStrategy: true };
        }
        return {
          retryAfterInMs
        };
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/retryStrategies/exponentialRetryStrategy.js
var require_exponentialRetryStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exponentialRetryStrategy = exponentialRetryStrategy2;
  exports.isExponentialRetryResponse = isExponentialRetryResponse2;
  exports.isSystemError = isSystemError2;
  var delay_js_1 = require_delay();
  var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
  var DEFAULT_CLIENT_RETRY_INTERVAL2 = 1000;
  var DEFAULT_CLIENT_MAX_RETRY_INTERVAL2 = 1000 * 64;
  function exponentialRetryStrategy2(options = {}) {
    var _a3, _b2;
    const retryInterval = (_a3 = options.retryDelayInMs) !== null && _a3 !== undefined ? _a3 : DEFAULT_CLIENT_RETRY_INTERVAL2;
    const maxRetryInterval = (_b2 = options.maxRetryDelayInMs) !== null && _b2 !== undefined ? _b2 : DEFAULT_CLIENT_MAX_RETRY_INTERVAL2;
    return {
      name: "exponentialRetryStrategy",
      retry({ retryCount, response, responseError }) {
        const matchedSystemError = isSystemError2(responseError);
        const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
        const isExponential = isExponentialRetryResponse2(response);
        const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
        const unknownResponse = response && ((0, throttlingRetryStrategy_js_1.isThrottlingRetryResponse)(response) || !isExponential);
        if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
          return { skipStrategy: true };
        }
        if (responseError && !matchedSystemError && !isExponential) {
          return { errorToThrow: responseError };
        }
        return (0, delay_js_1.calculateRetryDelay)(retryCount, {
          retryDelayInMs: retryInterval,
          maxRetryDelayInMs: maxRetryInterval
        });
      }
    };
  }
  function isExponentialRetryResponse2(response) {
    return Boolean(response && response.status !== undefined && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
  }
  function isSystemError2(err) {
    if (!err) {
      return false;
    }
    return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" || err.code === "ENOTFOUND";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/retryPolicy.js
var require_retryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retryPolicy = retryPolicy2;
  var helpers_js_1 = require_helpers2();
  var AbortError_js_1 = require_AbortError();
  var logger_js_1 = require_logger();
  var constants_js_1 = require_constants7();
  var retryPolicyLogger2 = (0, logger_js_1.createClientLogger)("ts-http-runtime retryPolicy");
  var retryPolicyName2 = "retryPolicy";
  function retryPolicy2(strategies, options = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
    const logger4 = options.logger || retryPolicyLogger2;
    return {
      name: retryPolicyName2,
      async sendRequest(request9, next) {
        var _a3, _b2;
        let response;
        let responseError;
        let retryCount = -1;
        retryRequest:
          while (true) {
            retryCount += 1;
            response = undefined;
            responseError = undefined;
            try {
              logger4.info(`Retry ${retryCount}: Attempting to send request`, request9.requestId);
              response = await next(request9);
              logger4.info(`Retry ${retryCount}: Received a response from request`, request9.requestId);
            } catch (e2) {
              logger4.error(`Retry ${retryCount}: Received an error from request`, request9.requestId);
              responseError = e2;
              if (!e2 || responseError.name !== "RestError") {
                throw e2;
              }
              response = responseError.response;
            }
            if ((_a3 = request9.abortSignal) === null || _a3 === undefined ? undefined : _a3.aborted) {
              logger4.error(`Retry ${retryCount}: Request aborted.`);
              const abortError = new AbortError_js_1.AbortError;
              throw abortError;
            }
            if (retryCount >= ((_b2 = options.maxRetries) !== null && _b2 !== undefined ? _b2 : constants_js_1.DEFAULT_RETRY_POLICY_COUNT)) {
              logger4.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
              if (responseError) {
                throw responseError;
              } else if (response) {
                return response;
              } else {
                throw new Error("Maximum retries reached with no response or error to throw");
              }
            }
            logger4.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
            strategiesLoop:
              for (const strategy of strategies) {
                const strategyLogger = strategy.logger || logger4;
                strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
                const modifiers = strategy.retry({
                  retryCount,
                  response,
                  responseError
                });
                if (modifiers.skipStrategy) {
                  strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                  continue strategiesLoop;
                }
                const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
                if (errorToThrow) {
                  strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                  throw errorToThrow;
                }
                if (retryAfterInMs || retryAfterInMs === 0) {
                  strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                  await (0, helpers_js_1.delay)(retryAfterInMs, undefined, { abortSignal: request9.abortSignal });
                  continue retryRequest;
                }
                if (redirectTo) {
                  strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                  request9.url = redirectTo;
                  continue retryRequest;
                }
              }
            if (responseError) {
              logger4.info(`None of the retry strategies could work with the received error. Throwing it.`);
              throw responseError;
            }
            if (response) {
              logger4.info(`None of the retry strategies could work with the received response. Returning it.`);
              return response;
            }
          }
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/defaultRetryPolicy.js
var require_defaultRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultRetryPolicyName = undefined;
  exports.defaultRetryPolicy = defaultRetryPolicy3;
  var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
  var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
  var retryPolicy_js_1 = require_retryPolicy();
  var constants_js_1 = require_constants7();
  exports.defaultRetryPolicyName = "defaultRetryPolicy";
  function defaultRetryPolicy3(options = {}) {
    var _a3;
    return {
      name: exports.defaultRetryPolicyName,
      sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)(), (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)(options)], {
        maxRetries: (_a3 = options.maxRetries) !== null && _a3 !== undefined ? _a3 : constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/checkEnvironment.js
var require_checkEnvironment = __commonJS((exports) => {
  var _a3;
  var _b2;
  var _c2;
  var _d2;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isReactNative = exports.isNodeRuntime = exports.isNodeLike = exports.isBun = exports.isDeno = exports.isWebWorker = exports.isBrowser = undefined;
  exports.isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  exports.isWebWorker = typeof self === "object" && typeof (self === null || self === undefined ? undefined : self.importScripts) === "function" && (((_a3 = self.constructor) === null || _a3 === undefined ? undefined : _a3.name) === "DedicatedWorkerGlobalScope" || ((_b2 = self.constructor) === null || _b2 === undefined ? undefined : _b2.name) === "ServiceWorkerGlobalScope" || ((_c2 = self.constructor) === null || _c2 === undefined ? undefined : _c2.name) === "SharedWorkerGlobalScope");
  exports.isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
  exports.isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
  exports.isNodeLike = typeof globalThis.process !== "undefined" && Boolean(globalThis.process.version) && Boolean((_d2 = globalThis.process.versions) === null || _d2 === undefined ? undefined : _d2.node);
  exports.isNodeRuntime = exports.isNodeLike && !exports.isBun && !exports.isDeno;
  exports.isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === undefined ? undefined : navigator.product) === "ReactNative";
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/formDataPolicy.js
var require_formDataPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formDataPolicyName = undefined;
  exports.formDataPolicy = formDataPolicy3;
  var bytesEncoding_js_1 = require_bytesEncoding();
  var checkEnvironment_js_1 = require_checkEnvironment();
  var httpHeaders_js_1 = require_httpHeaders();
  exports.formDataPolicyName = "formDataPolicy";
  function formDataToFormDataMap2(formData) {
    var _a3;
    const formDataMap = {};
    for (const [key, value] of formData.entries()) {
      (_a3 = formDataMap[key]) !== null && _a3 !== undefined || (formDataMap[key] = []);
      formDataMap[key].push(value);
    }
    return formDataMap;
  }
  function formDataPolicy3() {
    return {
      name: exports.formDataPolicyName,
      async sendRequest(request9, next) {
        if (checkEnvironment_js_1.isNodeLike && typeof FormData !== "undefined" && request9.body instanceof FormData) {
          request9.formData = formDataToFormDataMap2(request9.body);
          request9.body = undefined;
        }
        if (request9.formData) {
          const contentType = request9.headers.get("Content-Type");
          if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
            request9.body = wwwFormUrlEncode2(request9.formData);
          } else {
            await prepareFormData2(request9.formData, request9);
          }
          request9.formData = undefined;
        }
        return next(request9);
      }
    };
  }
  function wwwFormUrlEncode2(formData) {
    const urlSearchParams = new URLSearchParams;
    for (const [key, value] of Object.entries(formData)) {
      if (Array.isArray(value)) {
        for (const subValue of value) {
          urlSearchParams.append(key, subValue.toString());
        }
      } else {
        urlSearchParams.append(key, value.toString());
      }
    }
    return urlSearchParams.toString();
  }
  async function prepareFormData2(formData, request9) {
    const contentType = request9.headers.get("Content-Type");
    if (contentType && !contentType.startsWith("multipart/form-data")) {
      return;
    }
    request9.headers.set("Content-Type", contentType !== null && contentType !== undefined ? contentType : "multipart/form-data");
    const parts = [];
    for (const [fieldName, values] of Object.entries(formData)) {
      for (const value of Array.isArray(values) ? values : [values]) {
        if (typeof value === "string") {
          parts.push({
            headers: (0, httpHeaders_js_1.createHttpHeaders)({
              "Content-Disposition": `form-data; name="${fieldName}"`
            }),
            body: (0, bytesEncoding_js_1.stringToUint8Array)(value, "utf-8")
          });
        } else if (value === undefined || value === null || typeof value !== "object") {
          throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);
        } else {
          const fileName = value.name || "blob";
          const headers = (0, httpHeaders_js_1.createHttpHeaders)();
          headers.set("Content-Disposition", `form-data; name="${fieldName}"; filename="${fileName}"`);
          headers.set("Content-Type", value.type || "application/octet-stream");
          parts.push({
            headers,
            body: value
          });
        }
      }
    }
    request9.multipartBody = { parts };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/proxyPolicy.js
var require_proxyPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.globalNoProxyList = exports.proxyPolicyName = undefined;
  exports.loadNoProxy = loadNoProxy2;
  exports.getDefaultProxySettings = getDefaultProxySettings2;
  exports.proxyPolicy = proxyPolicy3;
  var https_proxy_agent_1 = require_dist5();
  var http_proxy_agent_1 = require_dist6();
  var log_js_1 = require_log3();
  var HTTPS_PROXY2 = "HTTPS_PROXY";
  var HTTP_PROXY2 = "HTTP_PROXY";
  var ALL_PROXY2 = "ALL_PROXY";
  var NO_PROXY2 = "NO_PROXY";
  exports.proxyPolicyName = "proxyPolicy";
  exports.globalNoProxyList = [];
  var noProxyListLoaded2 = false;
  var globalBypassedMap2 = new Map;
  function getEnvironmentValue2(name) {
    if (process.env[name]) {
      return process.env[name];
    } else if (process.env[name.toLowerCase()]) {
      return process.env[name.toLowerCase()];
    }
    return;
  }
  function loadEnvironmentProxyValue2() {
    if (!process) {
      return;
    }
    const httpsProxy = getEnvironmentValue2(HTTPS_PROXY2);
    const allProxy = getEnvironmentValue2(ALL_PROXY2);
    const httpProxy = getEnvironmentValue2(HTTP_PROXY2);
    return httpsProxy || allProxy || httpProxy;
  }
  function isBypassed2(uri, noProxyList, bypassedMap) {
    if (noProxyList.length === 0) {
      return false;
    }
    const host = new URL(uri).hostname;
    if (bypassedMap === null || bypassedMap === undefined ? undefined : bypassedMap.has(host)) {
      return bypassedMap.get(host);
    }
    let isBypassedFlag = false;
    for (const pattern of noProxyList) {
      if (pattern[0] === ".") {
        if (host.endsWith(pattern)) {
          isBypassedFlag = true;
        } else {
          if (host.length === pattern.length - 1 && host === pattern.slice(1)) {
            isBypassedFlag = true;
          }
        }
      } else {
        if (host === pattern) {
          isBypassedFlag = true;
        }
      }
    }
    bypassedMap === null || bypassedMap === undefined || bypassedMap.set(host, isBypassedFlag);
    return isBypassedFlag;
  }
  function loadNoProxy2() {
    const noProxy = getEnvironmentValue2(NO_PROXY2);
    noProxyListLoaded2 = true;
    if (noProxy) {
      return noProxy.split(",").map((item) => item.trim()).filter((item) => item.length);
    }
    return [];
  }
  function getDefaultProxySettings2(proxyUrl) {
    if (!proxyUrl) {
      proxyUrl = loadEnvironmentProxyValue2();
      if (!proxyUrl) {
        return;
      }
    }
    const parsedUrl = new URL(proxyUrl);
    const schema = parsedUrl.protocol ? parsedUrl.protocol + "//" : "";
    return {
      host: schema + parsedUrl.hostname,
      port: Number.parseInt(parsedUrl.port || "80"),
      username: parsedUrl.username,
      password: parsedUrl.password
    };
  }
  function getDefaultProxySettingsInternal2() {
    const envProxy = loadEnvironmentProxyValue2();
    return envProxy ? new URL(envProxy) : undefined;
  }
  function getUrlFromProxySettings2(settings) {
    let parsedProxyUrl;
    try {
      parsedProxyUrl = new URL(settings.host);
    } catch (_a3) {
      throw new Error(`Expecting a valid host string in proxy settings, but found "${settings.host}".`);
    }
    parsedProxyUrl.port = String(settings.port);
    if (settings.username) {
      parsedProxyUrl.username = settings.username;
    }
    if (settings.password) {
      parsedProxyUrl.password = settings.password;
    }
    return parsedProxyUrl;
  }
  function setProxyAgentOnRequest2(request9, cachedAgents, proxyUrl) {
    if (request9.agent) {
      return;
    }
    const url = new URL(request9.url);
    const isInsecure = url.protocol !== "https:";
    if (request9.tlsSettings) {
      log_js_1.logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
    }
    const headers = request9.headers.toJSON();
    if (isInsecure) {
      if (!cachedAgents.httpProxyAgent) {
        cachedAgents.httpProxyAgent = new http_proxy_agent_1.HttpProxyAgent(proxyUrl, { headers });
      }
      request9.agent = cachedAgents.httpProxyAgent;
    } else {
      if (!cachedAgents.httpsProxyAgent) {
        cachedAgents.httpsProxyAgent = new https_proxy_agent_1.HttpsProxyAgent(proxyUrl, { headers });
      }
      request9.agent = cachedAgents.httpsProxyAgent;
    }
  }
  function proxyPolicy3(proxySettings, options) {
    if (!noProxyListLoaded2) {
      exports.globalNoProxyList.push(...loadNoProxy2());
    }
    const defaultProxy = proxySettings ? getUrlFromProxySettings2(proxySettings) : getDefaultProxySettingsInternal2();
    const cachedAgents = {};
    return {
      name: exports.proxyPolicyName,
      async sendRequest(request9, next) {
        var _a3;
        if (!request9.proxySettings && defaultProxy && !isBypassed2(request9.url, (_a3 = options === null || options === undefined ? undefined : options.customNoProxyList) !== null && _a3 !== undefined ? _a3 : exports.globalNoProxyList, (options === null || options === undefined ? undefined : options.customNoProxyList) ? undefined : globalBypassedMap2)) {
          setProxyAgentOnRequest2(request9, cachedAgents, defaultProxy);
        } else if (request9.proxySettings) {
          setProxyAgentOnRequest2(request9, cachedAgents, getUrlFromProxySettings2(request9.proxySettings));
        }
        return next(request9);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/agentPolicy.js
var require_agentPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.agentPolicyName = undefined;
  exports.agentPolicy = agentPolicy3;
  exports.agentPolicyName = "agentPolicy";
  function agentPolicy3(agent) {
    return {
      name: exports.agentPolicyName,
      sendRequest: async (req, next) => {
        if (!req.agent) {
          req.agent = agent;
        }
        return next(req);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/tlsPolicy.js
var require_tlsPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tlsPolicyName = undefined;
  exports.tlsPolicy = tlsPolicy3;
  exports.tlsPolicyName = "tlsPolicy";
  function tlsPolicy3(tlsSettings) {
    return {
      name: exports.tlsPolicyName,
      sendRequest: async (req, next) => {
        if (!req.tlsSettings) {
          req.tlsSettings = tlsSettings;
        }
        return next(req);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/typeGuards.js
var require_typeGuards = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isNodeReadableStream = isNodeReadableStream2;
  exports.isWebReadableStream = isWebReadableStream2;
  exports.isBinaryBody = isBinaryBody2;
  exports.isReadableStream = isReadableStream3;
  exports.isBlob = isBlob2;
  function isNodeReadableStream2(x2) {
    return Boolean(x2 && typeof x2["pipe"] === "function");
  }
  function isWebReadableStream2(x2) {
    return Boolean(x2 && typeof x2.getReader === "function" && typeof x2.tee === "function");
  }
  function isBinaryBody2(body) {
    return body !== undefined && (body instanceof Uint8Array || isReadableStream3(body) || typeof body === "function" || body instanceof Blob);
  }
  function isReadableStream3(x2) {
    return isNodeReadableStream2(x2) || isWebReadableStream2(x2);
  }
  function isBlob2(x2) {
    return typeof x2.stream === "function";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/concat.js
var require_concat = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concat = concat2;
  var tslib_1 = require_tslib();
  var stream_1 = __require("stream");
  var typeGuards_js_1 = require_typeGuards();
  function streamAsyncIterator2() {
    return tslib_1.__asyncGenerator(this, arguments, function* streamAsyncIterator_1() {
      const reader = this.getReader();
      try {
        while (true) {
          const { done, value } = yield tslib_1.__await(reader.read());
          if (done) {
            return yield tslib_1.__await(undefined);
          }
          yield yield tslib_1.__await(value);
        }
      } finally {
        reader.releaseLock();
      }
    });
  }
  function makeAsyncIterable2(webStream) {
    if (!webStream[Symbol.asyncIterator]) {
      webStream[Symbol.asyncIterator] = streamAsyncIterator2.bind(webStream);
    }
    if (!webStream.values) {
      webStream.values = streamAsyncIterator2.bind(webStream);
    }
  }
  function ensureNodeStream2(stream) {
    if (stream instanceof ReadableStream) {
      makeAsyncIterable2(stream);
      return stream_1.Readable.fromWeb(stream);
    } else {
      return stream;
    }
  }
  function toStream2(source) {
    if (source instanceof Uint8Array) {
      return stream_1.Readable.from(Buffer.from(source));
    } else if ((0, typeGuards_js_1.isBlob)(source)) {
      return ensureNodeStream2(source.stream());
    } else {
      return ensureNodeStream2(source);
    }
  }
  async function concat2(sources) {
    return function() {
      const streams = sources.map((x2) => typeof x2 === "function" ? x2() : x2).map(toStream2);
      return stream_1.Readable.from(function() {
        return tslib_1.__asyncGenerator(this, arguments, function* () {
          var _a3, e_1, _b2, _c2;
          for (const stream of streams) {
            try {
              for (var _d2 = true, stream_2 = (e_1 = undefined, tslib_1.__asyncValues(stream)), stream_2_1;stream_2_1 = yield tslib_1.__await(stream_2.next()), _a3 = stream_2_1.done, !_a3; _d2 = true) {
                _c2 = stream_2_1.value;
                _d2 = false;
                const chunk = _c2;
                yield yield tslib_1.__await(chunk);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (!_d2 && !_a3 && (_b2 = stream_2.return))
                  yield tslib_1.__await(_b2.call(stream_2));
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
        });
      }());
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/multipartPolicy.js
var require_multipartPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.multipartPolicyName = undefined;
  exports.multipartPolicy = multipartPolicy3;
  var bytesEncoding_js_1 = require_bytesEncoding();
  var typeGuards_js_1 = require_typeGuards();
  var uuidUtils_js_1 = require_uuidUtils();
  var concat_js_1 = require_concat();
  function generateBoundary2() {
    return `----AzSDKFormBoundary${(0, uuidUtils_js_1.randomUUID)()}`;
  }
  function encodeHeaders2(headers) {
    let result = "";
    for (const [key, value] of headers) {
      result += `${key}: ${value}\r
`;
    }
    return result;
  }
  function getLength2(source) {
    if (source instanceof Uint8Array) {
      return source.byteLength;
    } else if ((0, typeGuards_js_1.isBlob)(source)) {
      return source.size === -1 ? undefined : source.size;
    } else {
      return;
    }
  }
  function getTotalLength2(sources) {
    let total = 0;
    for (const source of sources) {
      const partLength = getLength2(source);
      if (partLength === undefined) {
        return;
      } else {
        total += partLength;
      }
    }
    return total;
  }
  async function buildRequestBody2(request9, parts, boundary) {
    const sources = [
      (0, bytesEncoding_js_1.stringToUint8Array)(`--${boundary}`, "utf-8"),
      ...parts.flatMap((part) => [
        (0, bytesEncoding_js_1.stringToUint8Array)(`\r
`, "utf-8"),
        (0, bytesEncoding_js_1.stringToUint8Array)(encodeHeaders2(part.headers), "utf-8"),
        (0, bytesEncoding_js_1.stringToUint8Array)(`\r
`, "utf-8"),
        part.body,
        (0, bytesEncoding_js_1.stringToUint8Array)(`\r
--${boundary}`, "utf-8")
      ]),
      (0, bytesEncoding_js_1.stringToUint8Array)(`--\r
\r
`, "utf-8")
    ];
    const contentLength = getTotalLength2(sources);
    if (contentLength) {
      request9.headers.set("Content-Length", contentLength);
    }
    request9.body = await (0, concat_js_1.concat)(sources);
  }
  exports.multipartPolicyName = "multipartPolicy";
  var maxBoundaryLength2 = 70;
  var validBoundaryCharacters2 = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);
  function assertValidBoundary2(boundary) {
    if (boundary.length > maxBoundaryLength2) {
      throw new Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
    }
    if (Array.from(boundary).some((x2) => !validBoundaryCharacters2.has(x2))) {
      throw new Error(`Multipart boundary "${boundary}" contains invalid characters`);
    }
  }
  function multipartPolicy3() {
    return {
      name: exports.multipartPolicyName,
      async sendRequest(request9, next) {
        var _a3;
        if (!request9.multipartBody) {
          return next(request9);
        }
        if (request9.body) {
          throw new Error("multipartBody and regular body cannot be set at the same time");
        }
        let boundary = request9.multipartBody.boundary;
        const contentTypeHeader = (_a3 = request9.headers.get("Content-Type")) !== null && _a3 !== undefined ? _a3 : "multipart/mixed";
        const parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
        if (!parsedHeader) {
          throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);
        }
        const [, contentType, parsedBoundary] = parsedHeader;
        if (parsedBoundary && boundary && parsedBoundary !== boundary) {
          throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);
        }
        boundary !== null && boundary !== undefined || (boundary = parsedBoundary);
        if (boundary) {
          assertValidBoundary2(boundary);
        } else {
          boundary = generateBoundary2();
        }
        request9.headers.set("Content-Type", `${contentType}; boundary=${boundary}`);
        await buildRequestBody2(request9, request9.multipartBody.parts, boundary);
        request9.multipartBody = undefined;
        return next(request9);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/createPipelineFromOptions.js
var require_createPipelineFromOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createPipelineFromOptions = createPipelineFromOptions3;
  var logPolicy_js_1 = require_logPolicy();
  var pipeline_js_1 = require_pipeline();
  var redirectPolicy_js_1 = require_redirectPolicy();
  var userAgentPolicy_js_1 = require_userAgentPolicy();
  var decompressResponsePolicy_js_1 = require_decompressResponsePolicy();
  var defaultRetryPolicy_js_1 = require_defaultRetryPolicy();
  var formDataPolicy_js_1 = require_formDataPolicy();
  var checkEnvironment_js_1 = require_checkEnvironment();
  var proxyPolicy_js_1 = require_proxyPolicy();
  var agentPolicy_js_1 = require_agentPolicy();
  var tlsPolicy_js_1 = require_tlsPolicy();
  var multipartPolicy_js_1 = require_multipartPolicy();
  function createPipelineFromOptions3(options) {
    const pipeline = (0, pipeline_js_1.createEmptyPipeline)();
    if (checkEnvironment_js_1.isNodeLike) {
      if (options.agent) {
        pipeline.addPolicy((0, agentPolicy_js_1.agentPolicy)(options.agent));
      }
      if (options.tlsOptions) {
        pipeline.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options.tlsOptions));
      }
      pipeline.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options.proxyOptions));
      pipeline.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
    }
    pipeline.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] });
    pipeline.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options.userAgentOptions));
    pipeline.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" });
    pipeline.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options.retryOptions), { phase: "Retry" });
    if (checkEnvironment_js_1.isNodeLike) {
      pipeline.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options.redirectOptions), { afterPhase: "Retry" });
    }
    pipeline.addPolicy((0, logPolicy_js_1.logPolicy)(options.loggingOptions), { afterPhase: "Sign" });
    return pipeline;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/apiVersionPolicy.js
var require_apiVersionPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.apiVersionPolicyName = undefined;
  exports.apiVersionPolicy = apiVersionPolicy3;
  exports.apiVersionPolicyName = "ApiVersionPolicy";
  function apiVersionPolicy3(options) {
    return {
      name: exports.apiVersionPolicyName,
      sendRequest: (req, next) => {
        const url = new URL(req.url);
        if (!url.searchParams.get("api-version") && options.apiVersion) {
          req.url = `${req.url}${Array.from(url.searchParams.keys()).length > 0 ? "&" : "?"}api-version=${options.apiVersion}`;
        }
        return next(req);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/credentials.js
var require_credentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isOAuth2TokenCredential = isOAuth2TokenCredential2;
  exports.isBearerTokenCredential = isBearerTokenCredential2;
  exports.isBasicCredential = isBasicCredential2;
  exports.isApiKeyCredential = isApiKeyCredential2;
  function isOAuth2TokenCredential2(credential) {
    return "getOAuth2Token" in credential;
  }
  function isBearerTokenCredential2(credential) {
    return "getBearerToken" in credential;
  }
  function isBasicCredential2(credential) {
    return "username" in credential && "password" in credential;
  }
  function isApiKeyCredential2(credential) {
    return "key" in credential;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/checkInsecureConnection.js
var require_checkInsecureConnection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ensureSecureConnection = ensureSecureConnection2;
  var log_js_1 = require_log3();
  var insecureConnectionWarningEmmitted2 = false;
  function allowInsecureConnection2(request9, options) {
    if (options.allowInsecureConnection && request9.allowInsecureConnection) {
      const url = new URL(request9.url);
      if (url.hostname === "localhost" || url.hostname === "127.0.0.1") {
        return true;
      }
    }
    return false;
  }
  function emitInsecureConnectionWarning2() {
    const warning = "Sending token over insecure transport. Assume any token issued is compromised.";
    log_js_1.logger.warning(warning);
    if (typeof (process === null || process === undefined ? undefined : process.emitWarning) === "function" && !insecureConnectionWarningEmmitted2) {
      insecureConnectionWarningEmmitted2 = true;
      process.emitWarning(warning);
    }
  }
  function ensureSecureConnection2(request9, options) {
    if (!request9.url.toLowerCase().startsWith("https://")) {
      if (allowInsecureConnection2(request9, options)) {
        emitInsecureConnectionWarning2();
      } else {
        throw new Error("Authentication is not permitted for non-TLS protected (non-https) URLs when allowInsecureConnection is false.");
      }
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/apiKeyAuthenticationPolicy.js
var require_apiKeyAuthenticationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.apiKeyAuthenticationPolicyName = undefined;
  exports.apiKeyAuthenticationPolicy = apiKeyAuthenticationPolicy2;
  var checkInsecureConnection_js_1 = require_checkInsecureConnection();
  exports.apiKeyAuthenticationPolicyName = "apiKeyAuthenticationPolicy";
  function apiKeyAuthenticationPolicy2(options) {
    return {
      name: exports.apiKeyAuthenticationPolicyName,
      async sendRequest(request9, next) {
        var _a3, _b2;
        (0, checkInsecureConnection_js_1.ensureSecureConnection)(request9, options);
        const scheme = (_b2 = (_a3 = request9.authSchemes) !== null && _a3 !== undefined ? _a3 : options.authSchemes) === null || _b2 === undefined ? undefined : _b2.find((x2) => x2.kind === "apiKey");
        if (!scheme) {
          return next(request9);
        }
        if (scheme.apiKeyLocation !== "header") {
          throw new Error(`Unsupported API key location: ${scheme.apiKeyLocation}`);
        }
        request9.headers.set(scheme.name, options.credential.key);
        return next(request9);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/basicAuthenticationPolicy.js
var require_basicAuthenticationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.basicAuthenticationPolicyName = undefined;
  exports.basicAuthenticationPolicy = basicAuthenticationPolicy2;
  var bytesEncoding_js_1 = require_bytesEncoding();
  var checkInsecureConnection_js_1 = require_checkInsecureConnection();
  exports.basicAuthenticationPolicyName = "bearerAuthenticationPolicy";
  function basicAuthenticationPolicy2(options) {
    return {
      name: exports.basicAuthenticationPolicyName,
      async sendRequest(request9, next) {
        var _a3, _b2;
        (0, checkInsecureConnection_js_1.ensureSecureConnection)(request9, options);
        const scheme = (_b2 = (_a3 = request9.authSchemes) !== null && _a3 !== undefined ? _a3 : options.authSchemes) === null || _b2 === undefined ? undefined : _b2.find((x2) => x2.kind === "http" && x2.scheme === "basic");
        if (!scheme) {
          return next(request9);
        }
        const { username, password } = options.credential;
        const headerValue = (0, bytesEncoding_js_1.uint8ArrayToString)((0, bytesEncoding_js_1.stringToUint8Array)(`${username}:${password}`, "utf-8"), "base64");
        request9.headers.set("Authorization", `Basic ${headerValue}`);
        return next(request9);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/bearerAuthenticationPolicy.js
var require_bearerAuthenticationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bearerAuthenticationPolicyName = undefined;
  exports.bearerAuthenticationPolicy = bearerAuthenticationPolicy2;
  var checkInsecureConnection_js_1 = require_checkInsecureConnection();
  exports.bearerAuthenticationPolicyName = "bearerAuthenticationPolicy";
  function bearerAuthenticationPolicy2(options) {
    return {
      name: exports.bearerAuthenticationPolicyName,
      async sendRequest(request9, next) {
        var _a3, _b2;
        (0, checkInsecureConnection_js_1.ensureSecureConnection)(request9, options);
        const scheme = (_b2 = (_a3 = request9.authSchemes) !== null && _a3 !== undefined ? _a3 : options.authSchemes) === null || _b2 === undefined ? undefined : _b2.find((x2) => x2.kind === "http" && x2.scheme === "bearer");
        if (!scheme) {
          return next(request9);
        }
        const token = await options.credential.getBearerToken({
          abortSignal: request9.abortSignal
        });
        request9.headers.set("Authorization", `Bearer ${token}`);
        return next(request9);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/oauth2AuthenticationPolicy.js
var require_oauth2AuthenticationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.oauth2AuthenticationPolicyName = undefined;
  exports.oauth2AuthenticationPolicy = oauth2AuthenticationPolicy2;
  var checkInsecureConnection_js_1 = require_checkInsecureConnection();
  exports.oauth2AuthenticationPolicyName = "oauth2AuthenticationPolicy";
  function oauth2AuthenticationPolicy2(options) {
    return {
      name: exports.oauth2AuthenticationPolicyName,
      async sendRequest(request9, next) {
        var _a3, _b2;
        (0, checkInsecureConnection_js_1.ensureSecureConnection)(request9, options);
        const scheme = (_b2 = (_a3 = request9.authSchemes) !== null && _a3 !== undefined ? _a3 : options.authSchemes) === null || _b2 === undefined ? undefined : _b2.find((x2) => x2.kind === "oauth2");
        if (!scheme) {
          return next(request9);
        }
        const token = await options.credential.getOAuth2Token(scheme.flows, {
          abortSignal: request9.abortSignal
        });
        request9.headers.set("Authorization", `Bearer ${token}`);
        return next(request9);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/clientHelpers.js
var require_clientHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDefaultPipeline = createDefaultPipeline3;
  exports.getCachedDefaultHttpsClient = getCachedDefaultHttpsClient2;
  var defaultHttpClient_js_1 = require_defaultHttpClient();
  var createPipelineFromOptions_js_1 = require_createPipelineFromOptions();
  var apiVersionPolicy_js_1 = require_apiVersionPolicy();
  var credentials_js_1 = require_credentials();
  var apiKeyAuthenticationPolicy_js_1 = require_apiKeyAuthenticationPolicy();
  var basicAuthenticationPolicy_js_1 = require_basicAuthenticationPolicy();
  var bearerAuthenticationPolicy_js_1 = require_bearerAuthenticationPolicy();
  var oauth2AuthenticationPolicy_js_1 = require_oauth2AuthenticationPolicy();
  var cachedHttpClient2;
  function createDefaultPipeline3(options = {}) {
    const pipeline = (0, createPipelineFromOptions_js_1.createPipelineFromOptions)(options);
    pipeline.addPolicy((0, apiVersionPolicy_js_1.apiVersionPolicy)(options));
    const { credential, authSchemes, allowInsecureConnection: allowInsecureConnection2 } = options;
    if (credential) {
      if ((0, credentials_js_1.isApiKeyCredential)(credential)) {
        pipeline.addPolicy((0, apiKeyAuthenticationPolicy_js_1.apiKeyAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection: allowInsecureConnection2 }));
      } else if ((0, credentials_js_1.isBasicCredential)(credential)) {
        pipeline.addPolicy((0, basicAuthenticationPolicy_js_1.basicAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection: allowInsecureConnection2 }));
      } else if ((0, credentials_js_1.isBearerTokenCredential)(credential)) {
        pipeline.addPolicy((0, bearerAuthenticationPolicy_js_1.bearerAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection: allowInsecureConnection2 }));
      } else if ((0, credentials_js_1.isOAuth2TokenCredential)(credential)) {
        pipeline.addPolicy((0, oauth2AuthenticationPolicy_js_1.oauth2AuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection: allowInsecureConnection2 }));
      }
    }
    return pipeline;
  }
  function getCachedDefaultHttpsClient2() {
    if (!cachedHttpClient2) {
      cachedHttpClient2 = (0, defaultHttpClient_js_1.createDefaultHttpClient)();
    }
    return cachedHttpClient2;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/multipart.js
var require_multipart2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildBodyPart = buildBodyPart2;
  exports.buildMultipartBody = buildMultipartBody2;
  var restError_js_1 = require_restError();
  var httpHeaders_js_1 = require_httpHeaders();
  var bytesEncoding_js_1 = require_bytesEncoding();
  var typeGuards_js_1 = require_typeGuards();
  function getHeaderValue2(descriptor, headerName) {
    if (descriptor.headers) {
      const actualHeaderName = Object.keys(descriptor.headers).find((x2) => x2.toLowerCase() === headerName.toLowerCase());
      if (actualHeaderName) {
        return descriptor.headers[actualHeaderName];
      }
    }
    return;
  }
  function getPartContentType2(descriptor) {
    const contentTypeHeader = getHeaderValue2(descriptor, "content-type");
    if (contentTypeHeader) {
      return contentTypeHeader;
    }
    if (descriptor.contentType === null) {
      return;
    }
    if (descriptor.contentType) {
      return descriptor.contentType;
    }
    const { body } = descriptor;
    if (body === null || body === undefined) {
      return;
    }
    if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") {
      return "text/plain; charset=UTF-8";
    }
    if (body instanceof Blob) {
      return body.type || "application/octet-stream";
    }
    if ((0, typeGuards_js_1.isBinaryBody)(body)) {
      return "application/octet-stream";
    }
    return "application/json";
  }
  function escapeDispositionField2(value) {
    return JSON.stringify(value);
  }
  function getContentDisposition2(descriptor) {
    var _a3;
    const contentDispositionHeader = getHeaderValue2(descriptor, "content-disposition");
    if (contentDispositionHeader) {
      return contentDispositionHeader;
    }
    if (descriptor.dispositionType === undefined && descriptor.name === undefined && descriptor.filename === undefined) {
      return;
    }
    const dispositionType = (_a3 = descriptor.dispositionType) !== null && _a3 !== undefined ? _a3 : "form-data";
    let disposition = dispositionType;
    if (descriptor.name) {
      disposition += `; name=${escapeDispositionField2(descriptor.name)}`;
    }
    let filename = undefined;
    if (descriptor.filename) {
      filename = descriptor.filename;
    } else if (typeof File !== "undefined" && descriptor.body instanceof File) {
      const filenameFromFile = descriptor.body.name;
      if (filenameFromFile !== "") {
        filename = filenameFromFile;
      }
    }
    if (filename) {
      disposition += `; filename=${escapeDispositionField2(filename)}`;
    }
    return disposition;
  }
  function normalizeBody2(body, contentType) {
    if (body === undefined) {
      return new Uint8Array([]);
    }
    if ((0, typeGuards_js_1.isBinaryBody)(body)) {
      return body;
    }
    if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") {
      return (0, bytesEncoding_js_1.stringToUint8Array)(String(body), "utf-8");
    }
    if (contentType && /application\/(.+\+)?json(;.+)?/i.test(String(contentType))) {
      return (0, bytesEncoding_js_1.stringToUint8Array)(JSON.stringify(body), "utf-8");
    }
    throw new restError_js_1.RestError(`Unsupported body/content-type combination: ${body}, ${contentType}`);
  }
  function buildBodyPart2(descriptor) {
    var _a3;
    const contentType = getPartContentType2(descriptor);
    const contentDisposition = getContentDisposition2(descriptor);
    const headers = (0, httpHeaders_js_1.createHttpHeaders)((_a3 = descriptor.headers) !== null && _a3 !== undefined ? _a3 : {});
    if (contentType) {
      headers.set("content-type", contentType);
    }
    if (contentDisposition) {
      headers.set("content-disposition", contentDisposition);
    }
    const body = normalizeBody2(descriptor.body, contentType);
    return {
      headers,
      body
    };
  }
  function buildMultipartBody2(parts) {
    return { parts: parts.map(buildBodyPart2) };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/sendRequest.js
var require_sendRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sendRequest = sendRequest2;
  var restError_js_1 = require_restError();
  var httpHeaders_js_1 = require_httpHeaders();
  var pipelineRequest_js_1 = require_pipelineRequest();
  var clientHelpers_js_1 = require_clientHelpers();
  var typeGuards_js_1 = require_typeGuards();
  var multipart_js_1 = require_multipart2();
  async function sendRequest2(method, url, pipeline, options = {}, customHttpClient) {
    var _a3;
    const httpClient = customHttpClient !== null && customHttpClient !== undefined ? customHttpClient : (0, clientHelpers_js_1.getCachedDefaultHttpsClient)();
    const request9 = buildPipelineRequest2(method, url, options);
    try {
      const response = await pipeline.sendRequest(httpClient, request9);
      const headers = response.headers.toJSON();
      const stream = (_a3 = response.readableStreamBody) !== null && _a3 !== undefined ? _a3 : response.browserStreamBody;
      const parsedBody = options.responseAsStream || stream !== undefined ? undefined : getResponseBody2(response);
      const body = stream !== null && stream !== undefined ? stream : parsedBody;
      if (options === null || options === undefined ? undefined : options.onResponse) {
        options.onResponse(Object.assign(Object.assign({}, response), { request: request9, rawHeaders: headers, parsedBody }));
      }
      return {
        request: request9,
        headers,
        status: `${response.status}`,
        body
      };
    } catch (e2) {
      if ((0, restError_js_1.isRestError)(e2) && e2.response && options.onResponse) {
        const { response } = e2;
        const rawHeaders = response.headers.toJSON();
        options === null || options === undefined || options.onResponse(Object.assign(Object.assign({}, response), { request: request9, rawHeaders }), e2);
      }
      throw e2;
    }
  }
  function getRequestContentType2(options = {}) {
    var _a3, _b2, _c2;
    return (_c2 = (_a3 = options.contentType) !== null && _a3 !== undefined ? _a3 : (_b2 = options.headers) === null || _b2 === undefined ? undefined : _b2["content-type"]) !== null && _c2 !== undefined ? _c2 : getContentType2(options.body);
  }
  function getContentType2(body) {
    if (ArrayBuffer.isView(body)) {
      return "application/octet-stream";
    }
    if (typeof body === "string") {
      try {
        JSON.parse(body);
        return "application/json";
      } catch (error) {
        return;
      }
    }
    return "application/json";
  }
  function buildPipelineRequest2(method, url, options = {}) {
    var _a3, _b2, _c2;
    const requestContentType = getRequestContentType2(options);
    const { body, multipartBody } = getRequestBody3(options.body, requestContentType);
    const hasContent = body !== undefined || multipartBody !== undefined;
    const headers = (0, httpHeaders_js_1.createHttpHeaders)(Object.assign(Object.assign(Object.assign({}, options.headers ? options.headers : {}), { accept: (_c2 = (_a3 = options.accept) !== null && _a3 !== undefined ? _a3 : (_b2 = options.headers) === null || _b2 === undefined ? undefined : _b2.accept) !== null && _c2 !== undefined ? _c2 : "application/json" }), hasContent && requestContentType && {
      "content-type": requestContentType
    }));
    return (0, pipelineRequest_js_1.createPipelineRequest)({
      url,
      method,
      body,
      multipartBody,
      headers,
      allowInsecureConnection: options.allowInsecureConnection,
      abortSignal: options.abortSignal,
      onUploadProgress: options.onUploadProgress,
      onDownloadProgress: options.onDownloadProgress,
      timeout: options.timeout,
      enableBrowserStreams: true,
      streamResponseStatusCodes: options.responseAsStream ? new Set([Number.POSITIVE_INFINITY]) : undefined
    });
  }
  function getRequestBody3(body, contentType = "") {
    if (body === undefined) {
      return { body: undefined };
    }
    if (typeof FormData !== "undefined" && body instanceof FormData) {
      return { body };
    }
    if ((0, typeGuards_js_1.isReadableStream)(body)) {
      return { body };
    }
    if (ArrayBuffer.isView(body)) {
      return { body: body instanceof Uint8Array ? body : JSON.stringify(body) };
    }
    const firstType = contentType.split(";")[0];
    switch (firstType) {
      case "application/json":
        return { body: JSON.stringify(body) };
      case "multipart/form-data":
        if (Array.isArray(body)) {
          return { multipartBody: (0, multipart_js_1.buildMultipartBody)(body) };
        }
        return { body: JSON.stringify(body) };
      case "text/plain":
        return { body: String(body) };
      default:
        if (typeof body === "string") {
          return { body };
        }
        return { body: JSON.stringify(body) };
    }
  }
  function getResponseBody2(response) {
    var _a3, _b2;
    const contentType = (_a3 = response.headers.get("content-type")) !== null && _a3 !== undefined ? _a3 : "";
    const firstType = contentType.split(";")[0];
    const bodyToParse = (_b2 = response.bodyAsText) !== null && _b2 !== undefined ? _b2 : "";
    if (firstType === "text/plain") {
      return String(bodyToParse);
    }
    try {
      return bodyToParse ? JSON.parse(bodyToParse) : undefined;
    } catch (error) {
      if (firstType === "application/json") {
        throw createParseError2(response, error);
      }
      return String(bodyToParse);
    }
  }
  function createParseError2(response, err) {
    var _a3;
    const msg = `Error "${err}" occurred while parsing the response body - ${response.bodyAsText}.`;
    const errCode = (_a3 = err.code) !== null && _a3 !== undefined ? _a3 : restError_js_1.RestError.PARSE_ERROR;
    return new restError_js_1.RestError(msg, {
      code: errCode,
      statusCode: response.status,
      request: response.request,
      response
    });
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/urlHelpers.js
var require_urlHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildRequestUrl = buildRequestUrl2;
  exports.buildBaseUrl = buildBaseUrl2;
  exports.replaceAll = replaceAll2;
  function isQueryParameterWithOptions2(x2) {
    const value = x2.value;
    return value !== undefined && value.toString !== undefined && typeof value.toString === "function";
  }
  function buildRequestUrl2(endpoint7, routePath, pathParameters, options = {}) {
    if (routePath.startsWith("https://") || routePath.startsWith("http://")) {
      return routePath;
    }
    endpoint7 = buildBaseUrl2(endpoint7, options);
    routePath = buildRoutePath2(routePath, pathParameters, options);
    const requestUrl = appendQueryParams2(`${endpoint7}/${routePath}`, options);
    const url = new URL(requestUrl);
    return url.toString().replace(/([^:]\/)\/+/g, "$1");
  }
  function getQueryParamValue2(key, allowReserved, style, param) {
    let separator;
    if (style === "pipeDelimited") {
      separator = "|";
    } else if (style === "spaceDelimited") {
      separator = "%20";
    } else {
      separator = ",";
    }
    let paramValues;
    if (Array.isArray(param)) {
      paramValues = param;
    } else if (typeof param === "object" && param.toString === Object.prototype.toString) {
      paramValues = Object.entries(param).flat();
    } else {
      paramValues = [param];
    }
    const value = paramValues.map((p2) => {
      if (p2 === null || p2 === undefined) {
        return "";
      }
      if (!p2.toString || typeof p2.toString !== "function") {
        throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);
      }
      const rawValue = p2.toISOString !== undefined ? p2.toISOString() : p2.toString();
      return allowReserved ? rawValue : encodeURIComponent(rawValue);
    }).join(separator);
    return `${allowReserved ? key : encodeURIComponent(key)}=${value}`;
  }
  function appendQueryParams2(url, options = {}) {
    var _a3, _b2, _c2, _d2;
    if (!options.queryParameters) {
      return url;
    }
    const parsedUrl = new URL(url);
    const queryParams = options.queryParameters;
    const paramStrings = [];
    for (const key of Object.keys(queryParams)) {
      const param = queryParams[key];
      if (param === undefined || param === null) {
        continue;
      }
      const hasMetadata = isQueryParameterWithOptions2(param);
      const rawValue = hasMetadata ? param.value : param;
      const explode = hasMetadata ? (_a3 = param.explode) !== null && _a3 !== undefined ? _a3 : false : false;
      const style = hasMetadata && param.style ? param.style : "form";
      if (explode) {
        if (Array.isArray(rawValue)) {
          for (const item of rawValue) {
            paramStrings.push(getQueryParamValue2(key, (_b2 = options.skipUrlEncoding) !== null && _b2 !== undefined ? _b2 : false, style, item));
          }
        } else if (typeof rawValue === "object") {
          for (const [actualKey, value] of Object.entries(rawValue)) {
            paramStrings.push(getQueryParamValue2(actualKey, (_c2 = options.skipUrlEncoding) !== null && _c2 !== undefined ? _c2 : false, style, value));
          }
        } else {
          throw new Error("explode can only be set to true for objects and arrays");
        }
      } else {
        paramStrings.push(getQueryParamValue2(key, (_d2 = options.skipUrlEncoding) !== null && _d2 !== undefined ? _d2 : false, style, rawValue));
      }
    }
    if (parsedUrl.search !== "") {
      parsedUrl.search += "&";
    }
    parsedUrl.search += paramStrings.join("&");
    return parsedUrl.toString();
  }
  function buildBaseUrl2(endpoint7, options) {
    var _a3;
    if (!options.pathParameters) {
      return endpoint7;
    }
    const pathParams = options.pathParameters;
    for (const [key, param] of Object.entries(pathParams)) {
      if (param === undefined || param === null) {
        throw new Error(`Path parameters ${key} must not be undefined or null`);
      }
      if (!param.toString || typeof param.toString !== "function") {
        throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);
      }
      let value = param.toISOString !== undefined ? param.toISOString() : String(param);
      if (!options.skipUrlEncoding) {
        value = encodeURIComponent(param);
      }
      endpoint7 = (_a3 = replaceAll2(endpoint7, `{${key}}`, value)) !== null && _a3 !== undefined ? _a3 : "";
    }
    return endpoint7;
  }
  function buildRoutePath2(routePath, pathParameters, options = {}) {
    var _a3;
    for (const pathParam of pathParameters) {
      const allowReserved = typeof pathParam === "object" && ((_a3 = pathParam.allowReserved) !== null && _a3 !== undefined ? _a3 : false);
      let value = typeof pathParam === "object" ? pathParam.value : pathParam;
      if (!options.skipUrlEncoding && !allowReserved) {
        value = encodeURIComponent(value);
      }
      routePath = routePath.replace(/\{[\w-]+\}/, String(value));
    }
    return routePath;
  }
  function replaceAll2(value, searchValue, replaceValue) {
    return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/getClient.js
var require_getClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getClient = getClient3;
  var clientHelpers_js_1 = require_clientHelpers();
  var sendRequest_js_1 = require_sendRequest();
  var urlHelpers_js_1 = require_urlHelpers();
  var checkEnvironment_js_1 = require_checkEnvironment();
  function getClient3(endpoint7, clientOptions = {}) {
    var _a3, _b2, _c2;
    const pipeline = (_a3 = clientOptions.pipeline) !== null && _a3 !== undefined ? _a3 : (0, clientHelpers_js_1.createDefaultPipeline)(clientOptions);
    if ((_b2 = clientOptions.additionalPolicies) === null || _b2 === undefined ? undefined : _b2.length) {
      for (const { policy, position } of clientOptions.additionalPolicies) {
        const afterPhase = position === "perRetry" ? "Sign" : undefined;
        pipeline.addPolicy(policy, {
          afterPhase
        });
      }
    }
    const { allowInsecureConnection: allowInsecureConnection2, httpClient } = clientOptions;
    const endpointUrl = (_c2 = clientOptions.endpoint) !== null && _c2 !== undefined ? _c2 : endpoint7;
    const client = (path2, ...args) => {
      const getUrl = (requestOptions) => (0, urlHelpers_js_1.buildRequestUrl)(endpointUrl, path2, args, Object.assign({ allowInsecureConnection: allowInsecureConnection2 }, requestOptions));
      return {
        get: (requestOptions = {}) => {
          return buildOperation2("GET", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection2, httpClient);
        },
        post: (requestOptions = {}) => {
          return buildOperation2("POST", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection2, httpClient);
        },
        put: (requestOptions = {}) => {
          return buildOperation2("PUT", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection2, httpClient);
        },
        patch: (requestOptions = {}) => {
          return buildOperation2("PATCH", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection2, httpClient);
        },
        delete: (requestOptions = {}) => {
          return buildOperation2("DELETE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection2, httpClient);
        },
        head: (requestOptions = {}) => {
          return buildOperation2("HEAD", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection2, httpClient);
        },
        options: (requestOptions = {}) => {
          return buildOperation2("OPTIONS", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection2, httpClient);
        },
        trace: (requestOptions = {}) => {
          return buildOperation2("TRACE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection2, httpClient);
        }
      };
    };
    return {
      path: client,
      pathUnchecked: client,
      pipeline
    };
  }
  function buildOperation2(method, url, pipeline, options, allowInsecureConnection2, httpClient) {
    var _a3;
    allowInsecureConnection2 = (_a3 = options.allowInsecureConnection) !== null && _a3 !== undefined ? _a3 : allowInsecureConnection2;
    return {
      then: function(onFulfilled, onrejected) {
        return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, Object.assign(Object.assign({}, options), { allowInsecureConnection: allowInsecureConnection2 }), httpClient).then(onFulfilled, onrejected);
      },
      async asBrowserStream() {
        if (checkEnvironment_js_1.isNodeLike) {
          throw new Error("`asBrowserStream` is supported only in the browser environment. Use `asNodeStream` instead to obtain the response body stream. If you require a Web stream of the response in Node, consider using `Readable.toWeb` on the result of `asNodeStream`.");
        } else {
          return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, Object.assign(Object.assign({}, options), { allowInsecureConnection: allowInsecureConnection2, responseAsStream: true }), httpClient);
        }
      },
      async asNodeStream() {
        if (checkEnvironment_js_1.isNodeLike) {
          return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, Object.assign(Object.assign({}, options), { allowInsecureConnection: allowInsecureConnection2, responseAsStream: true }), httpClient);
        } else {
          throw new Error("`isNodeStream` is not supported in the browser environment. Use `asBrowserStream` to obtain the response body stream.");
        }
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/operationOptionHelpers.js
var require_operationOptionHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.operationOptionsToRequestParameters = operationOptionsToRequestParameters;
  function operationOptionsToRequestParameters(options) {
    var _a3, _b2, _c2, _d2, _e2, _f;
    return {
      allowInsecureConnection: (_a3 = options.requestOptions) === null || _a3 === undefined ? undefined : _a3.allowInsecureConnection,
      timeout: (_b2 = options.requestOptions) === null || _b2 === undefined ? undefined : _b2.timeout,
      skipUrlEncoding: (_c2 = options.requestOptions) === null || _c2 === undefined ? undefined : _c2.skipUrlEncoding,
      abortSignal: options.abortSignal,
      onUploadProgress: (_d2 = options.requestOptions) === null || _d2 === undefined ? undefined : _d2.onUploadProgress,
      onDownloadProgress: (_e2 = options.requestOptions) === null || _e2 === undefined ? undefined : _e2.onDownloadProgress,
      headers: Object.assign({}, (_f = options.requestOptions) === null || _f === undefined ? undefined : _f.headers),
      onResponse: options.onResponse
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/restError.js
var require_restError2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createRestError = createRestError;
  var restError_js_1 = require_restError();
  var httpHeaders_js_1 = require_httpHeaders();
  function createRestError(messageOrResponse, response) {
    var _a3, _b2, _c2;
    const resp = typeof messageOrResponse === "string" ? response : messageOrResponse;
    const internalError = (_b2 = (_a3 = resp.body) === null || _a3 === undefined ? undefined : _a3.error) !== null && _b2 !== undefined ? _b2 : resp.body;
    const message = typeof messageOrResponse === "string" ? messageOrResponse : (_c2 = internalError === null || internalError === undefined ? undefined : internalError.message) !== null && _c2 !== undefined ? _c2 : `Unexpected status code: ${resp.status}`;
    return new restError_js_1.RestError(message, {
      statusCode: statusCodeToNumber(resp.status),
      code: internalError === null || internalError === undefined ? undefined : internalError.code,
      request: resp.request,
      response: toPipelineResponse(resp)
    });
  }
  function toPipelineResponse(response) {
    var _a3;
    return {
      headers: (0, httpHeaders_js_1.createHttpHeaders)(response.headers),
      request: response.request,
      status: (_a3 = statusCodeToNumber(response.status)) !== null && _a3 !== undefined ? _a3 : -1
    };
  }
  function statusCodeToNumber(statusCode) {
    const status = Number.parseInt(statusCode);
    return Number.isNaN(status) ? undefined : status;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/index.js
var require_commonjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createRestError = exports.operationOptionsToRequestParameters = exports.getClient = exports.createDefaultHttpClient = exports.uint8ArrayToString = exports.stringToUint8Array = exports.isRestError = exports.RestError = exports.createEmptyPipeline = exports.createPipelineRequest = exports.createHttpHeaders = exports.TypeSpecRuntimeLogger = exports.setLogLevel = exports.getLogLevel = exports.createClientLogger = exports.AbortError = undefined;
  var tslib_1 = require_tslib();
  var AbortError_js_1 = require_AbortError();
  Object.defineProperty(exports, "AbortError", { enumerable: true, get: function() {
    return AbortError_js_1.AbortError;
  } });
  var logger_js_1 = require_logger();
  Object.defineProperty(exports, "createClientLogger", { enumerable: true, get: function() {
    return logger_js_1.createClientLogger;
  } });
  Object.defineProperty(exports, "getLogLevel", { enumerable: true, get: function() {
    return logger_js_1.getLogLevel;
  } });
  Object.defineProperty(exports, "setLogLevel", { enumerable: true, get: function() {
    return logger_js_1.setLogLevel;
  } });
  Object.defineProperty(exports, "TypeSpecRuntimeLogger", { enumerable: true, get: function() {
    return logger_js_1.TypeSpecRuntimeLogger;
  } });
  var httpHeaders_js_1 = require_httpHeaders();
  Object.defineProperty(exports, "createHttpHeaders", { enumerable: true, get: function() {
    return httpHeaders_js_1.createHttpHeaders;
  } });
  tslib_1.__exportStar(require_schemes(), exports);
  tslib_1.__exportStar(require_oauth2Flows(), exports);
  var pipelineRequest_js_1 = require_pipelineRequest();
  Object.defineProperty(exports, "createPipelineRequest", { enumerable: true, get: function() {
    return pipelineRequest_js_1.createPipelineRequest;
  } });
  var pipeline_js_1 = require_pipeline();
  Object.defineProperty(exports, "createEmptyPipeline", { enumerable: true, get: function() {
    return pipeline_js_1.createEmptyPipeline;
  } });
  var restError_js_1 = require_restError();
  Object.defineProperty(exports, "RestError", { enumerable: true, get: function() {
    return restError_js_1.RestError;
  } });
  Object.defineProperty(exports, "isRestError", { enumerable: true, get: function() {
    return restError_js_1.isRestError;
  } });
  var bytesEncoding_js_1 = require_bytesEncoding();
  Object.defineProperty(exports, "stringToUint8Array", { enumerable: true, get: function() {
    return bytesEncoding_js_1.stringToUint8Array;
  } });
  Object.defineProperty(exports, "uint8ArrayToString", { enumerable: true, get: function() {
    return bytesEncoding_js_1.uint8ArrayToString;
  } });
  var defaultHttpClient_js_1 = require_defaultHttpClient();
  Object.defineProperty(exports, "createDefaultHttpClient", { enumerable: true, get: function() {
    return defaultHttpClient_js_1.createDefaultHttpClient;
  } });
  var getClient_js_1 = require_getClient();
  Object.defineProperty(exports, "getClient", { enumerable: true, get: function() {
    return getClient_js_1.getClient;
  } });
  var operationOptionHelpers_js_1 = require_operationOptionHelpers();
  Object.defineProperty(exports, "operationOptionsToRequestParameters", { enumerable: true, get: function() {
    return operationOptionHelpers_js_1.operationOptionsToRequestParameters;
  } });
  var restError_js_2 = require_restError2();
  Object.defineProperty(exports, "createRestError", { enumerable: true, get: function() {
    return restError_js_2.createRestError;
  } });
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/pipeline.js
var require_pipeline2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createEmptyPipeline = createEmptyPipeline3;
  var ts_http_runtime_1 = require_commonjs();
  function createEmptyPipeline3() {
    return (0, ts_http_runtime_1.createEmptyPipeline)();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/internal.js
var require_internal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createLoggerContext = undefined;
  var logger_js_1 = require_logger();
  Object.defineProperty(exports, "createLoggerContext", { enumerable: true, get: function() {
    return logger_js_1.createLoggerContext;
  } });
});

// node_modules/@azure/logger/dist/commonjs/index.js
var require_commonjs2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureLogger = undefined;
  exports.setLogLevel = setLogLevel2;
  exports.getLogLevel = getLogLevel;
  exports.createClientLogger = createClientLogger3;
  var logger_1 = require_internal();
  var context5 = (0, logger_1.createLoggerContext)({
    logLevelEnvVarName: "AZURE_LOG_LEVEL",
    namespace: "azure"
  });
  exports.AzureLogger = context5.logger;
  function setLogLevel2(level) {
    context5.setLogLevel(level);
  }
  function getLogLevel() {
    return context5.getLogLevel();
  }
  function createClientLogger3(namespace) {
    return context5.createClientLogger(namespace);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/log.js
var require_log4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = undefined;
  var logger_1 = require_commonjs2();
  exports.logger = (0, logger_1.createClientLogger)("core-rest-pipeline");
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/exponentialRetryPolicy.js
var require_exponentialRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exponentialRetryPolicyName = undefined;
  exports.exponentialRetryPolicy = exponentialRetryPolicy;
  var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
  var retryPolicy_js_1 = require_retryPolicy();
  var constants_js_1 = require_constants7();
  exports.exponentialRetryPolicyName = "exponentialRetryPolicy";
  function exponentialRetryPolicy(options = {}) {
    var _a3;
    return (0, retryPolicy_js_1.retryPolicy)([
      (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)(Object.assign(Object.assign({}, options), { ignoreSystemErrors: true }))
    ], {
      maxRetries: (_a3 = options.maxRetries) !== null && _a3 !== undefined ? _a3 : constants_js_1.DEFAULT_RETRY_POLICY_COUNT
    });
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/systemErrorRetryPolicy.js
var require_systemErrorRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.systemErrorRetryPolicyName = undefined;
  exports.systemErrorRetryPolicy = systemErrorRetryPolicy;
  var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy();
  var retryPolicy_js_1 = require_retryPolicy();
  var constants_js_1 = require_constants7();
  exports.systemErrorRetryPolicyName = "systemErrorRetryPolicy";
  function systemErrorRetryPolicy(options = {}) {
    var _a3;
    return {
      name: exports.systemErrorRetryPolicyName,
      sendRequest: (0, retryPolicy_js_1.retryPolicy)([
        (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)(Object.assign(Object.assign({}, options), { ignoreHttpStatusCodes: true }))
      ], {
        maxRetries: (_a3 = options.maxRetries) !== null && _a3 !== undefined ? _a3 : constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/throttlingRetryPolicy.js
var require_throttlingRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throttlingRetryPolicyName = undefined;
  exports.throttlingRetryPolicy = throttlingRetryPolicy;
  var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy();
  var retryPolicy_js_1 = require_retryPolicy();
  var constants_js_1 = require_constants7();
  exports.throttlingRetryPolicyName = "throttlingRetryPolicy";
  function throttlingRetryPolicy(options = {}) {
    var _a3;
    return {
      name: exports.throttlingRetryPolicyName,
      sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)()], {
        maxRetries: (_a3 = options.maxRetries) !== null && _a3 !== undefined ? _a3 : constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/internal.js
var require_internal2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.userAgentPolicyName = exports.userAgentPolicy = exports.tlsPolicyName = exports.tlsPolicy = exports.redirectPolicyName = exports.redirectPolicy = exports.getDefaultProxySettings = exports.proxyPolicyName = exports.proxyPolicy = exports.multipartPolicyName = exports.multipartPolicy = exports.logPolicyName = exports.logPolicy = exports.formDataPolicyName = exports.formDataPolicy = exports.throttlingRetryPolicyName = exports.throttlingRetryPolicy = exports.systemErrorRetryPolicyName = exports.systemErrorRetryPolicy = exports.retryPolicy = exports.exponentialRetryPolicyName = exports.exponentialRetryPolicy = exports.defaultRetryPolicyName = exports.defaultRetryPolicy = exports.decompressResponsePolicyName = exports.decompressResponsePolicy = exports.agentPolicyName = exports.agentPolicy = undefined;
  var agentPolicy_js_1 = require_agentPolicy();
  Object.defineProperty(exports, "agentPolicy", { enumerable: true, get: function() {
    return agentPolicy_js_1.agentPolicy;
  } });
  Object.defineProperty(exports, "agentPolicyName", { enumerable: true, get: function() {
    return agentPolicy_js_1.agentPolicyName;
  } });
  var decompressResponsePolicy_js_1 = require_decompressResponsePolicy();
  Object.defineProperty(exports, "decompressResponsePolicy", { enumerable: true, get: function() {
    return decompressResponsePolicy_js_1.decompressResponsePolicy;
  } });
  Object.defineProperty(exports, "decompressResponsePolicyName", { enumerable: true, get: function() {
    return decompressResponsePolicy_js_1.decompressResponsePolicyName;
  } });
  var defaultRetryPolicy_js_1 = require_defaultRetryPolicy();
  Object.defineProperty(exports, "defaultRetryPolicy", { enumerable: true, get: function() {
    return defaultRetryPolicy_js_1.defaultRetryPolicy;
  } });
  Object.defineProperty(exports, "defaultRetryPolicyName", { enumerable: true, get: function() {
    return defaultRetryPolicy_js_1.defaultRetryPolicyName;
  } });
  var exponentialRetryPolicy_js_1 = require_exponentialRetryPolicy();
  Object.defineProperty(exports, "exponentialRetryPolicy", { enumerable: true, get: function() {
    return exponentialRetryPolicy_js_1.exponentialRetryPolicy;
  } });
  Object.defineProperty(exports, "exponentialRetryPolicyName", { enumerable: true, get: function() {
    return exponentialRetryPolicy_js_1.exponentialRetryPolicyName;
  } });
  var retryPolicy_js_1 = require_retryPolicy();
  Object.defineProperty(exports, "retryPolicy", { enumerable: true, get: function() {
    return retryPolicy_js_1.retryPolicy;
  } });
  var systemErrorRetryPolicy_js_1 = require_systemErrorRetryPolicy();
  Object.defineProperty(exports, "systemErrorRetryPolicy", { enumerable: true, get: function() {
    return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy;
  } });
  Object.defineProperty(exports, "systemErrorRetryPolicyName", { enumerable: true, get: function() {
    return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName;
  } });
  var throttlingRetryPolicy_js_1 = require_throttlingRetryPolicy();
  Object.defineProperty(exports, "throttlingRetryPolicy", { enumerable: true, get: function() {
    return throttlingRetryPolicy_js_1.throttlingRetryPolicy;
  } });
  Object.defineProperty(exports, "throttlingRetryPolicyName", { enumerable: true, get: function() {
    return throttlingRetryPolicy_js_1.throttlingRetryPolicyName;
  } });
  var formDataPolicy_js_1 = require_formDataPolicy();
  Object.defineProperty(exports, "formDataPolicy", { enumerable: true, get: function() {
    return formDataPolicy_js_1.formDataPolicy;
  } });
  Object.defineProperty(exports, "formDataPolicyName", { enumerable: true, get: function() {
    return formDataPolicy_js_1.formDataPolicyName;
  } });
  var logPolicy_js_1 = require_logPolicy();
  Object.defineProperty(exports, "logPolicy", { enumerable: true, get: function() {
    return logPolicy_js_1.logPolicy;
  } });
  Object.defineProperty(exports, "logPolicyName", { enumerable: true, get: function() {
    return logPolicy_js_1.logPolicyName;
  } });
  var multipartPolicy_js_1 = require_multipartPolicy();
  Object.defineProperty(exports, "multipartPolicy", { enumerable: true, get: function() {
    return multipartPolicy_js_1.multipartPolicy;
  } });
  Object.defineProperty(exports, "multipartPolicyName", { enumerable: true, get: function() {
    return multipartPolicy_js_1.multipartPolicyName;
  } });
  var proxyPolicy_js_1 = require_proxyPolicy();
  Object.defineProperty(exports, "proxyPolicy", { enumerable: true, get: function() {
    return proxyPolicy_js_1.proxyPolicy;
  } });
  Object.defineProperty(exports, "proxyPolicyName", { enumerable: true, get: function() {
    return proxyPolicy_js_1.proxyPolicyName;
  } });
  Object.defineProperty(exports, "getDefaultProxySettings", { enumerable: true, get: function() {
    return proxyPolicy_js_1.getDefaultProxySettings;
  } });
  var redirectPolicy_js_1 = require_redirectPolicy();
  Object.defineProperty(exports, "redirectPolicy", { enumerable: true, get: function() {
    return redirectPolicy_js_1.redirectPolicy;
  } });
  Object.defineProperty(exports, "redirectPolicyName", { enumerable: true, get: function() {
    return redirectPolicy_js_1.redirectPolicyName;
  } });
  var tlsPolicy_js_1 = require_tlsPolicy();
  Object.defineProperty(exports, "tlsPolicy", { enumerable: true, get: function() {
    return tlsPolicy_js_1.tlsPolicy;
  } });
  Object.defineProperty(exports, "tlsPolicyName", { enumerable: true, get: function() {
    return tlsPolicy_js_1.tlsPolicyName;
  } });
  var userAgentPolicy_js_1 = require_userAgentPolicy();
  Object.defineProperty(exports, "userAgentPolicy", { enumerable: true, get: function() {
    return userAgentPolicy_js_1.userAgentPolicy;
  } });
  Object.defineProperty(exports, "userAgentPolicyName", { enumerable: true, get: function() {
    return userAgentPolicy_js_1.userAgentPolicyName;
  } });
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/logPolicy.js
var require_logPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logPolicyName = undefined;
  exports.logPolicy = logPolicy3;
  var log_js_1 = require_log4();
  var policies_1 = require_internal2();
  exports.logPolicyName = policies_1.logPolicyName;
  function logPolicy3(options = {}) {
    return (0, policies_1.logPolicy)(Object.assign({ logger: log_js_1.logger.info }, options));
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/redirectPolicy.js
var require_redirectPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.redirectPolicyName = undefined;
  exports.redirectPolicy = redirectPolicy3;
  var policies_1 = require_internal2();
  exports.redirectPolicyName = policies_1.redirectPolicyName;
  function redirectPolicy3(options = {}) {
    return (0, policies_1.redirectPolicy)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgentPlatform.js
var require_userAgentPlatform2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHeaderName = getHeaderName3;
  exports.setPlatformSpecificData = setPlatformSpecificData3;
  var tslib_1 = require_tslib();
  var os3 = tslib_1.__importStar(__require("node:os"));
  var process5 = tslib_1.__importStar(__require("node:process"));
  function getHeaderName3() {
    return "User-Agent";
  }
  async function setPlatformSpecificData3(map) {
    if (process5 && process5.versions) {
      const versions3 = process5.versions;
      if (versions3.bun) {
        map.set("Bun", versions3.bun);
      } else if (versions3.deno) {
        map.set("Deno", versions3.deno);
      } else if (versions3.node) {
        map.set("Node", versions3.node);
      }
    }
    map.set("OS", `(${os3.arch()}-${os3.type()}-${os3.release()})`);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/constants.js
var require_constants8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_RETRY_POLICY_COUNT = exports.SDK_VERSION = undefined;
  exports.SDK_VERSION = "1.20.0";
  exports.DEFAULT_RETRY_POLICY_COUNT = 3;
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgent.js
var require_userAgent2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getUserAgentHeaderName = getUserAgentHeaderName3;
  exports.getUserAgentValue = getUserAgentValue3;
  var userAgentPlatform_js_1 = require_userAgentPlatform2();
  var constants_js_1 = require_constants8();
  function getUserAgentString3(telemetryInfo) {
    const parts = [];
    for (const [key, value] of telemetryInfo) {
      const token = value ? `${key}/${value}` : key;
      parts.push(token);
    }
    return parts.join(" ");
  }
  function getUserAgentHeaderName3() {
    return (0, userAgentPlatform_js_1.getHeaderName)();
  }
  async function getUserAgentValue3(prefix) {
    const runtimeInfo = new Map;
    runtimeInfo.set("core-rest-pipeline", constants_js_1.SDK_VERSION);
    await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
    const defaultAgent = getUserAgentString3(runtimeInfo);
    const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
    return userAgentValue;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/userAgentPolicy.js
var require_userAgentPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.userAgentPolicyName = undefined;
  exports.userAgentPolicy = userAgentPolicy3;
  var userAgent_js_1 = require_userAgent2();
  var UserAgentHeaderName3 = (0, userAgent_js_1.getUserAgentHeaderName)();
  exports.userAgentPolicyName = "userAgentPolicy";
  function userAgentPolicy3(options = {}) {
    const userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
    return {
      name: exports.userAgentPolicyName,
      async sendRequest(request9, next) {
        if (!request9.headers.has(UserAgentHeaderName3)) {
          request9.headers.set(UserAgentHeaderName3, await userAgentValue);
        }
        return next(request9);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/sha256.js
var require_sha256 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.computeSha256Hmac = computeSha256Hmac2;
  exports.computeSha256Hash = computeSha256Hash2;
  var node_crypto_1 = __require("node:crypto");
  async function computeSha256Hmac2(key, stringToSign, encoding) {
    const decodedKey = Buffer.from(key, "base64");
    return (0, node_crypto_1.createHmac)("sha256", decodedKey).update(stringToSign).digest(encoding);
  }
  async function computeSha256Hash2(content, encoding) {
    return (0, node_crypto_1.createHash)("sha256").update(content).digest(encoding);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/internal.js
var require_internal3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Sanitizer = exports.uint8ArrayToString = exports.stringToUint8Array = exports.isWebWorker = exports.isReactNative = exports.isDeno = exports.isNodeRuntime = exports.isNodeLike = exports.isBun = exports.isBrowser = exports.randomUUID = exports.computeSha256Hmac = exports.computeSha256Hash = exports.isError = exports.isObject = exports.getRandomIntegerInclusive = exports.calculateRetryDelay = undefined;
  var delay_js_1 = require_delay();
  Object.defineProperty(exports, "calculateRetryDelay", { enumerable: true, get: function() {
    return delay_js_1.calculateRetryDelay;
  } });
  var random_js_1 = require_random();
  Object.defineProperty(exports, "getRandomIntegerInclusive", { enumerable: true, get: function() {
    return random_js_1.getRandomIntegerInclusive;
  } });
  var object_js_1 = require_object();
  Object.defineProperty(exports, "isObject", { enumerable: true, get: function() {
    return object_js_1.isObject;
  } });
  var error_js_1 = require_error();
  Object.defineProperty(exports, "isError", { enumerable: true, get: function() {
    return error_js_1.isError;
  } });
  var sha256_js_1 = require_sha256();
  Object.defineProperty(exports, "computeSha256Hash", { enumerable: true, get: function() {
    return sha256_js_1.computeSha256Hash;
  } });
  Object.defineProperty(exports, "computeSha256Hmac", { enumerable: true, get: function() {
    return sha256_js_1.computeSha256Hmac;
  } });
  var uuidUtils_js_1 = require_uuidUtils();
  Object.defineProperty(exports, "randomUUID", { enumerable: true, get: function() {
    return uuidUtils_js_1.randomUUID;
  } });
  var checkEnvironment_js_1 = require_checkEnvironment();
  Object.defineProperty(exports, "isBrowser", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isBrowser;
  } });
  Object.defineProperty(exports, "isBun", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isBun;
  } });
  Object.defineProperty(exports, "isNodeLike", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isNodeLike;
  } });
  Object.defineProperty(exports, "isNodeRuntime", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isNodeRuntime;
  } });
  Object.defineProperty(exports, "isDeno", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isDeno;
  } });
  Object.defineProperty(exports, "isReactNative", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isReactNative;
  } });
  Object.defineProperty(exports, "isWebWorker", { enumerable: true, get: function() {
    return checkEnvironment_js_1.isWebWorker;
  } });
  var bytesEncoding_js_1 = require_bytesEncoding();
  Object.defineProperty(exports, "stringToUint8Array", { enumerable: true, get: function() {
    return bytesEncoding_js_1.stringToUint8Array;
  } });
  Object.defineProperty(exports, "uint8ArrayToString", { enumerable: true, get: function() {
    return bytesEncoding_js_1.uint8ArrayToString;
  } });
  var sanitizer_js_1 = require_sanitizer();
  Object.defineProperty(exports, "Sanitizer", { enumerable: true, get: function() {
    return sanitizer_js_1.Sanitizer;
  } });
});

// node_modules/@azure/core-util/dist/commonjs/aborterUtils.js
var require_aborterUtils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cancelablePromiseRace = cancelablePromiseRace;
  async function cancelablePromiseRace(abortablePromiseBuilders, options) {
    var _a3, _b2;
    const aborter = new AbortController;
    function abortHandler() {
      aborter.abort();
    }
    (_a3 = options === null || options === undefined ? undefined : options.abortSignal) === null || _a3 === undefined || _a3.addEventListener("abort", abortHandler);
    try {
      return await Promise.race(abortablePromiseBuilders.map((p2) => p2({ abortSignal: aborter.signal })));
    } finally {
      aborter.abort();
      (_b2 = options === null || options === undefined ? undefined : options.abortSignal) === null || _b2 === undefined || _b2.removeEventListener("abort", abortHandler);
    }
  }
});

// node_modules/@azure/core-util/node_modules/@azure/abort-controller/dist/commonjs/AbortError.js
var require_AbortError2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;

  class AbortError3 extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  }
  exports.AbortError = AbortError3;
});

// node_modules/@azure/core-util/node_modules/@azure/abort-controller/dist/commonjs/index.js
var require_commonjs3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;
  var AbortError_js_1 = require_AbortError2();
  Object.defineProperty(exports, "AbortError", { enumerable: true, get: function() {
    return AbortError_js_1.AbortError;
  } });
});

// node_modules/@azure/core-util/dist/commonjs/createAbortablePromise.js
var require_createAbortablePromise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createAbortablePromise = createAbortablePromise2;
  var abort_controller_1 = require_commonjs3();
  function createAbortablePromise2(buildPromise, options) {
    const { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options !== null && options !== undefined ? options : {};
    return new Promise((resolve5, reject) => {
      function rejectOnAbort() {
        reject(new abort_controller_1.AbortError(abortErrorMsg !== null && abortErrorMsg !== undefined ? abortErrorMsg : "The operation was aborted."));
      }
      function removeListeners() {
        abortSignal === null || abortSignal === undefined || abortSignal.removeEventListener("abort", onAbort);
      }
      function onAbort() {
        cleanupBeforeAbort === null || cleanupBeforeAbort === undefined || cleanupBeforeAbort();
        removeListeners();
        rejectOnAbort();
      }
      if (abortSignal === null || abortSignal === undefined ? undefined : abortSignal.aborted) {
        return rejectOnAbort();
      }
      try {
        buildPromise((x2) => {
          removeListeners();
          resolve5(x2);
        }, (x2) => {
          removeListeners();
          reject(x2);
        });
      } catch (err) {
        reject(err);
      }
      abortSignal === null || abortSignal === undefined || abortSignal.addEventListener("abort", onAbort);
    });
  }
});

// node_modules/@azure/core-util/dist/commonjs/delay.js
var require_delay2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delay = delay3;
  exports.calculateRetryDelay = calculateRetryDelay2;
  var createAbortablePromise_js_1 = require_createAbortablePromise();
  var util_1 = require_internal3();
  var StandardAbortMessage3 = "The delay was aborted.";
  function delay3(timeInMs, options) {
    let token;
    const { abortSignal, abortErrorMsg } = options !== null && options !== undefined ? options : {};
    return (0, createAbortablePromise_js_1.createAbortablePromise)((resolve5) => {
      token = setTimeout(resolve5, timeInMs);
    }, {
      cleanupBeforeAbort: () => clearTimeout(token),
      abortSignal,
      abortErrorMsg: abortErrorMsg !== null && abortErrorMsg !== undefined ? abortErrorMsg : StandardAbortMessage3
    });
  }
  function calculateRetryDelay2(retryAttempt, config) {
    const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
    const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
    const retryAfterInMs = clampedDelay / 2 + (0, util_1.getRandomIntegerInclusive)(0, clampedDelay / 2);
    return { retryAfterInMs };
  }
});

// node_modules/@azure/core-util/dist/commonjs/error.js
var require_error2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getErrorMessage = getErrorMessage2;
  var util_1 = require_internal3();
  function getErrorMessage2(e2) {
    if ((0, util_1.isError)(e2)) {
      return e2.message;
    } else {
      let stringified;
      try {
        if (typeof e2 === "object" && e2) {
          stringified = JSON.stringify(e2);
        } else {
          stringified = String(e2);
        }
      } catch (err) {
        stringified = "[unable to stringify input]";
      }
      return `Unknown error ${stringified}`;
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/typeGuards.js
var require_typeGuards2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isDefined = isDefined8;
  exports.isObjectWithProperties = isObjectWithProperties2;
  exports.objectHasProperty = objectHasProperty2;
  function isDefined8(thing) {
    return typeof thing !== "undefined" && thing !== null;
  }
  function isObjectWithProperties2(thing, properties) {
    if (!isDefined8(thing) || typeof thing !== "object") {
      return false;
    }
    for (const property of properties) {
      if (!objectHasProperty2(thing, property)) {
        return false;
      }
    }
    return true;
  }
  function objectHasProperty2(thing, property) {
    return isDefined8(thing) && typeof thing === "object" && property in thing;
  }
});

// node_modules/@azure/core-util/dist/commonjs/index.js
var require_commonjs4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isWebWorker = exports.isReactNative = exports.isNodeRuntime = exports.isNodeLike = exports.isNode = exports.isDeno = exports.isBun = exports.isBrowser = exports.objectHasProperty = exports.isObjectWithProperties = exports.isDefined = exports.getErrorMessage = exports.delay = exports.createAbortablePromise = exports.cancelablePromiseRace = undefined;
  exports.calculateRetryDelay = calculateRetryDelay2;
  exports.computeSha256Hash = computeSha256Hash2;
  exports.computeSha256Hmac = computeSha256Hmac2;
  exports.getRandomIntegerInclusive = getRandomIntegerInclusive2;
  exports.isError = isError3;
  exports.isObject = isObject3;
  exports.randomUUID = randomUUID2;
  exports.uint8ArrayToString = uint8ArrayToString2;
  exports.stringToUint8Array = stringToUint8Array2;
  var tslib_1 = require_tslib();
  var tspRuntime = tslib_1.__importStar(require_internal3());
  var aborterUtils_js_1 = require_aborterUtils();
  Object.defineProperty(exports, "cancelablePromiseRace", { enumerable: true, get: function() {
    return aborterUtils_js_1.cancelablePromiseRace;
  } });
  var createAbortablePromise_js_1 = require_createAbortablePromise();
  Object.defineProperty(exports, "createAbortablePromise", { enumerable: true, get: function() {
    return createAbortablePromise_js_1.createAbortablePromise;
  } });
  var delay_js_1 = require_delay2();
  Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
    return delay_js_1.delay;
  } });
  var error_js_1 = require_error2();
  Object.defineProperty(exports, "getErrorMessage", { enumerable: true, get: function() {
    return error_js_1.getErrorMessage;
  } });
  var typeGuards_js_1 = require_typeGuards2();
  Object.defineProperty(exports, "isDefined", { enumerable: true, get: function() {
    return typeGuards_js_1.isDefined;
  } });
  Object.defineProperty(exports, "isObjectWithProperties", { enumerable: true, get: function() {
    return typeGuards_js_1.isObjectWithProperties;
  } });
  Object.defineProperty(exports, "objectHasProperty", { enumerable: true, get: function() {
    return typeGuards_js_1.objectHasProperty;
  } });
  function calculateRetryDelay2(retryAttempt, config) {
    return tspRuntime.calculateRetryDelay(retryAttempt, config);
  }
  function computeSha256Hash2(content, encoding) {
    return tspRuntime.computeSha256Hash(content, encoding);
  }
  function computeSha256Hmac2(key, stringToSign, encoding) {
    return tspRuntime.computeSha256Hmac(key, stringToSign, encoding);
  }
  function getRandomIntegerInclusive2(min, max) {
    return tspRuntime.getRandomIntegerInclusive(min, max);
  }
  function isError3(e2) {
    return tspRuntime.isError(e2);
  }
  function isObject3(input) {
    return tspRuntime.isObject(input);
  }
  function randomUUID2() {
    return tspRuntime.randomUUID();
  }
  exports.isBrowser = tspRuntime.isBrowser;
  exports.isBun = tspRuntime.isBun;
  exports.isDeno = tspRuntime.isDeno;
  exports.isNode = tspRuntime.isNodeLike;
  exports.isNodeLike = tspRuntime.isNodeLike;
  exports.isNodeRuntime = tspRuntime.isNodeRuntime;
  exports.isReactNative = tspRuntime.isReactNative;
  exports.isWebWorker = tspRuntime.isWebWorker;
  function uint8ArrayToString2(bytes, format5) {
    return tspRuntime.uint8ArrayToString(bytes, format5);
  }
  function stringToUint8Array2(value, format5) {
    return tspRuntime.stringToUint8Array(value, format5);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/file.js
var require_file2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasRawContent = hasRawContent2;
  exports.getRawContent = getRawContent2;
  exports.createFileFromStream = createFileFromStream;
  exports.createFile = createFile;
  var core_util_1 = require_commonjs4();
  function isNodeReadableStream2(x2) {
    return Boolean(x2 && typeof x2["pipe"] === "function");
  }
  var unimplementedMethods = {
    arrayBuffer: () => {
      throw new Error("Not implemented");
    },
    bytes: () => {
      throw new Error("Not implemented");
    },
    slice: () => {
      throw new Error("Not implemented");
    },
    text: () => {
      throw new Error("Not implemented");
    }
  };
  var rawContent2 = Symbol("rawContent");
  function hasRawContent2(x2) {
    return typeof x2[rawContent2] === "function";
  }
  function getRawContent2(blob) {
    if (hasRawContent2(blob)) {
      return blob[rawContent2]();
    } else {
      return blob;
    }
  }
  function createFileFromStream(stream, name, options = {}) {
    var _a3, _b2, _c2, _d2;
    return Object.assign(Object.assign({}, unimplementedMethods), { type: (_a3 = options.type) !== null && _a3 !== undefined ? _a3 : "", lastModified: (_b2 = options.lastModified) !== null && _b2 !== undefined ? _b2 : new Date().getTime(), webkitRelativePath: (_c2 = options.webkitRelativePath) !== null && _c2 !== undefined ? _c2 : "", size: (_d2 = options.size) !== null && _d2 !== undefined ? _d2 : -1, name, stream: () => {
      const s2 = stream();
      if (isNodeReadableStream2(s2)) {
        throw new Error("Not supported: a Node stream was provided as input to createFileFromStream.");
      }
      return s2;
    }, [rawContent2]: stream });
  }
  function createFile(content, name, options = {}) {
    var _a3, _b2, _c2;
    if (core_util_1.isNodeLike) {
      return Object.assign(Object.assign({}, unimplementedMethods), { type: (_a3 = options.type) !== null && _a3 !== undefined ? _a3 : "", lastModified: (_b2 = options.lastModified) !== null && _b2 !== undefined ? _b2 : new Date().getTime(), webkitRelativePath: (_c2 = options.webkitRelativePath) !== null && _c2 !== undefined ? _c2 : "", size: content.byteLength, name, arrayBuffer: async () => content.buffer, stream: () => new Blob([content]).stream(), [rawContent2]: () => content });
    } else {
      return new File([content], name, options);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/multipartPolicy.js
var require_multipartPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.multipartPolicyName = undefined;
  exports.multipartPolicy = multipartPolicy3;
  var policies_1 = require_internal2();
  var file_js_1 = require_file2();
  exports.multipartPolicyName = policies_1.multipartPolicyName;
  function multipartPolicy3() {
    const tspPolicy = (0, policies_1.multipartPolicy)();
    return {
      name: exports.multipartPolicyName,
      sendRequest: async (request9, next) => {
        if (request9.multipartBody) {
          for (const part of request9.multipartBody.parts) {
            if ((0, file_js_1.hasRawContent)(part.body)) {
              part.body = (0, file_js_1.getRawContent)(part.body);
            }
          }
        }
        return tspPolicy.sendRequest(request9, next);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/decompressResponsePolicy.js
var require_decompressResponsePolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decompressResponsePolicyName = undefined;
  exports.decompressResponsePolicy = decompressResponsePolicy3;
  var policies_1 = require_internal2();
  exports.decompressResponsePolicyName = policies_1.decompressResponsePolicyName;
  function decompressResponsePolicy3() {
    return (0, policies_1.decompressResponsePolicy)();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/defaultRetryPolicy.js
var require_defaultRetryPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultRetryPolicyName = undefined;
  exports.defaultRetryPolicy = defaultRetryPolicy3;
  var policies_1 = require_internal2();
  exports.defaultRetryPolicyName = policies_1.defaultRetryPolicyName;
  function defaultRetryPolicy3(options = {}) {
    return (0, policies_1.defaultRetryPolicy)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/formDataPolicy.js
var require_formDataPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formDataPolicyName = undefined;
  exports.formDataPolicy = formDataPolicy3;
  var policies_1 = require_internal2();
  exports.formDataPolicyName = policies_1.formDataPolicyName;
  function formDataPolicy3() {
    return (0, policies_1.formDataPolicy)();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/proxyPolicy.js
var require_proxyPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.proxyPolicyName = undefined;
  exports.getDefaultProxySettings = getDefaultProxySettings2;
  exports.proxyPolicy = proxyPolicy3;
  var policies_1 = require_internal2();
  exports.proxyPolicyName = policies_1.proxyPolicyName;
  function getDefaultProxySettings2(proxyUrl) {
    return (0, policies_1.getDefaultProxySettings)(proxyUrl);
  }
  function proxyPolicy3(proxySettings, options) {
    return (0, policies_1.proxyPolicy)(proxySettings, options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/setClientRequestIdPolicy.js
var require_setClientRequestIdPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.setClientRequestIdPolicyName = undefined;
  exports.setClientRequestIdPolicy = setClientRequestIdPolicy2;
  exports.setClientRequestIdPolicyName = "setClientRequestIdPolicy";
  function setClientRequestIdPolicy2(requestIdHeaderName = "x-ms-client-request-id") {
    return {
      name: exports.setClientRequestIdPolicyName,
      async sendRequest(request9, next) {
        if (!request9.headers.has(requestIdHeaderName)) {
          request9.headers.set(requestIdHeaderName, request9.requestId);
        }
        return next(request9);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/agentPolicy.js
var require_agentPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.agentPolicyName = undefined;
  exports.agentPolicy = agentPolicy3;
  var policies_1 = require_internal2();
  exports.agentPolicyName = policies_1.agentPolicyName;
  function agentPolicy3(agent) {
    return (0, policies_1.agentPolicy)(agent);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tlsPolicy.js
var require_tlsPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tlsPolicyName = undefined;
  exports.tlsPolicy = tlsPolicy3;
  var policies_1 = require_internal2();
  exports.tlsPolicyName = policies_1.tlsPolicyName;
  function tlsPolicy3(tlsSettings) {
    return (0, policies_1.tlsPolicy)(tlsSettings);
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/tracingContext.js
var require_tracingContext = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TracingContextImpl = exports.knownContextKeys = undefined;
  exports.createTracingContext = createTracingContext2;
  exports.knownContextKeys = {
    span: Symbol.for("@azure/core-tracing span"),
    namespace: Symbol.for("@azure/core-tracing namespace")
  };
  function createTracingContext2(options = {}) {
    let context5 = new TracingContextImpl2(options.parentContext);
    if (options.span) {
      context5 = context5.setValue(exports.knownContextKeys.span, options.span);
    }
    if (options.namespace) {
      context5 = context5.setValue(exports.knownContextKeys.namespace, options.namespace);
    }
    return context5;
  }

  class TracingContextImpl2 {
    constructor(initialContext) {
      this._contextMap = initialContext instanceof TracingContextImpl2 ? new Map(initialContext._contextMap) : new Map;
    }
    setValue(key, value) {
      const newContext = new TracingContextImpl2(this);
      newContext._contextMap.set(key, value);
      return newContext;
    }
    getValue(key) {
      return this._contextMap.get(key);
    }
    deleteValue(key) {
      const newContext = new TracingContextImpl2(this);
      newContext._contextMap.delete(key);
      return newContext;
    }
  }
  exports.TracingContextImpl = TracingContextImpl2;
});

// node_modules/@azure/core-tracing/dist/commonjs/instrumenter.js
var require_instrumenter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDefaultTracingSpan = createDefaultTracingSpan2;
  exports.createDefaultInstrumenter = createDefaultInstrumenter2;
  exports.useInstrumenter = useInstrumenter;
  exports.getInstrumenter = getInstrumenter2;
  var tracingContext_js_1 = require_tracingContext();
  var state_js_1 = require_state();
  function createDefaultTracingSpan2() {
    return {
      end: () => {
      },
      isRecording: () => false,
      recordException: () => {
      },
      setAttribute: () => {
      },
      setStatus: () => {
      },
      addEvent: () => {
      }
    };
  }
  function createDefaultInstrumenter2() {
    return {
      createRequestHeaders: () => {
        return {};
      },
      parseTraceparentHeader: () => {
        return;
      },
      startSpan: (_name, spanOptions) => {
        return {
          span: createDefaultTracingSpan2(),
          tracingContext: (0, tracingContext_js_1.createTracingContext)({ parentContext: spanOptions.tracingContext })
        };
      },
      withContext(_context, callback, ...callbackArgs) {
        return callback(...callbackArgs);
      }
    };
  }
  function useInstrumenter(instrumenter) {
    state_js_1.state.instrumenterImplementation = instrumenter;
  }
  function getInstrumenter2() {
    if (!state_js_1.state.instrumenterImplementation) {
      state_js_1.state.instrumenterImplementation = createDefaultInstrumenter2();
    }
    return state_js_1.state.instrumenterImplementation;
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/tracingClient.js
var require_tracingClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTracingClient = createTracingClient2;
  var instrumenter_js_1 = require_instrumenter();
  var tracingContext_js_1 = require_tracingContext();
  function createTracingClient2(options) {
    const { namespace, packageName, packageVersion } = options;
    function startSpan(name, operationOptions, spanOptions) {
      var _a3;
      const startSpanResult = (0, instrumenter_js_1.getInstrumenter)().startSpan(name, Object.assign(Object.assign({}, spanOptions), { packageName, packageVersion, tracingContext: (_a3 = operationOptions === null || operationOptions === undefined ? undefined : operationOptions.tracingOptions) === null || _a3 === undefined ? undefined : _a3.tracingContext }));
      let tracingContext = startSpanResult.tracingContext;
      const span = startSpanResult.span;
      if (!tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace)) {
        tracingContext = tracingContext.setValue(tracingContext_js_1.knownContextKeys.namespace, namespace);
      }
      span.setAttribute("az.namespace", tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace));
      const updatedOptions = Object.assign({}, operationOptions, {
        tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === undefined ? undefined : operationOptions.tracingOptions), { tracingContext })
      });
      return {
        span,
        updatedOptions
      };
    }
    async function withSpan(name, operationOptions, callback, spanOptions) {
      const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
      try {
        const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
        span.setStatus({ status: "success" });
        return result;
      } catch (err) {
        span.setStatus({ status: "error", error: err });
        throw err;
      } finally {
        span.end();
      }
    }
    function withContext(context5, callback, ...callbackArgs) {
      return (0, instrumenter_js_1.getInstrumenter)().withContext(context5, callback, ...callbackArgs);
    }
    function parseTraceparentHeader(traceparentHeader) {
      return (0, instrumenter_js_1.getInstrumenter)().parseTraceparentHeader(traceparentHeader);
    }
    function createRequestHeaders(tracingContext) {
      return (0, instrumenter_js_1.getInstrumenter)().createRequestHeaders(tracingContext);
    }
    return {
      startSpan,
      withSpan,
      withContext,
      parseTraceparentHeader,
      createRequestHeaders
    };
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/index.js
var require_commonjs5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTracingClient = exports.useInstrumenter = undefined;
  var instrumenter_js_1 = require_instrumenter();
  Object.defineProperty(exports, "useInstrumenter", { enumerable: true, get: function() {
    return instrumenter_js_1.useInstrumenter;
  } });
  var tracingClient_js_1 = require_tracingClient();
  Object.defineProperty(exports, "createTracingClient", { enumerable: true, get: function() {
    return tracingClient_js_1.createTracingClient;
  } });
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/restError.js
var require_restError3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RestError = undefined;
  exports.isRestError = isRestError3;
  var ts_http_runtime_1 = require_commonjs();

  class RestError3 extends Error {
    constructor(message, options = {}) {
      super(message);
      return new ts_http_runtime_1.RestError(message, options);
    }
  }
  exports.RestError = RestError3;
  RestError3.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
  RestError3.PARSE_ERROR = "PARSE_ERROR";
  function isRestError3(e2) {
    return (0, ts_http_runtime_1.isRestError)(e2);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tracingPolicy.js
var require_tracingPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tracingPolicyName = undefined;
  exports.tracingPolicy = tracingPolicy3;
  var core_tracing_1 = require_commonjs5();
  var constants_js_1 = require_constants8();
  var userAgent_js_1 = require_userAgent2();
  var log_js_1 = require_log4();
  var core_util_1 = require_commonjs4();
  var restError_js_1 = require_restError3();
  var util_1 = require_internal3();
  exports.tracingPolicyName = "tracingPolicy";
  function tracingPolicy3(options = {}) {
    const userAgentPromise = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
    const sanitizer = new util_1.Sanitizer({
      additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
    });
    const tracingClient = tryCreateTracingClient2();
    return {
      name: exports.tracingPolicyName,
      async sendRequest(request9, next) {
        var _a3;
        if (!tracingClient) {
          return next(request9);
        }
        const userAgent7 = await userAgentPromise;
        const spanAttributes = {
          "http.url": sanitizer.sanitizeUrl(request9.url),
          "http.method": request9.method,
          "http.user_agent": userAgent7,
          requestId: request9.requestId
        };
        if (userAgent7) {
          spanAttributes["http.user_agent"] = userAgent7;
        }
        const { span, tracingContext } = (_a3 = tryCreateSpan3(tracingClient, request9, spanAttributes)) !== null && _a3 !== undefined ? _a3 : {};
        if (!span || !tracingContext) {
          return next(request9);
        }
        try {
          const response = await tracingClient.withContext(tracingContext, next, request9);
          tryProcessResponse3(span, response);
          return response;
        } catch (err) {
          tryProcessError3(span, err);
          throw err;
        }
      }
    };
  }
  function tryCreateTracingClient2() {
    try {
      return (0, core_tracing_1.createTracingClient)({
        namespace: "",
        packageName: "@azure/core-rest-pipeline",
        packageVersion: constants_js_1.SDK_VERSION
      });
    } catch (e2) {
      log_js_1.logger.warning(`Error when creating the TracingClient: ${(0, core_util_1.getErrorMessage)(e2)}`);
      return;
    }
  }
  function tryCreateSpan3(tracingClient, request9, spanAttributes) {
    try {
      const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request9.method}`, { tracingOptions: request9.tracingOptions }, {
        spanKind: "client",
        spanAttributes
      });
      if (!span.isRecording()) {
        span.end();
        return;
      }
      const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
      for (const [key, value] of Object.entries(headers)) {
        request9.headers.set(key, value);
      }
      return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
    } catch (e2) {
      log_js_1.logger.warning(`Skipping creating a tracing span due to an error: ${(0, core_util_1.getErrorMessage)(e2)}`);
      return;
    }
  }
  function tryProcessError3(span, error) {
    try {
      span.setStatus({
        status: "error",
        error: (0, core_util_1.isError)(error) ? error : undefined
      });
      if ((0, restError_js_1.isRestError)(error) && error.statusCode) {
        span.setAttribute("http.status_code", error.statusCode);
      }
      span.end();
    } catch (e2) {
      log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e2)}`);
    }
  }
  function tryProcessResponse3(span, response) {
    try {
      span.setAttribute("http.status_code", response.status);
      const serviceRequestId = response.headers.get("x-ms-request-id");
      if (serviceRequestId) {
        span.setAttribute("serviceRequestId", serviceRequestId);
      }
      if (response.status >= 400) {
        span.setStatus({
          status: "error"
        });
      }
      span.end();
    } catch (e2) {
      log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e2)}`);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/wrapAbortSignal.js
var require_wrapAbortSignal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapAbortSignalLike = wrapAbortSignalLike2;
  function wrapAbortSignalLike2(abortSignalLike) {
    if (abortSignalLike instanceof AbortSignal) {
      return { abortSignal: abortSignalLike };
    }
    if (abortSignalLike.aborted) {
      return { abortSignal: AbortSignal.abort(abortSignalLike.reason) };
    }
    const controller = new AbortController;
    let needsCleanup = true;
    function cleanup() {
      if (needsCleanup) {
        abortSignalLike.removeEventListener("abort", listener);
        needsCleanup = false;
      }
    }
    function listener() {
      controller.abort(abortSignalLike.reason);
      cleanup();
    }
    abortSignalLike.addEventListener("abort", listener);
    return { abortSignal: controller.signal, cleanup };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/wrapAbortSignalLikePolicy.js
var require_wrapAbortSignalLikePolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.wrapAbortSignalLikePolicyName = undefined;
  exports.wrapAbortSignalLikePolicy = wrapAbortSignalLikePolicy2;
  var wrapAbortSignal_js_1 = require_wrapAbortSignal();
  exports.wrapAbortSignalLikePolicyName = "wrapAbortSignalLikePolicy";
  function wrapAbortSignalLikePolicy2() {
    return {
      name: exports.wrapAbortSignalLikePolicyName,
      sendRequest: async (request9, next) => {
        if (!request9.abortSignal) {
          return next(request9);
        }
        const { abortSignal, cleanup } = (0, wrapAbortSignal_js_1.wrapAbortSignalLike)(request9.abortSignal);
        request9.abortSignal = abortSignal;
        try {
          return await next(request9);
        } finally {
          cleanup === null || cleanup === undefined || cleanup();
        }
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/createPipelineFromOptions.js
var require_createPipelineFromOptions2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createPipelineFromOptions = createPipelineFromOptions3;
  var logPolicy_js_1 = require_logPolicy2();
  var pipeline_js_1 = require_pipeline2();
  var redirectPolicy_js_1 = require_redirectPolicy2();
  var userAgentPolicy_js_1 = require_userAgentPolicy2();
  var multipartPolicy_js_1 = require_multipartPolicy2();
  var decompressResponsePolicy_js_1 = require_decompressResponsePolicy2();
  var defaultRetryPolicy_js_1 = require_defaultRetryPolicy2();
  var formDataPolicy_js_1 = require_formDataPolicy2();
  var core_util_1 = require_commonjs4();
  var proxyPolicy_js_1 = require_proxyPolicy2();
  var setClientRequestIdPolicy_js_1 = require_setClientRequestIdPolicy();
  var agentPolicy_js_1 = require_agentPolicy2();
  var tlsPolicy_js_1 = require_tlsPolicy2();
  var tracingPolicy_js_1 = require_tracingPolicy();
  var wrapAbortSignalLikePolicy_js_1 = require_wrapAbortSignalLikePolicy();
  function createPipelineFromOptions3(options) {
    var _a3;
    const pipeline = (0, pipeline_js_1.createEmptyPipeline)();
    if (core_util_1.isNodeLike) {
      if (options.agent) {
        pipeline.addPolicy((0, agentPolicy_js_1.agentPolicy)(options.agent));
      }
      if (options.tlsOptions) {
        pipeline.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options.tlsOptions));
      }
      pipeline.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options.proxyOptions));
      pipeline.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
    }
    pipeline.addPolicy((0, wrapAbortSignalLikePolicy_js_1.wrapAbortSignalLikePolicy)());
    pipeline.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] });
    pipeline.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options.userAgentOptions));
    pipeline.addPolicy((0, setClientRequestIdPolicy_js_1.setClientRequestIdPolicy)((_a3 = options.telemetryOptions) === null || _a3 === undefined ? undefined : _a3.clientRequestIdHeaderName));
    pipeline.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" });
    pipeline.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options.retryOptions), { phase: "Retry" });
    pipeline.addPolicy((0, tracingPolicy_js_1.tracingPolicy)(Object.assign(Object.assign({}, options.userAgentOptions), options.loggingOptions)), {
      afterPhase: "Retry"
    });
    if (core_util_1.isNodeLike) {
      pipeline.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options.redirectOptions), { afterPhase: "Retry" });
    }
    pipeline.addPolicy((0, logPolicy_js_1.logPolicy)(options.loggingOptions), { afterPhase: "Sign" });
    return pipeline;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/defaultHttpClient.js
var require_defaultHttpClient2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createDefaultHttpClient = createDefaultHttpClient3;
  var ts_http_runtime_1 = require_commonjs();
  var wrapAbortSignal_js_1 = require_wrapAbortSignal();
  function createDefaultHttpClient3() {
    const client = (0, ts_http_runtime_1.createDefaultHttpClient)();
    return {
      async sendRequest(request9) {
        const { abortSignal, cleanup } = request9.abortSignal ? (0, wrapAbortSignal_js_1.wrapAbortSignalLike)(request9.abortSignal) : {};
        try {
          request9.abortSignal = abortSignal;
          return await client.sendRequest(request9);
        } finally {
          cleanup === null || cleanup === undefined || cleanup();
        }
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/httpHeaders.js
var require_httpHeaders2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHttpHeaders = createHttpHeaders2;
  var ts_http_runtime_1 = require_commonjs();
  function createHttpHeaders2(rawHeaders) {
    return (0, ts_http_runtime_1.createHttpHeaders)(rawHeaders);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/pipelineRequest.js
var require_pipelineRequest2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createPipelineRequest = createPipelineRequest2;
  var ts_http_runtime_1 = require_commonjs();
  function createPipelineRequest2(options) {
    return (0, ts_http_runtime_1.createPipelineRequest)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/exponentialRetryPolicy.js
var require_exponentialRetryPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exponentialRetryPolicyName = undefined;
  exports.exponentialRetryPolicy = exponentialRetryPolicy;
  var policies_1 = require_internal2();
  exports.exponentialRetryPolicyName = policies_1.exponentialRetryPolicyName;
  function exponentialRetryPolicy(options = {}) {
    return (0, policies_1.exponentialRetryPolicy)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/systemErrorRetryPolicy.js
var require_systemErrorRetryPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.systemErrorRetryPolicyName = undefined;
  exports.systemErrorRetryPolicy = systemErrorRetryPolicy;
  var policies_1 = require_internal2();
  exports.systemErrorRetryPolicyName = policies_1.systemErrorRetryPolicyName;
  function systemErrorRetryPolicy(options = {}) {
    return (0, policies_1.systemErrorRetryPolicy)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/throttlingRetryPolicy.js
var require_throttlingRetryPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throttlingRetryPolicyName = undefined;
  exports.throttlingRetryPolicy = throttlingRetryPolicy;
  var policies_1 = require_internal2();
  exports.throttlingRetryPolicyName = policies_1.throttlingRetryPolicyName;
  function throttlingRetryPolicy(options = {}) {
    return (0, policies_1.throttlingRetryPolicy)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/retryPolicy.js
var require_retryPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retryPolicy = retryPolicy2;
  var logger_1 = require_commonjs2();
  var constants_js_1 = require_constants8();
  var policies_1 = require_internal2();
  var retryPolicyLogger2 = (0, logger_1.createClientLogger)("core-rest-pipeline retryPolicy");
  function retryPolicy2(strategies, options = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
    return (0, policies_1.retryPolicy)(strategies, Object.assign({ logger: retryPolicyLogger2 }, options));
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/tokenCycler.js
var require_tokenCycler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_CYCLER_OPTIONS = undefined;
  exports.createTokenCycler = createTokenCycler2;
  var core_util_1 = require_commonjs4();
  exports.DEFAULT_CYCLER_OPTIONS = {
    forcedRefreshWindowInMs: 1000,
    retryIntervalInMs: 3000,
    refreshWindowInMs: 1000 * 60 * 2
  };
  async function beginRefresh2(getAccessToken, retryIntervalInMs, refreshTimeout) {
    async function tryGetAccessToken() {
      if (Date.now() < refreshTimeout) {
        try {
          return await getAccessToken();
        } catch (_a3) {
          return null;
        }
      } else {
        const finalToken = await getAccessToken();
        if (finalToken === null) {
          throw new Error("Failed to refresh access token.");
        }
        return finalToken;
      }
    }
    let token = await tryGetAccessToken();
    while (token === null) {
      await (0, core_util_1.delay)(retryIntervalInMs);
      token = await tryGetAccessToken();
    }
    return token;
  }
  function createTokenCycler2(credential, tokenCyclerOptions) {
    let refreshWorker = null;
    let token = null;
    let tenantId;
    const options = Object.assign(Object.assign({}, exports.DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
    const cycler = {
      get isRefreshing() {
        return refreshWorker !== null;
      },
      get shouldRefresh() {
        var _a3;
        if (cycler.isRefreshing) {
          return false;
        }
        if ((token === null || token === undefined ? undefined : token.refreshAfterTimestamp) && token.refreshAfterTimestamp < Date.now()) {
          return true;
        }
        return ((_a3 = token === null || token === undefined ? undefined : token.expiresOnTimestamp) !== null && _a3 !== undefined ? _a3 : 0) - options.refreshWindowInMs < Date.now();
      },
      get mustRefresh() {
        return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
      }
    };
    function refresh(scopes, getTokenOptions) {
      var _a3;
      if (!cycler.isRefreshing) {
        const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
        refreshWorker = beginRefresh2(tryGetAccessToken, options.retryIntervalInMs, (_a3 = token === null || token === undefined ? undefined : token.expiresOnTimestamp) !== null && _a3 !== undefined ? _a3 : Date.now()).then((_token) => {
          refreshWorker = null;
          token = _token;
          tenantId = getTokenOptions.tenantId;
          return token;
        }).catch((reason) => {
          refreshWorker = null;
          token = null;
          tenantId = undefined;
          throw reason;
        });
      }
      return refreshWorker;
    }
    return async (scopes, tokenOptions) => {
      const hasClaimChallenge = Boolean(tokenOptions.claims);
      const tenantIdChanged = tenantId !== tokenOptions.tenantId;
      if (hasClaimChallenge) {
        token = null;
      }
      const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;
      if (mustRefresh) {
        return refresh(scopes, tokenOptions);
      }
      if (cycler.shouldRefresh) {
        refresh(scopes, tokenOptions);
      }
      return token;
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/bearerTokenAuthenticationPolicy.js
var require_bearerTokenAuthenticationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bearerTokenAuthenticationPolicyName = undefined;
  exports.bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy2;
  exports.parseChallenges = parseChallenges2;
  var tokenCycler_js_1 = require_tokenCycler();
  var log_js_1 = require_log4();
  var restError_js_1 = require_restError3();
  exports.bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
  async function trySendRequest2(request9, next) {
    try {
      return [await next(request9), undefined];
    } catch (e2) {
      if ((0, restError_js_1.isRestError)(e2) && e2.response) {
        return [e2.response, e2];
      } else {
        throw e2;
      }
    }
  }
  async function defaultAuthorizeRequest2(options) {
    const { scopes, getAccessToken, request: request9 } = options;
    const getTokenOptions = {
      abortSignal: request9.abortSignal,
      tracingOptions: request9.tracingOptions,
      enableCae: true
    };
    const accessToken = await getAccessToken(scopes, getTokenOptions);
    if (accessToken) {
      options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
    }
  }
  function isChallengeResponse2(response) {
    return response.status === 401 && response.headers.has("WWW-Authenticate");
  }
  async function authorizeRequestOnCaeChallenge2(onChallengeOptions, caeClaims) {
    var _a3;
    const { scopes } = onChallengeOptions;
    const accessToken = await onChallengeOptions.getAccessToken(scopes, {
      enableCae: true,
      claims: caeClaims
    });
    if (!accessToken) {
      return false;
    }
    onChallengeOptions.request.headers.set("Authorization", `${(_a3 = accessToken.tokenType) !== null && _a3 !== undefined ? _a3 : "Bearer"} ${accessToken.token}`);
    return true;
  }
  function bearerTokenAuthenticationPolicy2(options) {
    var _a3, _b2, _c2;
    const { credential, scopes, challengeCallbacks } = options;
    const logger4 = options.logger || log_js_1.logger;
    const callbacks = {
      authorizeRequest: (_b2 = (_a3 = challengeCallbacks === null || challengeCallbacks === undefined ? undefined : challengeCallbacks.authorizeRequest) === null || _a3 === undefined ? undefined : _a3.bind(challengeCallbacks)) !== null && _b2 !== undefined ? _b2 : defaultAuthorizeRequest2,
      authorizeRequestOnChallenge: (_c2 = challengeCallbacks === null || challengeCallbacks === undefined ? undefined : challengeCallbacks.authorizeRequestOnChallenge) === null || _c2 === undefined ? undefined : _c2.bind(challengeCallbacks)
    };
    const getAccessToken = credential ? (0, tokenCycler_js_1.createTokenCycler)(credential) : () => Promise.resolve(null);
    return {
      name: exports.bearerTokenAuthenticationPolicyName,
      async sendRequest(request9, next) {
        if (!request9.url.toLowerCase().startsWith("https://")) {
          throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
        }
        await callbacks.authorizeRequest({
          scopes: Array.isArray(scopes) ? scopes : [scopes],
          request: request9,
          getAccessToken,
          logger: logger4
        });
        let response;
        let error;
        let shouldSendRequest;
        [response, error] = await trySendRequest2(request9, next);
        if (isChallengeResponse2(response)) {
          let claims = getCaeChallengeClaims2(response.headers.get("WWW-Authenticate"));
          if (claims) {
            let parsedClaim;
            try {
              parsedClaim = atob(claims);
            } catch (e2) {
              logger4.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
              return response;
            }
            shouldSendRequest = await authorizeRequestOnCaeChallenge2({
              scopes: Array.isArray(scopes) ? scopes : [scopes],
              response,
              request: request9,
              getAccessToken,
              logger: logger4
            }, parsedClaim);
            if (shouldSendRequest) {
              [response, error] = await trySendRequest2(request9, next);
            }
          } else if (callbacks.authorizeRequestOnChallenge) {
            shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
              scopes: Array.isArray(scopes) ? scopes : [scopes],
              request: request9,
              response,
              getAccessToken,
              logger: logger4
            });
            if (shouldSendRequest) {
              [response, error] = await trySendRequest2(request9, next);
            }
            if (isChallengeResponse2(response)) {
              claims = getCaeChallengeClaims2(response.headers.get("WWW-Authenticate"));
              if (claims) {
                let parsedClaim;
                try {
                  parsedClaim = atob(claims);
                } catch (e2) {
                  logger4.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
                  return response;
                }
                shouldSendRequest = await authorizeRequestOnCaeChallenge2({
                  scopes: Array.isArray(scopes) ? scopes : [scopes],
                  response,
                  request: request9,
                  getAccessToken,
                  logger: logger4
                }, parsedClaim);
                if (shouldSendRequest) {
                  [response, error] = await trySendRequest2(request9, next);
                }
              }
            }
          }
        }
        if (error) {
          throw error;
        } else {
          return response;
        }
      }
    };
  }
  function parseChallenges2(challenges) {
    const challengeRegex = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g;
    const paramRegex = /(\w+)="([^"]*)"/g;
    const parsedChallenges = [];
    let match;
    while ((match = challengeRegex.exec(challenges)) !== null) {
      const scheme = match[1];
      const paramsString = match[2];
      const params = {};
      let paramMatch;
      while ((paramMatch = paramRegex.exec(paramsString)) !== null) {
        params[paramMatch[1]] = paramMatch[2];
      }
      parsedChallenges.push({ scheme, params });
    }
    return parsedChallenges;
  }
  function getCaeChallengeClaims2(challenges) {
    var _a3;
    if (!challenges) {
      return;
    }
    const parsedChallenges = parseChallenges2(challenges);
    return (_a3 = parsedChallenges.find((x2) => x2.scheme === "Bearer" && x2.params.claims && x2.params.error === "insufficient_claims")) === null || _a3 === undefined ? undefined : _a3.params.claims;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/ndJsonPolicy.js
var require_ndJsonPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ndJsonPolicyName = undefined;
  exports.ndJsonPolicy = ndJsonPolicy;
  exports.ndJsonPolicyName = "ndJsonPolicy";
  function ndJsonPolicy() {
    return {
      name: exports.ndJsonPolicyName,
      async sendRequest(request9, next) {
        if (typeof request9.body === "string" && request9.body.startsWith("[")) {
          const body = JSON.parse(request9.body);
          if (Array.isArray(body)) {
            request9.body = body.map((item) => JSON.stringify(item) + `
`).join("");
          }
        }
        return next(request9);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/auxiliaryAuthenticationHeaderPolicy.js
var require_auxiliaryAuthenticationHeaderPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.auxiliaryAuthenticationHeaderPolicyName = undefined;
  exports.auxiliaryAuthenticationHeaderPolicy = auxiliaryAuthenticationHeaderPolicy;
  var tokenCycler_js_1 = require_tokenCycler();
  var log_js_1 = require_log4();
  exports.auxiliaryAuthenticationHeaderPolicyName = "auxiliaryAuthenticationHeaderPolicy";
  var AUTHORIZATION_AUXILIARY_HEADER = "x-ms-authorization-auxiliary";
  async function sendAuthorizeRequest(options) {
    var _a3, _b2;
    const { scopes, getAccessToken, request: request9 } = options;
    const getTokenOptions = {
      abortSignal: request9.abortSignal,
      tracingOptions: request9.tracingOptions
    };
    return (_b2 = (_a3 = await getAccessToken(scopes, getTokenOptions)) === null || _a3 === undefined ? undefined : _a3.token) !== null && _b2 !== undefined ? _b2 : "";
  }
  function auxiliaryAuthenticationHeaderPolicy(options) {
    const { credentials, scopes } = options;
    const logger4 = options.logger || log_js_1.logger;
    const tokenCyclerMap = new WeakMap;
    return {
      name: exports.auxiliaryAuthenticationHeaderPolicyName,
      async sendRequest(request9, next) {
        if (!request9.url.toLowerCase().startsWith("https://")) {
          throw new Error("Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.");
        }
        if (!credentials || credentials.length === 0) {
          logger4.info(`${exports.auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);
          return next(request9);
        }
        const tokenPromises = [];
        for (const credential of credentials) {
          let getAccessToken = tokenCyclerMap.get(credential);
          if (!getAccessToken) {
            getAccessToken = (0, tokenCycler_js_1.createTokenCycler)(credential);
            tokenCyclerMap.set(credential, getAccessToken);
          }
          tokenPromises.push(sendAuthorizeRequest({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            request: request9,
            getAccessToken,
            logger: logger4
          }));
        }
        const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));
        if (auxiliaryTokens.length === 0) {
          logger4.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);
          return next(request9);
        }
        request9.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map((token) => `Bearer ${token}`).join(", "));
        return next(request9);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/index.js
var require_commonjs6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFileFromStream = exports.createFile = exports.agentPolicyName = exports.agentPolicy = exports.auxiliaryAuthenticationHeaderPolicyName = exports.auxiliaryAuthenticationHeaderPolicy = exports.ndJsonPolicyName = exports.ndJsonPolicy = exports.bearerTokenAuthenticationPolicyName = exports.bearerTokenAuthenticationPolicy = exports.formDataPolicyName = exports.formDataPolicy = exports.tlsPolicyName = exports.tlsPolicy = exports.userAgentPolicyName = exports.userAgentPolicy = exports.defaultRetryPolicy = exports.tracingPolicyName = exports.tracingPolicy = exports.retryPolicy = exports.throttlingRetryPolicyName = exports.throttlingRetryPolicy = exports.systemErrorRetryPolicyName = exports.systemErrorRetryPolicy = exports.redirectPolicyName = exports.redirectPolicy = exports.getDefaultProxySettings = exports.proxyPolicyName = exports.proxyPolicy = exports.multipartPolicyName = exports.multipartPolicy = exports.logPolicyName = exports.logPolicy = exports.setClientRequestIdPolicyName = exports.setClientRequestIdPolicy = exports.exponentialRetryPolicyName = exports.exponentialRetryPolicy = exports.decompressResponsePolicyName = exports.decompressResponsePolicy = exports.isRestError = exports.RestError = exports.createPipelineRequest = exports.createHttpHeaders = exports.createDefaultHttpClient = exports.createPipelineFromOptions = exports.createEmptyPipeline = undefined;
  var pipeline_js_1 = require_pipeline2();
  Object.defineProperty(exports, "createEmptyPipeline", { enumerable: true, get: function() {
    return pipeline_js_1.createEmptyPipeline;
  } });
  var createPipelineFromOptions_js_1 = require_createPipelineFromOptions2();
  Object.defineProperty(exports, "createPipelineFromOptions", { enumerable: true, get: function() {
    return createPipelineFromOptions_js_1.createPipelineFromOptions;
  } });
  var defaultHttpClient_js_1 = require_defaultHttpClient2();
  Object.defineProperty(exports, "createDefaultHttpClient", { enumerable: true, get: function() {
    return defaultHttpClient_js_1.createDefaultHttpClient;
  } });
  var httpHeaders_js_1 = require_httpHeaders2();
  Object.defineProperty(exports, "createHttpHeaders", { enumerable: true, get: function() {
    return httpHeaders_js_1.createHttpHeaders;
  } });
  var pipelineRequest_js_1 = require_pipelineRequest2();
  Object.defineProperty(exports, "createPipelineRequest", { enumerable: true, get: function() {
    return pipelineRequest_js_1.createPipelineRequest;
  } });
  var restError_js_1 = require_restError3();
  Object.defineProperty(exports, "RestError", { enumerable: true, get: function() {
    return restError_js_1.RestError;
  } });
  Object.defineProperty(exports, "isRestError", { enumerable: true, get: function() {
    return restError_js_1.isRestError;
  } });
  var decompressResponsePolicy_js_1 = require_decompressResponsePolicy2();
  Object.defineProperty(exports, "decompressResponsePolicy", { enumerable: true, get: function() {
    return decompressResponsePolicy_js_1.decompressResponsePolicy;
  } });
  Object.defineProperty(exports, "decompressResponsePolicyName", { enumerable: true, get: function() {
    return decompressResponsePolicy_js_1.decompressResponsePolicyName;
  } });
  var exponentialRetryPolicy_js_1 = require_exponentialRetryPolicy2();
  Object.defineProperty(exports, "exponentialRetryPolicy", { enumerable: true, get: function() {
    return exponentialRetryPolicy_js_1.exponentialRetryPolicy;
  } });
  Object.defineProperty(exports, "exponentialRetryPolicyName", { enumerable: true, get: function() {
    return exponentialRetryPolicy_js_1.exponentialRetryPolicyName;
  } });
  var setClientRequestIdPolicy_js_1 = require_setClientRequestIdPolicy();
  Object.defineProperty(exports, "setClientRequestIdPolicy", { enumerable: true, get: function() {
    return setClientRequestIdPolicy_js_1.setClientRequestIdPolicy;
  } });
  Object.defineProperty(exports, "setClientRequestIdPolicyName", { enumerable: true, get: function() {
    return setClientRequestIdPolicy_js_1.setClientRequestIdPolicyName;
  } });
  var logPolicy_js_1 = require_logPolicy2();
  Object.defineProperty(exports, "logPolicy", { enumerable: true, get: function() {
    return logPolicy_js_1.logPolicy;
  } });
  Object.defineProperty(exports, "logPolicyName", { enumerable: true, get: function() {
    return logPolicy_js_1.logPolicyName;
  } });
  var multipartPolicy_js_1 = require_multipartPolicy2();
  Object.defineProperty(exports, "multipartPolicy", { enumerable: true, get: function() {
    return multipartPolicy_js_1.multipartPolicy;
  } });
  Object.defineProperty(exports, "multipartPolicyName", { enumerable: true, get: function() {
    return multipartPolicy_js_1.multipartPolicyName;
  } });
  var proxyPolicy_js_1 = require_proxyPolicy2();
  Object.defineProperty(exports, "proxyPolicy", { enumerable: true, get: function() {
    return proxyPolicy_js_1.proxyPolicy;
  } });
  Object.defineProperty(exports, "proxyPolicyName", { enumerable: true, get: function() {
    return proxyPolicy_js_1.proxyPolicyName;
  } });
  Object.defineProperty(exports, "getDefaultProxySettings", { enumerable: true, get: function() {
    return proxyPolicy_js_1.getDefaultProxySettings;
  } });
  var redirectPolicy_js_1 = require_redirectPolicy2();
  Object.defineProperty(exports, "redirectPolicy", { enumerable: true, get: function() {
    return redirectPolicy_js_1.redirectPolicy;
  } });
  Object.defineProperty(exports, "redirectPolicyName", { enumerable: true, get: function() {
    return redirectPolicy_js_1.redirectPolicyName;
  } });
  var systemErrorRetryPolicy_js_1 = require_systemErrorRetryPolicy2();
  Object.defineProperty(exports, "systemErrorRetryPolicy", { enumerable: true, get: function() {
    return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy;
  } });
  Object.defineProperty(exports, "systemErrorRetryPolicyName", { enumerable: true, get: function() {
    return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName;
  } });
  var throttlingRetryPolicy_js_1 = require_throttlingRetryPolicy2();
  Object.defineProperty(exports, "throttlingRetryPolicy", { enumerable: true, get: function() {
    return throttlingRetryPolicy_js_1.throttlingRetryPolicy;
  } });
  Object.defineProperty(exports, "throttlingRetryPolicyName", { enumerable: true, get: function() {
    return throttlingRetryPolicy_js_1.throttlingRetryPolicyName;
  } });
  var retryPolicy_js_1 = require_retryPolicy2();
  Object.defineProperty(exports, "retryPolicy", { enumerable: true, get: function() {
    return retryPolicy_js_1.retryPolicy;
  } });
  var tracingPolicy_js_1 = require_tracingPolicy();
  Object.defineProperty(exports, "tracingPolicy", { enumerable: true, get: function() {
    return tracingPolicy_js_1.tracingPolicy;
  } });
  Object.defineProperty(exports, "tracingPolicyName", { enumerable: true, get: function() {
    return tracingPolicy_js_1.tracingPolicyName;
  } });
  var defaultRetryPolicy_js_1 = require_defaultRetryPolicy2();
  Object.defineProperty(exports, "defaultRetryPolicy", { enumerable: true, get: function() {
    return defaultRetryPolicy_js_1.defaultRetryPolicy;
  } });
  var userAgentPolicy_js_1 = require_userAgentPolicy2();
  Object.defineProperty(exports, "userAgentPolicy", { enumerable: true, get: function() {
    return userAgentPolicy_js_1.userAgentPolicy;
  } });
  Object.defineProperty(exports, "userAgentPolicyName", { enumerable: true, get: function() {
    return userAgentPolicy_js_1.userAgentPolicyName;
  } });
  var tlsPolicy_js_1 = require_tlsPolicy2();
  Object.defineProperty(exports, "tlsPolicy", { enumerable: true, get: function() {
    return tlsPolicy_js_1.tlsPolicy;
  } });
  Object.defineProperty(exports, "tlsPolicyName", { enumerable: true, get: function() {
    return tlsPolicy_js_1.tlsPolicyName;
  } });
  var formDataPolicy_js_1 = require_formDataPolicy2();
  Object.defineProperty(exports, "formDataPolicy", { enumerable: true, get: function() {
    return formDataPolicy_js_1.formDataPolicy;
  } });
  Object.defineProperty(exports, "formDataPolicyName", { enumerable: true, get: function() {
    return formDataPolicy_js_1.formDataPolicyName;
  } });
  var bearerTokenAuthenticationPolicy_js_1 = require_bearerTokenAuthenticationPolicy();
  Object.defineProperty(exports, "bearerTokenAuthenticationPolicy", { enumerable: true, get: function() {
    return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicy;
  } });
  Object.defineProperty(exports, "bearerTokenAuthenticationPolicyName", { enumerable: true, get: function() {
    return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicyName;
  } });
  var ndJsonPolicy_js_1 = require_ndJsonPolicy();
  Object.defineProperty(exports, "ndJsonPolicy", { enumerable: true, get: function() {
    return ndJsonPolicy_js_1.ndJsonPolicy;
  } });
  Object.defineProperty(exports, "ndJsonPolicyName", { enumerable: true, get: function() {
    return ndJsonPolicy_js_1.ndJsonPolicyName;
  } });
  var auxiliaryAuthenticationHeaderPolicy_js_1 = require_auxiliaryAuthenticationHeaderPolicy();
  Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicy", { enumerable: true, get: function() {
    return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicy;
  } });
  Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicyName", { enumerable: true, get: function() {
    return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicyName;
  } });
  var agentPolicy_js_1 = require_agentPolicy2();
  Object.defineProperty(exports, "agentPolicy", { enumerable: true, get: function() {
    return agentPolicy_js_1.agentPolicy;
  } });
  Object.defineProperty(exports, "agentPolicyName", { enumerable: true, get: function() {
    return agentPolicy_js_1.agentPolicyName;
  } });
  var file_js_1 = require_file2();
  Object.defineProperty(exports, "createFile", { enumerable: true, get: function() {
    return file_js_1.createFile;
  } });
  Object.defineProperty(exports, "createFileFromStream", { enumerable: true, get: function() {
    return file_js_1.createFileFromStream;
  } });
});

// node_modules/@azure/core-auth/dist/commonjs/azureKeyCredential.js
var require_azureKeyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureKeyCredential = undefined;

  class AzureKeyCredential2 {
    get key() {
      return this._key;
    }
    constructor(key) {
      if (!key) {
        throw new Error("key must be a non-empty string");
      }
      this._key = key;
    }
    update(newKey) {
      this._key = newKey;
    }
  }
  exports.AzureKeyCredential = AzureKeyCredential2;
});

// node_modules/@azure/core-auth/dist/commonjs/keyCredential.js
var require_keyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isKeyCredential = isKeyCredential3;
  var core_util_1 = require_commonjs4();
  function isKeyCredential3(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["key"]) && typeof credential.key === "string";
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureNamedKeyCredential.js
var require_azureNamedKeyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureNamedKeyCredential = undefined;
  exports.isNamedKeyCredential = isNamedKeyCredential;
  var core_util_1 = require_commonjs4();

  class AzureNamedKeyCredential {
    get key() {
      return this._key;
    }
    get name() {
      return this._name;
    }
    constructor(name, key) {
      if (!name || !key) {
        throw new TypeError("name and key must be non-empty strings");
      }
      this._name = name;
      this._key = key;
    }
    update(newName, newKey) {
      if (!newName || !newKey) {
        throw new TypeError("newName and newKey must be non-empty strings");
      }
      this._name = newName;
      this._key = newKey;
    }
  }
  exports.AzureNamedKeyCredential = AzureNamedKeyCredential;
  function isNamedKeyCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["name", "key"]) && typeof credential.key === "string" && typeof credential.name === "string";
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureSASCredential.js
var require_azureSASCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AzureSASCredential = undefined;
  exports.isSASCredential = isSASCredential;
  var core_util_1 = require_commonjs4();

  class AzureSASCredential {
    get signature() {
      return this._signature;
    }
    constructor(signature) {
      if (!signature) {
        throw new Error("shared access signature must be a non-empty string");
      }
      this._signature = signature;
    }
    update(newSignature) {
      if (!newSignature) {
        throw new Error("shared access signature must be a non-empty string");
      }
      this._signature = newSignature;
    }
  }
  exports.AzureSASCredential = AzureSASCredential;
  function isSASCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["signature"]) && typeof credential.signature === "string";
  }
});

// node_modules/@azure/core-auth/dist/commonjs/tokenCredential.js
var require_tokenCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isBearerToken = isBearerToken;
  exports.isPopToken = isPopToken;
  exports.isTokenCredential = isTokenCredential2;
  function isBearerToken(accessToken) {
    return !accessToken.tokenType || accessToken.tokenType === "Bearer";
  }
  function isPopToken(accessToken) {
    return accessToken.tokenType === "pop";
  }
  function isTokenCredential2(credential) {
    const castCredential = credential;
    return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === undefined || castCredential.getToken.length > 0);
  }
});

// node_modules/@azure/core-auth/dist/commonjs/index.js
var require_commonjs7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTokenCredential = exports.isSASCredential = exports.AzureSASCredential = exports.isNamedKeyCredential = exports.AzureNamedKeyCredential = exports.isKeyCredential = exports.AzureKeyCredential = undefined;
  var azureKeyCredential_js_1 = require_azureKeyCredential();
  Object.defineProperty(exports, "AzureKeyCredential", { enumerable: true, get: function() {
    return azureKeyCredential_js_1.AzureKeyCredential;
  } });
  var keyCredential_js_1 = require_keyCredential();
  Object.defineProperty(exports, "isKeyCredential", { enumerable: true, get: function() {
    return keyCredential_js_1.isKeyCredential;
  } });
  var azureNamedKeyCredential_js_1 = require_azureNamedKeyCredential();
  Object.defineProperty(exports, "AzureNamedKeyCredential", { enumerable: true, get: function() {
    return azureNamedKeyCredential_js_1.AzureNamedKeyCredential;
  } });
  Object.defineProperty(exports, "isNamedKeyCredential", { enumerable: true, get: function() {
    return azureNamedKeyCredential_js_1.isNamedKeyCredential;
  } });
  var azureSASCredential_js_1 = require_azureSASCredential();
  Object.defineProperty(exports, "AzureSASCredential", { enumerable: true, get: function() {
    return azureSASCredential_js_1.AzureSASCredential;
  } });
  Object.defineProperty(exports, "isSASCredential", { enumerable: true, get: function() {
    return azureSASCredential_js_1.isSASCredential;
  } });
  var tokenCredential_js_1 = require_tokenCredential();
  Object.defineProperty(exports, "isTokenCredential", { enumerable: true, get: function() {
    return tokenCredential_js_1.isTokenCredential;
  } });
});

// node_modules/@azure/core-http-compat/dist/commonjs/policies/disableKeepAlivePolicy.js
var require_disableKeepAlivePolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.disableKeepAlivePolicyName = undefined;
  exports.createDisableKeepAlivePolicy = createDisableKeepAlivePolicy;
  exports.pipelineContainsDisableKeepAlivePolicy = pipelineContainsDisableKeepAlivePolicy;
  exports.disableKeepAlivePolicyName = "DisableKeepAlivePolicy";
  function createDisableKeepAlivePolicy() {
    return {
      name: exports.disableKeepAlivePolicyName,
      async sendRequest(request9, next) {
        request9.disableKeepAlive = true;
        return next(request9);
      }
    };
  }
  function pipelineContainsDisableKeepAlivePolicy(pipeline) {
    return pipeline.getOrderedPolicies().some((policy) => policy.name === exports.disableKeepAlivePolicyName);
  }
});

// node_modules/@azure/core-client/dist/commonjs/base64.js
var require_base64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.encodeString = encodeString;
  exports.encodeByteArray = encodeByteArray;
  exports.decodeString = decodeString;
  exports.decodeStringToString = decodeStringToString;
  function encodeString(value) {
    return Buffer.from(value).toString("base64");
  }
  function encodeByteArray(value) {
    const bufferValue = value instanceof Buffer ? value : Buffer.from(value.buffer);
    return bufferValue.toString("base64");
  }
  function decodeString(value) {
    return Buffer.from(value, "base64");
  }
  function decodeStringToString(value) {
    return Buffer.from(value, "base64").toString();
  }
});

// node_modules/@azure/core-client/dist/commonjs/interfaces.js
var require_interfaces = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XML_CHARKEY = exports.XML_ATTRKEY = undefined;
  exports.XML_ATTRKEY = "$";
  exports.XML_CHARKEY = "_";
});

// node_modules/@azure/core-client/dist/commonjs/utils.js
var require_utils5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isPrimitiveBody = isPrimitiveBody;
  exports.isDuration = isDuration;
  exports.isValidUuid = isValidUuid;
  exports.flattenResponse = flattenResponse;
  function isPrimitiveBody(value, mapperTypeName) {
    return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || (mapperTypeName === null || mapperTypeName === undefined ? undefined : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === undefined || value === null);
  }
  var validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  function isDuration(value) {
    return validateISODuration.test(value);
  }
  var validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
  function isValidUuid(uuid) {
    return validUuidRegex.test(uuid);
  }
  function handleNullableResponseAndWrappableBody(responseObject) {
    const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);
    if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
      return responseObject.shouldWrapBody ? { body: null } : null;
    } else {
      return responseObject.shouldWrapBody ? Object.assign(Object.assign({}, responseObject.headers), { body: responseObject.body }) : combinedHeadersAndBody;
    }
  }
  function flattenResponse(fullResponse, responseSpec) {
    var _a3, _b2;
    const parsedHeaders = fullResponse.parsedHeaders;
    if (fullResponse.request.method === "HEAD") {
      return Object.assign(Object.assign({}, parsedHeaders), { body: fullResponse.parsedBody });
    }
    const bodyMapper = responseSpec && responseSpec.bodyMapper;
    const isNullable = Boolean(bodyMapper === null || bodyMapper === undefined ? undefined : bodyMapper.nullable);
    const expectedBodyTypeName = bodyMapper === null || bodyMapper === undefined ? undefined : bodyMapper.type.name;
    if (expectedBodyTypeName === "Stream") {
      return Object.assign(Object.assign({}, parsedHeaders), { blobBody: fullResponse.blobBody, readableStreamBody: fullResponse.readableStreamBody });
    }
    const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
    const isPageableResponse = Object.keys(modelProperties).some((k2) => modelProperties[k2].serializedName === "");
    if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
      const arrayResponse = (_a3 = fullResponse.parsedBody) !== null && _a3 !== undefined ? _a3 : [];
      for (const key of Object.keys(modelProperties)) {
        if (modelProperties[key].serializedName) {
          arrayResponse[key] = (_b2 = fullResponse.parsedBody) === null || _b2 === undefined ? undefined : _b2[key];
        }
      }
      if (parsedHeaders) {
        for (const key of Object.keys(parsedHeaders)) {
          arrayResponse[key] = parsedHeaders[key];
        }
      }
      return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
    }
    return handleNullableResponseAndWrappableBody({
      body: fullResponse.parsedBody,
      headers: parsedHeaders,
      hasNullableType: isNullable,
      shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
    });
  }
});

// node_modules/@azure/core-client/dist/commonjs/serializer.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MapperTypeNames = undefined;
  exports.createSerializer = createSerializer;
  var tslib_1 = require_tslib();
  var base64 = tslib_1.__importStar(require_base64());
  var interfaces_js_1 = require_interfaces();
  var utils_js_1 = require_utils5();

  class SerializerImpl {
    constructor(modelMappers = {}, isXML = false) {
      this.modelMappers = modelMappers;
      this.isXML = isXML;
    }
    validateConstraints(mapper, value, objectName) {
      const failValidation = (constraintName, constraintValue) => {
        throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
      };
      if (mapper.constraints && value !== undefined && value !== null) {
        const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems } = mapper.constraints;
        if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {
          failValidation("ExclusiveMaximum", ExclusiveMaximum);
        }
        if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {
          failValidation("ExclusiveMinimum", ExclusiveMinimum);
        }
        if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {
          failValidation("InclusiveMaximum", InclusiveMaximum);
        }
        if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {
          failValidation("InclusiveMinimum", InclusiveMinimum);
        }
        if (MaxItems !== undefined && value.length > MaxItems) {
          failValidation("MaxItems", MaxItems);
        }
        if (MaxLength !== undefined && value.length > MaxLength) {
          failValidation("MaxLength", MaxLength);
        }
        if (MinItems !== undefined && value.length < MinItems) {
          failValidation("MinItems", MinItems);
        }
        if (MinLength !== undefined && value.length < MinLength) {
          failValidation("MinLength", MinLength);
        }
        if (MultipleOf !== undefined && value % MultipleOf !== 0) {
          failValidation("MultipleOf", MultipleOf);
        }
        if (Pattern) {
          const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
          if (typeof value !== "string" || value.match(pattern) === null) {
            failValidation("Pattern", Pattern);
          }
        }
        if (UniqueItems && value.some((item, i2, ar) => ar.indexOf(item) !== i2)) {
          failValidation("UniqueItems", UniqueItems);
        }
      }
    }
    serialize(mapper, object, objectName, options = { xml: {} }) {
      var _a3, _b2, _c2;
      const updatedOptions = {
        xml: {
          rootName: (_a3 = options.xml.rootName) !== null && _a3 !== undefined ? _a3 : "",
          includeRoot: (_b2 = options.xml.includeRoot) !== null && _b2 !== undefined ? _b2 : false,
          xmlCharKey: (_c2 = options.xml.xmlCharKey) !== null && _c2 !== undefined ? _c2 : interfaces_js_1.XML_CHARKEY
        }
      };
      let payload = {};
      const mapperType = mapper.type.name;
      if (!objectName) {
        objectName = mapper.serializedName;
      }
      if (mapperType.match(/^Sequence$/i) !== null) {
        payload = [];
      }
      if (mapper.isConstant) {
        object = mapper.defaultValue;
      }
      const { required, nullable } = mapper;
      if (required && nullable && object === undefined) {
        throw new Error(`${objectName} cannot be undefined.`);
      }
      if (required && !nullable && (object === undefined || object === null)) {
        throw new Error(`${objectName} cannot be null or undefined.`);
      }
      if (!required && nullable === false && object === null) {
        throw new Error(`${objectName} cannot be null.`);
      }
      if (object === undefined || object === null) {
        payload = object;
      } else {
        if (mapperType.match(/^any$/i) !== null) {
          payload = object;
        } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
          payload = serializeBasicTypes(mapperType, objectName, object);
        } else if (mapperType.match(/^Enum$/i) !== null) {
          const enumMapper = mapper;
          payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
        } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
          payload = serializeDateTypes(mapperType, object, objectName);
        } else if (mapperType.match(/^ByteArray$/i) !== null) {
          payload = serializeByteArrayType(objectName, object);
        } else if (mapperType.match(/^Base64Url$/i) !== null) {
          payload = serializeBase64UrlType(objectName, object);
        } else if (mapperType.match(/^Sequence$/i) !== null) {
          payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        } else if (mapperType.match(/^Dictionary$/i) !== null) {
          payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        } else if (mapperType.match(/^Composite$/i) !== null) {
          payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        }
      }
      return payload;
    }
    deserialize(mapper, responseBody, objectName, options = { xml: {} }) {
      var _a3, _b2, _c2, _d2;
      const updatedOptions = {
        xml: {
          rootName: (_a3 = options.xml.rootName) !== null && _a3 !== undefined ? _a3 : "",
          includeRoot: (_b2 = options.xml.includeRoot) !== null && _b2 !== undefined ? _b2 : false,
          xmlCharKey: (_c2 = options.xml.xmlCharKey) !== null && _c2 !== undefined ? _c2 : interfaces_js_1.XML_CHARKEY
        },
        ignoreUnknownProperties: (_d2 = options.ignoreUnknownProperties) !== null && _d2 !== undefined ? _d2 : false
      };
      if (responseBody === undefined || responseBody === null) {
        if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
          responseBody = [];
        }
        if (mapper.defaultValue !== undefined) {
          responseBody = mapper.defaultValue;
        }
        return responseBody;
      }
      let payload;
      const mapperType = mapper.type.name;
      if (!objectName) {
        objectName = mapper.serializedName;
      }
      if (mapperType.match(/^Composite$/i) !== null) {
        payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
      } else {
        if (this.isXML) {
          const xmlCharKey = updatedOptions.xml.xmlCharKey;
          if (responseBody[interfaces_js_1.XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {
            responseBody = responseBody[xmlCharKey];
          }
        }
        if (mapperType.match(/^Number$/i) !== null) {
          payload = parseFloat(responseBody);
          if (isNaN(payload)) {
            payload = responseBody;
          }
        } else if (mapperType.match(/^Boolean$/i) !== null) {
          if (responseBody === "true") {
            payload = true;
          } else if (responseBody === "false") {
            payload = false;
          } else {
            payload = responseBody;
          }
        } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
          payload = responseBody;
        } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
          payload = new Date(responseBody);
        } else if (mapperType.match(/^UnixTime$/i) !== null) {
          payload = unixTimeToDate(responseBody);
        } else if (mapperType.match(/^ByteArray$/i) !== null) {
          payload = base64.decodeString(responseBody);
        } else if (mapperType.match(/^Base64Url$/i) !== null) {
          payload = base64UrlToByteArray(responseBody);
        } else if (mapperType.match(/^Sequence$/i) !== null) {
          payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
        } else if (mapperType.match(/^Dictionary$/i) !== null) {
          payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
        }
      }
      if (mapper.isConstant) {
        payload = mapper.defaultValue;
      }
      return payload;
    }
  }
  function createSerializer(modelMappers = {}, isXML = false) {
    return new SerializerImpl(modelMappers, isXML);
  }
  function trimEnd(str, ch) {
    let len = str.length;
    while (len - 1 >= 0 && str[len - 1] === ch) {
      --len;
    }
    return str.substr(0, len);
  }
  function bufferToBase64Url(buffer) {
    if (!buffer) {
      return;
    }
    if (!(buffer instanceof Uint8Array)) {
      throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
    }
    const str = base64.encodeByteArray(buffer);
    return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function base64UrlToByteArray(str) {
    if (!str) {
      return;
    }
    if (str && typeof str.valueOf() !== "string") {
      throw new Error("Please provide an input of type string for converting to Uint8Array");
    }
    str = str.replace(/-/g, "+").replace(/_/g, "/");
    return base64.decodeString(str);
  }
  function splitSerializeName(prop) {
    const classes = [];
    let partialclass = "";
    if (prop) {
      const subwords = prop.split(".");
      for (const item of subwords) {
        if (item.charAt(item.length - 1) === "\\") {
          partialclass += item.substr(0, item.length - 1) + ".";
        } else {
          partialclass += item;
          classes.push(partialclass);
          partialclass = "";
        }
      }
    }
    return classes;
  }
  function dateToUnixTime(d2) {
    if (!d2) {
      return;
    }
    if (typeof d2.valueOf() === "string") {
      d2 = new Date(d2);
    }
    return Math.floor(d2.getTime() / 1000);
  }
  function unixTimeToDate(n2) {
    if (!n2) {
      return;
    }
    return new Date(n2 * 1000);
  }
  function serializeBasicTypes(typeName, objectName, value) {
    if (value !== null && value !== undefined) {
      if (typeName.match(/^Number$/i) !== null) {
        if (typeof value !== "number") {
          throw new Error(`${objectName} with value ${value} must be of type number.`);
        }
      } else if (typeName.match(/^String$/i) !== null) {
        if (typeof value.valueOf() !== "string") {
          throw new Error(`${objectName} with value "${value}" must be of type string.`);
        }
      } else if (typeName.match(/^Uuid$/i) !== null) {
        if (!(typeof value.valueOf() === "string" && (0, utils_js_1.isValidUuid)(value))) {
          throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
        }
      } else if (typeName.match(/^Boolean$/i) !== null) {
        if (typeof value !== "boolean") {
          throw new Error(`${objectName} with value ${value} must be of type boolean.`);
        }
      } else if (typeName.match(/^Stream$/i) !== null) {
        const objectType = typeof value;
        if (objectType !== "string" && typeof value.pipe !== "function" && typeof value.tee !== "function" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob) && objectType !== "function") {
          throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`);
        }
      }
    }
    return value;
  }
  function serializeEnumType(objectName, allowedValues, value) {
    if (!allowedValues) {
      throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
    }
    const isPresent = allowedValues.some((item) => {
      if (typeof item.valueOf() === "string") {
        return item.toLowerCase() === value.toLowerCase();
      }
      return item === value;
    });
    if (!isPresent) {
      throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
    }
    return value;
  }
  function serializeByteArrayType(objectName, value) {
    if (value !== undefined && value !== null) {
      if (!(value instanceof Uint8Array)) {
        throw new Error(`${objectName} must be of type Uint8Array.`);
      }
      value = base64.encodeByteArray(value);
    }
    return value;
  }
  function serializeBase64UrlType(objectName, value) {
    if (value !== undefined && value !== null) {
      if (!(value instanceof Uint8Array)) {
        throw new Error(`${objectName} must be of type Uint8Array.`);
      }
      value = bufferToBase64Url(value);
    }
    return value;
  }
  function serializeDateTypes(typeName, value, objectName) {
    if (value !== undefined && value !== null) {
      if (typeName.match(/^Date$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
        }
        value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
      } else if (typeName.match(/^DateTime$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
        }
        value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
      } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
        }
        value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
      } else if (typeName.match(/^UnixTime$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
          throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` + `for it to be serialized in UnixTime/Epoch format.`);
        }
        value = dateToUnixTime(value);
      } else if (typeName.match(/^TimeSpan$/i) !== null) {
        if (!(0, utils_js_1.isDuration)(value)) {
          throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
        }
      }
    }
    return value;
  }
  function serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
    var _a3;
    if (!Array.isArray(object)) {
      throw new Error(`${objectName} must be of type Array.`);
    }
    let elementType = mapper.type.element;
    if (!elementType || typeof elementType !== "object") {
      throw new Error(`element" metadata for an Array must be defined in the ` + `mapper and it must of type "object" in ${objectName}.`);
    }
    if (elementType.type.name === "Composite" && elementType.type.className) {
      elementType = (_a3 = serializer.modelMappers[elementType.type.className]) !== null && _a3 !== undefined ? _a3 : elementType;
    }
    const tempArray = [];
    for (let i2 = 0;i2 < object.length; i2++) {
      const serializedValue = serializer.serialize(elementType, object[i2], objectName, options);
      if (isXml && elementType.xmlNamespace) {
        const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : "xmlns";
        if (elementType.type.name === "Composite") {
          tempArray[i2] = Object.assign({}, serializedValue);
          tempArray[i2][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
        } else {
          tempArray[i2] = {};
          tempArray[i2][options.xml.xmlCharKey] = serializedValue;
          tempArray[i2][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
        }
      } else {
        tempArray[i2] = serializedValue;
      }
    }
    return tempArray;
  }
  function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
    if (typeof object !== "object") {
      throw new Error(`${objectName} must be of type object.`);
    }
    const valueType = mapper.type.value;
    if (!valueType || typeof valueType !== "object") {
      throw new Error(`"value" metadata for a Dictionary must be defined in the ` + `mapper and it must of type "object" in ${objectName}.`);
    }
    const tempDictionary = {};
    for (const key of Object.keys(object)) {
      const serializedValue = serializer.serialize(valueType, object[key], objectName, options);
      tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
    }
    if (isXml && mapper.xmlNamespace) {
      const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
      const result = tempDictionary;
      result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };
      return result;
    }
    return tempDictionary;
  }
  function resolveAdditionalProperties(serializer, mapper, objectName) {
    const additionalProperties = mapper.type.additionalProperties;
    if (!additionalProperties && mapper.type.className) {
      const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
      return modelMapper === null || modelMapper === undefined ? undefined : modelMapper.type.additionalProperties;
    }
    return additionalProperties;
  }
  function resolveReferencedMapper(serializer, mapper, objectName) {
    const className = mapper.type.className;
    if (!className) {
      throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, undefined, 2)}".`);
    }
    return serializer.modelMappers[className];
  }
  function resolveModelProperties(serializer, mapper, objectName) {
    let modelProps = mapper.type.modelProperties;
    if (!modelProps) {
      const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
      if (!modelMapper) {
        throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
      }
      modelProps = modelMapper === null || modelMapper === undefined ? undefined : modelMapper.type.modelProperties;
      if (!modelProps) {
        throw new Error(`modelProperties cannot be null or undefined in the ` + `mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
      }
    }
    return modelProps;
  }
  function serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
      mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
    }
    if (object !== undefined && object !== null) {
      const payload = {};
      const modelProps = resolveModelProperties(serializer, mapper, objectName);
      for (const key of Object.keys(modelProps)) {
        const propertyMapper = modelProps[key];
        if (propertyMapper.readOnly) {
          continue;
        }
        let propName;
        let parentObject = payload;
        if (serializer.isXML) {
          if (propertyMapper.xmlIsWrapped) {
            propName = propertyMapper.xmlName;
          } else {
            propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
          }
        } else {
          const paths = splitSerializeName(propertyMapper.serializedName);
          propName = paths.pop();
          for (const pathName of paths) {
            const childObject = parentObject[pathName];
            if ((childObject === undefined || childObject === null) && (object[key] !== undefined && object[key] !== null || propertyMapper.defaultValue !== undefined)) {
              parentObject[pathName] = {};
            }
            parentObject = parentObject[pathName];
          }
        }
        if (parentObject !== undefined && parentObject !== null) {
          if (isXml && mapper.xmlNamespace) {
            const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
            parentObject[interfaces_js_1.XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[interfaces_js_1.XML_ATTRKEY]), { [xmlnsKey]: mapper.xmlNamespace });
          }
          const propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
          let toSerialize = object[key];
          const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
          if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === undefined || toSerialize === null)) {
            toSerialize = mapper.serializedName;
          }
          const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);
          if (serializedValue !== undefined && propName !== undefined && propName !== null) {
            const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
            if (isXml && propertyMapper.xmlIsAttribute) {
              parentObject[interfaces_js_1.XML_ATTRKEY] = parentObject[interfaces_js_1.XML_ATTRKEY] || {};
              parentObject[interfaces_js_1.XML_ATTRKEY][propName] = serializedValue;
            } else if (isXml && propertyMapper.xmlIsWrapped) {
              parentObject[propName] = { [propertyMapper.xmlElementName]: value };
            } else {
              parentObject[propName] = value;
            }
          }
        }
      }
      const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
      if (additionalPropertiesMapper) {
        const propNames = Object.keys(modelProps);
        for (const clientPropName in object) {
          const isAdditionalProperty = propNames.every((pn2) => pn2 !== clientPropName);
          if (isAdditionalProperty) {
            payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
          }
        }
      }
      return payload;
    }
    return object;
  }
  function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
    if (!isXml || !propertyMapper.xmlNamespace) {
      return serializedValue;
    }
    const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : "xmlns";
    const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };
    if (["Composite"].includes(propertyMapper.type.name)) {
      if (serializedValue[interfaces_js_1.XML_ATTRKEY]) {
        return serializedValue;
      } else {
        const result2 = Object.assign({}, serializedValue);
        result2[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
        return result2;
      }
    }
    const result = {};
    result[options.xml.xmlCharKey] = serializedValue;
    result[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
    return result;
  }
  function isSpecialXmlProperty(propertyName, options) {
    return [interfaces_js_1.XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);
  }
  function deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
    var _a3, _b2;
    const xmlCharKey = (_a3 = options.xml.xmlCharKey) !== null && _a3 !== undefined ? _a3 : interfaces_js_1.XML_CHARKEY;
    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
      mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
    }
    const modelProps = resolveModelProperties(serializer, mapper, objectName);
    let instance = {};
    const handledPropertyNames = [];
    for (const key of Object.keys(modelProps)) {
      const propertyMapper = modelProps[key];
      const paths = splitSerializeName(modelProps[key].serializedName);
      handledPropertyNames.push(paths[0]);
      const { serializedName, xmlName, xmlElementName } = propertyMapper;
      let propertyObjectName = objectName;
      if (serializedName !== "" && serializedName !== undefined) {
        propertyObjectName = objectName + "." + serializedName;
      }
      const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
      if (headerCollectionPrefix) {
        const dictionary = {};
        for (const headerKey of Object.keys(responseBody)) {
          if (headerKey.startsWith(headerCollectionPrefix)) {
            dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
          }
          handledPropertyNames.push(headerKey);
        }
        instance[key] = dictionary;
      } else if (serializer.isXML) {
        if (propertyMapper.xmlIsAttribute && responseBody[interfaces_js_1.XML_ATTRKEY]) {
          instance[key] = serializer.deserialize(propertyMapper, responseBody[interfaces_js_1.XML_ATTRKEY][xmlName], propertyObjectName, options);
        } else if (propertyMapper.xmlIsMsText) {
          if (responseBody[xmlCharKey] !== undefined) {
            instance[key] = responseBody[xmlCharKey];
          } else if (typeof responseBody === "string") {
            instance[key] = responseBody;
          }
        } else {
          const propertyName = xmlElementName || xmlName || serializedName;
          if (propertyMapper.xmlIsWrapped) {
            const wrapped = responseBody[xmlName];
            const elementList = (_b2 = wrapped === null || wrapped === undefined ? undefined : wrapped[xmlElementName]) !== null && _b2 !== undefined ? _b2 : [];
            instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);
            handledPropertyNames.push(xmlName);
          } else {
            const property = responseBody[propertyName];
            instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);
            handledPropertyNames.push(propertyName);
          }
        }
      } else {
        let propertyInstance;
        let res = responseBody;
        let steps = 0;
        for (const item of paths) {
          if (!res)
            break;
          steps++;
          res = res[item];
        }
        if (res === null && steps < paths.length) {
          res = undefined;
        }
        propertyInstance = res;
        const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
        if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === undefined || propertyInstance === null)) {
          propertyInstance = mapper.serializedName;
        }
        let serializedValue;
        if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
          propertyInstance = responseBody[key];
          const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
          for (const [k2, v2] of Object.entries(instance)) {
            if (!Object.prototype.hasOwnProperty.call(arrayInstance, k2)) {
              arrayInstance[k2] = v2;
            }
          }
          instance = arrayInstance;
        } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {
          serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
          instance[key] = serializedValue;
        }
      }
    }
    const additionalPropertiesMapper = mapper.type.additionalProperties;
    if (additionalPropertiesMapper) {
      const isAdditionalProperty = (responsePropName) => {
        for (const clientPropName in modelProps) {
          const paths = splitSerializeName(modelProps[clientPropName].serializedName);
          if (paths[0] === responsePropName) {
            return false;
          }
        }
        return true;
      };
      for (const responsePropName in responseBody) {
        if (isAdditionalProperty(responsePropName)) {
          instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
        }
      }
    } else if (responseBody && !options.ignoreUnknownProperties) {
      for (const key of Object.keys(responseBody)) {
        if (instance[key] === undefined && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) {
          instance[key] = responseBody[key];
        }
      }
    }
    return instance;
  }
  function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
    const value = mapper.type.value;
    if (!value || typeof value !== "object") {
      throw new Error(`"value" metadata for a Dictionary must be defined in the ` + `mapper and it must of type "object" in ${objectName}`);
    }
    if (responseBody) {
      const tempDictionary = {};
      for (const key of Object.keys(responseBody)) {
        tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
      }
      return tempDictionary;
    }
    return responseBody;
  }
  function deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
    var _a3;
    let element = mapper.type.element;
    if (!element || typeof element !== "object") {
      throw new Error(`element" metadata for an Array must be defined in the ` + `mapper and it must of type "object" in ${objectName}`);
    }
    if (responseBody) {
      if (!Array.isArray(responseBody)) {
        responseBody = [responseBody];
      }
      if (element.type.name === "Composite" && element.type.className) {
        element = (_a3 = serializer.modelMappers[element.type.className]) !== null && _a3 !== undefined ? _a3 : element;
      }
      const tempArray = [];
      for (let i2 = 0;i2 < responseBody.length; i2++) {
        tempArray[i2] = serializer.deserialize(element, responseBody[i2], `${objectName}[${i2}]`, options);
      }
      return tempArray;
    }
    return responseBody;
  }
  function getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
    const typeNamesToCheck = [typeName];
    while (typeNamesToCheck.length) {
      const currentName = typeNamesToCheck.shift();
      const indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + "." + discriminatorValue;
      if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {
        return discriminators[indexDiscriminator];
      } else {
        for (const [name, mapper] of Object.entries(discriminators)) {
          if (name.startsWith(currentName + ".") && mapper.type.uberParent === currentName && mapper.type.className) {
            typeNamesToCheck.push(mapper.type.className);
          }
        }
      }
    }
    return;
  }
  function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
    var _a3;
    const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
    if (polymorphicDiscriminator) {
      let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
      if (discriminatorName) {
        if (polymorphicPropertyName === "serializedName") {
          discriminatorName = discriminatorName.replace(/\\/gi, "");
        }
        const discriminatorValue = object[discriminatorName];
        const typeName = (_a3 = mapper.type.uberParent) !== null && _a3 !== undefined ? _a3 : mapper.type.className;
        if (typeof discriminatorValue === "string" && typeName) {
          const polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);
          if (polymorphicMapper) {
            mapper = polymorphicMapper;
          }
        }
      }
    }
    return mapper;
  }
  function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
    return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);
  }
  function getPolymorphicDiscriminatorSafely(serializer, typeName) {
    return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;
  }
  exports.MapperTypeNames = {
    Base64Url: "Base64Url",
    Boolean: "Boolean",
    ByteArray: "ByteArray",
    Composite: "Composite",
    Date: "Date",
    DateTime: "DateTime",
    DateTimeRfc1123: "DateTimeRfc1123",
    Dictionary: "Dictionary",
    Enum: "Enum",
    Number: "Number",
    Object: "Object",
    Sequence: "Sequence",
    String: "String",
    Stream: "Stream",
    TimeSpan: "TimeSpan",
    UnixTime: "UnixTime"
  };
});

// node_modules/@azure/core-client/dist/commonjs/state.js
var require_state2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.state = undefined;
  exports.state = {
    operationRequestMap: new WeakMap
  };
});

// node_modules/@azure/core-client/dist/commonjs/operationHelpers.js
var require_operationHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getOperationArgumentValueFromParameter = getOperationArgumentValueFromParameter;
  exports.getOperationRequestInfo = getOperationRequestInfo;
  var state_js_1 = require_state2();
  function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
    let parameterPath = parameter.parameterPath;
    const parameterMapper = parameter.mapper;
    let value;
    if (typeof parameterPath === "string") {
      parameterPath = [parameterPath];
    }
    if (Array.isArray(parameterPath)) {
      if (parameterPath.length > 0) {
        if (parameterMapper.isConstant) {
          value = parameterMapper.defaultValue;
        } else {
          let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
          if (!propertySearchResult.propertyFound && fallbackObject) {
            propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
          }
          let useDefaultValue = false;
          if (!propertySearchResult.propertyFound) {
            useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
          }
          value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
        }
      }
    } else {
      if (parameterMapper.required) {
        value = {};
      }
      for (const propertyName in parameterPath) {
        const propertyMapper = parameterMapper.type.modelProperties[propertyName];
        const propertyPath = parameterPath[propertyName];
        const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
          parameterPath: propertyPath,
          mapper: propertyMapper
        }, fallbackObject);
        if (propertyValue !== undefined) {
          if (!value) {
            value = {};
          }
          value[propertyName] = propertyValue;
        }
      }
    }
    return value;
  }
  function getPropertyFromParameterPath(parent, parameterPath) {
    const result = { propertyFound: false };
    let i2 = 0;
    for (;i2 < parameterPath.length; ++i2) {
      const parameterPathPart = parameterPath[i2];
      if (parent && parameterPathPart in parent) {
        parent = parent[parameterPathPart];
      } else {
        break;
      }
    }
    if (i2 === parameterPath.length) {
      result.propertyValue = parent;
      result.propertyFound = true;
    }
    return result;
  }
  var originalRequestSymbol = Symbol.for("@azure/core-client original request");
  function hasOriginalRequest(request9) {
    return originalRequestSymbol in request9;
  }
  function getOperationRequestInfo(request9) {
    if (hasOriginalRequest(request9)) {
      return getOperationRequestInfo(request9[originalRequestSymbol]);
    }
    let info = state_js_1.state.operationRequestMap.get(request9);
    if (!info) {
      info = {};
      state_js_1.state.operationRequestMap.set(request9, info);
    }
    return info;
  }
});

// node_modules/@azure/core-client/dist/commonjs/deserializationPolicy.js
var require_deserializationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deserializationPolicyName = undefined;
  exports.deserializationPolicy = deserializationPolicy;
  var interfaces_js_1 = require_interfaces();
  var core_rest_pipeline_1 = require_commonjs6();
  var serializer_js_1 = require_serializer();
  var operationHelpers_js_1 = require_operationHelpers();
  var defaultJsonContentTypes = ["application/json", "text/json"];
  var defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
  exports.deserializationPolicyName = "deserializationPolicy";
  function deserializationPolicy(options = {}) {
    var _a3, _b2, _c2, _d2, _e2, _f, _g;
    const jsonContentTypes = (_b2 = (_a3 = options.expectedContentTypes) === null || _a3 === undefined ? undefined : _a3.json) !== null && _b2 !== undefined ? _b2 : defaultJsonContentTypes;
    const xmlContentTypes = (_d2 = (_c2 = options.expectedContentTypes) === null || _c2 === undefined ? undefined : _c2.xml) !== null && _d2 !== undefined ? _d2 : defaultXmlContentTypes;
    const parseXML = options.parseXML;
    const serializerOptions = options.serializerOptions;
    const updatedOptions = {
      xml: {
        rootName: (_e2 = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.rootName) !== null && _e2 !== undefined ? _e2 : "",
        includeRoot: (_f = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.includeRoot) !== null && _f !== undefined ? _f : false,
        xmlCharKey: (_g = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.xmlCharKey) !== null && _g !== undefined ? _g : interfaces_js_1.XML_CHARKEY
      }
    };
    return {
      name: exports.deserializationPolicyName,
      async sendRequest(request9, next) {
        const response = await next(request9);
        return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
      }
    };
  }
  function getOperationResponseMap(parsedResponse) {
    let result;
    const request9 = parsedResponse.request;
    const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request9);
    const operationSpec = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationSpec;
    if (operationSpec) {
      if (!(operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationResponseGetter)) {
        result = operationSpec.responses[parsedResponse.status];
      } else {
        result = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationResponseGetter(operationSpec, parsedResponse);
      }
    }
    return result;
  }
  function shouldDeserializeResponse(parsedResponse) {
    const request9 = parsedResponse.request;
    const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request9);
    const shouldDeserialize = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.shouldDeserialize;
    let result;
    if (shouldDeserialize === undefined) {
      result = true;
    } else if (typeof shouldDeserialize === "boolean") {
      result = shouldDeserialize;
    } else {
      result = shouldDeserialize(parsedResponse);
    }
    return result;
  }
  async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
    const parsedResponse = await parse11(jsonContentTypes, xmlContentTypes, response, options, parseXML);
    if (!shouldDeserializeResponse(parsedResponse)) {
      return parsedResponse;
    }
    const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(parsedResponse.request);
    const operationSpec = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationSpec;
    if (!operationSpec || !operationSpec.responses) {
      return parsedResponse;
    }
    const responseSpec = getOperationResponseMap(parsedResponse);
    const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);
    if (error) {
      throw error;
    } else if (shouldReturnResponse) {
      return parsedResponse;
    }
    if (responseSpec) {
      if (responseSpec.bodyMapper) {
        let valueToDeserialize = parsedResponse.parsedBody;
        if (operationSpec.isXML && responseSpec.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
          valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
        }
        try {
          parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
        } catch (deserializeError) {
          const restError = new core_rest_pipeline_1.RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
            statusCode: parsedResponse.status,
            request: parsedResponse.request,
            response: parsedResponse
          });
          throw restError;
        }
      } else if (operationSpec.httpMethod === "HEAD") {
        parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
      }
      if (responseSpec.headersMapper) {
        parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: true });
      }
    }
    return parsedResponse;
  }
  function isOperationSpecEmpty(operationSpec) {
    const expectedStatusCodes = Object.keys(operationSpec.responses);
    return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
  }
  function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {
    var _a3, _b2, _c2, _d2, _e2;
    const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
    const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
    if (isExpectedStatusCode) {
      if (responseSpec) {
        if (!responseSpec.isError) {
          return { error: null, shouldReturnResponse: false };
        }
      } else {
        return { error: null, shouldReturnResponse: false };
      }
    }
    const errorResponseSpec = responseSpec !== null && responseSpec !== undefined ? responseSpec : operationSpec.responses.default;
    const initialErrorMessage = ((_a3 = parsedResponse.request.streamResponseStatusCodes) === null || _a3 === undefined ? undefined : _a3.has(parsedResponse.status)) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
    const error = new core_rest_pipeline_1.RestError(initialErrorMessage, {
      statusCode: parsedResponse.status,
      request: parsedResponse.request,
      response: parsedResponse
    });
    if (!errorResponseSpec && !(((_c2 = (_b2 = parsedResponse.parsedBody) === null || _b2 === undefined ? undefined : _b2.error) === null || _c2 === undefined ? undefined : _c2.code) && ((_e2 = (_d2 = parsedResponse.parsedBody) === null || _d2 === undefined ? undefined : _d2.error) === null || _e2 === undefined ? undefined : _e2.message))) {
      throw error;
    }
    const defaultBodyMapper = errorResponseSpec === null || errorResponseSpec === undefined ? undefined : errorResponseSpec.bodyMapper;
    const defaultHeadersMapper = errorResponseSpec === null || errorResponseSpec === undefined ? undefined : errorResponseSpec.headersMapper;
    try {
      if (parsedResponse.parsedBody) {
        const parsedBody = parsedResponse.parsedBody;
        let deserializedError;
        if (defaultBodyMapper) {
          let valueToDeserialize = parsedBody;
          if (operationSpec.isXML && defaultBodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
            valueToDeserialize = [];
            const elementName = defaultBodyMapper.xmlElementName;
            if (typeof parsedBody === "object" && elementName) {
              valueToDeserialize = parsedBody[elementName];
            }
          }
          deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
        }
        const internalError = parsedBody.error || deserializedError || parsedBody;
        error.code = internalError.code;
        if (internalError.message) {
          error.message = internalError.message;
        }
        if (defaultBodyMapper) {
          error.response.parsedBody = deserializedError;
        }
      }
      if (parsedResponse.headers && defaultHeadersMapper) {
        error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
      }
    } catch (defaultError) {
      error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
    }
    return { error, shouldReturnResponse: false };
  }
  async function parse11(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
    var _a3;
    if (!((_a3 = operationResponse.request.streamResponseStatusCodes) === null || _a3 === undefined ? undefined : _a3.has(operationResponse.status)) && operationResponse.bodyAsText) {
      const text = operationResponse.bodyAsText;
      const contentType = operationResponse.headers.get("Content-Type") || "";
      const contentComponents = !contentType ? [] : contentType.split(";").map((component) => component.toLowerCase());
      try {
        if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
          operationResponse.parsedBody = JSON.parse(text);
          return operationResponse;
        } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
          if (!parseXML) {
            throw new Error("Parsing XML not supported.");
          }
          const body = await parseXML(text, opts.xml);
          operationResponse.parsedBody = body;
          return operationResponse;
        }
      } catch (err) {
        const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
        const errCode = err.code || core_rest_pipeline_1.RestError.PARSE_ERROR;
        const e2 = new core_rest_pipeline_1.RestError(msg, {
          code: errCode,
          statusCode: operationResponse.status,
          request: operationResponse.request,
          response: operationResponse
        });
        throw e2;
      }
    }
    return operationResponse;
  }
});

// node_modules/@azure/core-client/dist/commonjs/interfaceHelpers.js
var require_interfaceHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getStreamingResponseStatusCodes = getStreamingResponseStatusCodes;
  exports.getPathStringFromParameter = getPathStringFromParameter;
  var serializer_js_1 = require_serializer();
  function getStreamingResponseStatusCodes(operationSpec) {
    const result = new Set;
    for (const statusCode in operationSpec.responses) {
      const operationResponse = operationSpec.responses[statusCode];
      if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Stream) {
        result.add(Number(statusCode));
      }
    }
    return result;
  }
  function getPathStringFromParameter(parameter) {
    const { parameterPath, mapper } = parameter;
    let result;
    if (typeof parameterPath === "string") {
      result = parameterPath;
    } else if (Array.isArray(parameterPath)) {
      result = parameterPath.join(".");
    } else {
      result = mapper.serializedName;
    }
    return result;
  }
});

// node_modules/@azure/core-client/dist/commonjs/serializationPolicy.js
var require_serializationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serializationPolicyName = undefined;
  exports.serializationPolicy = serializationPolicy;
  exports.serializeHeaders = serializeHeaders;
  exports.serializeRequestBody = serializeRequestBody;
  var interfaces_js_1 = require_interfaces();
  var operationHelpers_js_1 = require_operationHelpers();
  var serializer_js_1 = require_serializer();
  var interfaceHelpers_js_1 = require_interfaceHelpers();
  exports.serializationPolicyName = "serializationPolicy";
  function serializationPolicy(options = {}) {
    const stringifyXML = options.stringifyXML;
    return {
      name: exports.serializationPolicyName,
      async sendRequest(request9, next) {
        const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request9);
        const operationSpec = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationSpec;
        const operationArguments = operationInfo === null || operationInfo === undefined ? undefined : operationInfo.operationArguments;
        if (operationSpec && operationArguments) {
          serializeHeaders(request9, operationArguments, operationSpec);
          serializeRequestBody(request9, operationArguments, operationSpec, stringifyXML);
        }
        return next(request9);
      }
    };
  }
  function serializeHeaders(request9, operationArguments, operationSpec) {
    var _a3, _b2;
    if (operationSpec.headerParameters) {
      for (const headerParameter of operationSpec.headerParameters) {
        let headerValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, headerParameter);
        if (headerValue !== null && headerValue !== undefined || headerParameter.mapper.required) {
          headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter));
          const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
          if (headerCollectionPrefix) {
            for (const key of Object.keys(headerValue)) {
              request9.headers.set(headerCollectionPrefix + key, headerValue[key]);
            }
          } else {
            request9.headers.set(headerParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter), headerValue);
          }
        }
      }
    }
    const customHeaders = (_b2 = (_a3 = operationArguments.options) === null || _a3 === undefined ? undefined : _a3.requestOptions) === null || _b2 === undefined ? undefined : _b2.customHeaders;
    if (customHeaders) {
      for (const customHeaderName of Object.keys(customHeaders)) {
        request9.headers.set(customHeaderName, customHeaders[customHeaderName]);
      }
    }
  }
  function serializeRequestBody(request9, operationArguments, operationSpec, stringifyXML = function() {
    throw new Error("XML serialization unsupported!");
  }) {
    var _a3, _b2, _c2, _d2, _e2;
    const serializerOptions = (_a3 = operationArguments.options) === null || _a3 === undefined ? undefined : _a3.serializerOptions;
    const updatedOptions = {
      xml: {
        rootName: (_b2 = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.rootName) !== null && _b2 !== undefined ? _b2 : "",
        includeRoot: (_c2 = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.includeRoot) !== null && _c2 !== undefined ? _c2 : false,
        xmlCharKey: (_d2 = serializerOptions === null || serializerOptions === undefined ? undefined : serializerOptions.xml.xmlCharKey) !== null && _d2 !== undefined ? _d2 : interfaces_js_1.XML_CHARKEY
      }
    };
    const xmlCharKey = updatedOptions.xml.xmlCharKey;
    if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
      request9.body = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, operationSpec.requestBody);
      const bodyMapper = operationSpec.requestBody.mapper;
      const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper;
      const typeName = bodyMapper.type.name;
      try {
        if (request9.body !== undefined && request9.body !== null || nullable && request9.body === null || required) {
          const requestBodyParameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(operationSpec.requestBody);
          request9.body = operationSpec.serializer.serialize(bodyMapper, request9.body, requestBodyParameterPathString, updatedOptions);
          const isStream = typeName === serializer_js_1.MapperTypeNames.Stream;
          if (operationSpec.isXML) {
            const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
            const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request9.body, updatedOptions);
            if (typeName === serializer_js_1.MapperTypeNames.Sequence) {
              request9.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
            } else if (!isStream) {
              request9.body = stringifyXML(value, {
                rootName: xmlName || serializedName,
                xmlCharKey
              });
            }
          } else if (typeName === serializer_js_1.MapperTypeNames.String && (((_e2 = operationSpec.contentType) === null || _e2 === undefined ? undefined : _e2.match("text/plain")) || operationSpec.mediaType === "text")) {
            return;
          } else if (!isStream) {
            request9.body = JSON.stringify(request9.body);
          }
        }
      } catch (error) {
        throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, "  ")}.`);
      }
    } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
      request9.formData = {};
      for (const formDataParameter of operationSpec.formDataParameters) {
        const formDataParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, formDataParameter);
        if (formDataParameterValue !== undefined && formDataParameterValue !== null) {
          const formDataParameterPropertyName = formDataParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter);
          request9.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter), updatedOptions);
        }
      }
    }
  }
  function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
    if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
      const result = {};
      result[options.xml.xmlCharKey] = serializedValue;
      result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
      return result;
    }
    return serializedValue;
  }
  function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
    if (!Array.isArray(obj)) {
      obj = [obj];
    }
    if (!xmlNamespaceKey || !xmlNamespace) {
      return { [elementName]: obj };
    }
    const result = { [elementName]: obj };
    result[interfaces_js_1.XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
    return result;
  }
});

// node_modules/@azure/core-client/dist/commonjs/pipeline.js
var require_pipeline3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createClientPipeline = createClientPipeline;
  var deserializationPolicy_js_1 = require_deserializationPolicy();
  var core_rest_pipeline_1 = require_commonjs6();
  var serializationPolicy_js_1 = require_serializationPolicy();
  function createClientPipeline(options = {}) {
    const pipeline = (0, core_rest_pipeline_1.createPipelineFromOptions)(options !== null && options !== undefined ? options : {});
    if (options.credentialOptions) {
      pipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
        credential: options.credentialOptions.credential,
        scopes: options.credentialOptions.credentialScopes
      }));
    }
    pipeline.addPolicy((0, serializationPolicy_js_1.serializationPolicy)(options.serializationOptions), { phase: "Serialize" });
    pipeline.addPolicy((0, deserializationPolicy_js_1.deserializationPolicy)(options.deserializationOptions), {
      phase: "Deserialize"
    });
    return pipeline;
  }
});

// node_modules/@azure/core-client/dist/commonjs/httpClientCache.js
var require_httpClientCache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCachedDefaultHttpClient = getCachedDefaultHttpClient;
  var core_rest_pipeline_1 = require_commonjs6();
  var cachedHttpClient2;
  function getCachedDefaultHttpClient() {
    if (!cachedHttpClient2) {
      cachedHttpClient2 = (0, core_rest_pipeline_1.createDefaultHttpClient)();
    }
    return cachedHttpClient2;
  }
});

// node_modules/@azure/core-client/dist/commonjs/urlHelpers.js
var require_urlHelpers2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRequestUrl = getRequestUrl;
  exports.appendQueryParams = appendQueryParams2;
  var operationHelpers_js_1 = require_operationHelpers();
  var interfaceHelpers_js_1 = require_interfaceHelpers();
  var CollectionFormatToDelimiterMap = {
    CSV: ",",
    SSV: " ",
    Multi: "Multi",
    TSV: "\t",
    Pipes: "|"
  };
  function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
    const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
    let isAbsolutePath = false;
    let requestUrl = replaceAll2(baseUri, urlReplacements);
    if (operationSpec.path) {
      let path2 = replaceAll2(operationSpec.path, urlReplacements);
      if (operationSpec.path === "/{nextLink}" && path2.startsWith("/")) {
        path2 = path2.substring(1);
      }
      if (isAbsoluteUrl(path2)) {
        requestUrl = path2;
        isAbsolutePath = true;
      } else {
        requestUrl = appendPath(requestUrl, path2);
      }
    }
    const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
    requestUrl = appendQueryParams2(requestUrl, queryParams, sequenceParams, isAbsolutePath);
    return requestUrl;
  }
  function replaceAll2(input, replacements) {
    let result = input;
    for (const [searchValue, replaceValue] of replacements) {
      result = result.split(searchValue).join(replaceValue);
    }
    return result;
  }
  function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
    var _a3;
    const result = new Map;
    if ((_a3 = operationSpec.urlParameters) === null || _a3 === undefined ? undefined : _a3.length) {
      for (const urlParameter of operationSpec.urlParameters) {
        let urlParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, urlParameter, fallbackObject);
        const parameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(urlParameter);
        urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
        if (!urlParameter.skipEncoding) {
          urlParameterValue = encodeURIComponent(urlParameterValue);
        }
        result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
      }
    }
    return result;
  }
  function isAbsoluteUrl(url) {
    return url.includes("://");
  }
  function appendPath(url, pathToAppend) {
    if (!pathToAppend) {
      return url;
    }
    const parsedUrl = new URL(url);
    let newPath = parsedUrl.pathname;
    if (!newPath.endsWith("/")) {
      newPath = `${newPath}/`;
    }
    if (pathToAppend.startsWith("/")) {
      pathToAppend = pathToAppend.substring(1);
    }
    const searchStart = pathToAppend.indexOf("?");
    if (searchStart !== -1) {
      const path2 = pathToAppend.substring(0, searchStart);
      const search = pathToAppend.substring(searchStart + 1);
      newPath = newPath + path2;
      if (search) {
        parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
      }
    } else {
      newPath = newPath + pathToAppend;
    }
    parsedUrl.pathname = newPath;
    return parsedUrl.toString();
  }
  function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
    var _a3;
    const result = new Map;
    const sequenceParams = new Set;
    if ((_a3 = operationSpec.queryParameters) === null || _a3 === undefined ? undefined : _a3.length) {
      for (const queryParameter of operationSpec.queryParameters) {
        if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
          sequenceParams.add(queryParameter.mapper.serializedName);
        }
        let queryParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, queryParameter, fallbackObject);
        if (queryParameterValue !== undefined && queryParameterValue !== null || queryParameter.mapper.required) {
          queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter));
          const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
          if (Array.isArray(queryParameterValue)) {
            queryParameterValue = queryParameterValue.map((item) => {
              if (item === null || item === undefined) {
                return "";
              }
              return item;
            });
          }
          if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
            continue;
          } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
            queryParameterValue = queryParameterValue.join(delimiter);
          }
          if (!queryParameter.skipEncoding) {
            if (Array.isArray(queryParameterValue)) {
              queryParameterValue = queryParameterValue.map((item) => {
                return encodeURIComponent(item);
              });
            } else {
              queryParameterValue = encodeURIComponent(queryParameterValue);
            }
          }
          if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
            queryParameterValue = queryParameterValue.join(delimiter);
          }
          result.set(queryParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter), queryParameterValue);
        }
      }
    }
    return {
      queryParams: result,
      sequenceParams
    };
  }
  function simpleParseQueryParams(queryString) {
    const result = new Map;
    if (!queryString || queryString[0] !== "?") {
      return result;
    }
    queryString = queryString.slice(1);
    const pairs = queryString.split("&");
    for (const pair of pairs) {
      const [name, value] = pair.split("=", 2);
      const existingValue = result.get(name);
      if (existingValue) {
        if (Array.isArray(existingValue)) {
          existingValue.push(value);
        } else {
          result.set(name, [existingValue, value]);
        }
      } else {
        result.set(name, value);
      }
    }
    return result;
  }
  function appendQueryParams2(url, queryParams, sequenceParams, noOverwrite = false) {
    if (queryParams.size === 0) {
      return url;
    }
    const parsedUrl = new URL(url);
    const combinedParams = simpleParseQueryParams(parsedUrl.search);
    for (const [name, value] of queryParams) {
      const existingValue = combinedParams.get(name);
      if (Array.isArray(existingValue)) {
        if (Array.isArray(value)) {
          existingValue.push(...value);
          const valueSet = new Set(existingValue);
          combinedParams.set(name, Array.from(valueSet));
        } else {
          existingValue.push(value);
        }
      } else if (existingValue) {
        if (Array.isArray(value)) {
          value.unshift(existingValue);
        } else if (sequenceParams.has(name)) {
          combinedParams.set(name, [existingValue, value]);
        }
        if (!noOverwrite) {
          combinedParams.set(name, value);
        }
      } else {
        combinedParams.set(name, value);
      }
    }
    const searchPieces = [];
    for (const [name, value] of combinedParams) {
      if (typeof value === "string") {
        searchPieces.push(`${name}=${value}`);
      } else if (Array.isArray(value)) {
        for (const subValue of value) {
          searchPieces.push(`${name}=${subValue}`);
        }
      } else {
        searchPieces.push(`${name}=${value}`);
      }
    }
    parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
    return parsedUrl.toString();
  }
});

// node_modules/@azure/core-client/dist/commonjs/log.js
var require_log5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = undefined;
  var logger_1 = require_commonjs2();
  exports.logger = (0, logger_1.createClientLogger)("core-client");
});

// node_modules/@azure/core-client/dist/commonjs/serviceClient.js
var require_serviceClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServiceClient = undefined;
  var core_rest_pipeline_1 = require_commonjs6();
  var pipeline_js_1 = require_pipeline3();
  var utils_js_1 = require_utils5();
  var httpClientCache_js_1 = require_httpClientCache();
  var operationHelpers_js_1 = require_operationHelpers();
  var urlHelpers_js_1 = require_urlHelpers2();
  var interfaceHelpers_js_1 = require_interfaceHelpers();
  var log_js_1 = require_log5();

  class ServiceClient {
    constructor(options = {}) {
      var _a3, _b2;
      this._requestContentType = options.requestContentType;
      this._endpoint = (_a3 = options.endpoint) !== null && _a3 !== undefined ? _a3 : options.baseUri;
      if (options.baseUri) {
        log_js_1.logger.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
      }
      this._allowInsecureConnection = options.allowInsecureConnection;
      this._httpClient = options.httpClient || (0, httpClientCache_js_1.getCachedDefaultHttpClient)();
      this.pipeline = options.pipeline || createDefaultPipeline3(options);
      if ((_b2 = options.additionalPolicies) === null || _b2 === undefined ? undefined : _b2.length) {
        for (const { policy, position } of options.additionalPolicies) {
          const afterPhase = position === "perRetry" ? "Sign" : undefined;
          this.pipeline.addPolicy(policy, {
            afterPhase
          });
        }
      }
    }
    async sendRequest(request9) {
      return this.pipeline.sendRequest(this._httpClient, request9);
    }
    async sendOperationRequest(operationArguments, operationSpec) {
      const endpoint7 = operationSpec.baseUrl || this._endpoint;
      if (!endpoint7) {
        throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
      }
      const url = (0, urlHelpers_js_1.getRequestUrl)(endpoint7, operationSpec, operationArguments, this);
      const request9 = (0, core_rest_pipeline_1.createPipelineRequest)({
        url
      });
      request9.method = operationSpec.httpMethod;
      const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request9);
      operationInfo.operationSpec = operationSpec;
      operationInfo.operationArguments = operationArguments;
      const contentType = operationSpec.contentType || this._requestContentType;
      if (contentType && operationSpec.requestBody) {
        request9.headers.set("Content-Type", contentType);
      }
      const options = operationArguments.options;
      if (options) {
        const requestOptions = options.requestOptions;
        if (requestOptions) {
          if (requestOptions.timeout) {
            request9.timeout = requestOptions.timeout;
          }
          if (requestOptions.onUploadProgress) {
            request9.onUploadProgress = requestOptions.onUploadProgress;
          }
          if (requestOptions.onDownloadProgress) {
            request9.onDownloadProgress = requestOptions.onDownloadProgress;
          }
          if (requestOptions.shouldDeserialize !== undefined) {
            operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
          }
          if (requestOptions.allowInsecureConnection) {
            request9.allowInsecureConnection = true;
          }
        }
        if (options.abortSignal) {
          request9.abortSignal = options.abortSignal;
        }
        if (options.tracingOptions) {
          request9.tracingOptions = options.tracingOptions;
        }
      }
      if (this._allowInsecureConnection) {
        request9.allowInsecureConnection = true;
      }
      if (request9.streamResponseStatusCodes === undefined) {
        request9.streamResponseStatusCodes = (0, interfaceHelpers_js_1.getStreamingResponseStatusCodes)(operationSpec);
      }
      try {
        const rawResponse = await this.sendRequest(request9);
        const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[rawResponse.status]);
        if (options === null || options === undefined ? undefined : options.onResponse) {
          options.onResponse(rawResponse, flatResponse);
        }
        return flatResponse;
      } catch (error) {
        if (typeof error === "object" && (error === null || error === undefined ? undefined : error.response)) {
          const rawResponse = error.response;
          const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses["default"]);
          error.details = flatResponse;
          if (options === null || options === undefined ? undefined : options.onResponse) {
            options.onResponse(rawResponse, flatResponse, error);
          }
        }
        throw error;
      }
    }
  }
  exports.ServiceClient = ServiceClient;
  function createDefaultPipeline3(options) {
    const credentialScopes = getCredentialScopes(options);
    const credentialOptions = options.credential && credentialScopes ? { credentialScopes, credential: options.credential } : undefined;
    return (0, pipeline_js_1.createClientPipeline)(Object.assign(Object.assign({}, options), { credentialOptions }));
  }
  function getCredentialScopes(options) {
    if (options.credentialScopes) {
      return options.credentialScopes;
    }
    if (options.endpoint) {
      return `${options.endpoint}/.default`;
    }
    if (options.baseUri) {
      return `${options.baseUri}/.default`;
    }
    if (options.credential && !options.credentialScopes) {
      throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
    }
    return;
  }
});

// node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnClaimChallenge.js
var require_authorizeRequestOnClaimChallenge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseCAEChallenge = parseCAEChallenge;
  exports.authorizeRequestOnClaimChallenge = authorizeRequestOnClaimChallenge;
  var log_js_1 = require_log5();
  var base64_js_1 = require_base64();
  function parseCAEChallenge(challenges) {
    const bearerChallenges = `, ${challenges.trim()}`.split(", Bearer ").filter((x2) => x2);
    return bearerChallenges.map((challenge) => {
      const challengeParts = `${challenge.trim()}, `.split('", ').filter((x2) => x2);
      const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split('="')));
      return keyValuePairs.reduce((a2, b2) => Object.assign(Object.assign({}, a2), b2), {});
    });
  }
  async function authorizeRequestOnClaimChallenge(onChallengeOptions) {
    var _a3;
    const { scopes, response } = onChallengeOptions;
    const logger4 = onChallengeOptions.logger || log_js_1.logger;
    const challenge = response.headers.get("WWW-Authenticate");
    if (!challenge) {
      logger4.info(`The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.`);
      return false;
    }
    const challenges = parseCAEChallenge(challenge) || [];
    const parsedChallenge = challenges.find((x2) => x2.claims);
    if (!parsedChallenge) {
      logger4.info(`The WWW-Authenticate header was missing the necessary "claims" to perform the Continuous Access Evaluation authentication flow.`);
      return false;
    }
    const accessToken = await onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, {
      claims: (0, base64_js_1.decodeStringToString)(parsedChallenge.claims)
    });
    if (!accessToken) {
      return false;
    }
    onChallengeOptions.request.headers.set("Authorization", `${(_a3 = accessToken.tokenType) !== null && _a3 !== undefined ? _a3 : "Bearer"} ${accessToken.token}`);
    return true;
  }
});

// node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnTenantChallenge.js
var require_authorizeRequestOnTenantChallenge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.authorizeRequestOnTenantChallenge = undefined;
  var Constants = {
    DefaultScope: "/.default",
    HeaderConstants: {
      AUTHORIZATION: "authorization"
    }
  };
  function isUuid(text) {
    return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/.test(text);
  }
  var authorizeRequestOnTenantChallenge = async (challengeOptions) => {
    var _a3;
    const requestOptions = requestToOptions(challengeOptions.request);
    const challenge = getChallenge(challengeOptions.response);
    if (challenge) {
      const challengeInfo = parseChallenge(challenge);
      const challengeScopes = buildScopes(challengeOptions, challengeInfo);
      const tenantId = extractTenantId(challengeInfo);
      if (!tenantId) {
        return false;
      }
      const accessToken = await challengeOptions.getAccessToken(challengeScopes, Object.assign(Object.assign({}, requestOptions), { tenantId }));
      if (!accessToken) {
        return false;
      }
      challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `${(_a3 = accessToken.tokenType) !== null && _a3 !== undefined ? _a3 : "Bearer"} ${accessToken.token}`);
      return true;
    }
    return false;
  };
  exports.authorizeRequestOnTenantChallenge = authorizeRequestOnTenantChallenge;
  function extractTenantId(challengeInfo) {
    const parsedAuthUri = new URL(challengeInfo.authorization_uri);
    const pathSegments = parsedAuthUri.pathname.split("/");
    const tenantId = pathSegments[1];
    if (tenantId && isUuid(tenantId)) {
      return tenantId;
    }
    return;
  }
  function buildScopes(challengeOptions, challengeInfo) {
    if (!challengeInfo.resource_id) {
      return challengeOptions.scopes;
    }
    const challengeScopes = new URL(challengeInfo.resource_id);
    challengeScopes.pathname = Constants.DefaultScope;
    let scope = challengeScopes.toString();
    if (scope === "https://disk.azure.com/.default") {
      scope = "https://disk.azure.com//.default";
    }
    return [scope];
  }
  function getChallenge(response) {
    const challenge = response.headers.get("WWW-Authenticate");
    if (response.status === 401 && challenge) {
      return challenge;
    }
    return;
  }
  function parseChallenge(challenge) {
    const bearerChallenge = challenge.slice("Bearer ".length);
    const challengeParts = `${bearerChallenge.trim()} `.split(" ").filter((x2) => x2);
    const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split("=")));
    return keyValuePairs.reduce((a2, b2) => Object.assign(Object.assign({}, a2), b2), {});
  }
  function requestToOptions(request9) {
    return {
      abortSignal: request9.abortSignal,
      requestOptions: {
        timeout: request9.timeout
      },
      tracingOptions: request9.tracingOptions
    };
  }
});

// node_modules/@azure/core-client/dist/commonjs/index.js
var require_commonjs8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.authorizeRequestOnTenantChallenge = exports.authorizeRequestOnClaimChallenge = exports.serializationPolicyName = exports.serializationPolicy = exports.deserializationPolicyName = exports.deserializationPolicy = exports.XML_CHARKEY = exports.XML_ATTRKEY = exports.createClientPipeline = exports.ServiceClient = exports.MapperTypeNames = exports.createSerializer = undefined;
  var serializer_js_1 = require_serializer();
  Object.defineProperty(exports, "createSerializer", { enumerable: true, get: function() {
    return serializer_js_1.createSerializer;
  } });
  Object.defineProperty(exports, "MapperTypeNames", { enumerable: true, get: function() {
    return serializer_js_1.MapperTypeNames;
  } });
  var serviceClient_js_1 = require_serviceClient();
  Object.defineProperty(exports, "ServiceClient", { enumerable: true, get: function() {
    return serviceClient_js_1.ServiceClient;
  } });
  var pipeline_js_1 = require_pipeline3();
  Object.defineProperty(exports, "createClientPipeline", { enumerable: true, get: function() {
    return pipeline_js_1.createClientPipeline;
  } });
  var interfaces_js_1 = require_interfaces();
  Object.defineProperty(exports, "XML_ATTRKEY", { enumerable: true, get: function() {
    return interfaces_js_1.XML_ATTRKEY;
  } });
  Object.defineProperty(exports, "XML_CHARKEY", { enumerable: true, get: function() {
    return interfaces_js_1.XML_CHARKEY;
  } });
  var deserializationPolicy_js_1 = require_deserializationPolicy();
  Object.defineProperty(exports, "deserializationPolicy", { enumerable: true, get: function() {
    return deserializationPolicy_js_1.deserializationPolicy;
  } });
  Object.defineProperty(exports, "deserializationPolicyName", { enumerable: true, get: function() {
    return deserializationPolicy_js_1.deserializationPolicyName;
  } });
  var serializationPolicy_js_1 = require_serializationPolicy();
  Object.defineProperty(exports, "serializationPolicy", { enumerable: true, get: function() {
    return serializationPolicy_js_1.serializationPolicy;
  } });
  Object.defineProperty(exports, "serializationPolicyName", { enumerable: true, get: function() {
    return serializationPolicy_js_1.serializationPolicyName;
  } });
  var authorizeRequestOnClaimChallenge_js_1 = require_authorizeRequestOnClaimChallenge();
  Object.defineProperty(exports, "authorizeRequestOnClaimChallenge", { enumerable: true, get: function() {
    return authorizeRequestOnClaimChallenge_js_1.authorizeRequestOnClaimChallenge;
  } });
  var authorizeRequestOnTenantChallenge_js_1 = require_authorizeRequestOnTenantChallenge();
  Object.defineProperty(exports, "authorizeRequestOnTenantChallenge", { enumerable: true, get: function() {
    return authorizeRequestOnTenantChallenge_js_1.authorizeRequestOnTenantChallenge;
  } });
});

// node_modules/@azure/core-http-compat/dist/commonjs/util.js
var require_util8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HttpHeaders = undefined;
  exports.toPipelineRequest = toPipelineRequest;
  exports.toWebResourceLike = toWebResourceLike;
  exports.toHttpHeadersLike = toHttpHeadersLike;
  var core_rest_pipeline_1 = require_commonjs6();
  var originalRequestSymbol = Symbol("Original PipelineRequest");
  var originalClientRequestSymbol = Symbol.for("@azure/core-client original request");
  function toPipelineRequest(webResource, options = {}) {
    const compatWebResource = webResource;
    const request9 = compatWebResource[originalRequestSymbol];
    const headers = (0, core_rest_pipeline_1.createHttpHeaders)(webResource.headers.toJson({ preserveCase: true }));
    if (request9) {
      request9.headers = headers;
      return request9;
    } else {
      const newRequest = (0, core_rest_pipeline_1.createPipelineRequest)({
        url: webResource.url,
        method: webResource.method,
        headers,
        withCredentials: webResource.withCredentials,
        timeout: webResource.timeout,
        requestId: webResource.requestId,
        abortSignal: webResource.abortSignal,
        body: webResource.body,
        formData: webResource.formData,
        disableKeepAlive: !!webResource.keepAlive,
        onDownloadProgress: webResource.onDownloadProgress,
        onUploadProgress: webResource.onUploadProgress,
        proxySettings: webResource.proxySettings,
        streamResponseStatusCodes: webResource.streamResponseStatusCodes,
        agent: webResource.agent,
        requestOverrides: webResource.requestOverrides
      });
      if (options.originalRequest) {
        newRequest[originalClientRequestSymbol] = options.originalRequest;
      }
      return newRequest;
    }
  }
  function toWebResourceLike(request9, options) {
    var _a3;
    const originalRequest = (_a3 = options === null || options === undefined ? undefined : options.originalRequest) !== null && _a3 !== undefined ? _a3 : request9;
    const webResource = {
      url: request9.url,
      method: request9.method,
      headers: toHttpHeadersLike(request9.headers),
      withCredentials: request9.withCredentials,
      timeout: request9.timeout,
      requestId: request9.headers.get("x-ms-client-request-id") || request9.requestId,
      abortSignal: request9.abortSignal,
      body: request9.body,
      formData: request9.formData,
      keepAlive: !!request9.disableKeepAlive,
      onDownloadProgress: request9.onDownloadProgress,
      onUploadProgress: request9.onUploadProgress,
      proxySettings: request9.proxySettings,
      streamResponseStatusCodes: request9.streamResponseStatusCodes,
      agent: request9.agent,
      requestOverrides: request9.requestOverrides,
      clone() {
        throw new Error("Cannot clone a non-proxied WebResourceLike");
      },
      prepare() {
        throw new Error("WebResourceLike.prepare() is not supported by @azure/core-http-compat");
      },
      validateRequestProperties() {
      }
    };
    if (options === null || options === undefined ? undefined : options.createProxy) {
      return new Proxy(webResource, {
        get(target, prop, receiver) {
          if (prop === originalRequestSymbol) {
            return request9;
          } else if (prop === "clone") {
            return () => {
              return toWebResourceLike(toPipelineRequest(webResource, { originalRequest }), {
                createProxy: true,
                originalRequest
              });
            };
          }
          return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
          if (prop === "keepAlive") {
            request9.disableKeepAlive = !value;
          }
          const passThroughProps = [
            "url",
            "method",
            "withCredentials",
            "timeout",
            "requestId",
            "abortSignal",
            "body",
            "formData",
            "onDownloadProgress",
            "onUploadProgress",
            "proxySettings",
            "streamResponseStatusCodes",
            "agent",
            "requestOverrides"
          ];
          if (typeof prop === "string" && passThroughProps.includes(prop)) {
            request9[prop] = value;
          }
          return Reflect.set(target, prop, value, receiver);
        }
      });
    } else {
      return webResource;
    }
  }
  function toHttpHeadersLike(headers) {
    return new HttpHeaders(headers.toJSON({ preserveCase: true }));
  }
  function getHeaderKey(headerName) {
    return headerName.toLowerCase();
  }

  class HttpHeaders {
    constructor(rawHeaders) {
      this._headersMap = {};
      if (rawHeaders) {
        for (const headerName in rawHeaders) {
          this.set(headerName, rawHeaders[headerName]);
        }
      }
    }
    set(headerName, headerValue) {
      this._headersMap[getHeaderKey(headerName)] = {
        name: headerName,
        value: headerValue.toString()
      };
    }
    get(headerName) {
      const header = this._headersMap[getHeaderKey(headerName)];
      return !header ? undefined : header.value;
    }
    contains(headerName) {
      return !!this._headersMap[getHeaderKey(headerName)];
    }
    remove(headerName) {
      const result = this.contains(headerName);
      delete this._headersMap[getHeaderKey(headerName)];
      return result;
    }
    rawHeaders() {
      return this.toJson({ preserveCase: true });
    }
    headersArray() {
      const headers = [];
      for (const headerKey in this._headersMap) {
        headers.push(this._headersMap[headerKey]);
      }
      return headers;
    }
    headerNames() {
      const headerNames = [];
      const headers = this.headersArray();
      for (let i2 = 0;i2 < headers.length; ++i2) {
        headerNames.push(headers[i2].name);
      }
      return headerNames;
    }
    headerValues() {
      const headerValues = [];
      const headers = this.headersArray();
      for (let i2 = 0;i2 < headers.length; ++i2) {
        headerValues.push(headers[i2].value);
      }
      return headerValues;
    }
    toJson(options = {}) {
      const result = {};
      if (options.preserveCase) {
        for (const headerKey in this._headersMap) {
          const header = this._headersMap[headerKey];
          result[header.name] = header.value;
        }
      } else {
        for (const headerKey in this._headersMap) {
          const header = this._headersMap[headerKey];
          result[getHeaderKey(header.name)] = header.value;
        }
      }
      return result;
    }
    toString() {
      return JSON.stringify(this.toJson({ preserveCase: true }));
    }
    clone() {
      const resultPreservingCasing = {};
      for (const headerKey in this._headersMap) {
        const header = this._headersMap[headerKey];
        resultPreservingCasing[header.name] = header.value;
      }
      return new HttpHeaders(resultPreservingCasing);
    }
  }
  exports.HttpHeaders = HttpHeaders;
});

// node_modules/@azure/core-http-compat/dist/commonjs/response.js
var require_response2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toCompatResponse = toCompatResponse;
  exports.toPipelineResponse = toPipelineResponse;
  var core_rest_pipeline_1 = require_commonjs6();
  var util_js_1 = require_util8();
  var originalResponse = Symbol("Original FullOperationResponse");
  function toCompatResponse(response, options) {
    let request9 = (0, util_js_1.toWebResourceLike)(response.request);
    let headers = (0, util_js_1.toHttpHeadersLike)(response.headers);
    if (options === null || options === undefined ? undefined : options.createProxy) {
      return new Proxy(response, {
        get(target, prop, receiver) {
          if (prop === "headers") {
            return headers;
          } else if (prop === "request") {
            return request9;
          } else if (prop === originalResponse) {
            return response;
          }
          return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
          if (prop === "headers") {
            headers = value;
          } else if (prop === "request") {
            request9 = value;
          }
          return Reflect.set(target, prop, value, receiver);
        }
      });
    } else {
      return Object.assign(Object.assign({}, response), {
        request: request9,
        headers
      });
    }
  }
  function toPipelineResponse(compatResponse) {
    const extendedCompatResponse = compatResponse;
    const response = extendedCompatResponse[originalResponse];
    const headers = (0, core_rest_pipeline_1.createHttpHeaders)(compatResponse.headers.toJson({ preserveCase: true }));
    if (response) {
      response.headers = headers;
      return response;
    } else {
      return Object.assign(Object.assign({}, compatResponse), { headers, request: (0, util_js_1.toPipelineRequest)(compatResponse.request) });
    }
  }
});

// node_modules/@azure/core-http-compat/dist/commonjs/extendedClient.js
var require_extendedClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendedServiceClient = undefined;
  var disableKeepAlivePolicy_js_1 = require_disableKeepAlivePolicy();
  var core_rest_pipeline_1 = require_commonjs6();
  var core_client_1 = require_commonjs8();
  var response_js_1 = require_response2();

  class ExtendedServiceClient extends core_client_1.ServiceClient {
    constructor(options) {
      var _a3, _b2;
      super(options);
      if (((_a3 = options.keepAliveOptions) === null || _a3 === undefined ? undefined : _a3.enable) === false && !(0, disableKeepAlivePolicy_js_1.pipelineContainsDisableKeepAlivePolicy)(this.pipeline)) {
        this.pipeline.addPolicy((0, disableKeepAlivePolicy_js_1.createDisableKeepAlivePolicy)());
      }
      if (((_b2 = options.redirectOptions) === null || _b2 === undefined ? undefined : _b2.handleRedirects) === false) {
        this.pipeline.removePolicy({
          name: core_rest_pipeline_1.redirectPolicyName
        });
      }
    }
    async sendOperationRequest(operationArguments, operationSpec) {
      var _a3;
      const userProvidedCallBack = (_a3 = operationArguments === null || operationArguments === undefined ? undefined : operationArguments.options) === null || _a3 === undefined ? undefined : _a3.onResponse;
      let lastResponse;
      function onResponse(rawResponse, flatResponse, error) {
        lastResponse = rawResponse;
        if (userProvidedCallBack) {
          userProvidedCallBack(rawResponse, flatResponse, error);
        }
      }
      operationArguments.options = Object.assign(Object.assign({}, operationArguments.options), { onResponse });
      const result = await super.sendOperationRequest(operationArguments, operationSpec);
      if (lastResponse) {
        Object.defineProperty(result, "_response", {
          value: (0, response_js_1.toCompatResponse)(lastResponse)
        });
      }
      return result;
    }
  }
  exports.ExtendedServiceClient = ExtendedServiceClient;
});

// node_modules/@azure/core-http-compat/dist/commonjs/policies/requestPolicyFactoryPolicy.js
var require_requestPolicyFactoryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.requestPolicyFactoryPolicyName = exports.HttpPipelineLogLevel = undefined;
  exports.createRequestPolicyFactoryPolicy = createRequestPolicyFactoryPolicy;
  var util_js_1 = require_util8();
  var response_js_1 = require_response2();
  var HttpPipelineLogLevel;
  (function(HttpPipelineLogLevel2) {
    HttpPipelineLogLevel2[HttpPipelineLogLevel2["ERROR"] = 1] = "ERROR";
    HttpPipelineLogLevel2[HttpPipelineLogLevel2["INFO"] = 3] = "INFO";
    HttpPipelineLogLevel2[HttpPipelineLogLevel2["OFF"] = 0] = "OFF";
    HttpPipelineLogLevel2[HttpPipelineLogLevel2["WARNING"] = 2] = "WARNING";
  })(HttpPipelineLogLevel || (exports.HttpPipelineLogLevel = HttpPipelineLogLevel = {}));
  var mockRequestPolicyOptions = {
    log(_logLevel, _message) {
    },
    shouldLog(_logLevel) {
      return false;
    }
  };
  exports.requestPolicyFactoryPolicyName = "RequestPolicyFactoryPolicy";
  function createRequestPolicyFactoryPolicy(factories) {
    const orderedFactories = factories.slice().reverse();
    return {
      name: exports.requestPolicyFactoryPolicyName,
      async sendRequest(request9, next) {
        let httpPipeline = {
          async sendRequest(httpRequest) {
            const response2 = await next((0, util_js_1.toPipelineRequest)(httpRequest));
            return (0, response_js_1.toCompatResponse)(response2, { createProxy: true });
          }
        };
        for (const factory of orderedFactories) {
          httpPipeline = factory.create(httpPipeline, mockRequestPolicyOptions);
        }
        const webResourceLike = (0, util_js_1.toWebResourceLike)(request9, { createProxy: true });
        const response = await httpPipeline.sendRequest(webResourceLike);
        return (0, response_js_1.toPipelineResponse)(response);
      }
    };
  }
});

// node_modules/@azure/core-http-compat/dist/commonjs/httpClientAdapter.js
var require_httpClientAdapter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.convertHttpClient = convertHttpClient;
  var response_js_1 = require_response2();
  var util_js_1 = require_util8();
  function convertHttpClient(requestPolicyClient) {
    return {
      sendRequest: async (request9) => {
        const response = await requestPolicyClient.sendRequest((0, util_js_1.toWebResourceLike)(request9, { createProxy: true }));
        return (0, response_js_1.toPipelineResponse)(response);
      }
    };
  }
});

// node_modules/@azure/core-http-compat/dist/commonjs/index.js
var require_commonjs9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toHttpHeadersLike = exports.convertHttpClient = exports.disableKeepAlivePolicyName = exports.HttpPipelineLogLevel = exports.createRequestPolicyFactoryPolicy = exports.requestPolicyFactoryPolicyName = exports.ExtendedServiceClient = undefined;
  var extendedClient_js_1 = require_extendedClient();
  Object.defineProperty(exports, "ExtendedServiceClient", { enumerable: true, get: function() {
    return extendedClient_js_1.ExtendedServiceClient;
  } });
  var requestPolicyFactoryPolicy_js_1 = require_requestPolicyFactoryPolicy();
  Object.defineProperty(exports, "requestPolicyFactoryPolicyName", { enumerable: true, get: function() {
    return requestPolicyFactoryPolicy_js_1.requestPolicyFactoryPolicyName;
  } });
  Object.defineProperty(exports, "createRequestPolicyFactoryPolicy", { enumerable: true, get: function() {
    return requestPolicyFactoryPolicy_js_1.createRequestPolicyFactoryPolicy;
  } });
  Object.defineProperty(exports, "HttpPipelineLogLevel", { enumerable: true, get: function() {
    return requestPolicyFactoryPolicy_js_1.HttpPipelineLogLevel;
  } });
  var disableKeepAlivePolicy_js_1 = require_disableKeepAlivePolicy();
  Object.defineProperty(exports, "disableKeepAlivePolicyName", { enumerable: true, get: function() {
    return disableKeepAlivePolicy_js_1.disableKeepAlivePolicyName;
  } });
  var httpClientAdapter_js_1 = require_httpClientAdapter();
  Object.defineProperty(exports, "convertHttpClient", { enumerable: true, get: function() {
    return httpClientAdapter_js_1.convertHttpClient;
  } });
  var util_js_1 = require_util8();
  Object.defineProperty(exports, "toHttpHeadersLike", { enumerable: true, get: function() {
    return util_js_1.toHttpHeadersLike;
  } });
});

// node_modules/fast-xml-parser/lib/fxp.cjs
var require_fxp = __commonJS((exports, module) => {
  (() => {
    var t2 = { d: (e3, n3) => {
      for (var i3 in n3)
        t2.o(n3, i3) && !t2.o(e3, i3) && Object.defineProperty(e3, i3, { enumerable: true, get: n3[i3] });
    }, o: (t3, e3) => Object.prototype.hasOwnProperty.call(t3, e3), r: (t3) => {
      typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
    } }, e2 = {};
    t2.r(e2), t2.d(e2, { XMLBuilder: () => ft, XMLParser: () => st, XMLValidator: () => mt });
    const n2 = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", i2 = new RegExp("^[" + n2 + "][" + n2 + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
    function s2(t3, e3) {
      const n3 = [];
      let i3 = e3.exec(t3);
      for (;i3; ) {
        const s3 = [];
        s3.startIndex = e3.lastIndex - i3[0].length;
        const r3 = i3.length;
        for (let t4 = 0;t4 < r3; t4++)
          s3.push(i3[t4]);
        n3.push(s3), i3 = e3.exec(t3);
      }
      return n3;
    }
    const r2 = function(t3) {
      return !(i2.exec(t3) == null);
    }, o2 = { allowBooleanAttributes: false, unpairedTags: [] };
    function a2(t3, e3) {
      e3 = Object.assign({}, o2, e3);
      const n3 = [];
      let i3 = false, s3 = false;
      t3[0] === "\uFEFF" && (t3 = t3.substr(1));
      for (let o3 = 0;o3 < t3.length; o3++)
        if (t3[o3] === "<" && t3[o3 + 1] === "?") {
          if (o3 += 2, o3 = u2(t3, o3), o3.err)
            return o3;
        } else {
          if (t3[o3] !== "<") {
            if (l2(t3[o3]))
              continue;
            return x2("InvalidChar", "char '" + t3[o3] + "' is not expected.", N2(t3, o3));
          }
          {
            let a3 = o3;
            if (o3++, t3[o3] === "!") {
              o3 = h2(t3, o3);
              continue;
            }
            {
              let d3 = false;
              t3[o3] === "/" && (d3 = true, o3++);
              let f3 = "";
              for (;o3 < t3.length && t3[o3] !== ">" && t3[o3] !== " " && t3[o3] !== "\t" && t3[o3] !== `
` && t3[o3] !== "\r"; o3++)
                f3 += t3[o3];
              if (f3 = f3.trim(), f3[f3.length - 1] === "/" && (f3 = f3.substring(0, f3.length - 1), o3--), !r2(f3)) {
                let e4;
                return e4 = f3.trim().length === 0 ? "Invalid space after '<'." : "Tag '" + f3 + "' is an invalid name.", x2("InvalidTag", e4, N2(t3, o3));
              }
              const p3 = c2(t3, o3);
              if (p3 === false)
                return x2("InvalidAttr", "Attributes for '" + f3 + "' have open quote.", N2(t3, o3));
              let b3 = p3.value;
              if (o3 = p3.index, b3[b3.length - 1] === "/") {
                const n4 = o3 - b3.length;
                b3 = b3.substring(0, b3.length - 1);
                const s4 = g2(b3, e3);
                if (s4 !== true)
                  return x2(s4.err.code, s4.err.msg, N2(t3, n4 + s4.err.line));
                i3 = true;
              } else if (d3) {
                if (!p3.tagClosed)
                  return x2("InvalidTag", "Closing tag '" + f3 + "' doesn't have proper closing.", N2(t3, o3));
                if (b3.trim().length > 0)
                  return x2("InvalidTag", "Closing tag '" + f3 + "' can't have attributes or invalid starting.", N2(t3, a3));
                if (n3.length === 0)
                  return x2("InvalidTag", "Closing tag '" + f3 + "' has not been opened.", N2(t3, a3));
                {
                  const e4 = n3.pop();
                  if (f3 !== e4.tagName) {
                    let n4 = N2(t3, e4.tagStartPos);
                    return x2("InvalidTag", "Expected closing tag '" + e4.tagName + "' (opened in line " + n4.line + ", col " + n4.col + ") instead of closing tag '" + f3 + "'.", N2(t3, a3));
                  }
                  n3.length == 0 && (s3 = true);
                }
              } else {
                const r3 = g2(b3, e3);
                if (r3 !== true)
                  return x2(r3.err.code, r3.err.msg, N2(t3, o3 - b3.length + r3.err.line));
                if (s3 === true)
                  return x2("InvalidXml", "Multiple possible root nodes found.", N2(t3, o3));
                e3.unpairedTags.indexOf(f3) !== -1 || n3.push({ tagName: f3, tagStartPos: a3 }), i3 = true;
              }
              for (o3++;o3 < t3.length; o3++)
                if (t3[o3] === "<") {
                  if (t3[o3 + 1] === "!") {
                    o3++, o3 = h2(t3, o3);
                    continue;
                  }
                  if (t3[o3 + 1] !== "?")
                    break;
                  if (o3 = u2(t3, ++o3), o3.err)
                    return o3;
                } else if (t3[o3] === "&") {
                  const e4 = m2(t3, o3);
                  if (e4 == -1)
                    return x2("InvalidChar", "char '&' is not expected.", N2(t3, o3));
                  o3 = e4;
                } else if (s3 === true && !l2(t3[o3]))
                  return x2("InvalidXml", "Extra text at the end", N2(t3, o3));
              t3[o3] === "<" && o3--;
            }
          }
        }
      return i3 ? n3.length == 1 ? x2("InvalidTag", "Unclosed tag '" + n3[0].tagName + "'.", N2(t3, n3[0].tagStartPos)) : !(n3.length > 0) || x2("InvalidXml", "Invalid '" + JSON.stringify(n3.map((t4) => t4.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 }) : x2("InvalidXml", "Start tag expected.", 1);
    }
    function l2(t3) {
      return t3 === " " || t3 === "\t" || t3 === `
` || t3 === "\r";
    }
    function u2(t3, e3) {
      const n3 = e3;
      for (;e3 < t3.length; e3++)
        if (t3[e3] != "?" && t3[e3] != " ")
          ;
        else {
          const i3 = t3.substr(n3, e3 - n3);
          if (e3 > 5 && i3 === "xml")
            return x2("InvalidXml", "XML declaration allowed only at the start of the document.", N2(t3, e3));
          if (t3[e3] == "?" && t3[e3 + 1] == ">") {
            e3++;
            break;
          }
        }
      return e3;
    }
    function h2(t3, e3) {
      if (t3.length > e3 + 5 && t3[e3 + 1] === "-" && t3[e3 + 2] === "-") {
        for (e3 += 3;e3 < t3.length; e3++)
          if (t3[e3] === "-" && t3[e3 + 1] === "-" && t3[e3 + 2] === ">") {
            e3 += 2;
            break;
          }
      } else if (t3.length > e3 + 8 && t3[e3 + 1] === "D" && t3[e3 + 2] === "O" && t3[e3 + 3] === "C" && t3[e3 + 4] === "T" && t3[e3 + 5] === "Y" && t3[e3 + 6] === "P" && t3[e3 + 7] === "E") {
        let n3 = 1;
        for (e3 += 8;e3 < t3.length; e3++)
          if (t3[e3] === "<")
            n3++;
          else if (t3[e3] === ">" && (n3--, n3 === 0))
            break;
      } else if (t3.length > e3 + 9 && t3[e3 + 1] === "[" && t3[e3 + 2] === "C" && t3[e3 + 3] === "D" && t3[e3 + 4] === "A" && t3[e3 + 5] === "T" && t3[e3 + 6] === "A" && t3[e3 + 7] === "[") {
        for (e3 += 8;e3 < t3.length; e3++)
          if (t3[e3] === "]" && t3[e3 + 1] === "]" && t3[e3 + 2] === ">") {
            e3 += 2;
            break;
          }
      }
      return e3;
    }
    const d2 = '"', f2 = "'";
    function c2(t3, e3) {
      let n3 = "", i3 = "", s3 = false;
      for (;e3 < t3.length; e3++) {
        if (t3[e3] === d2 || t3[e3] === f2)
          i3 === "" ? i3 = t3[e3] : i3 !== t3[e3] || (i3 = "");
        else if (t3[e3] === ">" && i3 === "") {
          s3 = true;
          break;
        }
        n3 += t3[e3];
      }
      return i3 === "" && { value: n3, index: e3, tagClosed: s3 };
    }
    const p2 = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function g2(t3, e3) {
      const n3 = s2(t3, p2), i3 = {};
      for (let t4 = 0;t4 < n3.length; t4++) {
        if (n3[t4][1].length === 0)
          return x2("InvalidAttr", "Attribute '" + n3[t4][2] + "' has no space in starting.", E2(n3[t4]));
        if (n3[t4][3] !== undefined && n3[t4][4] === undefined)
          return x2("InvalidAttr", "Attribute '" + n3[t4][2] + "' is without value.", E2(n3[t4]));
        if (n3[t4][3] === undefined && !e3.allowBooleanAttributes)
          return x2("InvalidAttr", "boolean attribute '" + n3[t4][2] + "' is not allowed.", E2(n3[t4]));
        const s3 = n3[t4][2];
        if (!b2(s3))
          return x2("InvalidAttr", "Attribute '" + s3 + "' is an invalid name.", E2(n3[t4]));
        if (i3.hasOwnProperty(s3))
          return x2("InvalidAttr", "Attribute '" + s3 + "' is repeated.", E2(n3[t4]));
        i3[s3] = 1;
      }
      return true;
    }
    function m2(t3, e3) {
      if (t3[++e3] === ";")
        return -1;
      if (t3[e3] === "#")
        return function(t4, e4) {
          let n4 = /\d/;
          for (t4[e4] === "x" && (e4++, n4 = /[\da-fA-F]/);e4 < t4.length; e4++) {
            if (t4[e4] === ";")
              return e4;
            if (!t4[e4].match(n4))
              break;
          }
          return -1;
        }(t3, ++e3);
      let n3 = 0;
      for (;e3 < t3.length; e3++, n3++)
        if (!(t3[e3].match(/\w/) && n3 < 20)) {
          if (t3[e3] === ";")
            break;
          return -1;
        }
      return e3;
    }
    function x2(t3, e3, n3) {
      return { err: { code: t3, msg: e3, line: n3.line || n3, col: n3.col } };
    }
    function b2(t3) {
      return r2(t3);
    }
    function N2(t3, e3) {
      const n3 = t3.substring(0, e3).split(/\r?\n/);
      return { line: n3.length, col: n3[n3.length - 1].length + 1 };
    }
    function E2(t3) {
      return t3.startIndex + t3[1].length;
    }
    const v2 = { preserveOrder: false, attributeNamePrefix: "@_", attributesGroupName: false, textNodeName: "#text", ignoreAttributes: true, removeNSPrefix: false, allowBooleanAttributes: false, parseTagValue: true, parseAttributeValue: false, trimValues: true, cdataPropName: false, numberParseOptions: { hex: true, leadingZeros: true, eNotation: true }, tagValueProcessor: function(t3, e3) {
      return e3;
    }, attributeValueProcessor: function(t3, e3) {
      return e3;
    }, stopNodes: [], alwaysCreateTextNode: false, isArray: () => false, commentPropName: false, unpairedTags: [], processEntities: true, htmlEntities: false, ignoreDeclaration: false, ignorePiTags: false, transformTagName: false, transformAttributeName: false, updateTag: function(t3, e3, n3) {
      return t3;
    }, captureMetaData: false };
    let y2;
    y2 = typeof Symbol != "function" ? "@@xmlMetadata" : Symbol("XML Node Metadata");

    class T2 {
      constructor(t3) {
        this.tagname = t3, this.child = [], this[":@"] = {};
      }
      add(t3, e3) {
        t3 === "__proto__" && (t3 = "#__proto__"), this.child.push({ [t3]: e3 });
      }
      addChild(t3, e3) {
        t3.tagname === "__proto__" && (t3.tagname = "#__proto__"), t3[":@"] && Object.keys(t3[":@"]).length > 0 ? this.child.push({ [t3.tagname]: t3.child, ":@": t3[":@"] }) : this.child.push({ [t3.tagname]: t3.child }), e3 !== undefined && (this.child[this.child.length - 1][y2] = { startIndex: e3 });
      }
      static getMetaDataSymbol() {
        return y2;
      }
    }
    function w2(t3, e3) {
      const n3 = {};
      if (t3[e3 + 3] !== "O" || t3[e3 + 4] !== "C" || t3[e3 + 5] !== "T" || t3[e3 + 6] !== "Y" || t3[e3 + 7] !== "P" || t3[e3 + 8] !== "E")
        throw new Error("Invalid Tag instead of DOCTYPE");
      {
        e3 += 9;
        let i3 = 1, s3 = false, r3 = false, o3 = "";
        for (;e3 < t3.length; e3++)
          if (t3[e3] !== "<" || r3)
            if (t3[e3] === ">") {
              if (r3 ? t3[e3 - 1] === "-" && t3[e3 - 2] === "-" && (r3 = false, i3--) : i3--, i3 === 0)
                break;
            } else
              t3[e3] === "[" ? s3 = true : o3 += t3[e3];
          else {
            if (s3 && C2(t3, "!ENTITY", e3)) {
              let i4, s4;
              e3 += 7, [i4, s4, e3] = O2(t3, e3 + 1), s4.indexOf("&") === -1 && (n3[i4] = { regx: RegExp(`&${i4};`, "g"), val: s4 });
            } else if (s3 && C2(t3, "!ELEMENT", e3)) {
              e3 += 8;
              const { index: n4 } = S2(t3, e3 + 1);
              e3 = n4;
            } else if (s3 && C2(t3, "!ATTLIST", e3))
              e3 += 8;
            else if (s3 && C2(t3, "!NOTATION", e3)) {
              e3 += 9;
              const { index: n4 } = A2(t3, e3 + 1);
              e3 = n4;
            } else {
              if (!C2(t3, "!--", e3))
                throw new Error("Invalid DOCTYPE");
              r3 = true;
            }
            i3++, o3 = "";
          }
        if (i3 !== 0)
          throw new Error("Unclosed DOCTYPE");
      }
      return { entities: n3, i: e3 };
    }
    const P2 = (t3, e3) => {
      for (;e3 < t3.length && /\s/.test(t3[e3]); )
        e3++;
      return e3;
    };
    function O2(t3, e3) {
      e3 = P2(t3, e3);
      let n3 = "";
      for (;e3 < t3.length && !/\s/.test(t3[e3]) && t3[e3] !== '"' && t3[e3] !== "'"; )
        n3 += t3[e3], e3++;
      if ($2(n3), e3 = P2(t3, e3), t3.substring(e3, e3 + 6).toUpperCase() === "SYSTEM")
        throw new Error("External entities are not supported");
      if (t3[e3] === "%")
        throw new Error("Parameter entities are not supported");
      let i3 = "";
      return [e3, i3] = I2(t3, e3, "entity"), [n3, i3, --e3];
    }
    function A2(t3, e3) {
      e3 = P2(t3, e3);
      let n3 = "";
      for (;e3 < t3.length && !/\s/.test(t3[e3]); )
        n3 += t3[e3], e3++;
      $2(n3), e3 = P2(t3, e3);
      const i3 = t3.substring(e3, e3 + 6).toUpperCase();
      if (i3 !== "SYSTEM" && i3 !== "PUBLIC")
        throw new Error(`Expected SYSTEM or PUBLIC, found "${i3}"`);
      e3 += i3.length, e3 = P2(t3, e3);
      let s3 = null, r3 = null;
      if (i3 === "PUBLIC")
        [e3, s3] = I2(t3, e3, "publicIdentifier"), t3[e3 = P2(t3, e3)] !== '"' && t3[e3] !== "'" || ([e3, r3] = I2(t3, e3, "systemIdentifier"));
      else if (i3 === "SYSTEM" && ([e3, r3] = I2(t3, e3, "systemIdentifier"), !r3))
        throw new Error("Missing mandatory system identifier for SYSTEM notation");
      return { notationName: n3, publicIdentifier: s3, systemIdentifier: r3, index: --e3 };
    }
    function I2(t3, e3, n3) {
      let i3 = "";
      const s3 = t3[e3];
      if (s3 !== '"' && s3 !== "'")
        throw new Error(`Expected quoted string, found "${s3}"`);
      for (e3++;e3 < t3.length && t3[e3] !== s3; )
        i3 += t3[e3], e3++;
      if (t3[e3] !== s3)
        throw new Error(`Unterminated ${n3} value`);
      return [++e3, i3];
    }
    function S2(t3, e3) {
      e3 = P2(t3, e3);
      let n3 = "";
      for (;e3 < t3.length && !/\s/.test(t3[e3]); )
        n3 += t3[e3], e3++;
      if (!$2(n3))
        throw new Error(`Invalid element name: "${n3}"`);
      let i3 = "";
      if (t3[e3 = P2(t3, e3)] === "E" && C2(t3, "MPTY", e3))
        e3 += 4;
      else if (t3[e3] === "A" && C2(t3, "NY", e3))
        e3 += 2;
      else {
        if (t3[e3] !== "(")
          throw new Error(`Invalid Element Expression, found "${t3[e3]}"`);
        for (e3++;e3 < t3.length && t3[e3] !== ")"; )
          i3 += t3[e3], e3++;
        if (t3[e3] !== ")")
          throw new Error("Unterminated content model");
      }
      return { elementName: n3, contentModel: i3.trim(), index: e3 };
    }
    function C2(t3, e3, n3) {
      for (let i3 = 0;i3 < e3.length; i3++)
        if (e3[i3] !== t3[n3 + i3 + 1])
          return false;
      return true;
    }
    function $2(t3) {
      if (r2(t3))
        return t3;
      throw new Error(`Invalid entity name ${t3}`);
    }
    const j2 = /^[-+]?0x[a-fA-F0-9]+$/, D2 = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/, V2 = { hex: true, leadingZeros: true, decimalPoint: ".", eNotation: true };
    const M2 = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
    function _2(t3) {
      return typeof t3 == "function" ? t3 : Array.isArray(t3) ? (e3) => {
        for (const n3 of t3) {
          if (typeof n3 == "string" && e3 === n3)
            return true;
          if (n3 instanceof RegExp && n3.test(e3))
            return true;
        }
      } : () => false;
    }

    class k2 {
      constructor(t3) {
        this.options = t3, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = { apos: { regex: /&(apos|#39|#x27);/g, val: "'" }, gt: { regex: /&(gt|#62|#x3E);/g, val: ">" }, lt: { regex: /&(lt|#60|#x3C);/g, val: "<" }, quot: { regex: /&(quot|#34|#x22);/g, val: '"' } }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = { space: { regex: /&(nbsp|#160);/g, val: " " }, cent: { regex: /&(cent|#162);/g, val: "" }, pound: { regex: /&(pound|#163);/g, val: "" }, yen: { regex: /&(yen|#165);/g, val: "" }, euro: { regex: /&(euro|#8364);/g, val: "" }, copyright: { regex: /&(copy|#169);/g, val: "" }, reg: { regex: /&(reg|#174);/g, val: "" }, inr: { regex: /&(inr|#8377);/g, val: "" }, num_dec: { regex: /&#([0-9]{1,7});/g, val: (t4, e3) => String.fromCodePoint(Number.parseInt(e3, 10)) }, num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (t4, e3) => String.fromCodePoint(Number.parseInt(e3, 16)) } }, this.addExternalEntities = F2, this.parseXml = X2, this.parseTextData = L2, this.resolveNameSpace = B2, this.buildAttributesMap = G2, this.isItStopNode = Z2, this.replaceEntitiesValue = R2, this.readStopNodeData = J2, this.saveTextToParentTag = q2, this.addChild = Y2, this.ignoreAttributesFn = _2(this.options.ignoreAttributes);
      }
    }
    function F2(t3) {
      const e3 = Object.keys(t3);
      for (let n3 = 0;n3 < e3.length; n3++) {
        const i3 = e3[n3];
        this.lastEntities[i3] = { regex: new RegExp("&" + i3 + ";", "g"), val: t3[i3] };
      }
    }
    function L2(t3, e3, n3, i3, s3, r3, o3) {
      if (t3 !== undefined && (this.options.trimValues && !i3 && (t3 = t3.trim()), t3.length > 0)) {
        o3 || (t3 = this.replaceEntitiesValue(t3));
        const i4 = this.options.tagValueProcessor(e3, t3, n3, s3, r3);
        return i4 == null ? t3 : typeof i4 != typeof t3 || i4 !== t3 ? i4 : this.options.trimValues || t3.trim() === t3 ? H2(t3, this.options.parseTagValue, this.options.numberParseOptions) : t3;
      }
    }
    function B2(t3) {
      if (this.options.removeNSPrefix) {
        const e3 = t3.split(":"), n3 = t3.charAt(0) === "/" ? "/" : "";
        if (e3[0] === "xmlns")
          return "";
        e3.length === 2 && (t3 = n3 + e3[1]);
      }
      return t3;
    }
    const U2 = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function G2(t3, e3, n3) {
      if (this.options.ignoreAttributes !== true && typeof t3 == "string") {
        const n4 = s2(t3, U2), i3 = n4.length, r3 = {};
        for (let t4 = 0;t4 < i3; t4++) {
          const i4 = this.resolveNameSpace(n4[t4][1]);
          if (this.ignoreAttributesFn(i4, e3))
            continue;
          let s3 = n4[t4][4], o3 = this.options.attributeNamePrefix + i4;
          if (i4.length)
            if (this.options.transformAttributeName && (o3 = this.options.transformAttributeName(o3)), o3 === "__proto__" && (o3 = "#__proto__"), s3 !== undefined) {
              this.options.trimValues && (s3 = s3.trim()), s3 = this.replaceEntitiesValue(s3);
              const t5 = this.options.attributeValueProcessor(i4, s3, e3);
              r3[o3] = t5 == null ? s3 : typeof t5 != typeof s3 || t5 !== s3 ? t5 : H2(s3, this.options.parseAttributeValue, this.options.numberParseOptions);
            } else
              this.options.allowBooleanAttributes && (r3[o3] = true);
        }
        if (!Object.keys(r3).length)
          return;
        if (this.options.attributesGroupName) {
          const t4 = {};
          return t4[this.options.attributesGroupName] = r3, t4;
        }
        return r3;
      }
    }
    const X2 = function(t3) {
      t3 = t3.replace(/\r\n?/g, `
`);
      const e3 = new T2("!xml");
      let n3 = e3, i3 = "", s3 = "";
      for (let r3 = 0;r3 < t3.length; r3++)
        if (t3[r3] === "<")
          if (t3[r3 + 1] === "/") {
            const e4 = W2(t3, ">", r3, "Closing Tag is not closed.");
            let o3 = t3.substring(r3 + 2, e4).trim();
            if (this.options.removeNSPrefix) {
              const t4 = o3.indexOf(":");
              t4 !== -1 && (o3 = o3.substr(t4 + 1));
            }
            this.options.transformTagName && (o3 = this.options.transformTagName(o3)), n3 && (i3 = this.saveTextToParentTag(i3, n3, s3));
            const a3 = s3.substring(s3.lastIndexOf(".") + 1);
            if (o3 && this.options.unpairedTags.indexOf(o3) !== -1)
              throw new Error(`Unpaired tag can not be used as closing tag: </${o3}>`);
            let l3 = 0;
            a3 && this.options.unpairedTags.indexOf(a3) !== -1 ? (l3 = s3.lastIndexOf(".", s3.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : l3 = s3.lastIndexOf("."), s3 = s3.substring(0, l3), n3 = this.tagsNodeStack.pop(), i3 = "", r3 = e4;
          } else if (t3[r3 + 1] === "?") {
            let e4 = z2(t3, r3, false, "?>");
            if (!e4)
              throw new Error("Pi Tag is not closed.");
            if (i3 = this.saveTextToParentTag(i3, n3, s3), this.options.ignoreDeclaration && e4.tagName === "?xml" || this.options.ignorePiTags)
              ;
            else {
              const t4 = new T2(e4.tagName);
              t4.add(this.options.textNodeName, ""), e4.tagName !== e4.tagExp && e4.attrExpPresent && (t4[":@"] = this.buildAttributesMap(e4.tagExp, s3, e4.tagName)), this.addChild(n3, t4, s3, r3);
            }
            r3 = e4.closeIndex + 1;
          } else if (t3.substr(r3 + 1, 3) === "!--") {
            const e4 = W2(t3, "-->", r3 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const o3 = t3.substring(r3 + 4, e4 - 2);
              i3 = this.saveTextToParentTag(i3, n3, s3), n3.add(this.options.commentPropName, [{ [this.options.textNodeName]: o3 }]);
            }
            r3 = e4;
          } else if (t3.substr(r3 + 1, 2) === "!D") {
            const e4 = w2(t3, r3);
            this.docTypeEntities = e4.entities, r3 = e4.i;
          } else if (t3.substr(r3 + 1, 2) === "![") {
            const e4 = W2(t3, "]]>", r3, "CDATA is not closed.") - 2, o3 = t3.substring(r3 + 9, e4);
            i3 = this.saveTextToParentTag(i3, n3, s3);
            let a3 = this.parseTextData(o3, n3.tagname, s3, true, false, true, true);
            a3 == null && (a3 = ""), this.options.cdataPropName ? n3.add(this.options.cdataPropName, [{ [this.options.textNodeName]: o3 }]) : n3.add(this.options.textNodeName, a3), r3 = e4 + 2;
          } else {
            let o3 = z2(t3, r3, this.options.removeNSPrefix), a3 = o3.tagName;
            const l3 = o3.rawTagName;
            let { tagExp: u3, attrExpPresent: h3, closeIndex: d3 } = o3;
            this.options.transformTagName && (a3 = this.options.transformTagName(a3)), n3 && i3 && n3.tagname !== "!xml" && (i3 = this.saveTextToParentTag(i3, n3, s3, false));
            const f3 = n3;
            f3 && this.options.unpairedTags.indexOf(f3.tagname) !== -1 && (n3 = this.tagsNodeStack.pop(), s3 = s3.substring(0, s3.lastIndexOf("."))), a3 !== e3.tagname && (s3 += s3 ? "." + a3 : a3);
            const c3 = r3;
            if (this.isItStopNode(this.options.stopNodes, s3, a3)) {
              let e4 = "";
              if (u3.length > 0 && u3.lastIndexOf("/") === u3.length - 1)
                a3[a3.length - 1] === "/" ? (a3 = a3.substr(0, a3.length - 1), s3 = s3.substr(0, s3.length - 1), u3 = a3) : u3 = u3.substr(0, u3.length - 1), r3 = o3.closeIndex;
              else if (this.options.unpairedTags.indexOf(a3) !== -1)
                r3 = o3.closeIndex;
              else {
                const n4 = this.readStopNodeData(t3, l3, d3 + 1);
                if (!n4)
                  throw new Error(`Unexpected end of ${l3}`);
                r3 = n4.i, e4 = n4.tagContent;
              }
              const i4 = new T2(a3);
              a3 !== u3 && h3 && (i4[":@"] = this.buildAttributesMap(u3, s3, a3)), e4 && (e4 = this.parseTextData(e4, a3, s3, true, h3, true, true)), s3 = s3.substr(0, s3.lastIndexOf(".")), i4.add(this.options.textNodeName, e4), this.addChild(n3, i4, s3, c3);
            } else {
              if (u3.length > 0 && u3.lastIndexOf("/") === u3.length - 1) {
                a3[a3.length - 1] === "/" ? (a3 = a3.substr(0, a3.length - 1), s3 = s3.substr(0, s3.length - 1), u3 = a3) : u3 = u3.substr(0, u3.length - 1), this.options.transformTagName && (a3 = this.options.transformTagName(a3));
                const t4 = new T2(a3);
                a3 !== u3 && h3 && (t4[":@"] = this.buildAttributesMap(u3, s3, a3)), this.addChild(n3, t4, s3, c3), s3 = s3.substr(0, s3.lastIndexOf("."));
              } else {
                const t4 = new T2(a3);
                this.tagsNodeStack.push(n3), a3 !== u3 && h3 && (t4[":@"] = this.buildAttributesMap(u3, s3, a3)), this.addChild(n3, t4, s3, c3), n3 = t4;
              }
              i3 = "", r3 = d3;
            }
          }
        else
          i3 += t3[r3];
      return e3.child;
    };
    function Y2(t3, e3, n3, i3) {
      this.options.captureMetaData || (i3 = undefined);
      const s3 = this.options.updateTag(e3.tagname, n3, e3[":@"]);
      s3 === false || (typeof s3 == "string" ? (e3.tagname = s3, t3.addChild(e3, i3)) : t3.addChild(e3, i3));
    }
    const R2 = function(t3) {
      if (this.options.processEntities) {
        for (let e3 in this.docTypeEntities) {
          const n3 = this.docTypeEntities[e3];
          t3 = t3.replace(n3.regx, n3.val);
        }
        for (let e3 in this.lastEntities) {
          const n3 = this.lastEntities[e3];
          t3 = t3.replace(n3.regex, n3.val);
        }
        if (this.options.htmlEntities)
          for (let e3 in this.htmlEntities) {
            const n3 = this.htmlEntities[e3];
            t3 = t3.replace(n3.regex, n3.val);
          }
        t3 = t3.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return t3;
    };
    function q2(t3, e3, n3, i3) {
      return t3 && (i3 === undefined && (i3 = e3.child.length === 0), (t3 = this.parseTextData(t3, e3.tagname, n3, false, !!e3[":@"] && Object.keys(e3[":@"]).length !== 0, i3)) !== undefined && t3 !== "" && e3.add(this.options.textNodeName, t3), t3 = ""), t3;
    }
    function Z2(t3, e3, n3) {
      const i3 = "*." + n3;
      for (const n4 in t3) {
        const s3 = t3[n4];
        if (i3 === s3 || e3 === s3)
          return true;
      }
      return false;
    }
    function W2(t3, e3, n3, i3) {
      const s3 = t3.indexOf(e3, n3);
      if (s3 === -1)
        throw new Error(i3);
      return s3 + e3.length - 1;
    }
    function z2(t3, e3, n3, i3 = ">") {
      const s3 = function(t4, e4, n4 = ">") {
        let i4, s4 = "";
        for (let r4 = e4;r4 < t4.length; r4++) {
          let e5 = t4[r4];
          if (i4)
            e5 === i4 && (i4 = "");
          else if (e5 === '"' || e5 === "'")
            i4 = e5;
          else if (e5 === n4[0]) {
            if (!n4[1])
              return { data: s4, index: r4 };
            if (t4[r4 + 1] === n4[1])
              return { data: s4, index: r4 };
          } else
            e5 === "\t" && (e5 = " ");
          s4 += e5;
        }
      }(t3, e3 + 1, i3);
      if (!s3)
        return;
      let r3 = s3.data;
      const o3 = s3.index, a3 = r3.search(/\s/);
      let l3 = r3, u3 = true;
      a3 !== -1 && (l3 = r3.substring(0, a3), r3 = r3.substring(a3 + 1).trimStart());
      const h3 = l3;
      if (n3) {
        const t4 = l3.indexOf(":");
        t4 !== -1 && (l3 = l3.substr(t4 + 1), u3 = l3 !== s3.data.substr(t4 + 1));
      }
      return { tagName: l3, tagExp: r3, closeIndex: o3, attrExpPresent: u3, rawTagName: h3 };
    }
    function J2(t3, e3, n3) {
      const i3 = n3;
      let s3 = 1;
      for (;n3 < t3.length; n3++)
        if (t3[n3] === "<")
          if (t3[n3 + 1] === "/") {
            const r3 = W2(t3, ">", n3, `${e3} is not closed`);
            if (t3.substring(n3 + 2, r3).trim() === e3 && (s3--, s3 === 0))
              return { tagContent: t3.substring(i3, n3), i: r3 };
            n3 = r3;
          } else if (t3[n3 + 1] === "?")
            n3 = W2(t3, "?>", n3 + 1, "StopNode is not closed.");
          else if (t3.substr(n3 + 1, 3) === "!--")
            n3 = W2(t3, "-->", n3 + 3, "StopNode is not closed.");
          else if (t3.substr(n3 + 1, 2) === "![")
            n3 = W2(t3, "]]>", n3, "StopNode is not closed.") - 2;
          else {
            const i4 = z2(t3, n3, ">");
            i4 && ((i4 && i4.tagName) === e3 && i4.tagExp[i4.tagExp.length - 1] !== "/" && s3++, n3 = i4.closeIndex);
          }
    }
    function H2(t3, e3, n3) {
      if (e3 && typeof t3 == "string") {
        const e4 = t3.trim();
        return e4 === "true" || e4 !== "false" && function(t4, e5 = {}) {
          if (e5 = Object.assign({}, V2, e5), !t4 || typeof t4 != "string")
            return t4;
          let n4 = t4.trim();
          if (e5.skipLike !== undefined && e5.skipLike.test(n4))
            return t4;
          if (t4 === "0")
            return 0;
          if (e5.hex && j2.test(n4))
            return function(t5) {
              if (parseInt)
                return parseInt(t5, 16);
              if (Number.parseInt)
                return Number.parseInt(t5, 16);
              if (window && window.parseInt)
                return window.parseInt(t5, 16);
              throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
            }(n4);
          if (n4.search(/.+[eE].+/) !== -1)
            return function(t5, e6, n5) {
              if (!n5.eNotation)
                return t5;
              const i4 = e6.match(M2);
              if (i4) {
                let s3 = i4[1] || "";
                const r3 = i4[3].indexOf("e") === -1 ? "E" : "e", o3 = i4[2], a3 = s3 ? t5[o3.length + 1] === r3 : t5[o3.length] === r3;
                return o3.length > 1 && a3 ? t5 : o3.length !== 1 || !i4[3].startsWith(`.${r3}`) && i4[3][0] !== r3 ? n5.leadingZeros && !a3 ? (e6 = (i4[1] || "") + i4[3], Number(e6)) : t5 : Number(e6);
              }
              return t5;
            }(t4, n4, e5);
          {
            const s3 = D2.exec(n4);
            if (s3) {
              const r3 = s3[1] || "", o3 = s3[2];
              let a3 = (i3 = s3[3]) && i3.indexOf(".") !== -1 ? ((i3 = i3.replace(/0+$/, "")) === "." ? i3 = "0" : i3[0] === "." ? i3 = "0" + i3 : i3[i3.length - 1] === "." && (i3 = i3.substring(0, i3.length - 1)), i3) : i3;
              const l3 = r3 ? t4[o3.length + 1] === "." : t4[o3.length] === ".";
              if (!e5.leadingZeros && (o3.length > 1 || o3.length === 1 && !l3))
                return t4;
              {
                const i4 = Number(n4), s4 = String(i4);
                if (i4 === 0 || i4 === -0)
                  return i4;
                if (s4.search(/[eE]/) !== -1)
                  return e5.eNotation ? i4 : t4;
                if (n4.indexOf(".") !== -1)
                  return s4 === "0" || s4 === a3 || s4 === `${r3}${a3}` ? i4 : t4;
                let l4 = o3 ? a3 : n4;
                return o3 ? l4 === s4 || r3 + l4 === s4 ? i4 : t4 : l4 === s4 || l4 === r3 + s4 ? i4 : t4;
              }
            }
            return t4;
          }
          var i3;
        }(t3, n3);
      }
      return t3 !== undefined ? t3 : "";
    }
    const K2 = T2.getMetaDataSymbol();
    function Q2(t3, e3) {
      return tt(t3, e3);
    }
    function tt(t3, e3, n3) {
      let i3;
      const s3 = {};
      for (let r3 = 0;r3 < t3.length; r3++) {
        const o3 = t3[r3], a3 = et(o3);
        let l3 = "";
        if (l3 = n3 === undefined ? a3 : n3 + "." + a3, a3 === e3.textNodeName)
          i3 === undefined ? i3 = o3[a3] : i3 += "" + o3[a3];
        else {
          if (a3 === undefined)
            continue;
          if (o3[a3]) {
            let t4 = tt(o3[a3], e3, l3);
            const n4 = it(t4, e3);
            o3[K2] !== undefined && (t4[K2] = o3[K2]), o3[":@"] ? nt(t4, o3[":@"], l3, e3) : Object.keys(t4).length !== 1 || t4[e3.textNodeName] === undefined || e3.alwaysCreateTextNode ? Object.keys(t4).length === 0 && (e3.alwaysCreateTextNode ? t4[e3.textNodeName] = "" : t4 = "") : t4 = t4[e3.textNodeName], s3[a3] !== undefined && s3.hasOwnProperty(a3) ? (Array.isArray(s3[a3]) || (s3[a3] = [s3[a3]]), s3[a3].push(t4)) : e3.isArray(a3, l3, n4) ? s3[a3] = [t4] : s3[a3] = t4;
          }
        }
      }
      return typeof i3 == "string" ? i3.length > 0 && (s3[e3.textNodeName] = i3) : i3 !== undefined && (s3[e3.textNodeName] = i3), s3;
    }
    function et(t3) {
      const e3 = Object.keys(t3);
      for (let t4 = 0;t4 < e3.length; t4++) {
        const n3 = e3[t4];
        if (n3 !== ":@")
          return n3;
      }
    }
    function nt(t3, e3, n3, i3) {
      if (e3) {
        const s3 = Object.keys(e3), r3 = s3.length;
        for (let o3 = 0;o3 < r3; o3++) {
          const r4 = s3[o3];
          i3.isArray(r4, n3 + "." + r4, true, true) ? t3[r4] = [e3[r4]] : t3[r4] = e3[r4];
        }
      }
    }
    function it(t3, e3) {
      const { textNodeName: n3 } = e3, i3 = Object.keys(t3).length;
      return i3 === 0 || !(i3 !== 1 || !t3[n3] && typeof t3[n3] != "boolean" && t3[n3] !== 0);
    }

    class st {
      constructor(t3) {
        this.externalEntities = {}, this.options = function(t4) {
          return Object.assign({}, v2, t4);
        }(t3);
      }
      parse(t3, e3) {
        if (typeof t3 == "string")
          ;
        else {
          if (!t3.toString)
            throw new Error("XML data is accepted in String or Bytes[] form.");
          t3 = t3.toString();
        }
        if (e3) {
          e3 === true && (e3 = {});
          const n4 = a2(t3, e3);
          if (n4 !== true)
            throw Error(`${n4.err.msg}:${n4.err.line}:${n4.err.col}`);
        }
        const n3 = new k2(this.options);
        n3.addExternalEntities(this.externalEntities);
        const i3 = n3.parseXml(t3);
        return this.options.preserveOrder || i3 === undefined ? i3 : Q2(i3, this.options);
      }
      addEntity(t3, e3) {
        if (e3.indexOf("&") !== -1)
          throw new Error("Entity value can't have '&'");
        if (t3.indexOf("&") !== -1 || t3.indexOf(";") !== -1)
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        if (e3 === "&")
          throw new Error("An entity with value '&' is not permitted");
        this.externalEntities[t3] = e3;
      }
      static getMetaDataSymbol() {
        return T2.getMetaDataSymbol();
      }
    }
    function rt(t3, e3) {
      let n3 = "";
      return e3.format && e3.indentBy.length > 0 && (n3 = `
`), ot(t3, e3, "", n3);
    }
    function ot(t3, e3, n3, i3) {
      let s3 = "", r3 = false;
      for (let o3 = 0;o3 < t3.length; o3++) {
        const a3 = t3[o3], l3 = at(a3);
        if (l3 === undefined)
          continue;
        let u3 = "";
        if (u3 = n3.length === 0 ? l3 : `${n3}.${l3}`, l3 === e3.textNodeName) {
          let t4 = a3[l3];
          ut(u3, e3) || (t4 = e3.tagValueProcessor(l3, t4), t4 = ht(t4, e3)), r3 && (s3 += i3), s3 += t4, r3 = false;
          continue;
        }
        if (l3 === e3.cdataPropName) {
          r3 && (s3 += i3), s3 += `<![CDATA[${a3[l3][0][e3.textNodeName]}]]>`, r3 = false;
          continue;
        }
        if (l3 === e3.commentPropName) {
          s3 += i3 + `<!--${a3[l3][0][e3.textNodeName]}-->`, r3 = true;
          continue;
        }
        if (l3[0] === "?") {
          const t4 = lt(a3[":@"], e3), n4 = l3 === "?xml" ? "" : i3;
          let o4 = a3[l3][0][e3.textNodeName];
          o4 = o4.length !== 0 ? " " + o4 : "", s3 += n4 + `<${l3}${o4}${t4}?>`, r3 = true;
          continue;
        }
        let h3 = i3;
        h3 !== "" && (h3 += e3.indentBy);
        const d3 = i3 + `<${l3}${lt(a3[":@"], e3)}`, f3 = ot(a3[l3], e3, u3, h3);
        e3.unpairedTags.indexOf(l3) !== -1 ? e3.suppressUnpairedNode ? s3 += d3 + ">" : s3 += d3 + "/>" : f3 && f3.length !== 0 || !e3.suppressEmptyNode ? f3 && f3.endsWith(">") ? s3 += d3 + `>${f3}${i3}</${l3}>` : (s3 += d3 + ">", f3 && i3 !== "" && (f3.includes("/>") || f3.includes("</")) ? s3 += i3 + e3.indentBy + f3 + i3 : s3 += f3, s3 += `</${l3}>`) : s3 += d3 + "/>", r3 = true;
      }
      return s3;
    }
    function at(t3) {
      const e3 = Object.keys(t3);
      for (let n3 = 0;n3 < e3.length; n3++) {
        const i3 = e3[n3];
        if (t3.hasOwnProperty(i3) && i3 !== ":@")
          return i3;
      }
    }
    function lt(t3, e3) {
      let n3 = "";
      if (t3 && !e3.ignoreAttributes)
        for (let i3 in t3) {
          if (!t3.hasOwnProperty(i3))
            continue;
          let s3 = e3.attributeValueProcessor(i3, t3[i3]);
          s3 = ht(s3, e3), s3 === true && e3.suppressBooleanAttributes ? n3 += ` ${i3.substr(e3.attributeNamePrefix.length)}` : n3 += ` ${i3.substr(e3.attributeNamePrefix.length)}="${s3}"`;
        }
      return n3;
    }
    function ut(t3, e3) {
      let n3 = (t3 = t3.substr(0, t3.length - e3.textNodeName.length - 1)).substr(t3.lastIndexOf(".") + 1);
      for (let i3 in e3.stopNodes)
        if (e3.stopNodes[i3] === t3 || e3.stopNodes[i3] === "*." + n3)
          return true;
      return false;
    }
    function ht(t3, e3) {
      if (t3 && t3.length > 0 && e3.processEntities)
        for (let n3 = 0;n3 < e3.entities.length; n3++) {
          const i3 = e3.entities[n3];
          t3 = t3.replace(i3.regex, i3.val);
        }
      return t3;
    }
    const dt = { attributeNamePrefix: "@_", attributesGroupName: false, textNodeName: "#text", ignoreAttributes: true, cdataPropName: false, format: false, indentBy: "  ", suppressEmptyNode: false, suppressUnpairedNode: true, suppressBooleanAttributes: true, tagValueProcessor: function(t3, e3) {
      return e3;
    }, attributeValueProcessor: function(t3, e3) {
      return e3;
    }, preserveOrder: false, commentPropName: false, unpairedTags: [], entities: [{ regex: new RegExp("&", "g"), val: "&amp;" }, { regex: new RegExp(">", "g"), val: "&gt;" }, { regex: new RegExp("<", "g"), val: "&lt;" }, { regex: new RegExp("'", "g"), val: "&apos;" }, { regex: new RegExp('"', "g"), val: "&quot;" }], processEntities: true, stopNodes: [], oneListGroup: false };
    function ft(t3) {
      this.options = Object.assign({}, dt, t3), this.options.ignoreAttributes === true || this.options.attributesGroupName ? this.isAttribute = function() {
        return false;
      } : (this.ignoreAttributesFn = _2(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = gt), this.processTextOrObjNode = ct, this.options.format ? (this.indentate = pt, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
        return "";
      }, this.tagEndChar = ">", this.newLine = "");
    }
    function ct(t3, e3, n3, i3) {
      const s3 = this.j2x(t3, n3 + 1, i3.concat(e3));
      return t3[this.options.textNodeName] !== undefined && Object.keys(t3).length === 1 ? this.buildTextValNode(t3[this.options.textNodeName], e3, s3.attrStr, n3) : this.buildObjectNode(s3.val, e3, s3.attrStr, n3);
    }
    function pt(t3) {
      return this.options.indentBy.repeat(t3);
    }
    function gt(t3) {
      return !(!t3.startsWith(this.options.attributeNamePrefix) || t3 === this.options.textNodeName) && t3.substr(this.attrPrefixLen);
    }
    ft.prototype.build = function(t3) {
      return this.options.preserveOrder ? rt(t3, this.options) : (Array.isArray(t3) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (t3 = { [this.options.arrayNodeName]: t3 }), this.j2x(t3, 0, []).val);
    }, ft.prototype.j2x = function(t3, e3, n3) {
      let i3 = "", s3 = "";
      const r3 = n3.join(".");
      for (let o3 in t3)
        if (Object.prototype.hasOwnProperty.call(t3, o3))
          if (t3[o3] === undefined)
            this.isAttribute(o3) && (s3 += "");
          else if (t3[o3] === null)
            this.isAttribute(o3) || o3 === this.options.cdataPropName ? s3 += "" : o3[0] === "?" ? s3 += this.indentate(e3) + "<" + o3 + "?" + this.tagEndChar : s3 += this.indentate(e3) + "<" + o3 + "/" + this.tagEndChar;
          else if (t3[o3] instanceof Date)
            s3 += this.buildTextValNode(t3[o3], o3, "", e3);
          else if (typeof t3[o3] != "object") {
            const n4 = this.isAttribute(o3);
            if (n4 && !this.ignoreAttributesFn(n4, r3))
              i3 += this.buildAttrPairStr(n4, "" + t3[o3]);
            else if (!n4)
              if (o3 === this.options.textNodeName) {
                let e4 = this.options.tagValueProcessor(o3, "" + t3[o3]);
                s3 += this.replaceEntitiesValue(e4);
              } else
                s3 += this.buildTextValNode(t3[o3], o3, "", e3);
          } else if (Array.isArray(t3[o3])) {
            const i4 = t3[o3].length;
            let r4 = "", a3 = "";
            for (let l3 = 0;l3 < i4; l3++) {
              const i5 = t3[o3][l3];
              if (i5 === undefined)
                ;
              else if (i5 === null)
                o3[0] === "?" ? s3 += this.indentate(e3) + "<" + o3 + "?" + this.tagEndChar : s3 += this.indentate(e3) + "<" + o3 + "/" + this.tagEndChar;
              else if (typeof i5 == "object")
                if (this.options.oneListGroup) {
                  const t4 = this.j2x(i5, e3 + 1, n3.concat(o3));
                  r4 += t4.val, this.options.attributesGroupName && i5.hasOwnProperty(this.options.attributesGroupName) && (a3 += t4.attrStr);
                } else
                  r4 += this.processTextOrObjNode(i5, o3, e3, n3);
              else if (this.options.oneListGroup) {
                let t4 = this.options.tagValueProcessor(o3, i5);
                t4 = this.replaceEntitiesValue(t4), r4 += t4;
              } else
                r4 += this.buildTextValNode(i5, o3, "", e3);
            }
            this.options.oneListGroup && (r4 = this.buildObjectNode(r4, o3, a3, e3)), s3 += r4;
          } else if (this.options.attributesGroupName && o3 === this.options.attributesGroupName) {
            const e4 = Object.keys(t3[o3]), n4 = e4.length;
            for (let s4 = 0;s4 < n4; s4++)
              i3 += this.buildAttrPairStr(e4[s4], "" + t3[o3][e4[s4]]);
          } else
            s3 += this.processTextOrObjNode(t3[o3], o3, e3, n3);
      return { attrStr: i3, val: s3 };
    }, ft.prototype.buildAttrPairStr = function(t3, e3) {
      return e3 = this.options.attributeValueProcessor(t3, "" + e3), e3 = this.replaceEntitiesValue(e3), this.options.suppressBooleanAttributes && e3 === "true" ? " " + t3 : " " + t3 + '="' + e3 + '"';
    }, ft.prototype.buildObjectNode = function(t3, e3, n3, i3) {
      if (t3 === "")
        return e3[0] === "?" ? this.indentate(i3) + "<" + e3 + n3 + "?" + this.tagEndChar : this.indentate(i3) + "<" + e3 + n3 + this.closeTag(e3) + this.tagEndChar;
      {
        let s3 = "</" + e3 + this.tagEndChar, r3 = "";
        return e3[0] === "?" && (r3 = "?", s3 = ""), !n3 && n3 !== "" || t3.indexOf("<") !== -1 ? this.options.commentPropName !== false && e3 === this.options.commentPropName && r3.length === 0 ? this.indentate(i3) + `<!--${t3}-->` + this.newLine : this.indentate(i3) + "<" + e3 + n3 + r3 + this.tagEndChar + t3 + this.indentate(i3) + s3 : this.indentate(i3) + "<" + e3 + n3 + r3 + ">" + t3 + s3;
      }
    }, ft.prototype.closeTag = function(t3) {
      let e3 = "";
      return this.options.unpairedTags.indexOf(t3) !== -1 ? this.options.suppressUnpairedNode || (e3 = "/") : e3 = this.options.suppressEmptyNode ? "/" : `></${t3}`, e3;
    }, ft.prototype.buildTextValNode = function(t3, e3, n3, i3) {
      if (this.options.cdataPropName !== false && e3 === this.options.cdataPropName)
        return this.indentate(i3) + `<![CDATA[${t3}]]>` + this.newLine;
      if (this.options.commentPropName !== false && e3 === this.options.commentPropName)
        return this.indentate(i3) + `<!--${t3}-->` + this.newLine;
      if (e3[0] === "?")
        return this.indentate(i3) + "<" + e3 + n3 + "?" + this.tagEndChar;
      {
        let s3 = this.options.tagValueProcessor(e3, t3);
        return s3 = this.replaceEntitiesValue(s3), s3 === "" ? this.indentate(i3) + "<" + e3 + n3 + this.closeTag(e3) + this.tagEndChar : this.indentate(i3) + "<" + e3 + n3 + ">" + s3 + "</" + e3 + this.tagEndChar;
      }
    }, ft.prototype.replaceEntitiesValue = function(t3) {
      if (t3 && t3.length > 0 && this.options.processEntities)
        for (let e3 = 0;e3 < this.options.entities.length; e3++) {
          const n3 = this.options.entities[e3];
          t3 = t3.replace(n3.regex, n3.val);
        }
      return t3;
    };
    const mt = { validate: a2 };
    module.exports = e2;
  })();
});

// node_modules/@azure/core-xml/dist/commonjs/xml.common.js
var require_xml_common = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XML_CHARKEY = exports.XML_ATTRKEY = undefined;
  exports.XML_ATTRKEY = "$";
  exports.XML_CHARKEY = "_";
});

// node_modules/@azure/core-xml/dist/commonjs/xml.js
var require_xml = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stringifyXML = stringifyXML;
  exports.parseXML = parseXML;
  var fast_xml_parser_1 = require_fxp();
  var xml_common_js_1 = require_xml_common();
  function getCommonOptions(options) {
    var _a3;
    return {
      attributesGroupName: xml_common_js_1.XML_ATTRKEY,
      textNodeName: (_a3 = options.xmlCharKey) !== null && _a3 !== undefined ? _a3 : xml_common_js_1.XML_CHARKEY,
      ignoreAttributes: false,
      suppressBooleanAttributes: false
    };
  }
  function getSerializerOptions(options = {}) {
    var _a3, _b2;
    return Object.assign(Object.assign({}, getCommonOptions(options)), { attributeNamePrefix: "@_", format: true, suppressEmptyNode: true, indentBy: "", rootNodeName: (_a3 = options.rootName) !== null && _a3 !== undefined ? _a3 : "root", cdataPropName: (_b2 = options.cdataPropName) !== null && _b2 !== undefined ? _b2 : "__cdata" });
  }
  function getParserOptions(options = {}) {
    return Object.assign(Object.assign({}, getCommonOptions(options)), { parseAttributeValue: false, parseTagValue: false, attributeNamePrefix: "", stopNodes: options.stopNodes, processEntities: true, trimValues: false });
  }
  function stringifyXML(obj, opts = {}) {
    const parserOptions = getSerializerOptions(opts);
    const j2x = new fast_xml_parser_1.XMLBuilder(parserOptions);
    const node = { [parserOptions.rootNodeName]: obj };
    const xmlData = j2x.build(node);
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>${xmlData}`.replace(/\n/g, "");
  }
  async function parseXML(str, opts = {}) {
    if (!str) {
      throw new Error("Document is empty");
    }
    const validation = fast_xml_parser_1.XMLValidator.validate(str);
    if (validation !== true) {
      throw validation;
    }
    const parser = new fast_xml_parser_1.XMLParser(getParserOptions(opts));
    const parsedXml = parser.parse(str);
    if (parsedXml["?xml"]) {
      delete parsedXml["?xml"];
    }
    if (!opts.includeRoot) {
      for (const key of Object.keys(parsedXml)) {
        const value = parsedXml[key];
        return typeof value === "object" ? Object.assign({}, value) : value;
      }
    }
    return parsedXml;
  }
});

// node_modules/@azure/core-xml/dist/commonjs/index.js
var require_commonjs10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.XML_CHARKEY = exports.XML_ATTRKEY = exports.parseXML = exports.stringifyXML = undefined;
  var xml_js_1 = require_xml();
  Object.defineProperty(exports, "stringifyXML", { enumerable: true, get: function() {
    return xml_js_1.stringifyXML;
  } });
  Object.defineProperty(exports, "parseXML", { enumerable: true, get: function() {
    return xml_js_1.parseXML;
  } });
  var xml_common_js_1 = require_xml_common();
  Object.defineProperty(exports, "XML_ATTRKEY", { enumerable: true, get: function() {
    return xml_common_js_1.XML_ATTRKEY;
  } });
  Object.defineProperty(exports, "XML_CHARKEY", { enumerable: true, get: function() {
    return xml_common_js_1.XML_CHARKEY;
  } });
});

// node_modules/@azure/storage-blob/node_modules/@azure/abort-controller/dist/commonjs/AbortError.js
var require_AbortError3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;

  class AbortError3 extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  }
  exports.AbortError = AbortError3;
});

// node_modules/@azure/storage-blob/node_modules/@azure/abort-controller/dist/commonjs/index.js
var require_commonjs11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AbortError = undefined;
  var AbortError_js_1 = require_AbortError3();
  Object.defineProperty(exports, "AbortError", { enumerable: true, get: function() {
    return AbortError_js_1.AbortError;
  } });
});

// node_modules/@azure/core-lro/dist/commonjs/logger.js
var require_logger2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.logger = undefined;
  var logger_1 = require_commonjs2();
  exports.logger = (0, logger_1.createClientLogger)("core-lro");
});

// node_modules/@azure/core-lro/dist/commonjs/poller/constants.js
var require_constants9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.terminalStates = exports.POLL_INTERVAL_IN_MS = undefined;
  exports.POLL_INTERVAL_IN_MS = 2000;
  exports.terminalStates = ["succeeded", "canceled", "failed"];
});

// node_modules/@azure/core-lro/dist/commonjs/poller/operation.js
var require_operation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pollOperation = exports.initOperation = exports.deserializeState = undefined;
  var logger_js_1 = require_logger2();
  var constants_js_1 = require_constants9();
  function deserializeState(serializedState) {
    try {
      return JSON.parse(serializedState).state;
    } catch (e2) {
      throw new Error(`Unable to deserialize input state: ${serializedState}`);
    }
  }
  exports.deserializeState = deserializeState;
  function setStateError(inputs) {
    const { state: state2, stateProxy, isOperationError } = inputs;
    return (error) => {
      if (isOperationError(error)) {
        stateProxy.setError(state2, error);
        stateProxy.setFailed(state2);
      }
      throw error;
    };
  }
  function appendReadableErrorMessage(currentMessage, innerMessage) {
    let message = currentMessage;
    if (message.slice(-1) !== ".") {
      message = message + ".";
    }
    return message + " " + innerMessage;
  }
  function simplifyError(err) {
    let message = err.message;
    let code = err.code;
    let curErr = err;
    while (curErr.innererror) {
      curErr = curErr.innererror;
      code = curErr.code;
      message = appendReadableErrorMessage(message, curErr.message);
    }
    return {
      code,
      message
    };
  }
  function processOperationStatus(result) {
    const { state: state2, stateProxy, status, isDone, processResult, getError, response, setErrorAsResult } = result;
    switch (status) {
      case "succeeded": {
        stateProxy.setSucceeded(state2);
        break;
      }
      case "failed": {
        const err = getError === null || getError === undefined ? undefined : getError(response);
        let postfix = "";
        if (err) {
          const { code, message } = simplifyError(err);
          postfix = `. ${code}. ${message}`;
        }
        const errStr = `The long-running operation has failed${postfix}`;
        stateProxy.setError(state2, new Error(errStr));
        stateProxy.setFailed(state2);
        logger_js_1.logger.warning(errStr);
        break;
      }
      case "canceled": {
        stateProxy.setCanceled(state2);
        break;
      }
    }
    if ((isDone === null || isDone === undefined ? undefined : isDone(response, state2)) || isDone === undefined && ["succeeded", "canceled"].concat(setErrorAsResult ? [] : ["failed"]).includes(status)) {
      stateProxy.setResult(state2, buildResult({
        response,
        state: state2,
        processResult
      }));
    }
  }
  function buildResult(inputs) {
    const { processResult, response, state: state2 } = inputs;
    return processResult ? processResult(response, state2) : response;
  }
  async function initOperation(inputs) {
    const { init, stateProxy, processResult, getOperationStatus, withOperationLocation, setErrorAsResult } = inputs;
    const { operationLocation, resourceLocation, metadata, response } = await init();
    if (operationLocation)
      withOperationLocation === null || withOperationLocation === undefined || withOperationLocation(operationLocation, false);
    const config = {
      metadata,
      operationLocation,
      resourceLocation
    };
    logger_js_1.logger.verbose(`LRO: Operation description:`, config);
    const state2 = stateProxy.initState(config);
    const status = getOperationStatus({ response, state: state2, operationLocation });
    processOperationStatus({ state: state2, status, stateProxy, response, setErrorAsResult, processResult });
    return state2;
  }
  exports.initOperation = initOperation;
  async function pollOperationHelper(inputs) {
    const { poll, state: state2, stateProxy, operationLocation, getOperationStatus, getResourceLocation, isOperationError, options } = inputs;
    const response = await poll(operationLocation, options).catch(setStateError({
      state: state2,
      stateProxy,
      isOperationError
    }));
    const status = getOperationStatus(response, state2);
    logger_js_1.logger.verbose(`LRO: Status:
\tPolling from: ${state2.config.operationLocation}
\tOperation status: ${status}
\tPolling status: ${constants_js_1.terminalStates.includes(status) ? "Stopped" : "Running"}`);
    if (status === "succeeded") {
      const resourceLocation = getResourceLocation(response, state2);
      if (resourceLocation !== undefined) {
        return {
          response: await poll(resourceLocation).catch(setStateError({ state: state2, stateProxy, isOperationError })),
          status
        };
      }
    }
    return { response, status };
  }
  async function pollOperation(inputs) {
    const { poll, state: state2, stateProxy, options, getOperationStatus, getResourceLocation, getOperationLocation, isOperationError, withOperationLocation, getPollingInterval, processResult, getError, updateState, setDelay, isDone, setErrorAsResult } = inputs;
    const { operationLocation } = state2.config;
    if (operationLocation !== undefined) {
      const { response, status } = await pollOperationHelper({
        poll,
        getOperationStatus,
        state: state2,
        stateProxy,
        operationLocation,
        getResourceLocation,
        isOperationError,
        options
      });
      processOperationStatus({
        status,
        response,
        state: state2,
        stateProxy,
        isDone,
        processResult,
        getError,
        setErrorAsResult
      });
      if (!constants_js_1.terminalStates.includes(status)) {
        const intervalInMs = getPollingInterval === null || getPollingInterval === undefined ? undefined : getPollingInterval(response);
        if (intervalInMs)
          setDelay(intervalInMs);
        const location = getOperationLocation === null || getOperationLocation === undefined ? undefined : getOperationLocation(response, state2);
        if (location !== undefined) {
          const isUpdated = operationLocation !== location;
          state2.config.operationLocation = location;
          withOperationLocation === null || withOperationLocation === undefined || withOperationLocation(location, isUpdated);
        } else
          withOperationLocation === null || withOperationLocation === undefined || withOperationLocation(operationLocation, false);
      }
      updateState === null || updateState === undefined || updateState(state2, response);
    }
  }
  exports.pollOperation = pollOperation;
});

// node_modules/@azure/core-lro/dist/commonjs/http/operation.js
var require_operation2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pollHttpOperation = exports.isOperationError = exports.getResourceLocation = exports.getOperationStatus = exports.getOperationLocation = exports.initHttpOperation = exports.getStatusFromInitialResponse = exports.getErrorFromResponse = exports.parseRetryAfter = exports.inferLroMode = undefined;
  var operation_js_1 = require_operation();
  var logger_js_1 = require_logger2();
  function getOperationLocationPollingUrl(inputs) {
    const { azureAsyncOperation, operationLocation } = inputs;
    return operationLocation !== null && operationLocation !== undefined ? operationLocation : azureAsyncOperation;
  }
  function getLocationHeader(rawResponse) {
    return rawResponse.headers["location"];
  }
  function getOperationLocationHeader(rawResponse) {
    return rawResponse.headers["operation-location"];
  }
  function getAzureAsyncOperationHeader(rawResponse) {
    return rawResponse.headers["azure-asyncoperation"];
  }
  function findResourceLocation(inputs) {
    var _a3;
    const { location, requestMethod, requestPath, resourceLocationConfig } = inputs;
    switch (requestMethod) {
      case "PUT": {
        return requestPath;
      }
      case "DELETE": {
        return;
      }
      case "PATCH": {
        return (_a3 = getDefault()) !== null && _a3 !== undefined ? _a3 : requestPath;
      }
      default: {
        return getDefault();
      }
    }
    function getDefault() {
      switch (resourceLocationConfig) {
        case "azure-async-operation": {
          return;
        }
        case "original-uri": {
          return requestPath;
        }
        case "location":
        default: {
          return location;
        }
      }
    }
  }
  function inferLroMode(inputs) {
    const { rawResponse, requestMethod, requestPath, resourceLocationConfig } = inputs;
    const operationLocation = getOperationLocationHeader(rawResponse);
    const azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse);
    const pollingUrl = getOperationLocationPollingUrl({ operationLocation, azureAsyncOperation });
    const location = getLocationHeader(rawResponse);
    const normalizedRequestMethod = requestMethod === null || requestMethod === undefined ? undefined : requestMethod.toLocaleUpperCase();
    if (pollingUrl !== undefined) {
      return {
        mode: "OperationLocation",
        operationLocation: pollingUrl,
        resourceLocation: findResourceLocation({
          requestMethod: normalizedRequestMethod,
          location,
          requestPath,
          resourceLocationConfig
        })
      };
    } else if (location !== undefined) {
      return {
        mode: "ResourceLocation",
        operationLocation: location
      };
    } else if (normalizedRequestMethod === "PUT" && requestPath) {
      return {
        mode: "Body",
        operationLocation: requestPath
      };
    } else {
      return;
    }
  }
  exports.inferLroMode = inferLroMode;
  function transformStatus(inputs) {
    const { status, statusCode } = inputs;
    if (typeof status !== "string" && status !== undefined) {
      throw new Error(`Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ${status}. This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.`);
    }
    switch (status === null || status === undefined ? undefined : status.toLocaleLowerCase()) {
      case undefined:
        return toOperationStatus(statusCode);
      case "succeeded":
        return "succeeded";
      case "failed":
        return "failed";
      case "running":
      case "accepted":
      case "started":
      case "canceling":
      case "cancelling":
        return "running";
      case "canceled":
      case "cancelled":
        return "canceled";
      default: {
        logger_js_1.logger.verbose(`LRO: unrecognized operation status: ${status}`);
        return status;
      }
    }
  }
  function getStatus(rawResponse) {
    var _a3;
    const { status } = (_a3 = rawResponse.body) !== null && _a3 !== undefined ? _a3 : {};
    return transformStatus({ status, statusCode: rawResponse.statusCode });
  }
  function getProvisioningState(rawResponse) {
    var _a3, _b2;
    const { properties, provisioningState } = (_a3 = rawResponse.body) !== null && _a3 !== undefined ? _a3 : {};
    const status = (_b2 = properties === null || properties === undefined ? undefined : properties.provisioningState) !== null && _b2 !== undefined ? _b2 : provisioningState;
    return transformStatus({ status, statusCode: rawResponse.statusCode });
  }
  function toOperationStatus(statusCode) {
    if (statusCode === 202) {
      return "running";
    } else if (statusCode < 300) {
      return "succeeded";
    } else {
      return "failed";
    }
  }
  function parseRetryAfter({ rawResponse }) {
    const retryAfter = rawResponse.headers["retry-after"];
    if (retryAfter !== undefined) {
      const retryAfterInSeconds = parseInt(retryAfter);
      return isNaN(retryAfterInSeconds) ? calculatePollingIntervalFromDate(new Date(retryAfter)) : retryAfterInSeconds * 1000;
    }
    return;
  }
  exports.parseRetryAfter = parseRetryAfter;
  function getErrorFromResponse(response) {
    const error = accessBodyProperty(response, "error");
    if (!error) {
      logger_js_1.logger.warning(`The long-running operation failed but there is no error property in the response's body`);
      return;
    }
    if (!error.code || !error.message) {
      logger_js_1.logger.warning(`The long-running operation failed but the error property in the response's body doesn't contain code or message`);
      return;
    }
    return error;
  }
  exports.getErrorFromResponse = getErrorFromResponse;
  function calculatePollingIntervalFromDate(retryAfterDate) {
    const timeNow = Math.floor(new Date().getTime());
    const retryAfterTime = retryAfterDate.getTime();
    if (timeNow < retryAfterTime) {
      return retryAfterTime - timeNow;
    }
    return;
  }
  function getStatusFromInitialResponse(inputs) {
    const { response, state: state2, operationLocation } = inputs;
    function helper() {
      var _a3;
      const mode = (_a3 = state2.config.metadata) === null || _a3 === undefined ? undefined : _a3["mode"];
      switch (mode) {
        case undefined:
          return toOperationStatus(response.rawResponse.statusCode);
        case "Body":
          return getOperationStatus(response, state2);
        default:
          return "running";
      }
    }
    const status = helper();
    return status === "running" && operationLocation === undefined ? "succeeded" : status;
  }
  exports.getStatusFromInitialResponse = getStatusFromInitialResponse;
  async function initHttpOperation(inputs) {
    const { stateProxy, resourceLocationConfig, processResult, lro, setErrorAsResult } = inputs;
    return (0, operation_js_1.initOperation)({
      init: async () => {
        const response = await lro.sendInitialRequest();
        const config = inferLroMode({
          rawResponse: response.rawResponse,
          requestPath: lro.requestPath,
          requestMethod: lro.requestMethod,
          resourceLocationConfig
        });
        return Object.assign({ response, operationLocation: config === null || config === undefined ? undefined : config.operationLocation, resourceLocation: config === null || config === undefined ? undefined : config.resourceLocation }, (config === null || config === undefined ? undefined : config.mode) ? { metadata: { mode: config.mode } } : {});
      },
      stateProxy,
      processResult: processResult ? ({ flatResponse }, state2) => processResult(flatResponse, state2) : ({ flatResponse }) => flatResponse,
      getOperationStatus: getStatusFromInitialResponse,
      setErrorAsResult
    });
  }
  exports.initHttpOperation = initHttpOperation;
  function getOperationLocation({ rawResponse }, state2) {
    var _a3;
    const mode = (_a3 = state2.config.metadata) === null || _a3 === undefined ? undefined : _a3["mode"];
    switch (mode) {
      case "OperationLocation": {
        return getOperationLocationPollingUrl({
          operationLocation: getOperationLocationHeader(rawResponse),
          azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse)
        });
      }
      case "ResourceLocation": {
        return getLocationHeader(rawResponse);
      }
      case "Body":
      default: {
        return;
      }
    }
  }
  exports.getOperationLocation = getOperationLocation;
  function getOperationStatus({ rawResponse }, state2) {
    var _a3;
    const mode = (_a3 = state2.config.metadata) === null || _a3 === undefined ? undefined : _a3["mode"];
    switch (mode) {
      case "OperationLocation": {
        return getStatus(rawResponse);
      }
      case "ResourceLocation": {
        return toOperationStatus(rawResponse.statusCode);
      }
      case "Body": {
        return getProvisioningState(rawResponse);
      }
      default:
        throw new Error(`Internal error: Unexpected operation mode: ${mode}`);
    }
  }
  exports.getOperationStatus = getOperationStatus;
  function accessBodyProperty({ flatResponse, rawResponse }, prop) {
    var _a3, _b2;
    return (_a3 = flatResponse === null || flatResponse === undefined ? undefined : flatResponse[prop]) !== null && _a3 !== undefined ? _a3 : (_b2 = rawResponse.body) === null || _b2 === undefined ? undefined : _b2[prop];
  }
  function getResourceLocation(res, state2) {
    const loc = accessBodyProperty(res, "resourceLocation");
    if (loc && typeof loc === "string") {
      state2.config.resourceLocation = loc;
    }
    return state2.config.resourceLocation;
  }
  exports.getResourceLocation = getResourceLocation;
  function isOperationError(e2) {
    return e2.name === "RestError";
  }
  exports.isOperationError = isOperationError;
  async function pollHttpOperation(inputs) {
    const { lro, stateProxy, options, processResult, updateState, setDelay, state: state2, setErrorAsResult } = inputs;
    return (0, operation_js_1.pollOperation)({
      state: state2,
      stateProxy,
      setDelay,
      processResult: processResult ? ({ flatResponse }, inputState) => processResult(flatResponse, inputState) : ({ flatResponse }) => flatResponse,
      getError: getErrorFromResponse,
      updateState,
      getPollingInterval: parseRetryAfter,
      getOperationLocation,
      getOperationStatus,
      isOperationError,
      getResourceLocation,
      options,
      poll: async (location, inputOptions) => lro.sendPollRequest(location, inputOptions),
      setErrorAsResult
    });
  }
  exports.pollHttpOperation = pollHttpOperation;
});

// node_modules/@azure/core-lro/dist/commonjs/poller/poller.js
var require_poller = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildCreatePoller = undefined;
  var operation_js_1 = require_operation();
  var constants_js_1 = require_constants9();
  var core_util_1 = require_commonjs4();
  var createStateProxy = () => ({
    initState: (config) => ({ status: "running", config }),
    setCanceled: (state2) => state2.status = "canceled",
    setError: (state2, error) => state2.error = error,
    setResult: (state2, result) => state2.result = result,
    setRunning: (state2) => state2.status = "running",
    setSucceeded: (state2) => state2.status = "succeeded",
    setFailed: (state2) => state2.status = "failed",
    getError: (state2) => state2.error,
    getResult: (state2) => state2.result,
    isCanceled: (state2) => state2.status === "canceled",
    isFailed: (state2) => state2.status === "failed",
    isRunning: (state2) => state2.status === "running",
    isSucceeded: (state2) => state2.status === "succeeded"
  });
  function buildCreatePoller(inputs) {
    const { getOperationLocation, getStatusFromInitialResponse, getStatusFromPollResponse, isOperationError, getResourceLocation, getPollingInterval, getError, resolveOnUnsuccessful } = inputs;
    return async ({ init, poll }, options) => {
      const { processResult, updateState, withOperationLocation: withOperationLocationCallback, intervalInMs = constants_js_1.POLL_INTERVAL_IN_MS, restoreFrom } = options || {};
      const stateProxy = createStateProxy();
      const withOperationLocation = withOperationLocationCallback ? (() => {
        let called = false;
        return (operationLocation, isUpdated) => {
          if (isUpdated)
            withOperationLocationCallback(operationLocation);
          else if (!called)
            withOperationLocationCallback(operationLocation);
          called = true;
        };
      })() : undefined;
      const state2 = restoreFrom ? (0, operation_js_1.deserializeState)(restoreFrom) : await (0, operation_js_1.initOperation)({
        init,
        stateProxy,
        processResult,
        getOperationStatus: getStatusFromInitialResponse,
        withOperationLocation,
        setErrorAsResult: !resolveOnUnsuccessful
      });
      let resultPromise;
      const abortController = new AbortController;
      const handlers = new Map;
      const handleProgressEvents = async () => handlers.forEach((h2) => h2(state2));
      const cancelErrMsg = "Operation was canceled";
      let currentPollIntervalInMs = intervalInMs;
      const poller = {
        getOperationState: () => state2,
        getResult: () => state2.result,
        isDone: () => ["succeeded", "failed", "canceled"].includes(state2.status),
        isStopped: () => resultPromise === undefined,
        stopPolling: () => {
          abortController.abort();
        },
        toString: () => JSON.stringify({
          state: state2
        }),
        onProgress: (callback) => {
          const s2 = Symbol();
          handlers.set(s2, callback);
          return () => handlers.delete(s2);
        },
        pollUntilDone: (pollOptions) => resultPromise !== null && resultPromise !== undefined ? resultPromise : resultPromise = (async () => {
          const { abortSignal: inputAbortSignal } = pollOptions || {};
          function abortListener() {
            abortController.abort();
          }
          const abortSignal = abortController.signal;
          if (inputAbortSignal === null || inputAbortSignal === undefined ? undefined : inputAbortSignal.aborted) {
            abortController.abort();
          } else if (!abortSignal.aborted) {
            inputAbortSignal === null || inputAbortSignal === undefined || inputAbortSignal.addEventListener("abort", abortListener, { once: true });
          }
          try {
            if (!poller.isDone()) {
              await poller.poll({ abortSignal });
              while (!poller.isDone()) {
                await (0, core_util_1.delay)(currentPollIntervalInMs, { abortSignal });
                await poller.poll({ abortSignal });
              }
            }
          } finally {
            inputAbortSignal === null || inputAbortSignal === undefined || inputAbortSignal.removeEventListener("abort", abortListener);
          }
          if (resolveOnUnsuccessful) {
            return poller.getResult();
          } else {
            switch (state2.status) {
              case "succeeded":
                return poller.getResult();
              case "canceled":
                throw new Error(cancelErrMsg);
              case "failed":
                throw state2.error;
              case "notStarted":
              case "running":
                throw new Error(`Polling completed without succeeding or failing`);
            }
          }
        })().finally(() => {
          resultPromise = undefined;
        }),
        async poll(pollOptions) {
          if (resolveOnUnsuccessful) {
            if (poller.isDone())
              return;
          } else {
            switch (state2.status) {
              case "succeeded":
                return;
              case "canceled":
                throw new Error(cancelErrMsg);
              case "failed":
                throw state2.error;
            }
          }
          await (0, operation_js_1.pollOperation)({
            poll,
            state: state2,
            stateProxy,
            getOperationLocation,
            isOperationError,
            withOperationLocation,
            getPollingInterval,
            getOperationStatus: getStatusFromPollResponse,
            getResourceLocation,
            processResult,
            getError,
            updateState,
            options: pollOptions,
            setDelay: (pollIntervalInMs) => {
              currentPollIntervalInMs = pollIntervalInMs;
            },
            setErrorAsResult: !resolveOnUnsuccessful
          });
          await handleProgressEvents();
          if (!resolveOnUnsuccessful) {
            switch (state2.status) {
              case "canceled":
                throw new Error(cancelErrMsg);
              case "failed":
                throw state2.error;
            }
          }
        }
      };
      return poller;
    };
  }
  exports.buildCreatePoller = buildCreatePoller;
});

// node_modules/@azure/core-lro/dist/commonjs/http/poller.js
var require_poller2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHttpPoller = undefined;
  var operation_js_1 = require_operation2();
  var poller_js_1 = require_poller();
  async function createHttpPoller(lro, options) {
    const { resourceLocationConfig, intervalInMs, processResult, restoreFrom, updateState, withOperationLocation, resolveOnUnsuccessful = false } = options || {};
    return (0, poller_js_1.buildCreatePoller)({
      getStatusFromInitialResponse: operation_js_1.getStatusFromInitialResponse,
      getStatusFromPollResponse: operation_js_1.getOperationStatus,
      isOperationError: operation_js_1.isOperationError,
      getOperationLocation: operation_js_1.getOperationLocation,
      getResourceLocation: operation_js_1.getResourceLocation,
      getPollingInterval: operation_js_1.parseRetryAfter,
      getError: operation_js_1.getErrorFromResponse,
      resolveOnUnsuccessful
    })({
      init: async () => {
        const response = await lro.sendInitialRequest();
        const config = (0, operation_js_1.inferLroMode)({
          rawResponse: response.rawResponse,
          requestPath: lro.requestPath,
          requestMethod: lro.requestMethod,
          resourceLocationConfig
        });
        return Object.assign({ response, operationLocation: config === null || config === undefined ? undefined : config.operationLocation, resourceLocation: config === null || config === undefined ? undefined : config.resourceLocation }, (config === null || config === undefined ? undefined : config.mode) ? { metadata: { mode: config.mode } } : {});
      },
      poll: lro.sendPollRequest
    }, {
      intervalInMs,
      withOperationLocation,
      restoreFrom,
      updateState,
      processResult: processResult ? ({ flatResponse }, state2) => processResult(flatResponse, state2) : ({ flatResponse }) => flatResponse
    });
  }
  exports.createHttpPoller = createHttpPoller;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/operation.js
var require_operation3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GenericPollOperation = undefined;
  var operation_js_1 = require_operation2();
  var logger_js_1 = require_logger2();
  var createStateProxy = () => ({
    initState: (config) => ({ config, isStarted: true }),
    setCanceled: (state2) => state2.isCancelled = true,
    setError: (state2, error) => state2.error = error,
    setResult: (state2, result) => state2.result = result,
    setRunning: (state2) => state2.isStarted = true,
    setSucceeded: (state2) => state2.isCompleted = true,
    setFailed: () => {
    },
    getError: (state2) => state2.error,
    getResult: (state2) => state2.result,
    isCanceled: (state2) => !!state2.isCancelled,
    isFailed: (state2) => !!state2.error,
    isRunning: (state2) => !!state2.isStarted,
    isSucceeded: (state2) => Boolean(state2.isCompleted && !state2.isCancelled && !state2.error)
  });

  class GenericPollOperation {
    constructor(state2, lro, setErrorAsResult, lroResourceLocationConfig, processResult, updateState, isDone) {
      this.state = state2;
      this.lro = lro;
      this.setErrorAsResult = setErrorAsResult;
      this.lroResourceLocationConfig = lroResourceLocationConfig;
      this.processResult = processResult;
      this.updateState = updateState;
      this.isDone = isDone;
    }
    setPollerConfig(pollerConfig) {
      this.pollerConfig = pollerConfig;
    }
    async update(options) {
      var _a3;
      const stateProxy = createStateProxy();
      if (!this.state.isStarted) {
        this.state = Object.assign(Object.assign({}, this.state), await (0, operation_js_1.initHttpOperation)({
          lro: this.lro,
          stateProxy,
          resourceLocationConfig: this.lroResourceLocationConfig,
          processResult: this.processResult,
          setErrorAsResult: this.setErrorAsResult
        }));
      }
      const updateState = this.updateState;
      const isDone = this.isDone;
      if (!this.state.isCompleted && this.state.error === undefined) {
        await (0, operation_js_1.pollHttpOperation)({
          lro: this.lro,
          state: this.state,
          stateProxy,
          processResult: this.processResult,
          updateState: updateState ? (state2, { rawResponse }) => updateState(state2, rawResponse) : undefined,
          isDone: isDone ? ({ flatResponse }, state2) => isDone(flatResponse, state2) : undefined,
          options,
          setDelay: (intervalInMs) => {
            this.pollerConfig.intervalInMs = intervalInMs;
          },
          setErrorAsResult: this.setErrorAsResult
        });
      }
      (_a3 = options === null || options === undefined ? undefined : options.fireProgress) === null || _a3 === undefined || _a3.call(options, this.state);
      return this;
    }
    async cancel() {
      logger_js_1.logger.error("`cancelOperation` is deprecated because it wasn't implemented");
      return this;
    }
    toString() {
      return JSON.stringify({
        state: this.state
      });
    }
  }
  exports.GenericPollOperation = GenericPollOperation;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/poller.js
var require_poller3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Poller = exports.PollerCancelledError = exports.PollerStoppedError = undefined;

  class PollerStoppedError extends Error {
    constructor(message) {
      super(message);
      this.name = "PollerStoppedError";
      Object.setPrototypeOf(this, PollerStoppedError.prototype);
    }
  }
  exports.PollerStoppedError = PollerStoppedError;

  class PollerCancelledError extends Error {
    constructor(message) {
      super(message);
      this.name = "PollerCancelledError";
      Object.setPrototypeOf(this, PollerCancelledError.prototype);
    }
  }
  exports.PollerCancelledError = PollerCancelledError;

  class Poller {
    constructor(operation) {
      this.resolveOnUnsuccessful = false;
      this.stopped = true;
      this.pollProgressCallbacks = [];
      this.operation = operation;
      this.promise = new Promise((resolve5, reject) => {
        this.resolve = resolve5;
        this.reject = reject;
      });
      this.promise.catch(() => {
      });
    }
    async startPolling(pollOptions = {}) {
      if (this.stopped) {
        this.stopped = false;
      }
      while (!this.isStopped() && !this.isDone()) {
        await this.poll(pollOptions);
        await this.delay();
      }
    }
    async pollOnce(options = {}) {
      if (!this.isDone()) {
        this.operation = await this.operation.update({
          abortSignal: options.abortSignal,
          fireProgress: this.fireProgress.bind(this)
        });
      }
      this.processUpdatedState();
    }
    fireProgress(state2) {
      for (const callback of this.pollProgressCallbacks) {
        callback(state2);
      }
    }
    async cancelOnce(options = {}) {
      this.operation = await this.operation.cancel(options);
    }
    poll(options = {}) {
      if (!this.pollOncePromise) {
        this.pollOncePromise = this.pollOnce(options);
        const clearPollOncePromise = () => {
          this.pollOncePromise = undefined;
        };
        this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise).catch(this.reject);
      }
      return this.pollOncePromise;
    }
    processUpdatedState() {
      if (this.operation.state.error) {
        this.stopped = true;
        if (!this.resolveOnUnsuccessful) {
          this.reject(this.operation.state.error);
          throw this.operation.state.error;
        }
      }
      if (this.operation.state.isCancelled) {
        this.stopped = true;
        if (!this.resolveOnUnsuccessful) {
          const error = new PollerCancelledError("Operation was canceled");
          this.reject(error);
          throw error;
        }
      }
      if (this.isDone() && this.resolve) {
        this.resolve(this.getResult());
      }
    }
    async pollUntilDone(pollOptions = {}) {
      if (this.stopped) {
        this.startPolling(pollOptions).catch(this.reject);
      }
      this.processUpdatedState();
      return this.promise;
    }
    onProgress(callback) {
      this.pollProgressCallbacks.push(callback);
      return () => {
        this.pollProgressCallbacks = this.pollProgressCallbacks.filter((c2) => c2 !== callback);
      };
    }
    isDone() {
      const state2 = this.operation.state;
      return Boolean(state2.isCompleted || state2.isCancelled || state2.error);
    }
    stopPolling() {
      if (!this.stopped) {
        this.stopped = true;
        if (this.reject) {
          this.reject(new PollerStoppedError("This poller is already stopped"));
        }
      }
    }
    isStopped() {
      return this.stopped;
    }
    cancelOperation(options = {}) {
      if (!this.cancelPromise) {
        this.cancelPromise = this.cancelOnce(options);
      } else if (options.abortSignal) {
        throw new Error("A cancel request is currently pending");
      }
      return this.cancelPromise;
    }
    getOperationState() {
      return this.operation.state;
    }
    getResult() {
      const state2 = this.operation.state;
      return state2.result;
    }
    toString() {
      return this.operation.toString();
    }
  }
  exports.Poller = Poller;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/lroEngine.js
var require_lroEngine = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LroEngine = undefined;
  var operation_js_1 = require_operation3();
  var constants_js_1 = require_constants9();
  var poller_js_1 = require_poller3();
  var operation_js_2 = require_operation();

  class LroEngine extends poller_js_1.Poller {
    constructor(lro, options) {
      const { intervalInMs = constants_js_1.POLL_INTERVAL_IN_MS, resumeFrom, resolveOnUnsuccessful = false, isDone, lroResourceLocationConfig, processResult, updateState } = options || {};
      const state2 = resumeFrom ? (0, operation_js_2.deserializeState)(resumeFrom) : {};
      const operation = new operation_js_1.GenericPollOperation(state2, lro, !resolveOnUnsuccessful, lroResourceLocationConfig, processResult, updateState, isDone);
      super(operation);
      this.resolveOnUnsuccessful = resolveOnUnsuccessful;
      this.config = { intervalInMs };
      operation.setPollerConfig(this.config);
    }
    delay() {
      return new Promise((resolve5) => setTimeout(() => resolve5(), this.config.intervalInMs));
    }
  }
  exports.LroEngine = LroEngine;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/index.js
var require_lroEngine2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.LroEngine = undefined;
  var lroEngine_js_1 = require_lroEngine();
  Object.defineProperty(exports, "LroEngine", { enumerable: true, get: function() {
    return lroEngine_js_1.LroEngine;
  } });
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/pollOperation.js
var require_pollOperation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@azure/core-lro/dist/commonjs/index.js
var require_commonjs12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createHttpPoller = undefined;
  var tslib_1 = require_tslib();
  var poller_js_1 = require_poller2();
  Object.defineProperty(exports, "createHttpPoller", { enumerable: true, get: function() {
    return poller_js_1.createHttpPoller;
  } });
  tslib_1.__exportStar(require_lroEngine2(), exports);
  tslib_1.__exportStar(require_poller3(), exports);
  tslib_1.__exportStar(require_pollOperation(), exports);
});

// node_modules/@azure/storage-blob/dist/index.js
var require_dist7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var coreRestPipeline = require_commonjs6();
  var tslib2 = require_tslib();
  var coreAuth = require_commonjs7();
  var coreUtil = require_commonjs4();
  var coreHttpCompat = require_commonjs9();
  var coreClient = require_commonjs8();
  var coreXml = require_commonjs10();
  var logger$1 = require_commonjs2();
  var abortController = require_commonjs11();
  var crypto = __require("crypto");
  var coreTracing = require_commonjs5();
  var stream = __require("stream");
  var coreLro = require_commonjs12();
  var events = __require("events");
  var fs2 = __require("fs");
  var util2 = __require("util");
  var buffer = __require("buffer");
  function _interopNamespaceDefault(e2) {
    var n2 = Object.create(null);
    if (e2) {
      Object.keys(e2).forEach(function(k2) {
        if (k2 !== "default") {
          var d2 = Object.getOwnPropertyDescriptor(e2, k2);
          Object.defineProperty(n2, k2, d2.get ? d2 : {
            enumerable: true,
            get: function() {
              return e2[k2];
            }
          });
        }
      });
    }
    n2.default = e2;
    return Object.freeze(n2);
  }
  var coreHttpCompat__namespace = /* @__PURE__ */ _interopNamespaceDefault(coreHttpCompat);
  var coreClient__namespace = /* @__PURE__ */ _interopNamespaceDefault(coreClient);
  var fs__namespace = /* @__PURE__ */ _interopNamespaceDefault(fs2);
  var util__namespace = /* @__PURE__ */ _interopNamespaceDefault(util2);
  var logger4 = logger$1.createClientLogger("storage-blob");

  class BaseRequestPolicy {
    constructor(_nextPolicy, _options) {
      this._nextPolicy = _nextPolicy;
      this._options = _options;
    }
    shouldLog(logLevel) {
      return this._options.shouldLog(logLevel);
    }
    log(logLevel, message) {
      this._options.log(logLevel, message);
    }
  }
  var SDK_VERSION4 = "12.27.0";
  var SERVICE_VERSION = "2025-05-05";
  var BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = 256 * 1024 * 1024;
  var BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = 4000 * 1024 * 1024;
  var BLOCK_BLOB_MAX_BLOCKS = 50000;
  var DEFAULT_BLOCK_BUFFER_SIZE_BYTES = 8 * 1024 * 1024;
  var DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = 4 * 1024 * 1024;
  var DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = 5;
  var REQUEST_TIMEOUT = 100 * 1000;
  var StorageOAuthScopes = "https://storage.azure.com/.default";
  var URLConstants = {
    Parameters: {
      FORCE_BROWSER_NO_CACHE: "_",
      SNAPSHOT: "snapshot",
      VERSIONID: "versionid",
      TIMEOUT: "timeout"
    }
  };
  var HTTPURLConnection = {
    HTTP_ACCEPTED: 202
  };
  var HeaderConstants = {
    AUTHORIZATION: "Authorization",
    CONTENT_ENCODING: "Content-Encoding",
    CONTENT_ID: "Content-ID",
    CONTENT_LANGUAGE: "Content-Language",
    CONTENT_LENGTH: "Content-Length",
    CONTENT_MD5: "Content-Md5",
    CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
    CONTENT_TYPE: "Content-Type",
    COOKIE: "Cookie",
    DATE: "date",
    IF_MATCH: "if-match",
    IF_MODIFIED_SINCE: "if-modified-since",
    IF_NONE_MATCH: "if-none-match",
    IF_UNMODIFIED_SINCE: "if-unmodified-since",
    PREFIX_FOR_STORAGE: "x-ms-",
    RANGE: "Range",
    X_MS_DATE: "x-ms-date",
    X_MS_ERROR_CODE: "x-ms-error-code",
    X_MS_VERSION: "x-ms-version"
  };
  var ETagNone = "";
  var ETagAny = "*";
  var SIZE_1_MB = 1 * 1024 * 1024;
  var BATCH_MAX_REQUEST = 256;
  var BATCH_MAX_PAYLOAD_IN_BYTES = 4 * SIZE_1_MB;
  var HTTP_LINE_ENDING = `\r
`;
  var HTTP_VERSION_1_1 = "HTTP/1.1";
  var EncryptionAlgorithmAES25 = "AES256";
  var DevelopmentConnectionString = `DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;`;
  var StorageBlobLoggingAllowedHeaderNames = [
    "Access-Control-Allow-Origin",
    "Cache-Control",
    "Content-Length",
    "Content-Type",
    "Date",
    "Request-Id",
    "traceparent",
    "Transfer-Encoding",
    "User-Agent",
    "x-ms-client-request-id",
    "x-ms-date",
    "x-ms-error-code",
    "x-ms-request-id",
    "x-ms-return-client-request-id",
    "x-ms-version",
    "Accept-Ranges",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-MD5",
    "Content-Range",
    "ETag",
    "Last-Modified",
    "Server",
    "Vary",
    "x-ms-content-crc64",
    "x-ms-copy-action",
    "x-ms-copy-completion-time",
    "x-ms-copy-id",
    "x-ms-copy-progress",
    "x-ms-copy-status",
    "x-ms-has-immutability-policy",
    "x-ms-has-legal-hold",
    "x-ms-lease-state",
    "x-ms-lease-status",
    "x-ms-range",
    "x-ms-request-server-encrypted",
    "x-ms-server-encrypted",
    "x-ms-snapshot",
    "x-ms-source-range",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "x-ms-access-tier",
    "x-ms-access-tier-change-time",
    "x-ms-access-tier-inferred",
    "x-ms-account-kind",
    "x-ms-archive-status",
    "x-ms-blob-append-offset",
    "x-ms-blob-cache-control",
    "x-ms-blob-committed-block-count",
    "x-ms-blob-condition-appendpos",
    "x-ms-blob-condition-maxsize",
    "x-ms-blob-content-disposition",
    "x-ms-blob-content-encoding",
    "x-ms-blob-content-language",
    "x-ms-blob-content-length",
    "x-ms-blob-content-md5",
    "x-ms-blob-content-type",
    "x-ms-blob-public-access",
    "x-ms-blob-sequence-number",
    "x-ms-blob-type",
    "x-ms-copy-destination-snapshot",
    "x-ms-creation-time",
    "x-ms-default-encryption-scope",
    "x-ms-delete-snapshots",
    "x-ms-delete-type-permanent",
    "x-ms-deny-encryption-scope-override",
    "x-ms-encryption-algorithm",
    "x-ms-if-sequence-number-eq",
    "x-ms-if-sequence-number-le",
    "x-ms-if-sequence-number-lt",
    "x-ms-incremental-copy",
    "x-ms-lease-action",
    "x-ms-lease-break-period",
    "x-ms-lease-duration",
    "x-ms-lease-id",
    "x-ms-lease-time",
    "x-ms-page-write",
    "x-ms-proposed-lease-id",
    "x-ms-range-get-content-md5",
    "x-ms-rehydrate-priority",
    "x-ms-sequence-number-action",
    "x-ms-sku-name",
    "x-ms-source-content-md5",
    "x-ms-source-if-match",
    "x-ms-source-if-modified-since",
    "x-ms-source-if-none-match",
    "x-ms-source-if-unmodified-since",
    "x-ms-tag-count",
    "x-ms-encryption-key-sha256",
    "x-ms-copy-source-error-code",
    "x-ms-copy-source-status-code",
    "x-ms-if-tags",
    "x-ms-source-if-tags"
  ];
  var StorageBlobLoggingAllowedQueryParameters = [
    "comp",
    "maxresults",
    "rscc",
    "rscd",
    "rsce",
    "rscl",
    "rsct",
    "se",
    "si",
    "sip",
    "sp",
    "spr",
    "sr",
    "srt",
    "ss",
    "st",
    "sv",
    "include",
    "marker",
    "prefix",
    "copyid",
    "restype",
    "blockid",
    "blocklisttype",
    "delimiter",
    "prevsnapshot",
    "ske",
    "skoid",
    "sks",
    "skt",
    "sktid",
    "skv",
    "snapshot"
  ];
  var BlobUsesCustomerSpecifiedEncryptionMsg = "BlobUsesCustomerSpecifiedEncryption";
  var BlobDoesNotUseCustomerSpecifiedEncryption = "BlobDoesNotUseCustomerSpecifiedEncryption";
  var PathStylePorts = [
    "10000",
    "10001",
    "10002",
    "10003",
    "10004",
    "10100",
    "10101",
    "10102",
    "10103",
    "10104",
    "11000",
    "11001",
    "11002",
    "11003",
    "11004",
    "11100",
    "11101",
    "11102",
    "11103",
    "11104"
  ];
  function escapeURLPath(url2) {
    const urlParsed = new URL(url2);
    let path2 = urlParsed.pathname;
    path2 = path2 || "/";
    path2 = escape2(path2);
    urlParsed.pathname = path2;
    return urlParsed.toString();
  }
  function getProxyUriFromDevConnString(connectionString) {
    let proxyUri = "";
    if (connectionString.search("DevelopmentStorageProxyUri=") !== -1) {
      const matchCredentials = connectionString.split(";");
      for (const element of matchCredentials) {
        if (element.trim().startsWith("DevelopmentStorageProxyUri=")) {
          proxyUri = element.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
        }
      }
    }
    return proxyUri;
  }
  function getValueInConnString(connectionString, argument) {
    const elements = connectionString.split(";");
    for (const element of elements) {
      if (element.trim().startsWith(argument)) {
        return element.trim().match(argument + "=(.*)")[1];
      }
    }
    return "";
  }
  function extractConnectionStringParts(connectionString) {
    let proxyUri = "";
    if (connectionString.startsWith("UseDevelopmentStorage=true")) {
      proxyUri = getProxyUriFromDevConnString(connectionString);
      connectionString = DevelopmentConnectionString;
    }
    let blobEndpoint = getValueInConnString(connectionString, "BlobEndpoint");
    blobEndpoint = blobEndpoint.endsWith("/") ? blobEndpoint.slice(0, -1) : blobEndpoint;
    if (connectionString.search("DefaultEndpointsProtocol=") !== -1 && connectionString.search("AccountKey=") !== -1) {
      let defaultEndpointsProtocol = "";
      let accountName = "";
      let accountKey = Buffer.from("accountKey", "base64");
      let endpointSuffix = "";
      accountName = getValueInConnString(connectionString, "AccountName");
      accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64");
      if (!blobEndpoint) {
        defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
        const protocol = defaultEndpointsProtocol.toLowerCase();
        if (protocol !== "https" && protocol !== "http") {
          throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
        }
        endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix");
        if (!endpointSuffix) {
          throw new Error("Invalid EndpointSuffix in the provided Connection String");
        }
        blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
      }
      if (!accountName) {
        throw new Error("Invalid AccountName in the provided Connection String");
      } else if (accountKey.length === 0) {
        throw new Error("Invalid AccountKey in the provided Connection String");
      }
      return {
        kind: "AccountConnString",
        url: blobEndpoint,
        accountName,
        accountKey,
        proxyUri
      };
    } else {
      let accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
      let accountName = getValueInConnString(connectionString, "AccountName");
      if (!accountName) {
        accountName = getAccountNameFromUrl(blobEndpoint);
      }
      if (!blobEndpoint) {
        throw new Error("Invalid BlobEndpoint in the provided SAS Connection String");
      } else if (!accountSas) {
        throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
      }
      if (accountSas.startsWith("?")) {
        accountSas = accountSas.substring(1);
      }
      return { kind: "SASConnString", url: blobEndpoint, accountName, accountSas };
    }
  }
  function escape2(text) {
    return encodeURIComponent(text).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
  }
  function appendToURLPath(url2, name) {
    const urlParsed = new URL(url2);
    let path2 = urlParsed.pathname;
    path2 = path2 ? path2.endsWith("/") ? `${path2}${name}` : `${path2}/${name}` : name;
    urlParsed.pathname = path2;
    return urlParsed.toString();
  }
  function setURLParameter(url2, name, value) {
    const urlParsed = new URL(url2);
    const encodedName = encodeURIComponent(name);
    const encodedValue = value ? encodeURIComponent(value) : undefined;
    const searchString = urlParsed.search === "" ? "?" : urlParsed.search;
    const searchPieces = [];
    for (const pair of searchString.slice(1).split("&")) {
      if (pair) {
        const [key] = pair.split("=", 2);
        if (key !== encodedName) {
          searchPieces.push(pair);
        }
      }
    }
    if (encodedValue) {
      searchPieces.push(`${encodedName}=${encodedValue}`);
    }
    urlParsed.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
    return urlParsed.toString();
  }
  function getURLParameter(url2, name) {
    var _a3;
    const urlParsed = new URL(url2);
    return (_a3 = urlParsed.searchParams.get(name)) !== null && _a3 !== undefined ? _a3 : undefined;
  }
  function setURLHost(url2, host) {
    const urlParsed = new URL(url2);
    urlParsed.hostname = host;
    return urlParsed.toString();
  }
  function getURLPath(url2) {
    try {
      const urlParsed = new URL(url2);
      return urlParsed.pathname;
    } catch (e2) {
      return;
    }
  }
  function getURLScheme(url2) {
    try {
      const urlParsed = new URL(url2);
      return urlParsed.protocol.endsWith(":") ? urlParsed.protocol.slice(0, -1) : urlParsed.protocol;
    } catch (e2) {
      return;
    }
  }
  function getURLPathAndQuery(url2) {
    const urlParsed = new URL(url2);
    const pathString = urlParsed.pathname;
    if (!pathString) {
      throw new RangeError("Invalid url without valid path.");
    }
    let queryString = urlParsed.search || "";
    queryString = queryString.trim();
    if (queryString !== "") {
      queryString = queryString.startsWith("?") ? queryString : `?${queryString}`;
    }
    return `${pathString}${queryString}`;
  }
  function getURLQueries(url2) {
    let queryString = new URL(url2).search;
    if (!queryString) {
      return {};
    }
    queryString = queryString.trim();
    queryString = queryString.startsWith("?") ? queryString.substring(1) : queryString;
    let querySubStrings = queryString.split("&");
    querySubStrings = querySubStrings.filter((value) => {
      const indexOfEqual = value.indexOf("=");
      const lastIndexOfEqual = value.lastIndexOf("=");
      return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;
    });
    const queries = {};
    for (const querySubString of querySubStrings) {
      const splitResults = querySubString.split("=");
      const key = splitResults[0];
      const value = splitResults[1];
      queries[key] = value;
    }
    return queries;
  }
  function appendToURLQuery(url2, queryParts) {
    const urlParsed = new URL(url2);
    let query = urlParsed.search;
    if (query) {
      query += "&" + queryParts;
    } else {
      query = queryParts;
    }
    urlParsed.search = query;
    return urlParsed.toString();
  }
  function truncatedISO8061Date(date, withMilliseconds = true) {
    const dateString = date.toISOString();
    return withMilliseconds ? dateString.substring(0, dateString.length - 1) + "0000" + "Z" : dateString.substring(0, dateString.length - 5) + "Z";
  }
  function base64encode2(content) {
    return !coreUtil.isNode ? btoa(content) : Buffer.from(content).toString("base64");
  }
  function generateBlockID(blockIDPrefix, blockIndex) {
    const maxSourceStringLength = 48;
    const maxBlockIndexLength = 6;
    const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;
    if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {
      blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);
    }
    const res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, "0");
    return base64encode2(res);
  }
  async function delay3(timeInMs, aborter, abortError) {
    return new Promise((resolve5, reject) => {
      let timeout;
      const abortHandler = () => {
        if (timeout !== undefined) {
          clearTimeout(timeout);
        }
        reject(abortError);
      };
      const resolveHandler = () => {
        if (aborter !== undefined) {
          aborter.removeEventListener("abort", abortHandler);
        }
        resolve5();
      };
      timeout = setTimeout(resolveHandler, timeInMs);
      if (aborter !== undefined) {
        aborter.addEventListener("abort", abortHandler);
      }
    });
  }
  function padStart(currentString, targetLength, padString = " ") {
    if (String.prototype.padStart) {
      return currentString.padStart(targetLength, padString);
    }
    padString = padString || " ";
    if (currentString.length > targetLength) {
      return currentString;
    } else {
      targetLength = targetLength - currentString.length;
      if (targetLength > padString.length) {
        padString += padString.repeat(targetLength / padString.length);
      }
      return padString.slice(0, targetLength) + currentString;
    }
  }
  function iEqual(str1, str2) {
    return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
  }
  function getAccountNameFromUrl(url2) {
    const parsedUrl = new URL(url2);
    let accountName;
    try {
      if (parsedUrl.hostname.split(".")[1] === "blob") {
        accountName = parsedUrl.hostname.split(".")[0];
      } else if (isIpEndpointStyle(parsedUrl)) {
        accountName = parsedUrl.pathname.split("/")[1];
      } else {
        accountName = "";
      }
      return accountName;
    } catch (error) {
      throw new Error("Unable to extract accountName with provided information.");
    }
  }
  function isIpEndpointStyle(parsedUrl) {
    const host = parsedUrl.host;
    return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || Boolean(parsedUrl.port) && PathStylePorts.includes(parsedUrl.port);
  }
  function toBlobTagsString(tags2) {
    if (tags2 === undefined) {
      return;
    }
    const tagPairs = [];
    for (const key in tags2) {
      if (Object.prototype.hasOwnProperty.call(tags2, key)) {
        const value = tags2[key];
        tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
      }
    }
    return tagPairs.join("&");
  }
  function toBlobTags(tags2) {
    if (tags2 === undefined) {
      return;
    }
    const res = {
      blobTagSet: []
    };
    for (const key in tags2) {
      if (Object.prototype.hasOwnProperty.call(tags2, key)) {
        const value = tags2[key];
        res.blobTagSet.push({
          key,
          value
        });
      }
    }
    return res;
  }
  function toTags(tags2) {
    if (tags2 === undefined) {
      return;
    }
    const res = {};
    for (const blobTag of tags2.blobTagSet) {
      res[blobTag.key] = blobTag.value;
    }
    return res;
  }
  function toQuerySerialization(textConfiguration) {
    if (textConfiguration === undefined) {
      return;
    }
    switch (textConfiguration.kind) {
      case "csv":
        return {
          format: {
            type: "delimited",
            delimitedTextConfiguration: {
              columnSeparator: textConfiguration.columnSeparator || ",",
              fieldQuote: textConfiguration.fieldQuote || "",
              recordSeparator: textConfiguration.recordSeparator,
              escapeChar: textConfiguration.escapeCharacter || "",
              headersPresent: textConfiguration.hasHeaders || false
            }
          }
        };
      case "json":
        return {
          format: {
            type: "json",
            jsonTextConfiguration: {
              recordSeparator: textConfiguration.recordSeparator
            }
          }
        };
      case "arrow":
        return {
          format: {
            type: "arrow",
            arrowConfiguration: {
              schema: textConfiguration.schema
            }
          }
        };
      case "parquet":
        return {
          format: {
            type: "parquet"
          }
        };
      default:
        throw Error("Invalid BlobQueryTextConfiguration.");
    }
  }
  function parseObjectReplicationRecord(objectReplicationRecord) {
    if (!objectReplicationRecord) {
      return;
    }
    if ("policy-id" in objectReplicationRecord) {
      return;
    }
    const orProperties = [];
    for (const key in objectReplicationRecord) {
      const ids = key.split("_");
      const policyPrefix = "or-";
      if (ids[0].startsWith(policyPrefix)) {
        ids[0] = ids[0].substring(policyPrefix.length);
      }
      const rule = {
        ruleId: ids[1],
        replicationStatus: objectReplicationRecord[key]
      };
      const policyIndex = orProperties.findIndex((policy) => policy.policyId === ids[0]);
      if (policyIndex > -1) {
        orProperties[policyIndex].rules.push(rule);
      } else {
        orProperties.push({
          policyId: ids[0],
          rules: [rule]
        });
      }
    }
    return orProperties;
  }
  function httpAuthorizationToString(httpAuthorization) {
    return httpAuthorization ? httpAuthorization.scheme + " " + httpAuthorization.value : undefined;
  }
  function BlobNameToString(name) {
    if (name.encoded) {
      return decodeURIComponent(name.content);
    } else {
      return name.content;
    }
  }
  function ConvertInternalResponseOfListBlobFlat(internalResponse) {
    return Object.assign(Object.assign({}, internalResponse), { segment: {
      blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {
        const blobItem = Object.assign(Object.assign({}, blobItemInteral), { name: BlobNameToString(blobItemInteral.name) });
        return blobItem;
      })
    } });
  }
  function ConvertInternalResponseOfListBlobHierarchy(internalResponse) {
    var _a3;
    return Object.assign(Object.assign({}, internalResponse), { segment: {
      blobPrefixes: (_a3 = internalResponse.segment.blobPrefixes) === null || _a3 === undefined ? undefined : _a3.map((blobPrefixInternal) => {
        const blobPrefix = Object.assign(Object.assign({}, blobPrefixInternal), { name: BlobNameToString(blobPrefixInternal.name) });
        return blobPrefix;
      }),
      blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {
        const blobItem = Object.assign(Object.assign({}, blobItemInteral), { name: BlobNameToString(blobItemInteral.name) });
        return blobItem;
      })
    } });
  }
  function* ExtractPageRangeInfoItems(getPageRangesSegment) {
    let pageRange = [];
    let clearRange = [];
    if (getPageRangesSegment.pageRange)
      pageRange = getPageRangesSegment.pageRange;
    if (getPageRangesSegment.clearRange)
      clearRange = getPageRangesSegment.clearRange;
    let pageRangeIndex = 0;
    let clearRangeIndex = 0;
    while (pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length) {
      if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start) {
        yield {
          start: pageRange[pageRangeIndex].start,
          end: pageRange[pageRangeIndex].end,
          isClear: false
        };
        ++pageRangeIndex;
      } else {
        yield {
          start: clearRange[clearRangeIndex].start,
          end: clearRange[clearRangeIndex].end,
          isClear: true
        };
        ++clearRangeIndex;
      }
    }
    for (;pageRangeIndex < pageRange.length; ++pageRangeIndex) {
      yield {
        start: pageRange[pageRangeIndex].start,
        end: pageRange[pageRangeIndex].end,
        isClear: false
      };
    }
    for (;clearRangeIndex < clearRange.length; ++clearRangeIndex) {
      yield {
        start: clearRange[clearRangeIndex].start,
        end: clearRange[clearRangeIndex].end,
        isClear: true
      };
    }
  }
  function EscapePath(blobName) {
    const split = blobName.split("/");
    for (let i2 = 0;i2 < split.length; i2++) {
      split[i2] = encodeURIComponent(split[i2]);
    }
    return split.join("/");
  }
  function assertResponse(response) {
    if (`_response` in response) {
      return response;
    }
    throw new TypeError(`Unexpected response object ${response}`);
  }
  exports.StorageRetryPolicyType = undefined;
  (function(StorageRetryPolicyType2) {
    StorageRetryPolicyType2[StorageRetryPolicyType2["EXPONENTIAL"] = 0] = "EXPONENTIAL";
    StorageRetryPolicyType2[StorageRetryPolicyType2["FIXED"] = 1] = "FIXED";
  })(exports.StorageRetryPolicyType || (exports.StorageRetryPolicyType = {}));
  var DEFAULT_RETRY_OPTIONS$1 = {
    maxRetryDelayInMs: 120 * 1000,
    maxTries: 4,
    retryDelayInMs: 4 * 1000,
    retryPolicyType: exports.StorageRetryPolicyType.EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: undefined
  };
  var RETRY_ABORT_ERROR$1 = new abortController.AbortError("The operation was aborted.");

  class StorageRetryPolicy extends BaseRequestPolicy {
    constructor(nextPolicy, options, retryOptions = DEFAULT_RETRY_OPTIONS$1) {
      super(nextPolicy, options);
      this.retryOptions = {
        retryPolicyType: retryOptions.retryPolicyType ? retryOptions.retryPolicyType : DEFAULT_RETRY_OPTIONS$1.retryPolicyType,
        maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1 ? Math.floor(retryOptions.maxTries) : DEFAULT_RETRY_OPTIONS$1.maxTries,
        tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0 ? retryOptions.tryTimeoutInMs : DEFAULT_RETRY_OPTIONS$1.tryTimeoutInMs,
        retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0 ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS$1.maxRetryDelayInMs) : DEFAULT_RETRY_OPTIONS$1.retryDelayInMs,
        maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0 ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS$1.maxRetryDelayInMs,
        secondaryHost: retryOptions.secondaryHost ? retryOptions.secondaryHost : DEFAULT_RETRY_OPTIONS$1.secondaryHost
      };
    }
    async sendRequest(request9) {
      return this.attemptSendRequest(request9, false, 1);
    }
    async attemptSendRequest(request9, secondaryHas404, attempt) {
      const newRequest = request9.clone();
      const isPrimaryRetry = secondaryHas404 || !this.retryOptions.secondaryHost || !(request9.method === "GET" || request9.method === "HEAD" || request9.method === "OPTIONS") || attempt % 2 === 1;
      if (!isPrimaryRetry) {
        newRequest.url = setURLHost(newRequest.url, this.retryOptions.secondaryHost);
      }
      if (this.retryOptions.tryTimeoutInMs) {
        newRequest.url = setURLParameter(newRequest.url, URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1000).toString());
      }
      let response;
      try {
        logger4.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
        response = await this._nextPolicy.sendRequest(newRequest);
        if (!this.shouldRetry(isPrimaryRetry, attempt, response)) {
          return response;
        }
        secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
      } catch (err) {
        logger4.error(`RetryPolicy: Caught error, message: ${err.message}, code: ${err.code}`);
        if (!this.shouldRetry(isPrimaryRetry, attempt, response, err)) {
          throw err;
        }
      }
      await this.delay(isPrimaryRetry, attempt, request9.abortSignal);
      return this.attemptSendRequest(request9, secondaryHas404, ++attempt);
    }
    shouldRetry(isPrimaryRetry, attempt, response, err) {
      if (attempt >= this.retryOptions.maxTries) {
        logger4.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${this.retryOptions.maxTries}, no further try.`);
        return false;
      }
      const retriableErrors2 = [
        "ETIMEDOUT",
        "ESOCKETTIMEDOUT",
        "ECONNREFUSED",
        "ECONNRESET",
        "ENOENT",
        "ENOTFOUND",
        "TIMEOUT",
        "EPIPE",
        "REQUEST_SEND_ERROR"
      ];
      if (err) {
        for (const retriableError of retriableErrors2) {
          if (err.name.toUpperCase().includes(retriableError) || err.message.toUpperCase().includes(retriableError) || err.code && err.code.toString().toUpperCase() === retriableError) {
            logger4.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
            return true;
          }
        }
      }
      if (response || err) {
        const statusCode = response ? response.status : err ? err.statusCode : 0;
        if (!isPrimaryRetry && statusCode === 404) {
          logger4.info(`RetryPolicy: Secondary access with 404, will retry.`);
          return true;
        }
        if (statusCode === 503 || statusCode === 500) {
          logger4.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
          return true;
        }
      }
      if ((err === null || err === undefined ? undefined : err.code) === "PARSE_ERROR" && (err === null || err === undefined ? undefined : err.message.startsWith(`Error "Error: Unclosed root tag`))) {
        logger4.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
        return true;
      }
      return false;
    }
    async delay(isPrimaryRetry, attempt, abortSignal) {
      let delayTimeInMs = 0;
      if (isPrimaryRetry) {
        switch (this.retryOptions.retryPolicyType) {
          case exports.StorageRetryPolicyType.EXPONENTIAL:
            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
            break;
          case exports.StorageRetryPolicyType.FIXED:
            delayTimeInMs = this.retryOptions.retryDelayInMs;
            break;
        }
      } else {
        delayTimeInMs = Math.random() * 1000;
      }
      logger4.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
      return delay3(delayTimeInMs, abortSignal, RETRY_ABORT_ERROR$1);
    }
  }

  class StorageRetryPolicyFactory {
    constructor(retryOptions) {
      this.retryOptions = retryOptions;
    }
    create(nextPolicy, options) {
      return new StorageRetryPolicy(nextPolicy, options, this.retryOptions);
    }
  }

  class CredentialPolicy extends BaseRequestPolicy {
    sendRequest(request9) {
      return this._nextPolicy.sendRequest(this.signRequest(request9));
    }
    signRequest(request9) {
      return request9;
    }
  }
  var table_lv0 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1820,
    0,
    1823,
    1825,
    1827,
    1829,
    0,
    0,
    0,
    1837,
    2051,
    0,
    0,
    1843,
    0,
    3331,
    3354,
    3356,
    3358,
    3360,
    3362,
    3364,
    3366,
    3368,
    3370,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3586,
    3593,
    3594,
    3610,
    3617,
    3619,
    3621,
    3628,
    3634,
    3637,
    3638,
    3656,
    3665,
    3696,
    3708,
    3710,
    3721,
    3722,
    3729,
    3737,
    3743,
    3746,
    3748,
    3750,
    3751,
    3753,
    0,
    0,
    0,
    1859,
    1860,
    1864,
    3586,
    3593,
    3594,
    3610,
    3617,
    3619,
    3621,
    3628,
    3634,
    3637,
    3638,
    3656,
    3665,
    3696,
    3708,
    3710,
    3721,
    3722,
    3729,
    3737,
    3743,
    3746,
    3748,
    3750,
    3751,
    3753,
    0,
    1868,
    0,
    1872,
    0
  ]);
  var table_lv2 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  var table_lv4 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    32786,
    0,
    0,
    0,
    0,
    0,
    33298,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  function compareHeader(lhs, rhs) {
    if (isLessThan(lhs, rhs))
      return -1;
    return 1;
  }
  function isLessThan(lhs, rhs) {
    const tables = [table_lv0, table_lv2, table_lv4];
    let curr_level = 0;
    let i2 = 0;
    let j2 = 0;
    while (curr_level < tables.length) {
      if (curr_level === tables.length - 1 && i2 !== j2) {
        return i2 > j2;
      }
      const weight1 = i2 < lhs.length ? tables[curr_level][lhs[i2].charCodeAt(0)] : 1;
      const weight2 = j2 < rhs.length ? tables[curr_level][rhs[j2].charCodeAt(0)] : 1;
      if (weight1 === 1 && weight2 === 1) {
        i2 = 0;
        j2 = 0;
        ++curr_level;
      } else if (weight1 === weight2) {
        ++i2;
        ++j2;
      } else if (weight1 === 0) {
        ++i2;
      } else if (weight2 === 0) {
        ++j2;
      } else {
        return weight1 < weight2;
      }
    }
    return false;
  }

  class StorageSharedKeyCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy, options, factory) {
      super(nextPolicy, options);
      this.factory = factory;
    }
    signRequest(request9) {
      request9.headers.set(HeaderConstants.X_MS_DATE, new Date().toUTCString());
      if (request9.body && (typeof request9.body === "string" || request9.body !== undefined) && request9.body.length > 0) {
        request9.headers.set(HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request9.body));
      }
      const stringToSign = [
        request9.method.toUpperCase(),
        this.getHeaderValueToSign(request9, HeaderConstants.CONTENT_LANGUAGE),
        this.getHeaderValueToSign(request9, HeaderConstants.CONTENT_ENCODING),
        this.getHeaderValueToSign(request9, HeaderConstants.CONTENT_LENGTH),
        this.getHeaderValueToSign(request9, HeaderConstants.CONTENT_MD5),
        this.getHeaderValueToSign(request9, HeaderConstants.CONTENT_TYPE),
        this.getHeaderValueToSign(request9, HeaderConstants.DATE),
        this.getHeaderValueToSign(request9, HeaderConstants.IF_MODIFIED_SINCE),
        this.getHeaderValueToSign(request9, HeaderConstants.IF_MATCH),
        this.getHeaderValueToSign(request9, HeaderConstants.IF_NONE_MATCH),
        this.getHeaderValueToSign(request9, HeaderConstants.IF_UNMODIFIED_SINCE),
        this.getHeaderValueToSign(request9, HeaderConstants.RANGE)
      ].join(`
`) + `
` + this.getCanonicalizedHeadersString(request9) + this.getCanonicalizedResourceString(request9);
      const signature = this.factory.computeHMACSHA256(stringToSign);
      request9.headers.set(HeaderConstants.AUTHORIZATION, `SharedKey ${this.factory.accountName}:${signature}`);
      return request9;
    }
    getHeaderValueToSign(request9, headerName) {
      const value = request9.headers.get(headerName);
      if (!value) {
        return "";
      }
      if (headerName === HeaderConstants.CONTENT_LENGTH && value === "0") {
        return "";
      }
      return value;
    }
    getCanonicalizedHeadersString(request9) {
      let headersArray = request9.headers.headersArray().filter((value) => {
        return value.name.toLowerCase().startsWith(HeaderConstants.PREFIX_FOR_STORAGE);
      });
      headersArray.sort((a2, b2) => {
        return compareHeader(a2.name.toLowerCase(), b2.name.toLowerCase());
      });
      headersArray = headersArray.filter((value, index, array) => {
        if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
          return false;
        }
        return true;
      });
      let canonicalizedHeadersStringToSign = "";
      headersArray.forEach((header) => {
        canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
      });
      return canonicalizedHeadersStringToSign;
    }
    getCanonicalizedResourceString(request9) {
      const path2 = getURLPath(request9.url) || "/";
      let canonicalizedResourceString = "";
      canonicalizedResourceString += `/${this.factory.accountName}${path2}`;
      const queries = getURLQueries(request9.url);
      const lowercaseQueries = {};
      if (queries) {
        const queryKeys = [];
        for (const key in queries) {
          if (Object.prototype.hasOwnProperty.call(queries, key)) {
            const lowercaseKey = key.toLowerCase();
            lowercaseQueries[lowercaseKey] = queries[key];
            queryKeys.push(lowercaseKey);
          }
        }
        queryKeys.sort();
        for (const key of queryKeys) {
          canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
        }
      }
      return canonicalizedResourceString;
    }
  }

  class Credential {
    create(_nextPolicy, _options) {
      throw new Error("Method should be implemented in children classes.");
    }
  }

  class StorageSharedKeyCredential extends Credential {
    constructor(accountName, accountKey) {
      super();
      this.accountName = accountName;
      this.accountKey = Buffer.from(accountKey, "base64");
    }
    create(nextPolicy, options) {
      return new StorageSharedKeyCredentialPolicy(nextPolicy, options, this);
    }
    computeHMACSHA256(stringToSign) {
      return crypto.createHmac("sha256", this.accountKey).update(stringToSign, "utf8").digest("base64");
    }
  }

  class AnonymousCredentialPolicy extends CredentialPolicy {
    constructor(nextPolicy, options) {
      super(nextPolicy, options);
    }
  }

  class AnonymousCredential extends Credential {
    create(nextPolicy, options) {
      return new AnonymousCredentialPolicy(nextPolicy, options);
    }
  }
  var _defaultHttpClient;
  function getCachedDefaultHttpClient() {
    if (!_defaultHttpClient) {
      _defaultHttpClient = coreRestPipeline.createDefaultHttpClient();
    }
    return _defaultHttpClient;
  }
  var storageBrowserPolicyName = "storageBrowserPolicy";
  function storageBrowserPolicy() {
    return {
      name: storageBrowserPolicyName,
      async sendRequest(request9, next) {
        if (coreUtil.isNode) {
          return next(request9);
        }
        if (request9.method === "GET" || request9.method === "HEAD") {
          request9.url = setURLParameter(request9.url, URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, new Date().getTime().toString());
        }
        request9.headers.delete(HeaderConstants.COOKIE);
        request9.headers.delete(HeaderConstants.CONTENT_LENGTH);
        return next(request9);
      }
    };
  }
  var storageRetryPolicyName = "storageRetryPolicy";
  var StorageRetryPolicyType;
  (function(StorageRetryPolicyType2) {
    StorageRetryPolicyType2[StorageRetryPolicyType2["EXPONENTIAL"] = 0] = "EXPONENTIAL";
    StorageRetryPolicyType2[StorageRetryPolicyType2["FIXED"] = 1] = "FIXED";
  })(StorageRetryPolicyType || (StorageRetryPolicyType = {}));
  var DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120 * 1000,
    maxTries: 4,
    retryDelayInMs: 4 * 1000,
    retryPolicyType: StorageRetryPolicyType.EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: undefined
  };
  var retriableErrors = [
    "ETIMEDOUT",
    "ESOCKETTIMEDOUT",
    "ECONNREFUSED",
    "ECONNRESET",
    "ENOENT",
    "ENOTFOUND",
    "TIMEOUT",
    "EPIPE",
    "REQUEST_SEND_ERROR"
  ];
  var RETRY_ABORT_ERROR = new abortController.AbortError("The operation was aborted.");
  function storageRetryPolicy(options = {}) {
    var _a3, _b2, _c2, _d2, _e2, _f;
    const retryPolicyType = (_a3 = options.retryPolicyType) !== null && _a3 !== undefined ? _a3 : DEFAULT_RETRY_OPTIONS.retryPolicyType;
    const maxTries = (_b2 = options.maxTries) !== null && _b2 !== undefined ? _b2 : DEFAULT_RETRY_OPTIONS.maxTries;
    const retryDelayInMs = (_c2 = options.retryDelayInMs) !== null && _c2 !== undefined ? _c2 : DEFAULT_RETRY_OPTIONS.retryDelayInMs;
    const maxRetryDelayInMs = (_d2 = options.maxRetryDelayInMs) !== null && _d2 !== undefined ? _d2 : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs;
    const secondaryHost = (_e2 = options.secondaryHost) !== null && _e2 !== undefined ? _e2 : DEFAULT_RETRY_OPTIONS.secondaryHost;
    const tryTimeoutInMs = (_f = options.tryTimeoutInMs) !== null && _f !== undefined ? _f : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;
    function shouldRetry({ isPrimaryRetry, attempt, response, error }) {
      var _a4, _b3;
      if (attempt >= maxTries) {
        logger4.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`);
        return false;
      }
      if (error) {
        for (const retriableError of retriableErrors) {
          if (error.name.toUpperCase().includes(retriableError) || error.message.toUpperCase().includes(retriableError) || error.code && error.code.toString().toUpperCase() === retriableError) {
            logger4.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
            return true;
          }
        }
        if ((error === null || error === undefined ? undefined : error.code) === "PARSE_ERROR" && (error === null || error === undefined ? undefined : error.message.startsWith(`Error "Error: Unclosed root tag`))) {
          logger4.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
          return true;
        }
      }
      if (response || error) {
        const statusCode = (_b3 = (_a4 = response === null || response === undefined ? undefined : response.status) !== null && _a4 !== undefined ? _a4 : error === null || error === undefined ? undefined : error.statusCode) !== null && _b3 !== undefined ? _b3 : 0;
        if (!isPrimaryRetry && statusCode === 404) {
          logger4.info(`RetryPolicy: Secondary access with 404, will retry.`);
          return true;
        }
        if (statusCode === 503 || statusCode === 500) {
          logger4.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
          return true;
        }
      }
      return false;
    }
    function calculateDelay(isPrimaryRetry, attempt) {
      let delayTimeInMs = 0;
      if (isPrimaryRetry) {
        switch (retryPolicyType) {
          case StorageRetryPolicyType.EXPONENTIAL:
            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * retryDelayInMs, maxRetryDelayInMs);
            break;
          case StorageRetryPolicyType.FIXED:
            delayTimeInMs = retryDelayInMs;
            break;
        }
      } else {
        delayTimeInMs = Math.random() * 1000;
      }
      logger4.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
      return delayTimeInMs;
    }
    return {
      name: storageRetryPolicyName,
      async sendRequest(request9, next) {
        if (tryTimeoutInMs) {
          request9.url = setURLParameter(request9.url, URLConstants.Parameters.TIMEOUT, String(Math.floor(tryTimeoutInMs / 1000)));
        }
        const primaryUrl = request9.url;
        const secondaryUrl = secondaryHost ? setURLHost(request9.url, secondaryHost) : undefined;
        let secondaryHas404 = false;
        let attempt = 1;
        let retryAgain = true;
        let response;
        let error;
        while (retryAgain) {
          const isPrimaryRetry = secondaryHas404 || !secondaryUrl || !["GET", "HEAD", "OPTIONS"].includes(request9.method) || attempt % 2 === 1;
          request9.url = isPrimaryRetry ? primaryUrl : secondaryUrl;
          response = undefined;
          error = undefined;
          try {
            logger4.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
            response = await next(request9);
            secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
          } catch (e2) {
            if (coreRestPipeline.isRestError(e2)) {
              logger4.error(`RetryPolicy: Caught error, message: ${e2.message}, code: ${e2.code}`);
              error = e2;
            } else {
              logger4.error(`RetryPolicy: Caught error, message: ${coreUtil.getErrorMessage(e2)}`);
              throw e2;
            }
          }
          retryAgain = shouldRetry({ isPrimaryRetry, attempt, response, error });
          if (retryAgain) {
            await delay3(calculateDelay(isPrimaryRetry, attempt), request9.abortSignal, RETRY_ABORT_ERROR);
          }
          attempt++;
        }
        if (response) {
          return response;
        }
        throw error !== null && error !== undefined ? error : new coreRestPipeline.RestError("RetryPolicy failed without known error.");
      }
    };
  }
  var storageSharedKeyCredentialPolicyName = "storageSharedKeyCredentialPolicy";
  function storageSharedKeyCredentialPolicy(options) {
    function signRequest(request9) {
      request9.headers.set(HeaderConstants.X_MS_DATE, new Date().toUTCString());
      if (request9.body && (typeof request9.body === "string" || Buffer.isBuffer(request9.body)) && request9.body.length > 0) {
        request9.headers.set(HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request9.body));
      }
      const stringToSign = [
        request9.method.toUpperCase(),
        getHeaderValueToSign(request9, HeaderConstants.CONTENT_LANGUAGE),
        getHeaderValueToSign(request9, HeaderConstants.CONTENT_ENCODING),
        getHeaderValueToSign(request9, HeaderConstants.CONTENT_LENGTH),
        getHeaderValueToSign(request9, HeaderConstants.CONTENT_MD5),
        getHeaderValueToSign(request9, HeaderConstants.CONTENT_TYPE),
        getHeaderValueToSign(request9, HeaderConstants.DATE),
        getHeaderValueToSign(request9, HeaderConstants.IF_MODIFIED_SINCE),
        getHeaderValueToSign(request9, HeaderConstants.IF_MATCH),
        getHeaderValueToSign(request9, HeaderConstants.IF_NONE_MATCH),
        getHeaderValueToSign(request9, HeaderConstants.IF_UNMODIFIED_SINCE),
        getHeaderValueToSign(request9, HeaderConstants.RANGE)
      ].join(`
`) + `
` + getCanonicalizedHeadersString(request9) + getCanonicalizedResourceString(request9);
      const signature = crypto.createHmac("sha256", options.accountKey).update(stringToSign, "utf8").digest("base64");
      request9.headers.set(HeaderConstants.AUTHORIZATION, `SharedKey ${options.accountName}:${signature}`);
    }
    function getHeaderValueToSign(request9, headerName) {
      const value = request9.headers.get(headerName);
      if (!value) {
        return "";
      }
      if (headerName === HeaderConstants.CONTENT_LENGTH && value === "0") {
        return "";
      }
      return value;
    }
    function getCanonicalizedHeadersString(request9) {
      let headersArray = [];
      for (const [name, value] of request9.headers) {
        if (name.toLowerCase().startsWith(HeaderConstants.PREFIX_FOR_STORAGE)) {
          headersArray.push({ name, value });
        }
      }
      headersArray.sort((a2, b2) => {
        return compareHeader(a2.name.toLowerCase(), b2.name.toLowerCase());
      });
      headersArray = headersArray.filter((value, index, array) => {
        if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
          return false;
        }
        return true;
      });
      let canonicalizedHeadersStringToSign = "";
      headersArray.forEach((header) => {
        canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
      });
      return canonicalizedHeadersStringToSign;
    }
    function getCanonicalizedResourceString(request9) {
      const path2 = getURLPath(request9.url) || "/";
      let canonicalizedResourceString = "";
      canonicalizedResourceString += `/${options.accountName}${path2}`;
      const queries = getURLQueries(request9.url);
      const lowercaseQueries = {};
      if (queries) {
        const queryKeys = [];
        for (const key in queries) {
          if (Object.prototype.hasOwnProperty.call(queries, key)) {
            const lowercaseKey = key.toLowerCase();
            lowercaseQueries[lowercaseKey] = queries[key];
            queryKeys.push(lowercaseKey);
          }
        }
        queryKeys.sort();
        for (const key of queryKeys) {
          canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
        }
      }
      return canonicalizedResourceString;
    }
    return {
      name: storageSharedKeyCredentialPolicyName,
      async sendRequest(request9, next) {
        signRequest(request9);
        return next(request9);
      }
    };
  }

  class StorageBrowserPolicy extends BaseRequestPolicy {
    constructor(nextPolicy, options) {
      super(nextPolicy, options);
    }
    async sendRequest(request9) {
      if (coreUtil.isNode) {
        return this._nextPolicy.sendRequest(request9);
      }
      if (request9.method.toUpperCase() === "GET" || request9.method.toUpperCase() === "HEAD") {
        request9.url = setURLParameter(request9.url, URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, new Date().getTime().toString());
      }
      request9.headers.remove(HeaderConstants.COOKIE);
      request9.headers.remove(HeaderConstants.CONTENT_LENGTH);
      return this._nextPolicy.sendRequest(request9);
    }
  }

  class StorageBrowserPolicyFactory {
    create(nextPolicy, options) {
      return new StorageBrowserPolicy(nextPolicy, options);
    }
  }
  var storageCorrectContentLengthPolicyName = "StorageCorrectContentLengthPolicy";
  function storageCorrectContentLengthPolicy() {
    function correctContentLength(request9) {
      if (request9.body && (typeof request9.body === "string" || Buffer.isBuffer(request9.body)) && request9.body.length > 0) {
        request9.headers.set(HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request9.body));
      }
    }
    return {
      name: storageCorrectContentLengthPolicyName,
      async sendRequest(request9, next) {
        correctContentLength(request9);
        return next(request9);
      }
    };
  }
  function isPipelineLike(pipeline) {
    if (!pipeline || typeof pipeline !== "object") {
      return false;
    }
    const castPipeline = pipeline;
    return Array.isArray(castPipeline.factories) && typeof castPipeline.options === "object" && typeof castPipeline.toServiceClientOptions === "function";
  }

  class Pipeline {
    constructor(factories, options = {}) {
      this.factories = factories;
      this.options = options;
    }
    toServiceClientOptions() {
      return {
        httpClient: this.options.httpClient,
        requestPolicyFactories: this.factories
      };
    }
  }
  function newPipeline(credential, pipelineOptions = {}) {
    if (!credential) {
      credential = new AnonymousCredential;
    }
    const pipeline = new Pipeline([], pipelineOptions);
    pipeline._credential = credential;
    return pipeline;
  }
  function processDownlevelPipeline(pipeline) {
    const knownFactoryFunctions = [
      isAnonymousCredential,
      isStorageSharedKeyCredential,
      isCoreHttpBearerTokenFactory,
      isStorageBrowserPolicyFactory,
      isStorageRetryPolicyFactory,
      isStorageTelemetryPolicyFactory,
      isCoreHttpPolicyFactory
    ];
    if (pipeline.factories.length) {
      const novelFactories = pipeline.factories.filter((factory) => {
        return !knownFactoryFunctions.some((knownFactory) => knownFactory(factory));
      });
      if (novelFactories.length) {
        const hasInjector = novelFactories.some((factory) => isInjectorPolicyFactory(factory));
        return {
          wrappedPolicies: coreHttpCompat.createRequestPolicyFactoryPolicy(novelFactories),
          afterRetry: hasInjector
        };
      }
    }
    return;
  }
  function getCoreClientOptions(pipeline) {
    var _a3;
    const _b2 = pipeline.options, { httpClient: v1Client } = _b2, restOptions = tslib2.__rest(_b2, ["httpClient"]);
    let httpClient = pipeline._coreHttpClient;
    if (!httpClient) {
      httpClient = v1Client ? coreHttpCompat.convertHttpClient(v1Client) : getCachedDefaultHttpClient();
      pipeline._coreHttpClient = httpClient;
    }
    let corePipeline = pipeline._corePipeline;
    if (!corePipeline) {
      const packageDetails = `azsdk-js-azure-storage-blob/${SDK_VERSION4}`;
      const userAgentPrefix = restOptions.userAgentOptions && restOptions.userAgentOptions.userAgentPrefix ? `${restOptions.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
      corePipeline = coreClient.createClientPipeline(Object.assign(Object.assign({}, restOptions), { loggingOptions: {
        additionalAllowedHeaderNames: StorageBlobLoggingAllowedHeaderNames,
        additionalAllowedQueryParameters: StorageBlobLoggingAllowedQueryParameters,
        logger: logger4.info
      }, userAgentOptions: {
        userAgentPrefix
      }, serializationOptions: {
        stringifyXML: coreXml.stringifyXML,
        serializerOptions: {
          xml: {
            xmlCharKey: "#"
          }
        }
      }, deserializationOptions: {
        parseXML: coreXml.parseXML,
        serializerOptions: {
          xml: {
            xmlCharKey: "#"
          }
        }
      } }));
      corePipeline.removePolicy({ phase: "Retry" });
      corePipeline.removePolicy({ name: coreRestPipeline.decompressResponsePolicyName });
      corePipeline.addPolicy(storageCorrectContentLengthPolicy());
      corePipeline.addPolicy(storageRetryPolicy(restOptions.retryOptions), { phase: "Retry" });
      corePipeline.addPolicy(storageBrowserPolicy());
      const downlevelResults = processDownlevelPipeline(pipeline);
      if (downlevelResults) {
        corePipeline.addPolicy(downlevelResults.wrappedPolicies, downlevelResults.afterRetry ? { afterPhase: "Retry" } : undefined);
      }
      const credential = getCredentialFromPipeline(pipeline);
      if (coreAuth.isTokenCredential(credential)) {
        corePipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
          credential,
          scopes: (_a3 = restOptions.audience) !== null && _a3 !== undefined ? _a3 : StorageOAuthScopes,
          challengeCallbacks: { authorizeRequestOnChallenge: coreClient.authorizeRequestOnTenantChallenge }
        }), { phase: "Sign" });
      } else if (credential instanceof StorageSharedKeyCredential) {
        corePipeline.addPolicy(storageSharedKeyCredentialPolicy({
          accountName: credential.accountName,
          accountKey: credential.accountKey
        }), { phase: "Sign" });
      }
      pipeline._corePipeline = corePipeline;
    }
    return Object.assign(Object.assign({}, restOptions), { allowInsecureConnection: true, httpClient, pipeline: corePipeline });
  }
  function getCredentialFromPipeline(pipeline) {
    if (pipeline._credential) {
      return pipeline._credential;
    }
    let credential = new AnonymousCredential;
    for (const factory of pipeline.factories) {
      if (coreAuth.isTokenCredential(factory.credential)) {
        credential = factory.credential;
      } else if (isStorageSharedKeyCredential(factory)) {
        return factory;
      }
    }
    return credential;
  }
  function isStorageSharedKeyCredential(factory) {
    if (factory instanceof StorageSharedKeyCredential) {
      return true;
    }
    return factory.constructor.name === "StorageSharedKeyCredential";
  }
  function isAnonymousCredential(factory) {
    if (factory instanceof AnonymousCredential) {
      return true;
    }
    return factory.constructor.name === "AnonymousCredential";
  }
  function isCoreHttpBearerTokenFactory(factory) {
    return coreAuth.isTokenCredential(factory.credential);
  }
  function isStorageBrowserPolicyFactory(factory) {
    if (factory instanceof StorageBrowserPolicyFactory) {
      return true;
    }
    return factory.constructor.name === "StorageBrowserPolicyFactory";
  }
  function isStorageRetryPolicyFactory(factory) {
    if (factory instanceof StorageRetryPolicyFactory) {
      return true;
    }
    return factory.constructor.name === "StorageRetryPolicyFactory";
  }
  function isStorageTelemetryPolicyFactory(factory) {
    return factory.constructor.name === "TelemetryPolicyFactory";
  }
  function isInjectorPolicyFactory(factory) {
    return factory.constructor.name === "InjectorPolicyFactory";
  }
  function isCoreHttpPolicyFactory(factory) {
    const knownPolicies = [
      "GenerateClientRequestIdPolicy",
      "TracingPolicy",
      "LogPolicy",
      "ProxyPolicy",
      "DisableResponseDecompressionPolicy",
      "KeepAlivePolicy",
      "DeserializationPolicy"
    ];
    const mockHttpClient = {
      sendRequest: async (request9) => {
        return {
          request: request9,
          headers: request9.headers.clone(),
          status: 500
        };
      }
    };
    const mockRequestPolicyOptions = {
      log(_logLevel, _message) {
      },
      shouldLog(_logLevel) {
        return false;
      }
    };
    const policyInstance = factory.create(mockHttpClient, mockRequestPolicyOptions);
    const policyName = policyInstance.constructor.name;
    return knownPolicies.some((knownPolicyName) => {
      return policyName.startsWith(knownPolicyName);
    });
  }
  var BlobServiceProperties = {
    serializedName: "BlobServiceProperties",
    xmlName: "StorageServiceProperties",
    type: {
      name: "Composite",
      className: "BlobServiceProperties",
      modelProperties: {
        blobAnalyticsLogging: {
          serializedName: "Logging",
          xmlName: "Logging",
          type: {
            name: "Composite",
            className: "Logging"
          }
        },
        hourMetrics: {
          serializedName: "HourMetrics",
          xmlName: "HourMetrics",
          type: {
            name: "Composite",
            className: "Metrics"
          }
        },
        minuteMetrics: {
          serializedName: "MinuteMetrics",
          xmlName: "MinuteMetrics",
          type: {
            name: "Composite",
            className: "Metrics"
          }
        },
        cors: {
          serializedName: "Cors",
          xmlName: "Cors",
          xmlIsWrapped: true,
          xmlElementName: "CorsRule",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "CorsRule"
              }
            }
          }
        },
        defaultServiceVersion: {
          serializedName: "DefaultServiceVersion",
          xmlName: "DefaultServiceVersion",
          type: {
            name: "String"
          }
        },
        deleteRetentionPolicy: {
          serializedName: "DeleteRetentionPolicy",
          xmlName: "DeleteRetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        },
        staticWebsite: {
          serializedName: "StaticWebsite",
          xmlName: "StaticWebsite",
          type: {
            name: "Composite",
            className: "StaticWebsite"
          }
        }
      }
    }
  };
  var Logging = {
    serializedName: "Logging",
    type: {
      name: "Composite",
      className: "Logging",
      modelProperties: {
        version: {
          serializedName: "Version",
          required: true,
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        deleteProperty: {
          serializedName: "Delete",
          required: true,
          xmlName: "Delete",
          type: {
            name: "Boolean"
          }
        },
        read: {
          serializedName: "Read",
          required: true,
          xmlName: "Read",
          type: {
            name: "Boolean"
          }
        },
        write: {
          serializedName: "Write",
          required: true,
          xmlName: "Write",
          type: {
            name: "Boolean"
          }
        },
        retentionPolicy: {
          serializedName: "RetentionPolicy",
          xmlName: "RetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        }
      }
    }
  };
  var RetentionPolicy = {
    serializedName: "RetentionPolicy",
    type: {
      name: "Composite",
      className: "RetentionPolicy",
      modelProperties: {
        enabled: {
          serializedName: "Enabled",
          required: true,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        days: {
          constraints: {
            InclusiveMinimum: 1
          },
          serializedName: "Days",
          xmlName: "Days",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var Metrics = {
    serializedName: "Metrics",
    type: {
      name: "Composite",
      className: "Metrics",
      modelProperties: {
        version: {
          serializedName: "Version",
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        enabled: {
          serializedName: "Enabled",
          required: true,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        includeAPIs: {
          serializedName: "IncludeAPIs",
          xmlName: "IncludeAPIs",
          type: {
            name: "Boolean"
          }
        },
        retentionPolicy: {
          serializedName: "RetentionPolicy",
          xmlName: "RetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        }
      }
    }
  };
  var CorsRule = {
    serializedName: "CorsRule",
    type: {
      name: "Composite",
      className: "CorsRule",
      modelProperties: {
        allowedOrigins: {
          serializedName: "AllowedOrigins",
          required: true,
          xmlName: "AllowedOrigins",
          type: {
            name: "String"
          }
        },
        allowedMethods: {
          serializedName: "AllowedMethods",
          required: true,
          xmlName: "AllowedMethods",
          type: {
            name: "String"
          }
        },
        allowedHeaders: {
          serializedName: "AllowedHeaders",
          required: true,
          xmlName: "AllowedHeaders",
          type: {
            name: "String"
          }
        },
        exposedHeaders: {
          serializedName: "ExposedHeaders",
          required: true,
          xmlName: "ExposedHeaders",
          type: {
            name: "String"
          }
        },
        maxAgeInSeconds: {
          constraints: {
            InclusiveMinimum: 0
          },
          serializedName: "MaxAgeInSeconds",
          required: true,
          xmlName: "MaxAgeInSeconds",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var StaticWebsite = {
    serializedName: "StaticWebsite",
    type: {
      name: "Composite",
      className: "StaticWebsite",
      modelProperties: {
        enabled: {
          serializedName: "Enabled",
          required: true,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        indexDocument: {
          serializedName: "IndexDocument",
          xmlName: "IndexDocument",
          type: {
            name: "String"
          }
        },
        errorDocument404Path: {
          serializedName: "ErrorDocument404Path",
          xmlName: "ErrorDocument404Path",
          type: {
            name: "String"
          }
        },
        defaultIndexDocumentPath: {
          serializedName: "DefaultIndexDocumentPath",
          xmlName: "DefaultIndexDocumentPath",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var StorageError = {
    serializedName: "StorageError",
    type: {
      name: "Composite",
      className: "StorageError",
      modelProperties: {
        message: {
          serializedName: "Message",
          xmlName: "Message",
          type: {
            name: "String"
          }
        },
        code: {
          serializedName: "Code",
          xmlName: "Code",
          type: {
            name: "String"
          }
        },
        authenticationErrorDetail: {
          serializedName: "AuthenticationErrorDetail",
          xmlName: "AuthenticationErrorDetail",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobServiceStatistics = {
    serializedName: "BlobServiceStatistics",
    xmlName: "StorageServiceStats",
    type: {
      name: "Composite",
      className: "BlobServiceStatistics",
      modelProperties: {
        geoReplication: {
          serializedName: "GeoReplication",
          xmlName: "GeoReplication",
          type: {
            name: "Composite",
            className: "GeoReplication"
          }
        }
      }
    }
  };
  var GeoReplication = {
    serializedName: "GeoReplication",
    type: {
      name: "Composite",
      className: "GeoReplication",
      modelProperties: {
        status: {
          serializedName: "Status",
          required: true,
          xmlName: "Status",
          type: {
            name: "Enum",
            allowedValues: ["live", "bootstrap", "unavailable"]
          }
        },
        lastSyncOn: {
          serializedName: "LastSyncTime",
          required: true,
          xmlName: "LastSyncTime",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ListContainersSegmentResponse = {
    serializedName: "ListContainersSegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListContainersSegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        containerItems: {
          serializedName: "ContainerItems",
          required: true,
          xmlName: "Containers",
          xmlIsWrapped: true,
          xmlElementName: "Container",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ContainerItem"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerItem = {
    serializedName: "ContainerItem",
    xmlName: "Container",
    type: {
      name: "Composite",
      className: "ContainerItem",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: true,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        deleted: {
          serializedName: "Deleted",
          xmlName: "Deleted",
          type: {
            name: "Boolean"
          }
        },
        version: {
          serializedName: "Version",
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        properties: {
          serializedName: "Properties",
          xmlName: "Properties",
          type: {
            name: "Composite",
            className: "ContainerProperties"
          }
        },
        metadata: {
          serializedName: "Metadata",
          xmlName: "Metadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        }
      }
    }
  };
  var ContainerProperties = {
    serializedName: "ContainerProperties",
    type: {
      name: "Composite",
      className: "ContainerProperties",
      modelProperties: {
        lastModified: {
          serializedName: "Last-Modified",
          required: true,
          xmlName: "Last-Modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "Etag",
          required: true,
          xmlName: "Etag",
          type: {
            name: "String"
          }
        },
        leaseStatus: {
          serializedName: "LeaseStatus",
          xmlName: "LeaseStatus",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        leaseState: {
          serializedName: "LeaseState",
          xmlName: "LeaseState",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseDuration: {
          serializedName: "LeaseDuration",
          xmlName: "LeaseDuration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        publicAccess: {
          serializedName: "PublicAccess",
          xmlName: "PublicAccess",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        hasImmutabilityPolicy: {
          serializedName: "HasImmutabilityPolicy",
          xmlName: "HasImmutabilityPolicy",
          type: {
            name: "Boolean"
          }
        },
        hasLegalHold: {
          serializedName: "HasLegalHold",
          xmlName: "HasLegalHold",
          type: {
            name: "Boolean"
          }
        },
        defaultEncryptionScope: {
          serializedName: "DefaultEncryptionScope",
          xmlName: "DefaultEncryptionScope",
          type: {
            name: "String"
          }
        },
        preventEncryptionScopeOverride: {
          serializedName: "DenyEncryptionScopeOverride",
          xmlName: "DenyEncryptionScopeOverride",
          type: {
            name: "Boolean"
          }
        },
        deletedOn: {
          serializedName: "DeletedTime",
          xmlName: "DeletedTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        remainingRetentionDays: {
          serializedName: "RemainingRetentionDays",
          xmlName: "RemainingRetentionDays",
          type: {
            name: "Number"
          }
        },
        isImmutableStorageWithVersioningEnabled: {
          serializedName: "ImmutableStorageWithVersioningEnabled",
          xmlName: "ImmutableStorageWithVersioningEnabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var KeyInfo = {
    serializedName: "KeyInfo",
    type: {
      name: "Composite",
      className: "KeyInfo",
      modelProperties: {
        startsOn: {
          serializedName: "Start",
          required: true,
          xmlName: "Start",
          type: {
            name: "String"
          }
        },
        expiresOn: {
          serializedName: "Expiry",
          required: true,
          xmlName: "Expiry",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var UserDelegationKey = {
    serializedName: "UserDelegationKey",
    type: {
      name: "Composite",
      className: "UserDelegationKey",
      modelProperties: {
        signedObjectId: {
          serializedName: "SignedOid",
          required: true,
          xmlName: "SignedOid",
          type: {
            name: "String"
          }
        },
        signedTenantId: {
          serializedName: "SignedTid",
          required: true,
          xmlName: "SignedTid",
          type: {
            name: "String"
          }
        },
        signedStartsOn: {
          serializedName: "SignedStart",
          required: true,
          xmlName: "SignedStart",
          type: {
            name: "String"
          }
        },
        signedExpiresOn: {
          serializedName: "SignedExpiry",
          required: true,
          xmlName: "SignedExpiry",
          type: {
            name: "String"
          }
        },
        signedService: {
          serializedName: "SignedService",
          required: true,
          xmlName: "SignedService",
          type: {
            name: "String"
          }
        },
        signedVersion: {
          serializedName: "SignedVersion",
          required: true,
          xmlName: "SignedVersion",
          type: {
            name: "String"
          }
        },
        value: {
          serializedName: "Value",
          required: true,
          xmlName: "Value",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var FilterBlobSegment = {
    serializedName: "FilterBlobSegment",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "FilterBlobSegment",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        where: {
          serializedName: "Where",
          required: true,
          xmlName: "Where",
          type: {
            name: "String"
          }
        },
        blobs: {
          serializedName: "Blobs",
          required: true,
          xmlName: "Blobs",
          xmlIsWrapped: true,
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "FilterBlobItem"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var FilterBlobItem = {
    serializedName: "FilterBlobItem",
    xmlName: "Blob",
    type: {
      name: "Composite",
      className: "FilterBlobItem",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: true,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: true,
          xmlName: "ContainerName",
          type: {
            name: "String"
          }
        },
        tags: {
          serializedName: "Tags",
          xmlName: "Tags",
          type: {
            name: "Composite",
            className: "BlobTags"
          }
        }
      }
    }
  };
  var BlobTags = {
    serializedName: "BlobTags",
    xmlName: "Tags",
    type: {
      name: "Composite",
      className: "BlobTags",
      modelProperties: {
        blobTagSet: {
          serializedName: "BlobTagSet",
          required: true,
          xmlName: "TagSet",
          xmlIsWrapped: true,
          xmlElementName: "Tag",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobTag"
              }
            }
          }
        }
      }
    }
  };
  var BlobTag = {
    serializedName: "BlobTag",
    xmlName: "Tag",
    type: {
      name: "Composite",
      className: "BlobTag",
      modelProperties: {
        key: {
          serializedName: "Key",
          required: true,
          xmlName: "Key",
          type: {
            name: "String"
          }
        },
        value: {
          serializedName: "Value",
          required: true,
          xmlName: "Value",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var SignedIdentifier = {
    serializedName: "SignedIdentifier",
    xmlName: "SignedIdentifier",
    type: {
      name: "Composite",
      className: "SignedIdentifier",
      modelProperties: {
        id: {
          serializedName: "Id",
          required: true,
          xmlName: "Id",
          type: {
            name: "String"
          }
        },
        accessPolicy: {
          serializedName: "AccessPolicy",
          xmlName: "AccessPolicy",
          type: {
            name: "Composite",
            className: "AccessPolicy"
          }
        }
      }
    }
  };
  var AccessPolicy = {
    serializedName: "AccessPolicy",
    type: {
      name: "Composite",
      className: "AccessPolicy",
      modelProperties: {
        startsOn: {
          serializedName: "Start",
          xmlName: "Start",
          type: {
            name: "String"
          }
        },
        expiresOn: {
          serializedName: "Expiry",
          xmlName: "Expiry",
          type: {
            name: "String"
          }
        },
        permissions: {
          serializedName: "Permission",
          xmlName: "Permission",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ListBlobsFlatSegmentResponse = {
    serializedName: "ListBlobsFlatSegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListBlobsFlatSegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: true,
          xmlName: "ContainerName",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        segment: {
          serializedName: "Segment",
          xmlName: "Blobs",
          type: {
            name: "Composite",
            className: "BlobFlatListSegment"
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobFlatListSegment = {
    serializedName: "BlobFlatListSegment",
    xmlName: "Blobs",
    type: {
      name: "Composite",
      className: "BlobFlatListSegment",
      modelProperties: {
        blobItems: {
          serializedName: "BlobItems",
          required: true,
          xmlName: "BlobItems",
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobItemInternal"
              }
            }
          }
        }
      }
    }
  };
  var BlobItemInternal = {
    serializedName: "BlobItemInternal",
    xmlName: "Blob",
    type: {
      name: "Composite",
      className: "BlobItemInternal",
      modelProperties: {
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "Composite",
            className: "BlobName"
          }
        },
        deleted: {
          serializedName: "Deleted",
          required: true,
          xmlName: "Deleted",
          type: {
            name: "Boolean"
          }
        },
        snapshot: {
          serializedName: "Snapshot",
          required: true,
          xmlName: "Snapshot",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "VersionId",
          xmlName: "VersionId",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "IsCurrentVersion",
          xmlName: "IsCurrentVersion",
          type: {
            name: "Boolean"
          }
        },
        properties: {
          serializedName: "Properties",
          xmlName: "Properties",
          type: {
            name: "Composite",
            className: "BlobPropertiesInternal"
          }
        },
        metadata: {
          serializedName: "Metadata",
          xmlName: "Metadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        blobTags: {
          serializedName: "BlobTags",
          xmlName: "Tags",
          type: {
            name: "Composite",
            className: "BlobTags"
          }
        },
        objectReplicationMetadata: {
          serializedName: "ObjectReplicationMetadata",
          xmlName: "OrMetadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        hasVersionsOnly: {
          serializedName: "HasVersionsOnly",
          xmlName: "HasVersionsOnly",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var BlobName = {
    serializedName: "BlobName",
    type: {
      name: "Composite",
      className: "BlobName",
      modelProperties: {
        encoded: {
          serializedName: "Encoded",
          xmlName: "Encoded",
          xmlIsAttribute: true,
          type: {
            name: "Boolean"
          }
        },
        content: {
          serializedName: "content",
          xmlName: "content",
          xmlIsMsText: true,
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobPropertiesInternal = {
    serializedName: "BlobPropertiesInternal",
    xmlName: "Properties",
    type: {
      name: "Composite",
      className: "BlobPropertiesInternal",
      modelProperties: {
        createdOn: {
          serializedName: "Creation-Time",
          xmlName: "Creation-Time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        lastModified: {
          serializedName: "Last-Modified",
          required: true,
          xmlName: "Last-Modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "Etag",
          required: true,
          xmlName: "Etag",
          type: {
            name: "String"
          }
        },
        contentLength: {
          serializedName: "Content-Length",
          xmlName: "Content-Length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "Content-Type",
          xmlName: "Content-Type",
          type: {
            name: "String"
          }
        },
        contentEncoding: {
          serializedName: "Content-Encoding",
          xmlName: "Content-Encoding",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "Content-Language",
          xmlName: "Content-Language",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "Content-MD5",
          xmlName: "Content-MD5",
          type: {
            name: "ByteArray"
          }
        },
        contentDisposition: {
          serializedName: "Content-Disposition",
          xmlName: "Content-Disposition",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "Cache-Control",
          xmlName: "Cache-Control",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "BlobType",
          xmlName: "BlobType",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        leaseStatus: {
          serializedName: "LeaseStatus",
          xmlName: "LeaseStatus",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        leaseState: {
          serializedName: "LeaseState",
          xmlName: "LeaseState",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseDuration: {
          serializedName: "LeaseDuration",
          xmlName: "LeaseDuration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        copyId: {
          serializedName: "CopyId",
          xmlName: "CopyId",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "CopyStatus",
          xmlName: "CopyStatus",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        copySource: {
          serializedName: "CopySource",
          xmlName: "CopySource",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "CopyProgress",
          xmlName: "CopyProgress",
          type: {
            name: "String"
          }
        },
        copyCompletedOn: {
          serializedName: "CopyCompletionTime",
          xmlName: "CopyCompletionTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "CopyStatusDescription",
          xmlName: "CopyStatusDescription",
          type: {
            name: "String"
          }
        },
        serverEncrypted: {
          serializedName: "ServerEncrypted",
          xmlName: "ServerEncrypted",
          type: {
            name: "Boolean"
          }
        },
        incrementalCopy: {
          serializedName: "IncrementalCopy",
          xmlName: "IncrementalCopy",
          type: {
            name: "Boolean"
          }
        },
        destinationSnapshot: {
          serializedName: "DestinationSnapshot",
          xmlName: "DestinationSnapshot",
          type: {
            name: "String"
          }
        },
        deletedOn: {
          serializedName: "DeletedTime",
          xmlName: "DeletedTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        remainingRetentionDays: {
          serializedName: "RemainingRetentionDays",
          xmlName: "RemainingRetentionDays",
          type: {
            name: "Number"
          }
        },
        accessTier: {
          serializedName: "AccessTier",
          xmlName: "AccessTier",
          type: {
            name: "Enum",
            allowedValues: [
              "P4",
              "P6",
              "P10",
              "P15",
              "P20",
              "P30",
              "P40",
              "P50",
              "P60",
              "P70",
              "P80",
              "Hot",
              "Cool",
              "Archive",
              "Cold"
            ]
          }
        },
        accessTierInferred: {
          serializedName: "AccessTierInferred",
          xmlName: "AccessTierInferred",
          type: {
            name: "Boolean"
          }
        },
        archiveStatus: {
          serializedName: "ArchiveStatus",
          xmlName: "ArchiveStatus",
          type: {
            name: "Enum",
            allowedValues: [
              "rehydrate-pending-to-hot",
              "rehydrate-pending-to-cool",
              "rehydrate-pending-to-cold"
            ]
          }
        },
        customerProvidedKeySha256: {
          serializedName: "CustomerProvidedKeySha256",
          xmlName: "CustomerProvidedKeySha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "EncryptionScope",
          xmlName: "EncryptionScope",
          type: {
            name: "String"
          }
        },
        accessTierChangedOn: {
          serializedName: "AccessTierChangeTime",
          xmlName: "AccessTierChangeTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        tagCount: {
          serializedName: "TagCount",
          xmlName: "TagCount",
          type: {
            name: "Number"
          }
        },
        expiresOn: {
          serializedName: "Expiry-Time",
          xmlName: "Expiry-Time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "Sealed",
          xmlName: "Sealed",
          type: {
            name: "Boolean"
          }
        },
        rehydratePriority: {
          serializedName: "RehydratePriority",
          xmlName: "RehydratePriority",
          type: {
            name: "Enum",
            allowedValues: ["High", "Standard"]
          }
        },
        lastAccessedOn: {
          serializedName: "LastAccessTime",
          xmlName: "LastAccessTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "ImmutabilityPolicyUntilDate",
          xmlName: "ImmutabilityPolicyUntilDate",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "ImmutabilityPolicyMode",
          xmlName: "ImmutabilityPolicyMode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "LegalHold",
          xmlName: "LegalHold",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var ListBlobsHierarchySegmentResponse = {
    serializedName: "ListBlobsHierarchySegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListBlobsHierarchySegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: true,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: true,
          xmlName: "ContainerName",
          xmlIsAttribute: true,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        delimiter: {
          serializedName: "Delimiter",
          xmlName: "Delimiter",
          type: {
            name: "String"
          }
        },
        segment: {
          serializedName: "Segment",
          xmlName: "Blobs",
          type: {
            name: "Composite",
            className: "BlobHierarchyListSegment"
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobHierarchyListSegment = {
    serializedName: "BlobHierarchyListSegment",
    xmlName: "Blobs",
    type: {
      name: "Composite",
      className: "BlobHierarchyListSegment",
      modelProperties: {
        blobPrefixes: {
          serializedName: "BlobPrefixes",
          xmlName: "BlobPrefixes",
          xmlElementName: "BlobPrefix",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobPrefix"
              }
            }
          }
        },
        blobItems: {
          serializedName: "BlobItems",
          required: true,
          xmlName: "BlobItems",
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobItemInternal"
              }
            }
          }
        }
      }
    }
  };
  var BlobPrefix = {
    serializedName: "BlobPrefix",
    type: {
      name: "Composite",
      className: "BlobPrefix",
      modelProperties: {
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "Composite",
            className: "BlobName"
          }
        }
      }
    }
  };
  var BlockLookupList = {
    serializedName: "BlockLookupList",
    xmlName: "BlockList",
    type: {
      name: "Composite",
      className: "BlockLookupList",
      modelProperties: {
        committed: {
          serializedName: "Committed",
          xmlName: "Committed",
          xmlElementName: "Committed",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        },
        uncommitted: {
          serializedName: "Uncommitted",
          xmlName: "Uncommitted",
          xmlElementName: "Uncommitted",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        },
        latest: {
          serializedName: "Latest",
          xmlName: "Latest",
          xmlElementName: "Latest",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        }
      }
    }
  };
  var BlockList = {
    serializedName: "BlockList",
    type: {
      name: "Composite",
      className: "BlockList",
      modelProperties: {
        committedBlocks: {
          serializedName: "CommittedBlocks",
          xmlName: "CommittedBlocks",
          xmlIsWrapped: true,
          xmlElementName: "Block",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "Block"
              }
            }
          }
        },
        uncommittedBlocks: {
          serializedName: "UncommittedBlocks",
          xmlName: "UncommittedBlocks",
          xmlIsWrapped: true,
          xmlElementName: "Block",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "Block"
              }
            }
          }
        }
      }
    }
  };
  var Block = {
    serializedName: "Block",
    type: {
      name: "Composite",
      className: "Block",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: true,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        size: {
          serializedName: "Size",
          required: true,
          xmlName: "Size",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var PageList = {
    serializedName: "PageList",
    type: {
      name: "Composite",
      className: "PageList",
      modelProperties: {
        pageRange: {
          serializedName: "PageRange",
          xmlName: "PageRange",
          xmlElementName: "PageRange",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "PageRange"
              }
            }
          }
        },
        clearRange: {
          serializedName: "ClearRange",
          xmlName: "ClearRange",
          xmlElementName: "ClearRange",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ClearRange"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageRange = {
    serializedName: "PageRange",
    xmlName: "PageRange",
    type: {
      name: "Composite",
      className: "PageRange",
      modelProperties: {
        start: {
          serializedName: "Start",
          required: true,
          xmlName: "Start",
          type: {
            name: "Number"
          }
        },
        end: {
          serializedName: "End",
          required: true,
          xmlName: "End",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var ClearRange = {
    serializedName: "ClearRange",
    xmlName: "ClearRange",
    type: {
      name: "Composite",
      className: "ClearRange",
      modelProperties: {
        start: {
          serializedName: "Start",
          required: true,
          xmlName: "Start",
          type: {
            name: "Number"
          }
        },
        end: {
          serializedName: "End",
          required: true,
          xmlName: "End",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var QueryRequest = {
    serializedName: "QueryRequest",
    xmlName: "QueryRequest",
    type: {
      name: "Composite",
      className: "QueryRequest",
      modelProperties: {
        queryType: {
          serializedName: "QueryType",
          required: true,
          xmlName: "QueryType",
          type: {
            name: "String"
          }
        },
        expression: {
          serializedName: "Expression",
          required: true,
          xmlName: "Expression",
          type: {
            name: "String"
          }
        },
        inputSerialization: {
          serializedName: "InputSerialization",
          xmlName: "InputSerialization",
          type: {
            name: "Composite",
            className: "QuerySerialization"
          }
        },
        outputSerialization: {
          serializedName: "OutputSerialization",
          xmlName: "OutputSerialization",
          type: {
            name: "Composite",
            className: "QuerySerialization"
          }
        }
      }
    }
  };
  var QuerySerialization = {
    serializedName: "QuerySerialization",
    type: {
      name: "Composite",
      className: "QuerySerialization",
      modelProperties: {
        format: {
          serializedName: "Format",
          xmlName: "Format",
          type: {
            name: "Composite",
            className: "QueryFormat"
          }
        }
      }
    }
  };
  var QueryFormat = {
    serializedName: "QueryFormat",
    type: {
      name: "Composite",
      className: "QueryFormat",
      modelProperties: {
        type: {
          serializedName: "Type",
          required: true,
          xmlName: "Type",
          type: {
            name: "Enum",
            allowedValues: ["delimited", "json", "arrow", "parquet"]
          }
        },
        delimitedTextConfiguration: {
          serializedName: "DelimitedTextConfiguration",
          xmlName: "DelimitedTextConfiguration",
          type: {
            name: "Composite",
            className: "DelimitedTextConfiguration"
          }
        },
        jsonTextConfiguration: {
          serializedName: "JsonTextConfiguration",
          xmlName: "JsonTextConfiguration",
          type: {
            name: "Composite",
            className: "JsonTextConfiguration"
          }
        },
        arrowConfiguration: {
          serializedName: "ArrowConfiguration",
          xmlName: "ArrowConfiguration",
          type: {
            name: "Composite",
            className: "ArrowConfiguration"
          }
        },
        parquetTextConfiguration: {
          serializedName: "ParquetTextConfiguration",
          xmlName: "ParquetTextConfiguration",
          type: {
            name: "Dictionary",
            value: { type: { name: "any" } }
          }
        }
      }
    }
  };
  var DelimitedTextConfiguration = {
    serializedName: "DelimitedTextConfiguration",
    xmlName: "DelimitedTextConfiguration",
    type: {
      name: "Composite",
      className: "DelimitedTextConfiguration",
      modelProperties: {
        columnSeparator: {
          serializedName: "ColumnSeparator",
          xmlName: "ColumnSeparator",
          type: {
            name: "String"
          }
        },
        fieldQuote: {
          serializedName: "FieldQuote",
          xmlName: "FieldQuote",
          type: {
            name: "String"
          }
        },
        recordSeparator: {
          serializedName: "RecordSeparator",
          xmlName: "RecordSeparator",
          type: {
            name: "String"
          }
        },
        escapeChar: {
          serializedName: "EscapeChar",
          xmlName: "EscapeChar",
          type: {
            name: "String"
          }
        },
        headersPresent: {
          serializedName: "HeadersPresent",
          xmlName: "HasHeaders",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var JsonTextConfiguration = {
    serializedName: "JsonTextConfiguration",
    xmlName: "JsonTextConfiguration",
    type: {
      name: "Composite",
      className: "JsonTextConfiguration",
      modelProperties: {
        recordSeparator: {
          serializedName: "RecordSeparator",
          xmlName: "RecordSeparator",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ArrowConfiguration = {
    serializedName: "ArrowConfiguration",
    xmlName: "ArrowConfiguration",
    type: {
      name: "Composite",
      className: "ArrowConfiguration",
      modelProperties: {
        schema: {
          serializedName: "Schema",
          required: true,
          xmlName: "Schema",
          xmlIsWrapped: true,
          xmlElementName: "Field",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ArrowField"
              }
            }
          }
        }
      }
    }
  };
  var ArrowField = {
    serializedName: "ArrowField",
    xmlName: "Field",
    type: {
      name: "Composite",
      className: "ArrowField",
      modelProperties: {
        type: {
          serializedName: "Type",
          required: true,
          xmlName: "Type",
          type: {
            name: "String"
          }
        },
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        precision: {
          serializedName: "Precision",
          xmlName: "Precision",
          type: {
            name: "Number"
          }
        },
        scale: {
          serializedName: "Scale",
          xmlName: "Scale",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  var ServiceSetPropertiesHeaders = {
    serializedName: "Service_setPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ServiceSetPropertiesHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceSetPropertiesExceptionHeaders = {
    serializedName: "Service_setPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceSetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetPropertiesHeaders = {
    serializedName: "Service_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetPropertiesHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetPropertiesExceptionHeaders = {
    serializedName: "Service_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetStatisticsHeaders = {
    serializedName: "Service_getStatisticsHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetStatisticsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetStatisticsExceptionHeaders = {
    serializedName: "Service_getStatisticsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetStatisticsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceListContainersSegmentHeaders = {
    serializedName: "Service_listContainersSegmentHeaders",
    type: {
      name: "Composite",
      className: "ServiceListContainersSegmentHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceListContainersSegmentExceptionHeaders = {
    serializedName: "Service_listContainersSegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceListContainersSegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetUserDelegationKeyHeaders = {
    serializedName: "Service_getUserDelegationKeyHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetUserDelegationKeyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetUserDelegationKeyExceptionHeaders = {
    serializedName: "Service_getUserDelegationKeyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetUserDelegationKeyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetAccountInfoHeaders = {
    serializedName: "Service_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceGetAccountInfoExceptionHeaders = {
    serializedName: "Service_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceSubmitBatchHeaders = {
    serializedName: "Service_submitBatchHeaders",
    type: {
      name: "Composite",
      className: "ServiceSubmitBatchHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceSubmitBatchExceptionHeaders = {
    serializedName: "Service_submitBatchExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceSubmitBatchExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceFilterBlobsHeaders = {
    serializedName: "Service_filterBlobsHeaders",
    type: {
      name: "Composite",
      className: "ServiceFilterBlobsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ServiceFilterBlobsExceptionHeaders = {
    serializedName: "Service_filterBlobsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceFilterBlobsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerCreateHeaders = {
    serializedName: "Container_createHeaders",
    type: {
      name: "Composite",
      className: "ContainerCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerCreateExceptionHeaders = {
    serializedName: "Container_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerGetPropertiesHeaders = {
    serializedName: "Container_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetPropertiesHeaders",
      modelProperties: {
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobPublicAccess: {
          serializedName: "x-ms-blob-public-access",
          xmlName: "x-ms-blob-public-access",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        hasImmutabilityPolicy: {
          serializedName: "x-ms-has-immutability-policy",
          xmlName: "x-ms-has-immutability-policy",
          type: {
            name: "Boolean"
          }
        },
        hasLegalHold: {
          serializedName: "x-ms-has-legal-hold",
          xmlName: "x-ms-has-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        defaultEncryptionScope: {
          serializedName: "x-ms-default-encryption-scope",
          xmlName: "x-ms-default-encryption-scope",
          type: {
            name: "String"
          }
        },
        denyEncryptionScopeOverride: {
          serializedName: "x-ms-deny-encryption-scope-override",
          xmlName: "x-ms-deny-encryption-scope-override",
          type: {
            name: "Boolean"
          }
        },
        isImmutableStorageWithVersioningEnabled: {
          serializedName: "x-ms-immutable-storage-with-versioning-enabled",
          xmlName: "x-ms-immutable-storage-with-versioning-enabled",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerGetPropertiesExceptionHeaders = {
    serializedName: "Container_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerDeleteHeaders = {
    serializedName: "Container_deleteHeaders",
    type: {
      name: "Composite",
      className: "ContainerDeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerDeleteExceptionHeaders = {
    serializedName: "Container_deleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerDeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSetMetadataHeaders = {
    serializedName: "Container_setMetadataHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetMetadataHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSetMetadataExceptionHeaders = {
    serializedName: "Container_setMetadataExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetMetadataExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerGetAccessPolicyHeaders = {
    serializedName: "Container_getAccessPolicyHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccessPolicyHeaders",
      modelProperties: {
        blobPublicAccess: {
          serializedName: "x-ms-blob-public-access",
          xmlName: "x-ms-blob-public-access",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerGetAccessPolicyExceptionHeaders = {
    serializedName: "Container_getAccessPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccessPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSetAccessPolicyHeaders = {
    serializedName: "Container_setAccessPolicyHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetAccessPolicyHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSetAccessPolicyExceptionHeaders = {
    serializedName: "Container_setAccessPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetAccessPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerRestoreHeaders = {
    serializedName: "Container_restoreHeaders",
    type: {
      name: "Composite",
      className: "ContainerRestoreHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerRestoreExceptionHeaders = {
    serializedName: "Container_restoreExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRestoreExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerRenameHeaders = {
    serializedName: "Container_renameHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenameHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerRenameExceptionHeaders = {
    serializedName: "Container_renameExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenameExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSubmitBatchHeaders = {
    serializedName: "Container_submitBatchHeaders",
    type: {
      name: "Composite",
      className: "ContainerSubmitBatchHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerSubmitBatchExceptionHeaders = {
    serializedName: "Container_submitBatchExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSubmitBatchExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerFilterBlobsHeaders = {
    serializedName: "Container_filterBlobsHeaders",
    type: {
      name: "Composite",
      className: "ContainerFilterBlobsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerFilterBlobsExceptionHeaders = {
    serializedName: "Container_filterBlobsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerFilterBlobsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerAcquireLeaseHeaders = {
    serializedName: "Container_acquireLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerAcquireLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerAcquireLeaseExceptionHeaders = {
    serializedName: "Container_acquireLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerAcquireLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerReleaseLeaseHeaders = {
    serializedName: "Container_releaseLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerReleaseLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerReleaseLeaseExceptionHeaders = {
    serializedName: "Container_releaseLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerReleaseLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerRenewLeaseHeaders = {
    serializedName: "Container_renewLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenewLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerRenewLeaseExceptionHeaders = {
    serializedName: "Container_renewLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenewLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerBreakLeaseHeaders = {
    serializedName: "Container_breakLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerBreakLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseTime: {
          serializedName: "x-ms-lease-time",
          xmlName: "x-ms-lease-time",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerBreakLeaseExceptionHeaders = {
    serializedName: "Container_breakLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerBreakLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerChangeLeaseHeaders = {
    serializedName: "Container_changeLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerChangeLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var ContainerChangeLeaseExceptionHeaders = {
    serializedName: "Container_changeLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerChangeLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerListBlobFlatSegmentHeaders = {
    serializedName: "Container_listBlobFlatSegmentHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobFlatSegmentHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerListBlobFlatSegmentExceptionHeaders = {
    serializedName: "Container_listBlobFlatSegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobFlatSegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerListBlobHierarchySegmentHeaders = {
    serializedName: "Container_listBlobHierarchySegmentHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobHierarchySegmentHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerListBlobHierarchySegmentExceptionHeaders = {
    serializedName: "Container_listBlobHierarchySegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobHierarchySegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var ContainerGetAccountInfoHeaders = {
    serializedName: "Container_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var ContainerGetAccountInfoExceptionHeaders = {
    serializedName: "Container_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobDownloadHeaders = {
    serializedName: "Blob_downloadHeaders",
    type: {
      name: "Composite",
      className: "BlobDownloadHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        createdOn: {
          serializedName: "x-ms-creation-time",
          xmlName: "x-ms-creation-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        objectReplicationPolicyId: {
          serializedName: "x-ms-or-policy-id",
          xmlName: "x-ms-or-policy-id",
          type: {
            name: "String"
          }
        },
        objectReplicationRules: {
          serializedName: "x-ms-or",
          headerCollectionPrefix: "x-ms-or-",
          xmlName: "x-ms-or",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        contentRange: {
          serializedName: "content-range",
          xmlName: "content-range",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletedOn: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "x-ms-is-current-version",
          xmlName: "x-ms-is-current-version",
          type: {
            name: "Boolean"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        blobContentMD5: {
          serializedName: "x-ms-blob-content-md5",
          xmlName: "x-ms-blob-content-md5",
          type: {
            name: "ByteArray"
          }
        },
        tagCount: {
          serializedName: "x-ms-tag-count",
          xmlName: "x-ms-tag-count",
          type: {
            name: "Number"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        },
        lastAccessed: {
          serializedName: "x-ms-last-access-time",
          xmlName: "x-ms-last-access-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        contentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        }
      }
    }
  };
  var BlobDownloadExceptionHeaders = {
    serializedName: "Blob_downloadExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDownloadExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobGetPropertiesHeaders = {
    serializedName: "Blob_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "BlobGetPropertiesHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        createdOn: {
          serializedName: "x-ms-creation-time",
          xmlName: "x-ms-creation-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        objectReplicationPolicyId: {
          serializedName: "x-ms-or-policy-id",
          xmlName: "x-ms-or-policy-id",
          type: {
            name: "String"
          }
        },
        objectReplicationRules: {
          serializedName: "x-ms-or",
          headerCollectionPrefix: "x-ms-or-",
          xmlName: "x-ms-or",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletedOn: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        isIncrementalCopy: {
          serializedName: "x-ms-incremental-copy",
          xmlName: "x-ms-incremental-copy",
          type: {
            name: "Boolean"
          }
        },
        destinationSnapshot: {
          serializedName: "x-ms-copy-destination-snapshot",
          xmlName: "x-ms-copy-destination-snapshot",
          type: {
            name: "String"
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        accessTier: {
          serializedName: "x-ms-access-tier",
          xmlName: "x-ms-access-tier",
          type: {
            name: "String"
          }
        },
        accessTierInferred: {
          serializedName: "x-ms-access-tier-inferred",
          xmlName: "x-ms-access-tier-inferred",
          type: {
            name: "Boolean"
          }
        },
        archiveStatus: {
          serializedName: "x-ms-archive-status",
          xmlName: "x-ms-archive-status",
          type: {
            name: "String"
          }
        },
        accessTierChangedOn: {
          serializedName: "x-ms-access-tier-change-time",
          xmlName: "x-ms-access-tier-change-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "x-ms-is-current-version",
          xmlName: "x-ms-is-current-version",
          type: {
            name: "Boolean"
          }
        },
        tagCount: {
          serializedName: "x-ms-tag-count",
          xmlName: "x-ms-tag-count",
          type: {
            name: "Number"
          }
        },
        expiresOn: {
          serializedName: "x-ms-expiry-time",
          xmlName: "x-ms-expiry-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        },
        rehydratePriority: {
          serializedName: "x-ms-rehydrate-priority",
          xmlName: "x-ms-rehydrate-priority",
          type: {
            name: "Enum",
            allowedValues: ["High", "Standard"]
          }
        },
        lastAccessed: {
          serializedName: "x-ms-last-access-time",
          xmlName: "x-ms-last-access-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobGetPropertiesExceptionHeaders = {
    serializedName: "Blob_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobDeleteHeaders = {
    serializedName: "Blob_deleteHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobDeleteExceptionHeaders = {
    serializedName: "Blob_deleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobUndeleteHeaders = {
    serializedName: "Blob_undeleteHeaders",
    type: {
      name: "Composite",
      className: "BlobUndeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobUndeleteExceptionHeaders = {
    serializedName: "Blob_undeleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobUndeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetExpiryHeaders = {
    serializedName: "Blob_setExpiryHeaders",
    type: {
      name: "Composite",
      className: "BlobSetExpiryHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobSetExpiryExceptionHeaders = {
    serializedName: "Blob_setExpiryExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetExpiryExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetHttpHeadersHeaders = {
    serializedName: "Blob_setHttpHeadersHeaders",
    type: {
      name: "Composite",
      className: "BlobSetHttpHeadersHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetHttpHeadersExceptionHeaders = {
    serializedName: "Blob_setHttpHeadersExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetHttpHeadersExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetImmutabilityPolicyHeaders = {
    serializedName: "Blob_setImmutabilityPolicyHeaders",
    type: {
      name: "Composite",
      className: "BlobSetImmutabilityPolicyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiry: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        }
      }
    }
  };
  var BlobSetImmutabilityPolicyExceptionHeaders = {
    serializedName: "Blob_setImmutabilityPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetImmutabilityPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobDeleteImmutabilityPolicyHeaders = {
    serializedName: "Blob_deleteImmutabilityPolicyHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteImmutabilityPolicyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobDeleteImmutabilityPolicyExceptionHeaders = {
    serializedName: "Blob_deleteImmutabilityPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteImmutabilityPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetLegalHoldHeaders = {
    serializedName: "Blob_setLegalHoldHeaders",
    type: {
      name: "Composite",
      className: "BlobSetLegalHoldHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var BlobSetLegalHoldExceptionHeaders = {
    serializedName: "Blob_setLegalHoldExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetLegalHoldExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetMetadataHeaders = {
    serializedName: "Blob_setMetadataHeaders",
    type: {
      name: "Composite",
      className: "BlobSetMetadataHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetMetadataExceptionHeaders = {
    serializedName: "Blob_setMetadataExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetMetadataExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobAcquireLeaseHeaders = {
    serializedName: "Blob_acquireLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobAcquireLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobAcquireLeaseExceptionHeaders = {
    serializedName: "Blob_acquireLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobAcquireLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobReleaseLeaseHeaders = {
    serializedName: "Blob_releaseLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobReleaseLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobReleaseLeaseExceptionHeaders = {
    serializedName: "Blob_releaseLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobReleaseLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobRenewLeaseHeaders = {
    serializedName: "Blob_renewLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobRenewLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobRenewLeaseExceptionHeaders = {
    serializedName: "Blob_renewLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobRenewLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobChangeLeaseHeaders = {
    serializedName: "Blob_changeLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobChangeLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobChangeLeaseExceptionHeaders = {
    serializedName: "Blob_changeLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobChangeLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobBreakLeaseHeaders = {
    serializedName: "Blob_breakLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobBreakLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseTime: {
          serializedName: "x-ms-lease-time",
          xmlName: "x-ms-lease-time",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  var BlobBreakLeaseExceptionHeaders = {
    serializedName: "Blob_breakLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobBreakLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobCreateSnapshotHeaders = {
    serializedName: "Blob_createSnapshotHeaders",
    type: {
      name: "Composite",
      className: "BlobCreateSnapshotHeaders",
      modelProperties: {
        snapshot: {
          serializedName: "x-ms-snapshot",
          xmlName: "x-ms-snapshot",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobCreateSnapshotExceptionHeaders = {
    serializedName: "Blob_createSnapshotExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobCreateSnapshotExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobStartCopyFromURLHeaders = {
    serializedName: "Blob_startCopyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobStartCopyFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobStartCopyFromURLExceptionHeaders = {
    serializedName: "Blob_startCopyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobStartCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobCopyFromURLHeaders = {
    serializedName: "Blob_copyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobCopyFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          defaultValue: "success",
          isConstant: true,
          serializedName: "x-ms-copy-status",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobCopyFromURLExceptionHeaders = {
    serializedName: "Blob_copyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobAbortCopyFromURLHeaders = {
    serializedName: "Blob_abortCopyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobAbortCopyFromURLHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobAbortCopyFromURLExceptionHeaders = {
    serializedName: "Blob_abortCopyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobAbortCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetTierHeaders = {
    serializedName: "Blob_setTierHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTierHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetTierExceptionHeaders = {
    serializedName: "Blob_setTierExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTierExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobGetAccountInfoHeaders = {
    serializedName: "Blob_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "BlobGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var BlobGetAccountInfoExceptionHeaders = {
    serializedName: "Blob_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobQueryHeaders = {
    serializedName: "Blob_queryHeaders",
    type: {
      name: "Composite",
      className: "BlobQueryHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        contentRange: {
          serializedName: "content-range",
          xmlName: "content-range",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletionTime: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        blobContentMD5: {
          serializedName: "x-ms-blob-content-md5",
          xmlName: "x-ms-blob-content-md5",
          type: {
            name: "ByteArray"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        contentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        }
      }
    }
  };
  var BlobQueryExceptionHeaders = {
    serializedName: "Blob_queryExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobQueryExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobGetTagsHeaders = {
    serializedName: "Blob_getTagsHeaders",
    type: {
      name: "Composite",
      className: "BlobGetTagsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobGetTagsExceptionHeaders = {
    serializedName: "Blob_getTagsExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetTagsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetTagsHeaders = {
    serializedName: "Blob_setTagsHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTagsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlobSetTagsExceptionHeaders = {
    serializedName: "Blob_setTagsExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTagsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobCreateHeaders = {
    serializedName: "PageBlob_createHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobCreateExceptionHeaders = {
    serializedName: "PageBlob_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUploadPagesHeaders = {
    serializedName: "PageBlob_uploadPagesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUploadPagesExceptionHeaders = {
    serializedName: "PageBlob_uploadPagesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobClearPagesHeaders = {
    serializedName: "PageBlob_clearPagesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobClearPagesHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobClearPagesExceptionHeaders = {
    serializedName: "PageBlob_clearPagesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobClearPagesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUploadPagesFromURLHeaders = {
    serializedName: "PageBlob_uploadPagesFromURLHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUploadPagesFromURLExceptionHeaders = {
    serializedName: "PageBlob_uploadPagesFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobGetPageRangesHeaders = {
    serializedName: "PageBlob_getPageRangesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobGetPageRangesExceptionHeaders = {
    serializedName: "PageBlob_getPageRangesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobGetPageRangesDiffHeaders = {
    serializedName: "PageBlob_getPageRangesDiffHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesDiffHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobGetPageRangesDiffExceptionHeaders = {
    serializedName: "PageBlob_getPageRangesDiffExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesDiffExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobResizeHeaders = {
    serializedName: "PageBlob_resizeHeaders",
    type: {
      name: "Composite",
      className: "PageBlobResizeHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobResizeExceptionHeaders = {
    serializedName: "PageBlob_resizeExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobResizeExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUpdateSequenceNumberHeaders = {
    serializedName: "PageBlob_updateSequenceNumberHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUpdateSequenceNumberHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobUpdateSequenceNumberExceptionHeaders = {
    serializedName: "PageBlob_updateSequenceNumberExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUpdateSequenceNumberExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobCopyIncrementalHeaders = {
    serializedName: "PageBlob_copyIncrementalHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCopyIncrementalHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var PageBlobCopyIncrementalExceptionHeaders = {
    serializedName: "PageBlob_copyIncrementalExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCopyIncrementalExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobCreateHeaders = {
    serializedName: "AppendBlob_createHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobCreateExceptionHeaders = {
    serializedName: "AppendBlob_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobAppendBlockHeaders = {
    serializedName: "AppendBlob_appendBlockHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobAppendOffset: {
          serializedName: "x-ms-blob-append-offset",
          xmlName: "x-ms-blob-append-offset",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobAppendBlockExceptionHeaders = {
    serializedName: "AppendBlob_appendBlockExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobAppendBlockFromUrlHeaders = {
    serializedName: "AppendBlob_appendBlockFromUrlHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockFromUrlHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobAppendOffset: {
          serializedName: "x-ms-blob-append-offset",
          xmlName: "x-ms-blob-append-offset",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobAppendBlockFromUrlExceptionHeaders = {
    serializedName: "AppendBlob_appendBlockFromUrlExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockFromUrlExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var AppendBlobSealHeaders = {
    serializedName: "AppendBlob_sealHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobSealHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  var AppendBlobSealExceptionHeaders = {
    serializedName: "AppendBlob_sealExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobSealExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobUploadHeaders = {
    serializedName: "BlockBlob_uploadHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobUploadHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobUploadExceptionHeaders = {
    serializedName: "BlockBlob_uploadExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobUploadExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobPutBlobFromUrlHeaders = {
    serializedName: "BlockBlob_putBlobFromUrlHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobPutBlobFromUrlHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobPutBlobFromUrlExceptionHeaders = {
    serializedName: "BlockBlob_putBlobFromUrlExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobPutBlobFromUrlExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobStageBlockHeaders = {
    serializedName: "BlockBlob_stageBlockHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockHeaders",
      modelProperties: {
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobStageBlockExceptionHeaders = {
    serializedName: "BlockBlob_stageBlockExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobStageBlockFromURLHeaders = {
    serializedName: "BlockBlob_stageBlockFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockFromURLHeaders",
      modelProperties: {
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobStageBlockFromURLExceptionHeaders = {
    serializedName: "BlockBlob_stageBlockFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobCommitBlockListHeaders = {
    serializedName: "BlockBlob_commitBlockListHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobCommitBlockListHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobCommitBlockListExceptionHeaders = {
    serializedName: "BlockBlob_commitBlockListExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobCommitBlockListExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobGetBlockListHeaders = {
    serializedName: "BlockBlob_getBlockListHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobGetBlockListHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var BlockBlobGetBlockListExceptionHeaders = {
    serializedName: "BlockBlob_getBlockListExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobGetBlockListExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  var Mappers = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    AccessPolicy,
    AppendBlobAppendBlockExceptionHeaders,
    AppendBlobAppendBlockFromUrlExceptionHeaders,
    AppendBlobAppendBlockFromUrlHeaders,
    AppendBlobAppendBlockHeaders,
    AppendBlobCreateExceptionHeaders,
    AppendBlobCreateHeaders,
    AppendBlobSealExceptionHeaders,
    AppendBlobSealHeaders,
    ArrowConfiguration,
    ArrowField,
    BlobAbortCopyFromURLExceptionHeaders,
    BlobAbortCopyFromURLHeaders,
    BlobAcquireLeaseExceptionHeaders,
    BlobAcquireLeaseHeaders,
    BlobBreakLeaseExceptionHeaders,
    BlobBreakLeaseHeaders,
    BlobChangeLeaseExceptionHeaders,
    BlobChangeLeaseHeaders,
    BlobCopyFromURLExceptionHeaders,
    BlobCopyFromURLHeaders,
    BlobCreateSnapshotExceptionHeaders,
    BlobCreateSnapshotHeaders,
    BlobDeleteExceptionHeaders,
    BlobDeleteHeaders,
    BlobDeleteImmutabilityPolicyExceptionHeaders,
    BlobDeleteImmutabilityPolicyHeaders,
    BlobDownloadExceptionHeaders,
    BlobDownloadHeaders,
    BlobFlatListSegment,
    BlobGetAccountInfoExceptionHeaders,
    BlobGetAccountInfoHeaders,
    BlobGetPropertiesExceptionHeaders,
    BlobGetPropertiesHeaders,
    BlobGetTagsExceptionHeaders,
    BlobGetTagsHeaders,
    BlobHierarchyListSegment,
    BlobItemInternal,
    BlobName,
    BlobPrefix,
    BlobPropertiesInternal,
    BlobQueryExceptionHeaders,
    BlobQueryHeaders,
    BlobReleaseLeaseExceptionHeaders,
    BlobReleaseLeaseHeaders,
    BlobRenewLeaseExceptionHeaders,
    BlobRenewLeaseHeaders,
    BlobServiceProperties,
    BlobServiceStatistics,
    BlobSetExpiryExceptionHeaders,
    BlobSetExpiryHeaders,
    BlobSetHttpHeadersExceptionHeaders,
    BlobSetHttpHeadersHeaders,
    BlobSetImmutabilityPolicyExceptionHeaders,
    BlobSetImmutabilityPolicyHeaders,
    BlobSetLegalHoldExceptionHeaders,
    BlobSetLegalHoldHeaders,
    BlobSetMetadataExceptionHeaders,
    BlobSetMetadataHeaders,
    BlobSetTagsExceptionHeaders,
    BlobSetTagsHeaders,
    BlobSetTierExceptionHeaders,
    BlobSetTierHeaders,
    BlobStartCopyFromURLExceptionHeaders,
    BlobStartCopyFromURLHeaders,
    BlobTag,
    BlobTags,
    BlobUndeleteExceptionHeaders,
    BlobUndeleteHeaders,
    Block,
    BlockBlobCommitBlockListExceptionHeaders,
    BlockBlobCommitBlockListHeaders,
    BlockBlobGetBlockListExceptionHeaders,
    BlockBlobGetBlockListHeaders,
    BlockBlobPutBlobFromUrlExceptionHeaders,
    BlockBlobPutBlobFromUrlHeaders,
    BlockBlobStageBlockExceptionHeaders,
    BlockBlobStageBlockFromURLExceptionHeaders,
    BlockBlobStageBlockFromURLHeaders,
    BlockBlobStageBlockHeaders,
    BlockBlobUploadExceptionHeaders,
    BlockBlobUploadHeaders,
    BlockList,
    BlockLookupList,
    ClearRange,
    ContainerAcquireLeaseExceptionHeaders,
    ContainerAcquireLeaseHeaders,
    ContainerBreakLeaseExceptionHeaders,
    ContainerBreakLeaseHeaders,
    ContainerChangeLeaseExceptionHeaders,
    ContainerChangeLeaseHeaders,
    ContainerCreateExceptionHeaders,
    ContainerCreateHeaders,
    ContainerDeleteExceptionHeaders,
    ContainerDeleteHeaders,
    ContainerFilterBlobsExceptionHeaders,
    ContainerFilterBlobsHeaders,
    ContainerGetAccessPolicyExceptionHeaders,
    ContainerGetAccessPolicyHeaders,
    ContainerGetAccountInfoExceptionHeaders,
    ContainerGetAccountInfoHeaders,
    ContainerGetPropertiesExceptionHeaders,
    ContainerGetPropertiesHeaders,
    ContainerItem,
    ContainerListBlobFlatSegmentExceptionHeaders,
    ContainerListBlobFlatSegmentHeaders,
    ContainerListBlobHierarchySegmentExceptionHeaders,
    ContainerListBlobHierarchySegmentHeaders,
    ContainerProperties,
    ContainerReleaseLeaseExceptionHeaders,
    ContainerReleaseLeaseHeaders,
    ContainerRenameExceptionHeaders,
    ContainerRenameHeaders,
    ContainerRenewLeaseExceptionHeaders,
    ContainerRenewLeaseHeaders,
    ContainerRestoreExceptionHeaders,
    ContainerRestoreHeaders,
    ContainerSetAccessPolicyExceptionHeaders,
    ContainerSetAccessPolicyHeaders,
    ContainerSetMetadataExceptionHeaders,
    ContainerSetMetadataHeaders,
    ContainerSubmitBatchExceptionHeaders,
    ContainerSubmitBatchHeaders,
    CorsRule,
    DelimitedTextConfiguration,
    FilterBlobItem,
    FilterBlobSegment,
    GeoReplication,
    JsonTextConfiguration,
    KeyInfo,
    ListBlobsFlatSegmentResponse,
    ListBlobsHierarchySegmentResponse,
    ListContainersSegmentResponse,
    Logging,
    Metrics,
    PageBlobClearPagesExceptionHeaders,
    PageBlobClearPagesHeaders,
    PageBlobCopyIncrementalExceptionHeaders,
    PageBlobCopyIncrementalHeaders,
    PageBlobCreateExceptionHeaders,
    PageBlobCreateHeaders,
    PageBlobGetPageRangesDiffExceptionHeaders,
    PageBlobGetPageRangesDiffHeaders,
    PageBlobGetPageRangesExceptionHeaders,
    PageBlobGetPageRangesHeaders,
    PageBlobResizeExceptionHeaders,
    PageBlobResizeHeaders,
    PageBlobUpdateSequenceNumberExceptionHeaders,
    PageBlobUpdateSequenceNumberHeaders,
    PageBlobUploadPagesExceptionHeaders,
    PageBlobUploadPagesFromURLExceptionHeaders,
    PageBlobUploadPagesFromURLHeaders,
    PageBlobUploadPagesHeaders,
    PageList,
    PageRange,
    QueryFormat,
    QueryRequest,
    QuerySerialization,
    RetentionPolicy,
    ServiceFilterBlobsExceptionHeaders,
    ServiceFilterBlobsHeaders,
    ServiceGetAccountInfoExceptionHeaders,
    ServiceGetAccountInfoHeaders,
    ServiceGetPropertiesExceptionHeaders,
    ServiceGetPropertiesHeaders,
    ServiceGetStatisticsExceptionHeaders,
    ServiceGetStatisticsHeaders,
    ServiceGetUserDelegationKeyExceptionHeaders,
    ServiceGetUserDelegationKeyHeaders,
    ServiceListContainersSegmentExceptionHeaders,
    ServiceListContainersSegmentHeaders,
    ServiceSetPropertiesExceptionHeaders,
    ServiceSetPropertiesHeaders,
    ServiceSubmitBatchExceptionHeaders,
    ServiceSubmitBatchHeaders,
    SignedIdentifier,
    StaticWebsite,
    StorageError,
    UserDelegationKey
  });
  var contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  var blobServiceProperties = {
    parameterPath: "blobServiceProperties",
    mapper: BlobServiceProperties
  };
  var accept = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  var url = {
    parameterPath: "url",
    mapper: {
      serializedName: "url",
      required: true,
      xmlName: "url",
      type: {
        name: "String"
      }
    },
    skipEncoding: true
  };
  var restype = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "service",
      isConstant: true,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  var comp = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "properties",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var timeoutInSeconds = {
    parameterPath: ["options", "timeoutInSeconds"],
    mapper: {
      constraints: {
        InclusiveMinimum: 0
      },
      serializedName: "timeout",
      xmlName: "timeout",
      type: {
        name: "Number"
      }
    }
  };
  var version = {
    parameterPath: "version",
    mapper: {
      defaultValue: "2025-05-05",
      isConstant: true,
      serializedName: "x-ms-version",
      type: {
        name: "String"
      }
    }
  };
  var requestId = {
    parameterPath: ["options", "requestId"],
    mapper: {
      serializedName: "x-ms-client-request-id",
      xmlName: "x-ms-client-request-id",
      type: {
        name: "String"
      }
    }
  };
  var accept1 = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  var comp1 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "stats",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var comp2 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "list",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var prefix = {
    parameterPath: ["options", "prefix"],
    mapper: {
      serializedName: "prefix",
      xmlName: "prefix",
      type: {
        name: "String"
      }
    }
  };
  var marker = {
    parameterPath: ["options", "marker"],
    mapper: {
      serializedName: "marker",
      xmlName: "marker",
      type: {
        name: "String"
      }
    }
  };
  var maxPageSize = {
    parameterPath: ["options", "maxPageSize"],
    mapper: {
      constraints: {
        InclusiveMinimum: 1
      },
      serializedName: "maxresults",
      xmlName: "maxresults",
      type: {
        name: "Number"
      }
    }
  };
  var include = {
    parameterPath: ["options", "include"],
    mapper: {
      serializedName: "include",
      xmlName: "include",
      xmlElementName: "ListContainersIncludeType",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Enum",
            allowedValues: ["metadata", "deleted", "system"]
          }
        }
      }
    },
    collectionFormat: "CSV"
  };
  var keyInfo = {
    parameterPath: "keyInfo",
    mapper: KeyInfo
  };
  var comp3 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "userdelegationkey",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var restype1 = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "account",
      isConstant: true,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  var body = {
    parameterPath: "body",
    mapper: {
      serializedName: "body",
      required: true,
      xmlName: "body",
      type: {
        name: "Stream"
      }
    }
  };
  var comp4 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "batch",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var contentLength = {
    parameterPath: "contentLength",
    mapper: {
      serializedName: "Content-Length",
      required: true,
      xmlName: "Content-Length",
      type: {
        name: "Number"
      }
    }
  };
  var multipartContentType = {
    parameterPath: "multipartContentType",
    mapper: {
      serializedName: "Content-Type",
      required: true,
      xmlName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  var comp5 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "blobs",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var where = {
    parameterPath: ["options", "where"],
    mapper: {
      serializedName: "where",
      xmlName: "where",
      type: {
        name: "String"
      }
    }
  };
  var restype2 = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "container",
      isConstant: true,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  var metadata = {
    parameterPath: ["options", "metadata"],
    mapper: {
      serializedName: "x-ms-meta",
      xmlName: "x-ms-meta",
      headerCollectionPrefix: "x-ms-meta-",
      type: {
        name: "Dictionary",
        value: { type: { name: "String" } }
      }
    }
  };
  var access = {
    parameterPath: ["options", "access"],
    mapper: {
      serializedName: "x-ms-blob-public-access",
      xmlName: "x-ms-blob-public-access",
      type: {
        name: "Enum",
        allowedValues: ["container", "blob"]
      }
    }
  };
  var defaultEncryptionScope = {
    parameterPath: [
      "options",
      "containerEncryptionScope",
      "defaultEncryptionScope"
    ],
    mapper: {
      serializedName: "x-ms-default-encryption-scope",
      xmlName: "x-ms-default-encryption-scope",
      type: {
        name: "String"
      }
    }
  };
  var preventEncryptionScopeOverride = {
    parameterPath: [
      "options",
      "containerEncryptionScope",
      "preventEncryptionScopeOverride"
    ],
    mapper: {
      serializedName: "x-ms-deny-encryption-scope-override",
      xmlName: "x-ms-deny-encryption-scope-override",
      type: {
        name: "Boolean"
      }
    }
  };
  var leaseId = {
    parameterPath: ["options", "leaseAccessConditions", "leaseId"],
    mapper: {
      serializedName: "x-ms-lease-id",
      xmlName: "x-ms-lease-id",
      type: {
        name: "String"
      }
    }
  };
  var ifModifiedSince = {
    parameterPath: ["options", "modifiedAccessConditions", "ifModifiedSince"],
    mapper: {
      serializedName: "If-Modified-Since",
      xmlName: "If-Modified-Since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  var ifUnmodifiedSince = {
    parameterPath: ["options", "modifiedAccessConditions", "ifUnmodifiedSince"],
    mapper: {
      serializedName: "If-Unmodified-Since",
      xmlName: "If-Unmodified-Since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  var comp6 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "metadata",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var comp7 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "acl",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var containerAcl = {
    parameterPath: ["options", "containerAcl"],
    mapper: {
      serializedName: "containerAcl",
      xmlName: "SignedIdentifiers",
      xmlIsWrapped: true,
      xmlElementName: "SignedIdentifier",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Composite",
            className: "SignedIdentifier"
          }
        }
      }
    }
  };
  var comp8 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "undelete",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var deletedContainerName = {
    parameterPath: ["options", "deletedContainerName"],
    mapper: {
      serializedName: "x-ms-deleted-container-name",
      xmlName: "x-ms-deleted-container-name",
      type: {
        name: "String"
      }
    }
  };
  var deletedContainerVersion = {
    parameterPath: ["options", "deletedContainerVersion"],
    mapper: {
      serializedName: "x-ms-deleted-container-version",
      xmlName: "x-ms-deleted-container-version",
      type: {
        name: "String"
      }
    }
  };
  var comp9 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "rename",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var sourceContainerName = {
    parameterPath: "sourceContainerName",
    mapper: {
      serializedName: "x-ms-source-container-name",
      required: true,
      xmlName: "x-ms-source-container-name",
      type: {
        name: "String"
      }
    }
  };
  var sourceLeaseId = {
    parameterPath: ["options", "sourceLeaseId"],
    mapper: {
      serializedName: "x-ms-source-lease-id",
      xmlName: "x-ms-source-lease-id",
      type: {
        name: "String"
      }
    }
  };
  var comp10 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "lease",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var action = {
    parameterPath: "action",
    mapper: {
      defaultValue: "acquire",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  var duration = {
    parameterPath: ["options", "duration"],
    mapper: {
      serializedName: "x-ms-lease-duration",
      xmlName: "x-ms-lease-duration",
      type: {
        name: "Number"
      }
    }
  };
  var proposedLeaseId = {
    parameterPath: ["options", "proposedLeaseId"],
    mapper: {
      serializedName: "x-ms-proposed-lease-id",
      xmlName: "x-ms-proposed-lease-id",
      type: {
        name: "String"
      }
    }
  };
  var action1 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "release",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  var leaseId1 = {
    parameterPath: "leaseId",
    mapper: {
      serializedName: "x-ms-lease-id",
      required: true,
      xmlName: "x-ms-lease-id",
      type: {
        name: "String"
      }
    }
  };
  var action2 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "renew",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  var action3 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "break",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  var breakPeriod = {
    parameterPath: ["options", "breakPeriod"],
    mapper: {
      serializedName: "x-ms-lease-break-period",
      xmlName: "x-ms-lease-break-period",
      type: {
        name: "Number"
      }
    }
  };
  var action4 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "change",
      isConstant: true,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  var proposedLeaseId1 = {
    parameterPath: "proposedLeaseId",
    mapper: {
      serializedName: "x-ms-proposed-lease-id",
      required: true,
      xmlName: "x-ms-proposed-lease-id",
      type: {
        name: "String"
      }
    }
  };
  var include1 = {
    parameterPath: ["options", "include"],
    mapper: {
      serializedName: "include",
      xmlName: "include",
      xmlElementName: "ListBlobsIncludeItem",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Enum",
            allowedValues: [
              "copy",
              "deleted",
              "metadata",
              "snapshots",
              "uncommittedblobs",
              "versions",
              "tags",
              "immutabilitypolicy",
              "legalhold",
              "deletedwithversions"
            ]
          }
        }
      }
    },
    collectionFormat: "CSV"
  };
  var delimiter = {
    parameterPath: "delimiter",
    mapper: {
      serializedName: "delimiter",
      required: true,
      xmlName: "delimiter",
      type: {
        name: "String"
      }
    }
  };
  var snapshot = {
    parameterPath: ["options", "snapshot"],
    mapper: {
      serializedName: "snapshot",
      xmlName: "snapshot",
      type: {
        name: "String"
      }
    }
  };
  var versionId = {
    parameterPath: ["options", "versionId"],
    mapper: {
      serializedName: "versionid",
      xmlName: "versionid",
      type: {
        name: "String"
      }
    }
  };
  var range = {
    parameterPath: ["options", "range"],
    mapper: {
      serializedName: "x-ms-range",
      xmlName: "x-ms-range",
      type: {
        name: "String"
      }
    }
  };
  var rangeGetContentMD5 = {
    parameterPath: ["options", "rangeGetContentMD5"],
    mapper: {
      serializedName: "x-ms-range-get-content-md5",
      xmlName: "x-ms-range-get-content-md5",
      type: {
        name: "Boolean"
      }
    }
  };
  var rangeGetContentCRC64 = {
    parameterPath: ["options", "rangeGetContentCRC64"],
    mapper: {
      serializedName: "x-ms-range-get-content-crc64",
      xmlName: "x-ms-range-get-content-crc64",
      type: {
        name: "Boolean"
      }
    }
  };
  var encryptionKey = {
    parameterPath: ["options", "cpkInfo", "encryptionKey"],
    mapper: {
      serializedName: "x-ms-encryption-key",
      xmlName: "x-ms-encryption-key",
      type: {
        name: "String"
      }
    }
  };
  var encryptionKeySha256 = {
    parameterPath: ["options", "cpkInfo", "encryptionKeySha256"],
    mapper: {
      serializedName: "x-ms-encryption-key-sha256",
      xmlName: "x-ms-encryption-key-sha256",
      type: {
        name: "String"
      }
    }
  };
  var encryptionAlgorithm = {
    parameterPath: ["options", "cpkInfo", "encryptionAlgorithm"],
    mapper: {
      serializedName: "x-ms-encryption-algorithm",
      xmlName: "x-ms-encryption-algorithm",
      type: {
        name: "String"
      }
    }
  };
  var ifMatch = {
    parameterPath: ["options", "modifiedAccessConditions", "ifMatch"],
    mapper: {
      serializedName: "If-Match",
      xmlName: "If-Match",
      type: {
        name: "String"
      }
    }
  };
  var ifNoneMatch = {
    parameterPath: ["options", "modifiedAccessConditions", "ifNoneMatch"],
    mapper: {
      serializedName: "If-None-Match",
      xmlName: "If-None-Match",
      type: {
        name: "String"
      }
    }
  };
  var ifTags = {
    parameterPath: ["options", "modifiedAccessConditions", "ifTags"],
    mapper: {
      serializedName: "x-ms-if-tags",
      xmlName: "x-ms-if-tags",
      type: {
        name: "String"
      }
    }
  };
  var deleteSnapshots = {
    parameterPath: ["options", "deleteSnapshots"],
    mapper: {
      serializedName: "x-ms-delete-snapshots",
      xmlName: "x-ms-delete-snapshots",
      type: {
        name: "Enum",
        allowedValues: ["include", "only"]
      }
    }
  };
  var blobDeleteType = {
    parameterPath: ["options", "blobDeleteType"],
    mapper: {
      serializedName: "deletetype",
      xmlName: "deletetype",
      type: {
        name: "String"
      }
    }
  };
  var comp11 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "expiry",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var expiryOptions = {
    parameterPath: "expiryOptions",
    mapper: {
      serializedName: "x-ms-expiry-option",
      required: true,
      xmlName: "x-ms-expiry-option",
      type: {
        name: "String"
      }
    }
  };
  var expiresOn = {
    parameterPath: ["options", "expiresOn"],
    mapper: {
      serializedName: "x-ms-expiry-time",
      xmlName: "x-ms-expiry-time",
      type: {
        name: "String"
      }
    }
  };
  var blobCacheControl = {
    parameterPath: ["options", "blobHttpHeaders", "blobCacheControl"],
    mapper: {
      serializedName: "x-ms-blob-cache-control",
      xmlName: "x-ms-blob-cache-control",
      type: {
        name: "String"
      }
    }
  };
  var blobContentType = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentType"],
    mapper: {
      serializedName: "x-ms-blob-content-type",
      xmlName: "x-ms-blob-content-type",
      type: {
        name: "String"
      }
    }
  };
  var blobContentMD5 = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentMD5"],
    mapper: {
      serializedName: "x-ms-blob-content-md5",
      xmlName: "x-ms-blob-content-md5",
      type: {
        name: "ByteArray"
      }
    }
  };
  var blobContentEncoding = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentEncoding"],
    mapper: {
      serializedName: "x-ms-blob-content-encoding",
      xmlName: "x-ms-blob-content-encoding",
      type: {
        name: "String"
      }
    }
  };
  var blobContentLanguage = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentLanguage"],
    mapper: {
      serializedName: "x-ms-blob-content-language",
      xmlName: "x-ms-blob-content-language",
      type: {
        name: "String"
      }
    }
  };
  var blobContentDisposition = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentDisposition"],
    mapper: {
      serializedName: "x-ms-blob-content-disposition",
      xmlName: "x-ms-blob-content-disposition",
      type: {
        name: "String"
      }
    }
  };
  var comp12 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "immutabilityPolicies",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var immutabilityPolicyExpiry = {
    parameterPath: ["options", "immutabilityPolicyExpiry"],
    mapper: {
      serializedName: "x-ms-immutability-policy-until-date",
      xmlName: "x-ms-immutability-policy-until-date",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  var immutabilityPolicyMode = {
    parameterPath: ["options", "immutabilityPolicyMode"],
    mapper: {
      serializedName: "x-ms-immutability-policy-mode",
      xmlName: "x-ms-immutability-policy-mode",
      type: {
        name: "Enum",
        allowedValues: ["Mutable", "Unlocked", "Locked"]
      }
    }
  };
  var comp13 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "legalhold",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var legalHold = {
    parameterPath: "legalHold",
    mapper: {
      serializedName: "x-ms-legal-hold",
      required: true,
      xmlName: "x-ms-legal-hold",
      type: {
        name: "Boolean"
      }
    }
  };
  var encryptionScope = {
    parameterPath: ["options", "encryptionScope"],
    mapper: {
      serializedName: "x-ms-encryption-scope",
      xmlName: "x-ms-encryption-scope",
      type: {
        name: "String"
      }
    }
  };
  var comp14 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "snapshot",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var tier = {
    parameterPath: ["options", "tier"],
    mapper: {
      serializedName: "x-ms-access-tier",
      xmlName: "x-ms-access-tier",
      type: {
        name: "Enum",
        allowedValues: [
          "P4",
          "P6",
          "P10",
          "P15",
          "P20",
          "P30",
          "P40",
          "P50",
          "P60",
          "P70",
          "P80",
          "Hot",
          "Cool",
          "Archive",
          "Cold"
        ]
      }
    }
  };
  var rehydratePriority = {
    parameterPath: ["options", "rehydratePriority"],
    mapper: {
      serializedName: "x-ms-rehydrate-priority",
      xmlName: "x-ms-rehydrate-priority",
      type: {
        name: "Enum",
        allowedValues: ["High", "Standard"]
      }
    }
  };
  var sourceIfModifiedSince = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfModifiedSince"
    ],
    mapper: {
      serializedName: "x-ms-source-if-modified-since",
      xmlName: "x-ms-source-if-modified-since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  var sourceIfUnmodifiedSince = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfUnmodifiedSince"
    ],
    mapper: {
      serializedName: "x-ms-source-if-unmodified-since",
      xmlName: "x-ms-source-if-unmodified-since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  var sourceIfMatch = {
    parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfMatch"],
    mapper: {
      serializedName: "x-ms-source-if-match",
      xmlName: "x-ms-source-if-match",
      type: {
        name: "String"
      }
    }
  };
  var sourceIfNoneMatch = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfNoneMatch"
    ],
    mapper: {
      serializedName: "x-ms-source-if-none-match",
      xmlName: "x-ms-source-if-none-match",
      type: {
        name: "String"
      }
    }
  };
  var sourceIfTags = {
    parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfTags"],
    mapper: {
      serializedName: "x-ms-source-if-tags",
      xmlName: "x-ms-source-if-tags",
      type: {
        name: "String"
      }
    }
  };
  var copySource = {
    parameterPath: "copySource",
    mapper: {
      serializedName: "x-ms-copy-source",
      required: true,
      xmlName: "x-ms-copy-source",
      type: {
        name: "String"
      }
    }
  };
  var blobTagsString = {
    parameterPath: ["options", "blobTagsString"],
    mapper: {
      serializedName: "x-ms-tags",
      xmlName: "x-ms-tags",
      type: {
        name: "String"
      }
    }
  };
  var sealBlob = {
    parameterPath: ["options", "sealBlob"],
    mapper: {
      serializedName: "x-ms-seal-blob",
      xmlName: "x-ms-seal-blob",
      type: {
        name: "Boolean"
      }
    }
  };
  var legalHold1 = {
    parameterPath: ["options", "legalHold"],
    mapper: {
      serializedName: "x-ms-legal-hold",
      xmlName: "x-ms-legal-hold",
      type: {
        name: "Boolean"
      }
    }
  };
  var xMsRequiresSync = {
    parameterPath: "xMsRequiresSync",
    mapper: {
      defaultValue: "true",
      isConstant: true,
      serializedName: "x-ms-requires-sync",
      type: {
        name: "String"
      }
    }
  };
  var sourceContentMD5 = {
    parameterPath: ["options", "sourceContentMD5"],
    mapper: {
      serializedName: "x-ms-source-content-md5",
      xmlName: "x-ms-source-content-md5",
      type: {
        name: "ByteArray"
      }
    }
  };
  var copySourceAuthorization = {
    parameterPath: ["options", "copySourceAuthorization"],
    mapper: {
      serializedName: "x-ms-copy-source-authorization",
      xmlName: "x-ms-copy-source-authorization",
      type: {
        name: "String"
      }
    }
  };
  var copySourceTags = {
    parameterPath: ["options", "copySourceTags"],
    mapper: {
      serializedName: "x-ms-copy-source-tag-option",
      xmlName: "x-ms-copy-source-tag-option",
      type: {
        name: "Enum",
        allowedValues: ["REPLACE", "COPY"]
      }
    }
  };
  var comp15 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "copy",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var copyActionAbortConstant = {
    parameterPath: "copyActionAbortConstant",
    mapper: {
      defaultValue: "abort",
      isConstant: true,
      serializedName: "x-ms-copy-action",
      type: {
        name: "String"
      }
    }
  };
  var copyId = {
    parameterPath: "copyId",
    mapper: {
      serializedName: "copyid",
      required: true,
      xmlName: "copyid",
      type: {
        name: "String"
      }
    }
  };
  var comp16 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "tier",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var tier1 = {
    parameterPath: "tier",
    mapper: {
      serializedName: "x-ms-access-tier",
      required: true,
      xmlName: "x-ms-access-tier",
      type: {
        name: "Enum",
        allowedValues: [
          "P4",
          "P6",
          "P10",
          "P15",
          "P20",
          "P30",
          "P40",
          "P50",
          "P60",
          "P70",
          "P80",
          "Hot",
          "Cool",
          "Archive",
          "Cold"
        ]
      }
    }
  };
  var queryRequest = {
    parameterPath: ["options", "queryRequest"],
    mapper: QueryRequest
  };
  var comp17 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "query",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var comp18 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "tags",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var tags = {
    parameterPath: ["options", "tags"],
    mapper: BlobTags
  };
  var transactionalContentMD5 = {
    parameterPath: ["options", "transactionalContentMD5"],
    mapper: {
      serializedName: "Content-MD5",
      xmlName: "Content-MD5",
      type: {
        name: "ByteArray"
      }
    }
  };
  var transactionalContentCrc64 = {
    parameterPath: ["options", "transactionalContentCrc64"],
    mapper: {
      serializedName: "x-ms-content-crc64",
      xmlName: "x-ms-content-crc64",
      type: {
        name: "ByteArray"
      }
    }
  };
  var blobType = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "PageBlob",
      isConstant: true,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  var blobContentLength = {
    parameterPath: "blobContentLength",
    mapper: {
      serializedName: "x-ms-blob-content-length",
      required: true,
      xmlName: "x-ms-blob-content-length",
      type: {
        name: "Number"
      }
    }
  };
  var blobSequenceNumber = {
    parameterPath: ["options", "blobSequenceNumber"],
    mapper: {
      defaultValue: 0,
      serializedName: "x-ms-blob-sequence-number",
      xmlName: "x-ms-blob-sequence-number",
      type: {
        name: "Number"
      }
    }
  };
  var contentType1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
      defaultValue: "application/octet-stream",
      isConstant: true,
      serializedName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  var body1 = {
    parameterPath: "body",
    mapper: {
      serializedName: "body",
      required: true,
      xmlName: "body",
      type: {
        name: "Stream"
      }
    }
  };
  var accept2 = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: true,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  var comp19 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "page",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var pageWrite = {
    parameterPath: "pageWrite",
    mapper: {
      defaultValue: "update",
      isConstant: true,
      serializedName: "x-ms-page-write",
      type: {
        name: "String"
      }
    }
  };
  var ifSequenceNumberLessThanOrEqualTo = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberLessThanOrEqualTo"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-le",
      xmlName: "x-ms-if-sequence-number-le",
      type: {
        name: "Number"
      }
    }
  };
  var ifSequenceNumberLessThan = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberLessThan"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-lt",
      xmlName: "x-ms-if-sequence-number-lt",
      type: {
        name: "Number"
      }
    }
  };
  var ifSequenceNumberEqualTo = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberEqualTo"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-eq",
      xmlName: "x-ms-if-sequence-number-eq",
      type: {
        name: "Number"
      }
    }
  };
  var pageWrite1 = {
    parameterPath: "pageWrite",
    mapper: {
      defaultValue: "clear",
      isConstant: true,
      serializedName: "x-ms-page-write",
      type: {
        name: "String"
      }
    }
  };
  var sourceUrl = {
    parameterPath: "sourceUrl",
    mapper: {
      serializedName: "x-ms-copy-source",
      required: true,
      xmlName: "x-ms-copy-source",
      type: {
        name: "String"
      }
    }
  };
  var sourceRange = {
    parameterPath: "sourceRange",
    mapper: {
      serializedName: "x-ms-source-range",
      required: true,
      xmlName: "x-ms-source-range",
      type: {
        name: "String"
      }
    }
  };
  var sourceContentCrc64 = {
    parameterPath: ["options", "sourceContentCrc64"],
    mapper: {
      serializedName: "x-ms-source-content-crc64",
      xmlName: "x-ms-source-content-crc64",
      type: {
        name: "ByteArray"
      }
    }
  };
  var range1 = {
    parameterPath: "range",
    mapper: {
      serializedName: "x-ms-range",
      required: true,
      xmlName: "x-ms-range",
      type: {
        name: "String"
      }
    }
  };
  var comp20 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "pagelist",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var prevsnapshot = {
    parameterPath: ["options", "prevsnapshot"],
    mapper: {
      serializedName: "prevsnapshot",
      xmlName: "prevsnapshot",
      type: {
        name: "String"
      }
    }
  };
  var prevSnapshotUrl = {
    parameterPath: ["options", "prevSnapshotUrl"],
    mapper: {
      serializedName: "x-ms-previous-snapshot-url",
      xmlName: "x-ms-previous-snapshot-url",
      type: {
        name: "String"
      }
    }
  };
  var sequenceNumberAction = {
    parameterPath: "sequenceNumberAction",
    mapper: {
      serializedName: "x-ms-sequence-number-action",
      required: true,
      xmlName: "x-ms-sequence-number-action",
      type: {
        name: "Enum",
        allowedValues: ["max", "update", "increment"]
      }
    }
  };
  var comp21 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "incrementalcopy",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var blobType1 = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "AppendBlob",
      isConstant: true,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  var comp22 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "appendblock",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var maxSize = {
    parameterPath: ["options", "appendPositionAccessConditions", "maxSize"],
    mapper: {
      serializedName: "x-ms-blob-condition-maxsize",
      xmlName: "x-ms-blob-condition-maxsize",
      type: {
        name: "Number"
      }
    }
  };
  var appendPosition = {
    parameterPath: [
      "options",
      "appendPositionAccessConditions",
      "appendPosition"
    ],
    mapper: {
      serializedName: "x-ms-blob-condition-appendpos",
      xmlName: "x-ms-blob-condition-appendpos",
      type: {
        name: "Number"
      }
    }
  };
  var sourceRange1 = {
    parameterPath: ["options", "sourceRange"],
    mapper: {
      serializedName: "x-ms-source-range",
      xmlName: "x-ms-source-range",
      type: {
        name: "String"
      }
    }
  };
  var comp23 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "seal",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var blobType2 = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "BlockBlob",
      isConstant: true,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  var copySourceBlobProperties = {
    parameterPath: ["options", "copySourceBlobProperties"],
    mapper: {
      serializedName: "x-ms-copy-source-blob-properties",
      xmlName: "x-ms-copy-source-blob-properties",
      type: {
        name: "Boolean"
      }
    }
  };
  var comp24 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "block",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var blockId = {
    parameterPath: "blockId",
    mapper: {
      serializedName: "blockid",
      required: true,
      xmlName: "blockid",
      type: {
        name: "String"
      }
    }
  };
  var blocks = {
    parameterPath: "blocks",
    mapper: BlockLookupList
  };
  var comp25 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "blocklist",
      isConstant: true,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  var listType = {
    parameterPath: "listType",
    mapper: {
      defaultValue: "committed",
      serializedName: "blocklisttype",
      required: true,
      xmlName: "blocklisttype",
      type: {
        name: "Enum",
        allowedValues: ["committed", "uncommitted", "all"]
      }
    }
  };

  class ServiceImpl {
    constructor(client) {
      this.client = client;
    }
    setProperties(blobServiceProperties2, options) {
      return this.client.sendOperationRequest({ blobServiceProperties: blobServiceProperties2, options }, setPropertiesOperationSpec);
    }
    getProperties(options) {
      return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec$2);
    }
    getStatistics(options) {
      return this.client.sendOperationRequest({ options }, getStatisticsOperationSpec);
    }
    listContainersSegment(options) {
      return this.client.sendOperationRequest({ options }, listContainersSegmentOperationSpec);
    }
    getUserDelegationKey(keyInfo2, options) {
      return this.client.sendOperationRequest({ keyInfo: keyInfo2, options }, getUserDelegationKeyOperationSpec);
    }
    getAccountInfo(options) {
      return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec$2);
    }
    submitBatch(contentLength2, multipartContentType2, body2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, multipartContentType: multipartContentType2, body: body2, options }, submitBatchOperationSpec$1);
    }
    filterBlobs(options) {
      return this.client.sendOperationRequest({ options }, filterBlobsOperationSpec$1);
    }
  }
  var xmlSerializer$5 = coreClient__namespace.createSerializer(Mappers, true);
  var setPropertiesOperationSpec = {
    path: "/",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: ServiceSetPropertiesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceSetPropertiesExceptionHeaders
      }
    },
    requestBody: blobServiceProperties,
    queryParameters: [
      restype,
      comp,
      timeoutInSeconds
    ],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$5
  };
  var getPropertiesOperationSpec$2 = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: BlobServiceProperties,
        headersMapper: ServiceGetPropertiesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [
      restype,
      comp,
      timeoutInSeconds
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$5
  };
  var getStatisticsOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: BlobServiceStatistics,
        headersMapper: ServiceGetStatisticsHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceGetStatisticsExceptionHeaders
      }
    },
    queryParameters: [
      restype,
      timeoutInSeconds,
      comp1
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$5
  };
  var listContainersSegmentOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: ListContainersSegmentResponse,
        headersMapper: ServiceListContainersSegmentHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceListContainersSegmentExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      comp2,
      prefix,
      marker,
      maxPageSize,
      include
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$5
  };
  var getUserDelegationKeyOperationSpec = {
    path: "/",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: UserDelegationKey,
        headersMapper: ServiceGetUserDelegationKeyHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceGetUserDelegationKeyExceptionHeaders
      }
    },
    requestBody: keyInfo,
    queryParameters: [
      restype,
      timeoutInSeconds,
      comp3
    ],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$5
  };
  var getAccountInfoOperationSpec$2 = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: ServiceGetAccountInfoHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      comp,
      timeoutInSeconds,
      restype1
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$5
  };
  var submitBatchOperationSpec$1 = {
    path: "/",
    httpMethod: "POST",
    responses: {
      202: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: ServiceSubmitBatchHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceSubmitBatchExceptionHeaders
      }
    },
    requestBody: body,
    queryParameters: [timeoutInSeconds, comp4],
    urlParameters: [url],
    headerParameters: [
      accept,
      version,
      requestId,
      contentLength,
      multipartContentType
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$5
  };
  var filterBlobsOperationSpec$1 = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: FilterBlobSegment,
        headersMapper: ServiceFilterBlobsHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ServiceFilterBlobsExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      marker,
      maxPageSize,
      comp5,
      where
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$5
  };

  class ContainerImpl {
    constructor(client) {
      this.client = client;
    }
    create(options) {
      return this.client.sendOperationRequest({ options }, createOperationSpec$2);
    }
    getProperties(options) {
      return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec$1);
    }
    delete(options) {
      return this.client.sendOperationRequest({ options }, deleteOperationSpec$1);
    }
    setMetadata(options) {
      return this.client.sendOperationRequest({ options }, setMetadataOperationSpec$1);
    }
    getAccessPolicy(options) {
      return this.client.sendOperationRequest({ options }, getAccessPolicyOperationSpec);
    }
    setAccessPolicy(options) {
      return this.client.sendOperationRequest({ options }, setAccessPolicyOperationSpec);
    }
    restore(options) {
      return this.client.sendOperationRequest({ options }, restoreOperationSpec);
    }
    rename(sourceContainerName2, options) {
      return this.client.sendOperationRequest({ sourceContainerName: sourceContainerName2, options }, renameOperationSpec);
    }
    submitBatch(contentLength2, multipartContentType2, body2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, multipartContentType: multipartContentType2, body: body2, options }, submitBatchOperationSpec);
    }
    filterBlobs(options) {
      return this.client.sendOperationRequest({ options }, filterBlobsOperationSpec);
    }
    acquireLease(options) {
      return this.client.sendOperationRequest({ options }, acquireLeaseOperationSpec$1);
    }
    releaseLease(leaseId2, options) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, options }, releaseLeaseOperationSpec$1);
    }
    renewLease(leaseId2, options) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, options }, renewLeaseOperationSpec$1);
    }
    breakLease(options) {
      return this.client.sendOperationRequest({ options }, breakLeaseOperationSpec$1);
    }
    changeLease(leaseId2, proposedLeaseId2, options) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, proposedLeaseId: proposedLeaseId2, options }, changeLeaseOperationSpec$1);
    }
    listBlobFlatSegment(options) {
      return this.client.sendOperationRequest({ options }, listBlobFlatSegmentOperationSpec);
    }
    listBlobHierarchySegment(delimiter2, options) {
      return this.client.sendOperationRequest({ delimiter: delimiter2, options }, listBlobHierarchySegmentOperationSpec);
    }
    getAccountInfo(options) {
      return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec$1);
    }
  }
  var xmlSerializer$4 = coreClient__namespace.createSerializer(Mappers, true);
  var createOperationSpec$2 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: ContainerCreateHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerCreateExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, restype2],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      access,
      defaultEncryptionScope,
      preventEncryptionScopeOverride
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var getPropertiesOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: ContainerGetPropertiesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, restype2],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var deleteOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "DELETE",
    responses: {
      202: {
        headersMapper: ContainerDeleteHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerDeleteExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, restype2],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var setMetadataOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerSetMetadataHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerSetMetadataExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp6
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      leaseId,
      ifModifiedSince
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var getAccessPolicyOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: {
          type: {
            name: "Sequence",
            element: {
              type: { name: "Composite", className: "SignedIdentifier" }
            }
          },
          serializedName: "SignedIdentifiers",
          xmlName: "SignedIdentifiers",
          xmlIsWrapped: true,
          xmlElementName: "SignedIdentifier"
        },
        headersMapper: ContainerGetAccessPolicyHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerGetAccessPolicyExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp7
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var setAccessPolicyOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerSetAccessPolicyHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerSetAccessPolicyExceptionHeaders
      }
    },
    requestBody: containerAcl,
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp7
    ],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId,
      access,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$4
  };
  var restoreOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: ContainerRestoreHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerRestoreExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp8
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      deletedContainerName,
      deletedContainerVersion
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var renameOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerRenameHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerRenameExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp9
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      sourceContainerName,
      sourceLeaseId
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var submitBatchOperationSpec = {
    path: "/{containerName}",
    httpMethod: "POST",
    responses: {
      202: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: ContainerSubmitBatchHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerSubmitBatchExceptionHeaders
      }
    },
    requestBody: body,
    queryParameters: [
      timeoutInSeconds,
      comp4,
      restype2
    ],
    urlParameters: [url],
    headerParameters: [
      accept,
      version,
      requestId,
      contentLength,
      multipartContentType
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$4
  };
  var filterBlobsOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: FilterBlobSegment,
        headersMapper: ContainerFilterBlobsHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerFilterBlobsExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      marker,
      maxPageSize,
      comp5,
      where,
      restype2
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var acquireLeaseOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: ContainerAcquireLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerAcquireLeaseExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp10
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action,
      duration,
      proposedLeaseId
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var releaseLeaseOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerReleaseLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerReleaseLeaseExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp10
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action1,
      leaseId1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var renewLeaseOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerRenewLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerRenewLeaseExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp10
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      leaseId1,
      action2
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var breakLeaseOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: ContainerBreakLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerBreakLeaseExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp10
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action3,
      breakPeriod
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var changeLeaseOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: ContainerChangeLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerChangeLeaseExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      restype2,
      comp10
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      leaseId1,
      action4,
      proposedLeaseId1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var listBlobFlatSegmentOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: ListBlobsFlatSegmentResponse,
        headersMapper: ContainerListBlobFlatSegmentHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerListBlobFlatSegmentExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      comp2,
      prefix,
      marker,
      maxPageSize,
      restype2,
      include1
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var listBlobHierarchySegmentOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: ListBlobsHierarchySegmentResponse,
        headersMapper: ContainerListBlobHierarchySegmentHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerListBlobHierarchySegmentExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      comp2,
      prefix,
      marker,
      maxPageSize,
      restype2,
      include1,
      delimiter
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };
  var getAccountInfoOperationSpec$1 = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: ContainerGetAccountInfoHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: ContainerGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      comp,
      timeoutInSeconds,
      restype1
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$4
  };

  class BlobImpl {
    constructor(client) {
      this.client = client;
    }
    download(options) {
      return this.client.sendOperationRequest({ options }, downloadOperationSpec);
    }
    getProperties(options) {
      return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec);
    }
    delete(options) {
      return this.client.sendOperationRequest({ options }, deleteOperationSpec);
    }
    undelete(options) {
      return this.client.sendOperationRequest({ options }, undeleteOperationSpec);
    }
    setExpiry(expiryOptions2, options) {
      return this.client.sendOperationRequest({ expiryOptions: expiryOptions2, options }, setExpiryOperationSpec);
    }
    setHttpHeaders(options) {
      return this.client.sendOperationRequest({ options }, setHttpHeadersOperationSpec);
    }
    setImmutabilityPolicy(options) {
      return this.client.sendOperationRequest({ options }, setImmutabilityPolicyOperationSpec);
    }
    deleteImmutabilityPolicy(options) {
      return this.client.sendOperationRequest({ options }, deleteImmutabilityPolicyOperationSpec);
    }
    setLegalHold(legalHold2, options) {
      return this.client.sendOperationRequest({ legalHold: legalHold2, options }, setLegalHoldOperationSpec);
    }
    setMetadata(options) {
      return this.client.sendOperationRequest({ options }, setMetadataOperationSpec);
    }
    acquireLease(options) {
      return this.client.sendOperationRequest({ options }, acquireLeaseOperationSpec);
    }
    releaseLease(leaseId2, options) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, options }, releaseLeaseOperationSpec);
    }
    renewLease(leaseId2, options) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, options }, renewLeaseOperationSpec);
    }
    changeLease(leaseId2, proposedLeaseId2, options) {
      return this.client.sendOperationRequest({ leaseId: leaseId2, proposedLeaseId: proposedLeaseId2, options }, changeLeaseOperationSpec);
    }
    breakLease(options) {
      return this.client.sendOperationRequest({ options }, breakLeaseOperationSpec);
    }
    createSnapshot(options) {
      return this.client.sendOperationRequest({ options }, createSnapshotOperationSpec);
    }
    startCopyFromURL(copySource2, options) {
      return this.client.sendOperationRequest({ copySource: copySource2, options }, startCopyFromURLOperationSpec);
    }
    copyFromURL(copySource2, options) {
      return this.client.sendOperationRequest({ copySource: copySource2, options }, copyFromURLOperationSpec);
    }
    abortCopyFromURL(copyId2, options) {
      return this.client.sendOperationRequest({ copyId: copyId2, options }, abortCopyFromURLOperationSpec);
    }
    setTier(tier2, options) {
      return this.client.sendOperationRequest({ tier: tier2, options }, setTierOperationSpec);
    }
    getAccountInfo(options) {
      return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec);
    }
    query(options) {
      return this.client.sendOperationRequest({ options }, queryOperationSpec);
    }
    getTags(options) {
      return this.client.sendOperationRequest({ options }, getTagsOperationSpec);
    }
    setTags(options) {
      return this.client.sendOperationRequest({ options }, setTagsOperationSpec);
    }
  }
  var xmlSerializer$3 = coreClient__namespace.createSerializer(Mappers, true);
  var downloadOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: BlobDownloadHeaders
      },
      206: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: BlobDownloadHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobDownloadExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      range,
      rangeGetContentMD5,
      rangeGetContentCRC64,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var getPropertiesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "HEAD",
    responses: {
      200: {
        headersMapper: BlobGetPropertiesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var deleteOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "DELETE",
    responses: {
      202: {
        headersMapper: BlobDeleteHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobDeleteExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId,
      blobDeleteType
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      deleteSnapshots
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var undeleteOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobUndeleteHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobUndeleteExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp8],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setExpiryOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetExpiryHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetExpiryExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp11],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      expiryOptions,
      expiresOn
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setHttpHeadersOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetHttpHeadersHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetHttpHeadersExceptionHeaders
      }
    },
    queryParameters: [comp, timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setImmutabilityPolicyOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetImmutabilityPolicyHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetImmutabilityPolicyExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId,
      comp12
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifUnmodifiedSince,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var deleteImmutabilityPolicyOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "DELETE",
    responses: {
      200: {
        headersMapper: BlobDeleteImmutabilityPolicyHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobDeleteImmutabilityPolicyExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId,
      comp12
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setLegalHoldOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetLegalHoldHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetLegalHoldExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId,
      comp13
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      legalHold
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setMetadataOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetMetadataHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetMetadataExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp6],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var acquireLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlobAcquireLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobAcquireLeaseExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp10],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action,
      duration,
      proposedLeaseId,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var releaseLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobReleaseLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobReleaseLeaseExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp10],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action1,
      leaseId1,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var renewLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobRenewLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobRenewLeaseExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp10],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      leaseId1,
      action2,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var changeLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobChangeLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobChangeLeaseExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp10],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      leaseId1,
      action4,
      proposedLeaseId1,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var breakLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: BlobBreakLeaseHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobBreakLeaseExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp10],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      action3,
      breakPeriod,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var createSnapshotOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlobCreateSnapshotHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobCreateSnapshotExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp14],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var startCopyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: BlobStartCopyFromURLHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobStartCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      tier,
      rehydratePriority,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      sourceIfTags,
      copySource,
      blobTagsString,
      sealBlob,
      legalHold1
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var copyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: BlobCopyFromURLHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      encryptionScope,
      tier,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      copySource,
      blobTagsString,
      legalHold1,
      xMsRequiresSync,
      sourceContentMD5,
      copySourceAuthorization,
      copySourceTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var abortCopyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      204: {
        headersMapper: BlobAbortCopyFromURLHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobAbortCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      comp15,
      copyId
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      copyActionAbortConstant
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setTierOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: BlobSetTierHeaders
      },
      202: {
        headersMapper: BlobSetTierHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetTierExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId,
      comp16
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifTags,
      rehydratePriority,
      tier1
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var getAccountInfoOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: BlobGetAccountInfoHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      comp,
      timeoutInSeconds,
      restype1
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var queryOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: BlobQueryHeaders
      },
      206: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: BlobQueryHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobQueryExceptionHeaders
      }
    },
    requestBody: queryRequest,
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      comp17
    ],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$3
  };
  var getTagsOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: BlobTags,
        headersMapper: BlobGetTagsHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobGetTagsExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      versionId,
      comp18
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$3
  };
  var setTagsOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      204: {
        headersMapper: BlobSetTagsHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlobSetTagsExceptionHeaders
      }
    },
    requestBody: tags,
    queryParameters: [
      timeoutInSeconds,
      versionId,
      comp18
    ],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId,
      leaseId,
      ifTags,
      transactionalContentMD5,
      transactionalContentCrc64
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$3
  };

  class PageBlobImpl {
    constructor(client) {
      this.client = client;
    }
    create(contentLength2, blobContentLength2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, blobContentLength: blobContentLength2, options }, createOperationSpec$1);
    }
    uploadPages(contentLength2, body2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, body: body2, options }, uploadPagesOperationSpec);
    }
    clearPages(contentLength2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, options }, clearPagesOperationSpec);
    }
    uploadPagesFromURL(sourceUrl2, sourceRange2, contentLength2, range2, options) {
      return this.client.sendOperationRequest({ sourceUrl: sourceUrl2, sourceRange: sourceRange2, contentLength: contentLength2, range: range2, options }, uploadPagesFromURLOperationSpec);
    }
    getPageRanges(options) {
      return this.client.sendOperationRequest({ options }, getPageRangesOperationSpec);
    }
    getPageRangesDiff(options) {
      return this.client.sendOperationRequest({ options }, getPageRangesDiffOperationSpec);
    }
    resize(blobContentLength2, options) {
      return this.client.sendOperationRequest({ blobContentLength: blobContentLength2, options }, resizeOperationSpec);
    }
    updateSequenceNumber(sequenceNumberAction2, options) {
      return this.client.sendOperationRequest({ sequenceNumberAction: sequenceNumberAction2, options }, updateSequenceNumberOperationSpec);
    }
    copyIncremental(copySource2, options) {
      return this.client.sendOperationRequest({ copySource: copySource2, options }, copyIncrementalOperationSpec);
    }
  }
  var xmlSerializer$2 = coreClient__namespace.createSerializer(Mappers, true);
  var createOperationSpec$1 = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: PageBlobCreateHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobCreateExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      encryptionScope,
      tier,
      blobTagsString,
      legalHold1,
      blobType,
      blobContentLength,
      blobSequenceNumber
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var uploadPagesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: PageBlobUploadPagesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobUploadPagesExceptionHeaders
      }
    },
    requestBody: body1,
    queryParameters: [timeoutInSeconds, comp19],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      contentLength,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      range,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      transactionalContentMD5,
      transactionalContentCrc64,
      contentType1,
      accept2,
      pageWrite,
      ifSequenceNumberLessThanOrEqualTo,
      ifSequenceNumberLessThan,
      ifSequenceNumberEqualTo
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer$2
  };
  var clearPagesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: PageBlobClearPagesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobClearPagesExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp19],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      range,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      ifSequenceNumberLessThanOrEqualTo,
      ifSequenceNumberLessThan,
      ifSequenceNumberEqualTo,
      pageWrite1
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var uploadPagesFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: PageBlobUploadPagesFromURLHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobUploadPagesFromURLExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp19],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      sourceContentMD5,
      copySourceAuthorization,
      pageWrite,
      ifSequenceNumberLessThanOrEqualTo,
      ifSequenceNumberLessThan,
      ifSequenceNumberEqualTo,
      sourceUrl,
      sourceRange,
      sourceContentCrc64,
      range1
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var getPageRangesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: PageList,
        headersMapper: PageBlobGetPageRangesHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobGetPageRangesExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      marker,
      maxPageSize,
      snapshot,
      comp20
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      range,
      ifMatch,
      ifNoneMatch,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var getPageRangesDiffOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: PageList,
        headersMapper: PageBlobGetPageRangesDiffHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobGetPageRangesDiffExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      marker,
      maxPageSize,
      snapshot,
      comp20,
      prevsnapshot
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      range,
      ifMatch,
      ifNoneMatch,
      ifTags,
      prevSnapshotUrl
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var resizeOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: PageBlobResizeHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobResizeExceptionHeaders
      }
    },
    queryParameters: [comp, timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      blobContentLength
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var updateSequenceNumberOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: PageBlobUpdateSequenceNumberHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobUpdateSequenceNumberExceptionHeaders
      }
    },
    queryParameters: [comp, timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobSequenceNumber,
      sequenceNumberAction
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };
  var copyIncrementalOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: PageBlobCopyIncrementalHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: PageBlobCopyIncrementalExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp21],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      ifTags,
      copySource
    ],
    isXML: true,
    serializer: xmlSerializer$2
  };

  class AppendBlobImpl {
    constructor(client) {
      this.client = client;
    }
    create(contentLength2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, options }, createOperationSpec);
    }
    appendBlock(contentLength2, body2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, body: body2, options }, appendBlockOperationSpec);
    }
    appendBlockFromUrl(sourceUrl2, contentLength2, options) {
      return this.client.sendOperationRequest({ sourceUrl: sourceUrl2, contentLength: contentLength2, options }, appendBlockFromUrlOperationSpec);
    }
    seal(options) {
      return this.client.sendOperationRequest({ options }, sealOperationSpec);
    }
  }
  var xmlSerializer$1 = coreClient__namespace.createSerializer(Mappers, true);
  var createOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: AppendBlobCreateHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: AppendBlobCreateExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      encryptionScope,
      blobTagsString,
      legalHold1,
      blobType1
    ],
    isXML: true,
    serializer: xmlSerializer$1
  };
  var appendBlockOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: AppendBlobAppendBlockHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: AppendBlobAppendBlockExceptionHeaders
      }
    },
    requestBody: body1,
    queryParameters: [timeoutInSeconds, comp22],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      contentLength,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      transactionalContentMD5,
      transactionalContentCrc64,
      contentType1,
      accept2,
      maxSize,
      appendPosition
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer$1
  };
  var appendBlockFromUrlOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: AppendBlobAppendBlockFromUrlHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: AppendBlobAppendBlockFromUrlExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp22],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      encryptionScope,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      sourceContentMD5,
      copySourceAuthorization,
      transactionalContentMD5,
      sourceUrl,
      sourceContentCrc64,
      maxSize,
      appendPosition,
      sourceRange1
    ],
    isXML: true,
    serializer: xmlSerializer$1
  };
  var sealOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: AppendBlobSealHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: AppendBlobSealExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds, comp23],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      ifMatch,
      ifNoneMatch,
      appendPosition
    ],
    isXML: true,
    serializer: xmlSerializer$1
  };

  class BlockBlobImpl {
    constructor(client) {
      this.client = client;
    }
    upload(contentLength2, body2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, body: body2, options }, uploadOperationSpec);
    }
    putBlobFromUrl(contentLength2, copySource2, options) {
      return this.client.sendOperationRequest({ contentLength: contentLength2, copySource: copySource2, options }, putBlobFromUrlOperationSpec);
    }
    stageBlock(blockId2, contentLength2, body2, options) {
      return this.client.sendOperationRequest({ blockId: blockId2, contentLength: contentLength2, body: body2, options }, stageBlockOperationSpec);
    }
    stageBlockFromURL(blockId2, contentLength2, sourceUrl2, options) {
      return this.client.sendOperationRequest({ blockId: blockId2, contentLength: contentLength2, sourceUrl: sourceUrl2, options }, stageBlockFromURLOperationSpec);
    }
    commitBlockList(blocks2, options) {
      return this.client.sendOperationRequest({ blocks: blocks2, options }, commitBlockListOperationSpec);
    }
    getBlockList(listType2, options) {
      return this.client.sendOperationRequest({ listType: listType2, options }, getBlockListOperationSpec);
    }
  }
  var xmlSerializer = coreClient__namespace.createSerializer(Mappers, true);
  var uploadOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlockBlobUploadHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobUploadExceptionHeaders
      }
    },
    requestBody: body1,
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      contentLength,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      encryptionScope,
      tier,
      blobTagsString,
      legalHold1,
      transactionalContentMD5,
      transactionalContentCrc64,
      contentType1,
      accept2,
      blobType2
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  };
  var putBlobFromUrlOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlockBlobPutBlobFromUrlHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobPutBlobFromUrlExceptionHeaders
      }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition,
      encryptionScope,
      tier,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      sourceIfTags,
      copySource,
      blobTagsString,
      sourceContentMD5,
      copySourceAuthorization,
      copySourceTags,
      transactionalContentMD5,
      blobType2,
      copySourceBlobProperties
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var stageBlockOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlockBlobStageBlockHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobStageBlockExceptionHeaders
      }
    },
    requestBody: body1,
    queryParameters: [
      timeoutInSeconds,
      comp24,
      blockId
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      contentLength,
      leaseId,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      encryptionScope,
      transactionalContentMD5,
      transactionalContentCrc64,
      contentType1,
      accept2
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  };
  var stageBlockFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlockBlobStageBlockFromURLHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobStageBlockFromURLExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      comp24,
      blockId
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      contentLength,
      leaseId,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      encryptionScope,
      sourceIfModifiedSince,
      sourceIfUnmodifiedSince,
      sourceIfMatch,
      sourceIfNoneMatch,
      sourceContentMD5,
      copySourceAuthorization,
      sourceUrl,
      sourceContentCrc64,
      sourceRange1
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var commitBlockListOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: BlockBlobCommitBlockListHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobCommitBlockListExceptionHeaders
      }
    },
    requestBody: blocks,
    queryParameters: [timeoutInSeconds, comp25],
    urlParameters: [url],
    headerParameters: [
      contentType,
      accept,
      version,
      requestId,
      metadata,
      leaseId,
      ifModifiedSince,
      ifUnmodifiedSince,
      encryptionKey,
      encryptionKeySha256,
      encryptionAlgorithm,
      ifMatch,
      ifNoneMatch,
      ifTags,
      blobCacheControl,
      blobContentType,
      blobContentMD5,
      blobContentEncoding,
      blobContentLanguage,
      blobContentDisposition,
      immutabilityPolicyExpiry,
      immutabilityPolicyMode,
      encryptionScope,
      tier,
      blobTagsString,
      legalHold1,
      transactionalContentMD5,
      transactionalContentCrc64
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
  var getBlockListOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: BlockList,
        headersMapper: BlockBlobGetBlockListHeaders
      },
      default: {
        bodyMapper: StorageError,
        headersMapper: BlockBlobGetBlockListExceptionHeaders
      }
    },
    queryParameters: [
      timeoutInSeconds,
      snapshot,
      comp25,
      listType
    ],
    urlParameters: [url],
    headerParameters: [
      version,
      requestId,
      accept1,
      leaseId,
      ifTags
    ],
    isXML: true,
    serializer: xmlSerializer
  };
  var StorageClient$1 = class StorageClient2 extends coreHttpCompat__namespace.ExtendedServiceClient {
    constructor(url2, options) {
      var _a3, _b2;
      if (url2 === undefined) {
        throw new Error("'url' cannot be null");
      }
      if (!options) {
        options = {};
      }
      const defaults = {
        requestContentType: "application/json; charset=utf-8"
      };
      const packageDetails = `azsdk-js-azure-storage-blob/12.27.0`;
      const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
      const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
        userAgentPrefix
      }, endpoint: (_b2 = (_a3 = options.endpoint) !== null && _a3 !== undefined ? _a3 : options.baseUri) !== null && _b2 !== undefined ? _b2 : "{url}" });
      super(optionsWithDefaults);
      this.url = url2;
      this.version = options.version || "2025-05-05";
      this.service = new ServiceImpl(this);
      this.container = new ContainerImpl(this);
      this.blob = new BlobImpl(this);
      this.pageBlob = new PageBlobImpl(this);
      this.appendBlob = new AppendBlobImpl(this);
      this.blockBlob = new BlockBlobImpl(this);
    }
  };

  class StorageContextClient extends StorageClient$1 {
    async sendOperationRequest(operationArguments, operationSpec) {
      const operationSpecToSend = Object.assign({}, operationSpec);
      if (operationSpecToSend.path === "/{containerName}" || operationSpecToSend.path === "/{containerName}/{blob}") {
        operationSpecToSend.path = "";
      }
      return super.sendOperationRequest(operationArguments, operationSpecToSend);
    }
  }

  class StorageClient {
    constructor(url2, pipeline) {
      this.url = escapeURLPath(url2);
      this.accountName = getAccountNameFromUrl(url2);
      this.pipeline = pipeline;
      this.storageClientContext = new StorageContextClient(this.url, getCoreClientOptions(pipeline));
      this.isHttps = iEqual(getURLScheme(this.url) || "", "https");
      this.credential = getCredentialFromPipeline(pipeline);
      const storageClientContext = this.storageClientContext;
      storageClientContext.requestContentType = undefined;
    }
  }
  var tracingClient = coreTracing.createTracingClient({
    packageName: "@azure/storage-blob",
    packageVersion: SDK_VERSION4,
    namespace: "Microsoft.Storage"
  });

  class BlobSASPermissions {
    constructor() {
      this.read = false;
      this.add = false;
      this.create = false;
      this.write = false;
      this.delete = false;
      this.deleteVersion = false;
      this.tag = false;
      this.move = false;
      this.execute = false;
      this.setImmutabilityPolicy = false;
      this.permanentDelete = false;
    }
    static parse(permissions) {
      const blobSASPermissions = new BlobSASPermissions;
      for (const char of permissions) {
        switch (char) {
          case "r":
            blobSASPermissions.read = true;
            break;
          case "a":
            blobSASPermissions.add = true;
            break;
          case "c":
            blobSASPermissions.create = true;
            break;
          case "w":
            blobSASPermissions.write = true;
            break;
          case "d":
            blobSASPermissions.delete = true;
            break;
          case "x":
            blobSASPermissions.deleteVersion = true;
            break;
          case "t":
            blobSASPermissions.tag = true;
            break;
          case "m":
            blobSASPermissions.move = true;
            break;
          case "e":
            blobSASPermissions.execute = true;
            break;
          case "i":
            blobSASPermissions.setImmutabilityPolicy = true;
            break;
          case "y":
            blobSASPermissions.permanentDelete = true;
            break;
          default:
            throw new RangeError(`Invalid permission: ${char}`);
        }
      }
      return blobSASPermissions;
    }
    static from(permissionLike) {
      const blobSASPermissions = new BlobSASPermissions;
      if (permissionLike.read) {
        blobSASPermissions.read = true;
      }
      if (permissionLike.add) {
        blobSASPermissions.add = true;
      }
      if (permissionLike.create) {
        blobSASPermissions.create = true;
      }
      if (permissionLike.write) {
        blobSASPermissions.write = true;
      }
      if (permissionLike.delete) {
        blobSASPermissions.delete = true;
      }
      if (permissionLike.deleteVersion) {
        blobSASPermissions.deleteVersion = true;
      }
      if (permissionLike.tag) {
        blobSASPermissions.tag = true;
      }
      if (permissionLike.move) {
        blobSASPermissions.move = true;
      }
      if (permissionLike.execute) {
        blobSASPermissions.execute = true;
      }
      if (permissionLike.setImmutabilityPolicy) {
        blobSASPermissions.setImmutabilityPolicy = true;
      }
      if (permissionLike.permanentDelete) {
        blobSASPermissions.permanentDelete = true;
      }
      return blobSASPermissions;
    }
    toString() {
      const permissions = [];
      if (this.read) {
        permissions.push("r");
      }
      if (this.add) {
        permissions.push("a");
      }
      if (this.create) {
        permissions.push("c");
      }
      if (this.write) {
        permissions.push("w");
      }
      if (this.delete) {
        permissions.push("d");
      }
      if (this.deleteVersion) {
        permissions.push("x");
      }
      if (this.tag) {
        permissions.push("t");
      }
      if (this.move) {
        permissions.push("m");
      }
      if (this.execute) {
        permissions.push("e");
      }
      if (this.setImmutabilityPolicy) {
        permissions.push("i");
      }
      if (this.permanentDelete) {
        permissions.push("y");
      }
      return permissions.join("");
    }
  }

  class ContainerSASPermissions {
    constructor() {
      this.read = false;
      this.add = false;
      this.create = false;
      this.write = false;
      this.delete = false;
      this.deleteVersion = false;
      this.list = false;
      this.tag = false;
      this.move = false;
      this.execute = false;
      this.setImmutabilityPolicy = false;
      this.permanentDelete = false;
      this.filterByTags = false;
    }
    static parse(permissions) {
      const containerSASPermissions = new ContainerSASPermissions;
      for (const char of permissions) {
        switch (char) {
          case "r":
            containerSASPermissions.read = true;
            break;
          case "a":
            containerSASPermissions.add = true;
            break;
          case "c":
            containerSASPermissions.create = true;
            break;
          case "w":
            containerSASPermissions.write = true;
            break;
          case "d":
            containerSASPermissions.delete = true;
            break;
          case "l":
            containerSASPermissions.list = true;
            break;
          case "t":
            containerSASPermissions.tag = true;
            break;
          case "x":
            containerSASPermissions.deleteVersion = true;
            break;
          case "m":
            containerSASPermissions.move = true;
            break;
          case "e":
            containerSASPermissions.execute = true;
            break;
          case "i":
            containerSASPermissions.setImmutabilityPolicy = true;
            break;
          case "y":
            containerSASPermissions.permanentDelete = true;
            break;
          case "f":
            containerSASPermissions.filterByTags = true;
            break;
          default:
            throw new RangeError(`Invalid permission ${char}`);
        }
      }
      return containerSASPermissions;
    }
    static from(permissionLike) {
      const containerSASPermissions = new ContainerSASPermissions;
      if (permissionLike.read) {
        containerSASPermissions.read = true;
      }
      if (permissionLike.add) {
        containerSASPermissions.add = true;
      }
      if (permissionLike.create) {
        containerSASPermissions.create = true;
      }
      if (permissionLike.write) {
        containerSASPermissions.write = true;
      }
      if (permissionLike.delete) {
        containerSASPermissions.delete = true;
      }
      if (permissionLike.list) {
        containerSASPermissions.list = true;
      }
      if (permissionLike.deleteVersion) {
        containerSASPermissions.deleteVersion = true;
      }
      if (permissionLike.tag) {
        containerSASPermissions.tag = true;
      }
      if (permissionLike.move) {
        containerSASPermissions.move = true;
      }
      if (permissionLike.execute) {
        containerSASPermissions.execute = true;
      }
      if (permissionLike.setImmutabilityPolicy) {
        containerSASPermissions.setImmutabilityPolicy = true;
      }
      if (permissionLike.permanentDelete) {
        containerSASPermissions.permanentDelete = true;
      }
      if (permissionLike.filterByTags) {
        containerSASPermissions.filterByTags = true;
      }
      return containerSASPermissions;
    }
    toString() {
      const permissions = [];
      if (this.read) {
        permissions.push("r");
      }
      if (this.add) {
        permissions.push("a");
      }
      if (this.create) {
        permissions.push("c");
      }
      if (this.write) {
        permissions.push("w");
      }
      if (this.delete) {
        permissions.push("d");
      }
      if (this.deleteVersion) {
        permissions.push("x");
      }
      if (this.list) {
        permissions.push("l");
      }
      if (this.tag) {
        permissions.push("t");
      }
      if (this.move) {
        permissions.push("m");
      }
      if (this.execute) {
        permissions.push("e");
      }
      if (this.setImmutabilityPolicy) {
        permissions.push("i");
      }
      if (this.permanentDelete) {
        permissions.push("y");
      }
      if (this.filterByTags) {
        permissions.push("f");
      }
      return permissions.join("");
    }
  }

  class UserDelegationKeyCredential {
    constructor(accountName, userDelegationKey) {
      this.accountName = accountName;
      this.userDelegationKey = userDelegationKey;
      this.key = Buffer.from(userDelegationKey.value, "base64");
    }
    computeHMACSHA256(stringToSign) {
      return crypto.createHmac("sha256", this.key).update(stringToSign, "utf8").digest("base64");
    }
  }
  function ipRangeToString(ipRange) {
    return ipRange.end ? `${ipRange.start}-${ipRange.end}` : ipRange.start;
  }
  exports.SASProtocol = undefined;
  (function(SASProtocol) {
    SASProtocol["Https"] = "https";
    SASProtocol["HttpsAndHttp"] = "https,http";
  })(exports.SASProtocol || (exports.SASProtocol = {}));

  class SASQueryParameters {
    get ipRange() {
      if (this.ipRangeInner) {
        return {
          end: this.ipRangeInner.end,
          start: this.ipRangeInner.start
        };
      }
      return;
    }
    constructor(version2, signature, permissionsOrOptions, services, resourceTypes, protocol, startsOn, expiresOn2, ipRange, identifier, resource, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType2, userDelegationKey, preauthorizedAgentObjectId, correlationId, encryptionScope2) {
      this.version = version2;
      this.signature = signature;
      if (permissionsOrOptions !== undefined && typeof permissionsOrOptions !== "string") {
        this.permissions = permissionsOrOptions.permissions;
        this.services = permissionsOrOptions.services;
        this.resourceTypes = permissionsOrOptions.resourceTypes;
        this.protocol = permissionsOrOptions.protocol;
        this.startsOn = permissionsOrOptions.startsOn;
        this.expiresOn = permissionsOrOptions.expiresOn;
        this.ipRangeInner = permissionsOrOptions.ipRange;
        this.identifier = permissionsOrOptions.identifier;
        this.encryptionScope = permissionsOrOptions.encryptionScope;
        this.resource = permissionsOrOptions.resource;
        this.cacheControl = permissionsOrOptions.cacheControl;
        this.contentDisposition = permissionsOrOptions.contentDisposition;
        this.contentEncoding = permissionsOrOptions.contentEncoding;
        this.contentLanguage = permissionsOrOptions.contentLanguage;
        this.contentType = permissionsOrOptions.contentType;
        if (permissionsOrOptions.userDelegationKey) {
          this.signedOid = permissionsOrOptions.userDelegationKey.signedObjectId;
          this.signedTenantId = permissionsOrOptions.userDelegationKey.signedTenantId;
          this.signedStartsOn = permissionsOrOptions.userDelegationKey.signedStartsOn;
          this.signedExpiresOn = permissionsOrOptions.userDelegationKey.signedExpiresOn;
          this.signedService = permissionsOrOptions.userDelegationKey.signedService;
          this.signedVersion = permissionsOrOptions.userDelegationKey.signedVersion;
          this.preauthorizedAgentObjectId = permissionsOrOptions.preauthorizedAgentObjectId;
          this.correlationId = permissionsOrOptions.correlationId;
        }
      } else {
        this.services = services;
        this.resourceTypes = resourceTypes;
        this.expiresOn = expiresOn2;
        this.permissions = permissionsOrOptions;
        this.protocol = protocol;
        this.startsOn = startsOn;
        this.ipRangeInner = ipRange;
        this.encryptionScope = encryptionScope2;
        this.identifier = identifier;
        this.resource = resource;
        this.cacheControl = cacheControl;
        this.contentDisposition = contentDisposition;
        this.contentEncoding = contentEncoding;
        this.contentLanguage = contentLanguage;
        this.contentType = contentType2;
        if (userDelegationKey) {
          this.signedOid = userDelegationKey.signedObjectId;
          this.signedTenantId = userDelegationKey.signedTenantId;
          this.signedStartsOn = userDelegationKey.signedStartsOn;
          this.signedExpiresOn = userDelegationKey.signedExpiresOn;
          this.signedService = userDelegationKey.signedService;
          this.signedVersion = userDelegationKey.signedVersion;
          this.preauthorizedAgentObjectId = preauthorizedAgentObjectId;
          this.correlationId = correlationId;
        }
      }
    }
    toString() {
      const params = [
        "sv",
        "ss",
        "srt",
        "spr",
        "st",
        "se",
        "sip",
        "si",
        "ses",
        "skoid",
        "sktid",
        "skt",
        "ske",
        "sks",
        "skv",
        "sr",
        "sp",
        "sig",
        "rscc",
        "rscd",
        "rsce",
        "rscl",
        "rsct",
        "saoid",
        "scid"
      ];
      const queries = [];
      for (const param of params) {
        switch (param) {
          case "sv":
            this.tryAppendQueryParameter(queries, param, this.version);
            break;
          case "ss":
            this.tryAppendQueryParameter(queries, param, this.services);
            break;
          case "srt":
            this.tryAppendQueryParameter(queries, param, this.resourceTypes);
            break;
          case "spr":
            this.tryAppendQueryParameter(queries, param, this.protocol);
            break;
          case "st":
            this.tryAppendQueryParameter(queries, param, this.startsOn ? truncatedISO8061Date(this.startsOn, false) : undefined);
            break;
          case "se":
            this.tryAppendQueryParameter(queries, param, this.expiresOn ? truncatedISO8061Date(this.expiresOn, false) : undefined);
            break;
          case "sip":
            this.tryAppendQueryParameter(queries, param, this.ipRange ? ipRangeToString(this.ipRange) : undefined);
            break;
          case "si":
            this.tryAppendQueryParameter(queries, param, this.identifier);
            break;
          case "ses":
            this.tryAppendQueryParameter(queries, param, this.encryptionScope);
            break;
          case "skoid":
            this.tryAppendQueryParameter(queries, param, this.signedOid);
            break;
          case "sktid":
            this.tryAppendQueryParameter(queries, param, this.signedTenantId);
            break;
          case "skt":
            this.tryAppendQueryParameter(queries, param, this.signedStartsOn ? truncatedISO8061Date(this.signedStartsOn, false) : undefined);
            break;
          case "ske":
            this.tryAppendQueryParameter(queries, param, this.signedExpiresOn ? truncatedISO8061Date(this.signedExpiresOn, false) : undefined);
            break;
          case "sks":
            this.tryAppendQueryParameter(queries, param, this.signedService);
            break;
          case "skv":
            this.tryAppendQueryParameter(queries, param, this.signedVersion);
            break;
          case "sr":
            this.tryAppendQueryParameter(queries, param, this.resource);
            break;
          case "sp":
            this.tryAppendQueryParameter(queries, param, this.permissions);
            break;
          case "sig":
            this.tryAppendQueryParameter(queries, param, this.signature);
            break;
          case "rscc":
            this.tryAppendQueryParameter(queries, param, this.cacheControl);
            break;
          case "rscd":
            this.tryAppendQueryParameter(queries, param, this.contentDisposition);
            break;
          case "rsce":
            this.tryAppendQueryParameter(queries, param, this.contentEncoding);
            break;
          case "rscl":
            this.tryAppendQueryParameter(queries, param, this.contentLanguage);
            break;
          case "rsct":
            this.tryAppendQueryParameter(queries, param, this.contentType);
            break;
          case "saoid":
            this.tryAppendQueryParameter(queries, param, this.preauthorizedAgentObjectId);
            break;
          case "scid":
            this.tryAppendQueryParameter(queries, param, this.correlationId);
            break;
        }
      }
      return queries.join("&");
    }
    tryAppendQueryParameter(queries, key, value) {
      if (!value) {
        return;
      }
      key = encodeURIComponent(key);
      value = encodeURIComponent(value);
      if (key.length > 0 && value.length > 0) {
        queries.push(`${key}=${value}`);
      }
    }
  }
  function generateBlobSASQueryParameters(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
    return generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName).sasQueryParameters;
  }
  function generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
    const version2 = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;
    const sharedKeyCredential = sharedKeyCredentialOrUserDelegationKey instanceof StorageSharedKeyCredential ? sharedKeyCredentialOrUserDelegationKey : undefined;
    let userDelegationKeyCredential;
    if (sharedKeyCredential === undefined && accountName !== undefined) {
      userDelegationKeyCredential = new UserDelegationKeyCredential(accountName, sharedKeyCredentialOrUserDelegationKey);
    }
    if (sharedKeyCredential === undefined && userDelegationKeyCredential === undefined) {
      throw TypeError("Invalid sharedKeyCredential, userDelegationKey or accountName.");
    }
    if (version2 >= "2020-12-06") {
      if (sharedKeyCredential !== undefined) {
        return generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential);
      } else {
        return generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential);
      }
    }
    if (version2 >= "2018-11-09") {
      if (sharedKeyCredential !== undefined) {
        return generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential);
      } else {
        if (version2 >= "2020-02-10") {
          return generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential);
        } else {
          return generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential);
        }
      }
    }
    if (version2 >= "2015-04-05") {
      if (sharedKeyCredential !== undefined) {
        return generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential);
      } else {
        throw new RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.");
      }
    }
    throw new RangeError("'version' must be >= '2015-04-05'.");
  }
  function generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    if (blobSASSignatureValues.blobName) {
      resource = "b";
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join(`
`);
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),
      stringToSign
    };
  }
  function generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join(`
`);
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),
      stringToSign
    };
  }
  function generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.encryptionScope,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join(`
`);
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, undefined, undefined, undefined, blobSASSignatureValues.encryptionScope),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join(`
`);
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.preauthorizedAgentObjectId,
      undefined,
      blobSASSignatureValues.correlationId,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join(`
`);
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential) {
    blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);
    if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {
      throw new RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    }
    let resource = "c";
    let timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      resource = "b";
      if (blobSASSignatureValues.snapshotTime) {
        resource = "bs";
      } else if (blobSASSignatureValues.versionId) {
        resource = "bv";
        timestamp = blobSASSignatureValues.versionId;
      }
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions) {
      if (blobSASSignatureValues.blobName) {
        verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      } else {
        verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      }
    }
    const stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : "",
      blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.preauthorizedAgentObjectId,
      undefined,
      blobSASSignatureValues.correlationId,
      blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.encryptionScope,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join(`
`);
    const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope),
      stringToSign
    };
  }
  function getCanonicalName(accountName, containerName, blobName) {
    const elements = [`/blob/${accountName}/${containerName}`];
    if (blobName) {
      elements.push(`/${blobName}`);
    }
    return elements.join("");
  }
  function SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues) {
    const version2 = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;
    if (blobSASSignatureValues.snapshotTime && version2 < "2018-11-09") {
      throw RangeError("'version' must be >= '2018-11-09' when providing 'snapshotTime'.");
    }
    if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.snapshotTime) {
      throw RangeError("Must provide 'blobName' when providing 'snapshotTime'.");
    }
    if (blobSASSignatureValues.versionId && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when providing 'versionId'.");
    }
    if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.versionId) {
      throw RangeError("Must provide 'blobName' when providing 'versionId'.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.setImmutabilityPolicy && version2 < "2020-08-04") {
      throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.deleteVersion && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when providing 'x' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.permanentDelete && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when providing 'y' permission.");
    }
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.tag && version2 < "2019-12-12") {
      throw RangeError("'version' must be >= '2019-12-12' when providing 't' permission.");
    }
    if (version2 < "2020-02-10" && blobSASSignatureValues.permissions && (blobSASSignatureValues.permissions.move || blobSASSignatureValues.permissions.execute)) {
      throw RangeError("'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.");
    }
    if (version2 < "2021-04-10" && blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.filterByTags) {
      throw RangeError("'version' must be >= '2021-04-10' when providing the 'f' permission.");
    }
    if (version2 < "2020-02-10" && (blobSASSignatureValues.preauthorizedAgentObjectId || blobSASSignatureValues.correlationId)) {
      throw RangeError("'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.");
    }
    if (blobSASSignatureValues.encryptionScope && version2 < "2020-12-06") {
      throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
    }
    blobSASSignatureValues.version = version2;
    return blobSASSignatureValues;
  }

  class BlobLeaseClient {
    get leaseId() {
      return this._leaseId;
    }
    get url() {
      return this._url;
    }
    constructor(client, leaseId2) {
      const clientContext = client.storageClientContext;
      this._url = client.url;
      if (client.name === undefined) {
        this._isContainer = true;
        this._containerOrBlobOperation = clientContext.container;
      } else {
        this._isContainer = false;
        this._containerOrBlobOperation = clientContext.blob;
      }
      if (!leaseId2) {
        leaseId2 = coreUtil.randomUUID();
      }
      this._leaseId = leaseId2;
    }
    async acquireLease(duration2, options = {}) {
      var _a3, _b2, _c2, _d2, _e2;
      if (this._isContainer && (((_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.ifMatch) && ((_b2 = options.conditions) === null || _b2 === undefined ? undefined : _b2.ifMatch) !== ETagNone || ((_c2 = options.conditions) === null || _c2 === undefined ? undefined : _c2.ifNoneMatch) && ((_d2 = options.conditions) === null || _d2 === undefined ? undefined : _d2.ifNoneMatch) !== ETagNone || ((_e2 = options.conditions) === null || _e2 === undefined ? undefined : _e2.tagConditions))) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracingClient.withSpan("BlobLeaseClient-acquireLease", options, async (updatedOptions) => {
        var _a4;
        return assertResponse(await this._containerOrBlobOperation.acquireLease({
          abortSignal: options.abortSignal,
          duration: duration2,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a4 = options.conditions) === null || _a4 === undefined ? undefined : _a4.tagConditions }),
          proposedLeaseId: this._leaseId,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async changeLease(proposedLeaseId2, options = {}) {
      var _a3, _b2, _c2, _d2, _e2;
      if (this._isContainer && (((_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.ifMatch) && ((_b2 = options.conditions) === null || _b2 === undefined ? undefined : _b2.ifMatch) !== ETagNone || ((_c2 = options.conditions) === null || _c2 === undefined ? undefined : _c2.ifNoneMatch) && ((_d2 = options.conditions) === null || _d2 === undefined ? undefined : _d2.ifNoneMatch) !== ETagNone || ((_e2 = options.conditions) === null || _e2 === undefined ? undefined : _e2.tagConditions))) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracingClient.withSpan("BlobLeaseClient-changeLease", options, async (updatedOptions) => {
        var _a4;
        const response = assertResponse(await this._containerOrBlobOperation.changeLease(this._leaseId, proposedLeaseId2, {
          abortSignal: options.abortSignal,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a4 = options.conditions) === null || _a4 === undefined ? undefined : _a4.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        this._leaseId = proposedLeaseId2;
        return response;
      });
    }
    async releaseLease(options = {}) {
      var _a3, _b2, _c2, _d2, _e2;
      if (this._isContainer && (((_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.ifMatch) && ((_b2 = options.conditions) === null || _b2 === undefined ? undefined : _b2.ifMatch) !== ETagNone || ((_c2 = options.conditions) === null || _c2 === undefined ? undefined : _c2.ifNoneMatch) && ((_d2 = options.conditions) === null || _d2 === undefined ? undefined : _d2.ifNoneMatch) !== ETagNone || ((_e2 = options.conditions) === null || _e2 === undefined ? undefined : _e2.tagConditions))) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracingClient.withSpan("BlobLeaseClient-releaseLease", options, async (updatedOptions) => {
        var _a4;
        return assertResponse(await this._containerOrBlobOperation.releaseLease(this._leaseId, {
          abortSignal: options.abortSignal,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a4 = options.conditions) === null || _a4 === undefined ? undefined : _a4.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async renewLease(options = {}) {
      var _a3, _b2, _c2, _d2, _e2;
      if (this._isContainer && (((_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.ifMatch) && ((_b2 = options.conditions) === null || _b2 === undefined ? undefined : _b2.ifMatch) !== ETagNone || ((_c2 = options.conditions) === null || _c2 === undefined ? undefined : _c2.ifNoneMatch) && ((_d2 = options.conditions) === null || _d2 === undefined ? undefined : _d2.ifNoneMatch) !== ETagNone || ((_e2 = options.conditions) === null || _e2 === undefined ? undefined : _e2.tagConditions))) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracingClient.withSpan("BlobLeaseClient-renewLease", options, async (updatedOptions) => {
        var _a4;
        return this._containerOrBlobOperation.renewLease(this._leaseId, {
          abortSignal: options.abortSignal,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a4 = options.conditions) === null || _a4 === undefined ? undefined : _a4.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        });
      });
    }
    async breakLease(breakPeriod2, options = {}) {
      var _a3, _b2, _c2, _d2, _e2;
      if (this._isContainer && (((_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.ifMatch) && ((_b2 = options.conditions) === null || _b2 === undefined ? undefined : _b2.ifMatch) !== ETagNone || ((_c2 = options.conditions) === null || _c2 === undefined ? undefined : _c2.ifNoneMatch) && ((_d2 = options.conditions) === null || _d2 === undefined ? undefined : _d2.ifNoneMatch) !== ETagNone || ((_e2 = options.conditions) === null || _e2 === undefined ? undefined : _e2.tagConditions))) {
        throw new RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      }
      return tracingClient.withSpan("BlobLeaseClient-breakLease", options, async (updatedOptions) => {
        var _a4;
        const operationOptions = {
          abortSignal: options.abortSignal,
          breakPeriod: breakPeriod2,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a4 = options.conditions) === null || _a4 === undefined ? undefined : _a4.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        };
        return assertResponse(await this._containerOrBlobOperation.breakLease(operationOptions));
      });
    }
  }

  class RetriableReadableStream extends stream.Readable {
    constructor(source, getter, offset, count, options = {}) {
      super({ highWaterMark: options.highWaterMark });
      this.retries = 0;
      this.sourceDataHandler = (data) => {
        if (this.options.doInjectErrorOnce) {
          this.options.doInjectErrorOnce = undefined;
          this.source.pause();
          this.sourceErrorOrEndHandler();
          this.source.destroy();
          return;
        }
        this.offset += data.length;
        if (this.onProgress) {
          this.onProgress({ loadedBytes: this.offset - this.start });
        }
        if (!this.push(data)) {
          this.source.pause();
        }
      };
      this.sourceAbortedHandler = () => {
        const abortError = new abortController.AbortError("The operation was aborted.");
        this.destroy(abortError);
      };
      this.sourceErrorOrEndHandler = (err) => {
        if (err && err.name === "AbortError") {
          this.destroy(err);
          return;
        }
        this.removeSourceEventHandlers();
        if (this.offset - 1 === this.end) {
          this.push(null);
        } else if (this.offset <= this.end) {
          if (this.retries < this.maxRetryRequests) {
            this.retries += 1;
            this.getter(this.offset).then((newSource) => {
              this.source = newSource;
              this.setSourceEventHandlers();
              return;
            }).catch((error) => {
              this.destroy(error);
            });
          } else {
            this.destroy(new Error(`Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: ${this.offset - 1}, data needed offset: ${this.end}, retries: ${this.retries}, max retries: ${this.maxRetryRequests}`));
          }
        } else {
          this.destroy(new Error(`Data corruption failure: Received more data than original request, data needed offset is ${this.end}, received offset: ${this.offset - 1}`));
        }
      };
      this.getter = getter;
      this.source = source;
      this.start = offset;
      this.offset = offset;
      this.end = offset + count - 1;
      this.maxRetryRequests = options.maxRetryRequests && options.maxRetryRequests >= 0 ? options.maxRetryRequests : 0;
      this.onProgress = options.onProgress;
      this.options = options;
      this.setSourceEventHandlers();
    }
    _read() {
      this.source.resume();
    }
    setSourceEventHandlers() {
      this.source.on("data", this.sourceDataHandler);
      this.source.on("end", this.sourceErrorOrEndHandler);
      this.source.on("error", this.sourceErrorOrEndHandler);
      this.source.on("aborted", this.sourceAbortedHandler);
    }
    removeSourceEventHandlers() {
      this.source.removeListener("data", this.sourceDataHandler);
      this.source.removeListener("end", this.sourceErrorOrEndHandler);
      this.source.removeListener("error", this.sourceErrorOrEndHandler);
      this.source.removeListener("aborted", this.sourceAbortedHandler);
    }
    _destroy(error, callback) {
      this.removeSourceEventHandlers();
      this.source.destroy();
      callback(error === null ? undefined : error);
    }
  }

  class BlobDownloadResponse {
    get acceptRanges() {
      return this.originalResponse.acceptRanges;
    }
    get cacheControl() {
      return this.originalResponse.cacheControl;
    }
    get contentDisposition() {
      return this.originalResponse.contentDisposition;
    }
    get contentEncoding() {
      return this.originalResponse.contentEncoding;
    }
    get contentLanguage() {
      return this.originalResponse.contentLanguage;
    }
    get blobSequenceNumber() {
      return this.originalResponse.blobSequenceNumber;
    }
    get blobType() {
      return this.originalResponse.blobType;
    }
    get contentLength() {
      return this.originalResponse.contentLength;
    }
    get contentMD5() {
      return this.originalResponse.contentMD5;
    }
    get contentRange() {
      return this.originalResponse.contentRange;
    }
    get contentType() {
      return this.originalResponse.contentType;
    }
    get copyCompletedOn() {
      return this.originalResponse.copyCompletedOn;
    }
    get copyId() {
      return this.originalResponse.copyId;
    }
    get copyProgress() {
      return this.originalResponse.copyProgress;
    }
    get copySource() {
      return this.originalResponse.copySource;
    }
    get copyStatus() {
      return this.originalResponse.copyStatus;
    }
    get copyStatusDescription() {
      return this.originalResponse.copyStatusDescription;
    }
    get leaseDuration() {
      return this.originalResponse.leaseDuration;
    }
    get leaseState() {
      return this.originalResponse.leaseState;
    }
    get leaseStatus() {
      return this.originalResponse.leaseStatus;
    }
    get date() {
      return this.originalResponse.date;
    }
    get blobCommittedBlockCount() {
      return this.originalResponse.blobCommittedBlockCount;
    }
    get etag() {
      return this.originalResponse.etag;
    }
    get tagCount() {
      return this.originalResponse.tagCount;
    }
    get errorCode() {
      return this.originalResponse.errorCode;
    }
    get isServerEncrypted() {
      return this.originalResponse.isServerEncrypted;
    }
    get blobContentMD5() {
      return this.originalResponse.blobContentMD5;
    }
    get lastModified() {
      return this.originalResponse.lastModified;
    }
    get lastAccessed() {
      return this.originalResponse.lastAccessed;
    }
    get createdOn() {
      return this.originalResponse.createdOn;
    }
    get metadata() {
      return this.originalResponse.metadata;
    }
    get requestId() {
      return this.originalResponse.requestId;
    }
    get clientRequestId() {
      return this.originalResponse.clientRequestId;
    }
    get version() {
      return this.originalResponse.version;
    }
    get versionId() {
      return this.originalResponse.versionId;
    }
    get isCurrentVersion() {
      return this.originalResponse.isCurrentVersion;
    }
    get encryptionKeySha256() {
      return this.originalResponse.encryptionKeySha256;
    }
    get contentCrc64() {
      return this.originalResponse.contentCrc64;
    }
    get objectReplicationDestinationPolicyId() {
      return this.originalResponse.objectReplicationDestinationPolicyId;
    }
    get objectReplicationSourceProperties() {
      return this.originalResponse.objectReplicationSourceProperties;
    }
    get isSealed() {
      return this.originalResponse.isSealed;
    }
    get immutabilityPolicyExpiresOn() {
      return this.originalResponse.immutabilityPolicyExpiresOn;
    }
    get immutabilityPolicyMode() {
      return this.originalResponse.immutabilityPolicyMode;
    }
    get legalHold() {
      return this.originalResponse.legalHold;
    }
    get contentAsBlob() {
      return this.originalResponse.blobBody;
    }
    get readableStreamBody() {
      return coreUtil.isNode ? this.blobDownloadStream : undefined;
    }
    get _response() {
      return this.originalResponse._response;
    }
    constructor(originalResponse, getter, offset, count, options = {}) {
      this.originalResponse = originalResponse;
      this.blobDownloadStream = new RetriableReadableStream(this.originalResponse.readableStreamBody, getter, offset, count, options);
    }
  }
  var AVRO_SYNC_MARKER_SIZE = 16;
  var AVRO_INIT_BYTES = new Uint8Array([79, 98, 106, 1]);
  var AVRO_CODEC_KEY = "avro.codec";
  var AVRO_SCHEMA_KEY = "avro.schema";

  class AvroParser {
    static async readFixedBytes(stream2, length, options = {}) {
      const bytes = await stream2.read(length, { abortSignal: options.abortSignal });
      if (bytes.length !== length) {
        throw new Error("Hit stream end.");
      }
      return bytes;
    }
    static async readByte(stream2, options = {}) {
      const buf = await AvroParser.readFixedBytes(stream2, 1, options);
      return buf[0];
    }
    static async readZigZagLong(stream2, options = {}) {
      let zigZagEncoded = 0;
      let significanceInBit = 0;
      let byte, haveMoreByte, significanceInFloat;
      do {
        byte = await AvroParser.readByte(stream2, options);
        haveMoreByte = byte & 128;
        zigZagEncoded |= (byte & 127) << significanceInBit;
        significanceInBit += 7;
      } while (haveMoreByte && significanceInBit < 28);
      if (haveMoreByte) {
        zigZagEncoded = zigZagEncoded;
        significanceInFloat = 268435456;
        do {
          byte = await AvroParser.readByte(stream2, options);
          zigZagEncoded += (byte & 127) * significanceInFloat;
          significanceInFloat *= 128;
        } while (byte & 128);
        const res = (zigZagEncoded % 2 ? -(zigZagEncoded + 1) : zigZagEncoded) / 2;
        if (res < Number.MIN_SAFE_INTEGER || res > Number.MAX_SAFE_INTEGER) {
          throw new Error("Integer overflow.");
        }
        return res;
      }
      return zigZagEncoded >> 1 ^ -(zigZagEncoded & 1);
    }
    static async readLong(stream2, options = {}) {
      return AvroParser.readZigZagLong(stream2, options);
    }
    static async readInt(stream2, options = {}) {
      return AvroParser.readZigZagLong(stream2, options);
    }
    static async readNull() {
      return null;
    }
    static async readBoolean(stream2, options = {}) {
      const b2 = await AvroParser.readByte(stream2, options);
      if (b2 === 1) {
        return true;
      } else if (b2 === 0) {
        return false;
      } else {
        throw new Error("Byte was not a boolean.");
      }
    }
    static async readFloat(stream2, options = {}) {
      const u8arr = await AvroParser.readFixedBytes(stream2, 4, options);
      const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);
      return view.getFloat32(0, true);
    }
    static async readDouble(stream2, options = {}) {
      const u8arr = await AvroParser.readFixedBytes(stream2, 8, options);
      const view = new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength);
      return view.getFloat64(0, true);
    }
    static async readBytes(stream2, options = {}) {
      const size = await AvroParser.readLong(stream2, options);
      if (size < 0) {
        throw new Error("Bytes size was negative.");
      }
      return stream2.read(size, { abortSignal: options.abortSignal });
    }
    static async readString(stream2, options = {}) {
      const u8arr = await AvroParser.readBytes(stream2, options);
      const utf8decoder = new TextDecoder;
      return utf8decoder.decode(u8arr);
    }
    static async readMapPair(stream2, readItemMethod, options = {}) {
      const key = await AvroParser.readString(stream2, options);
      const value = await readItemMethod(stream2, options);
      return { key, value };
    }
    static async readMap(stream2, readItemMethod, options = {}) {
      const readPairMethod = (s2, opts = {}) => {
        return AvroParser.readMapPair(s2, readItemMethod, opts);
      };
      const pairs = await AvroParser.readArray(stream2, readPairMethod, options);
      const dict = {};
      for (const pair of pairs) {
        dict[pair.key] = pair.value;
      }
      return dict;
    }
    static async readArray(stream2, readItemMethod, options = {}) {
      const items = [];
      for (let count = await AvroParser.readLong(stream2, options);count !== 0; count = await AvroParser.readLong(stream2, options)) {
        if (count < 0) {
          await AvroParser.readLong(stream2, options);
          count = -count;
        }
        while (count--) {
          const item = await readItemMethod(stream2, options);
          items.push(item);
        }
      }
      return items;
    }
  }
  var AvroComplex;
  (function(AvroComplex2) {
    AvroComplex2["RECORD"] = "record";
    AvroComplex2["ENUM"] = "enum";
    AvroComplex2["ARRAY"] = "array";
    AvroComplex2["MAP"] = "map";
    AvroComplex2["UNION"] = "union";
    AvroComplex2["FIXED"] = "fixed";
  })(AvroComplex || (AvroComplex = {}));
  var AvroPrimitive;
  (function(AvroPrimitive2) {
    AvroPrimitive2["NULL"] = "null";
    AvroPrimitive2["BOOLEAN"] = "boolean";
    AvroPrimitive2["INT"] = "int";
    AvroPrimitive2["LONG"] = "long";
    AvroPrimitive2["FLOAT"] = "float";
    AvroPrimitive2["DOUBLE"] = "double";
    AvroPrimitive2["BYTES"] = "bytes";
    AvroPrimitive2["STRING"] = "string";
  })(AvroPrimitive || (AvroPrimitive = {}));

  class AvroType {
    static fromSchema(schema) {
      if (typeof schema === "string") {
        return AvroType.fromStringSchema(schema);
      } else if (Array.isArray(schema)) {
        return AvroType.fromArraySchema(schema);
      } else {
        return AvroType.fromObjectSchema(schema);
      }
    }
    static fromStringSchema(schema) {
      switch (schema) {
        case AvroPrimitive.NULL:
        case AvroPrimitive.BOOLEAN:
        case AvroPrimitive.INT:
        case AvroPrimitive.LONG:
        case AvroPrimitive.FLOAT:
        case AvroPrimitive.DOUBLE:
        case AvroPrimitive.BYTES:
        case AvroPrimitive.STRING:
          return new AvroPrimitiveType(schema);
        default:
          throw new Error(`Unexpected Avro type ${schema}`);
      }
    }
    static fromArraySchema(schema) {
      return new AvroUnionType(schema.map(AvroType.fromSchema));
    }
    static fromObjectSchema(schema) {
      const type3 = schema.type;
      try {
        return AvroType.fromStringSchema(type3);
      } catch (_a3) {
      }
      switch (type3) {
        case AvroComplex.RECORD:
          if (schema.aliases) {
            throw new Error(`aliases currently is not supported, schema: ${schema}`);
          }
          if (!schema.name) {
            throw new Error(`Required attribute 'name' doesn't exist on schema: ${schema}`);
          }
          const fields = {};
          if (!schema.fields) {
            throw new Error(`Required attribute 'fields' doesn't exist on schema: ${schema}`);
          }
          for (const field of schema.fields) {
            fields[field.name] = AvroType.fromSchema(field.type);
          }
          return new AvroRecordType(fields, schema.name);
        case AvroComplex.ENUM:
          if (schema.aliases) {
            throw new Error(`aliases currently is not supported, schema: ${schema}`);
          }
          if (!schema.symbols) {
            throw new Error(`Required attribute 'symbols' doesn't exist on schema: ${schema}`);
          }
          return new AvroEnumType(schema.symbols);
        case AvroComplex.MAP:
          if (!schema.values) {
            throw new Error(`Required attribute 'values' doesn't exist on schema: ${schema}`);
          }
          return new AvroMapType(AvroType.fromSchema(schema.values));
        case AvroComplex.ARRAY:
        case AvroComplex.FIXED:
        default:
          throw new Error(`Unexpected Avro type ${type3} in ${schema}`);
      }
    }
  }

  class AvroPrimitiveType extends AvroType {
    constructor(primitive) {
      super();
      this._primitive = primitive;
    }
    read(stream2, options = {}) {
      switch (this._primitive) {
        case AvroPrimitive.NULL:
          return AvroParser.readNull();
        case AvroPrimitive.BOOLEAN:
          return AvroParser.readBoolean(stream2, options);
        case AvroPrimitive.INT:
          return AvroParser.readInt(stream2, options);
        case AvroPrimitive.LONG:
          return AvroParser.readLong(stream2, options);
        case AvroPrimitive.FLOAT:
          return AvroParser.readFloat(stream2, options);
        case AvroPrimitive.DOUBLE:
          return AvroParser.readDouble(stream2, options);
        case AvroPrimitive.BYTES:
          return AvroParser.readBytes(stream2, options);
        case AvroPrimitive.STRING:
          return AvroParser.readString(stream2, options);
        default:
          throw new Error("Unknown Avro Primitive");
      }
    }
  }

  class AvroEnumType extends AvroType {
    constructor(symbols) {
      super();
      this._symbols = symbols;
    }
    async read(stream2, options = {}) {
      const value = await AvroParser.readInt(stream2, options);
      return this._symbols[value];
    }
  }

  class AvroUnionType extends AvroType {
    constructor(types2) {
      super();
      this._types = types2;
    }
    async read(stream2, options = {}) {
      const typeIndex = await AvroParser.readInt(stream2, options);
      return this._types[typeIndex].read(stream2, options);
    }
  }

  class AvroMapType extends AvroType {
    constructor(itemType) {
      super();
      this._itemType = itemType;
    }
    read(stream2, options = {}) {
      const readItemMethod = (s2, opts) => {
        return this._itemType.read(s2, opts);
      };
      return AvroParser.readMap(stream2, readItemMethod, options);
    }
  }

  class AvroRecordType extends AvroType {
    constructor(fields, name) {
      super();
      this._fields = fields;
      this._name = name;
    }
    async read(stream2, options = {}) {
      const record = {};
      record["$schema"] = this._name;
      for (const key in this._fields) {
        if (Object.prototype.hasOwnProperty.call(this._fields, key)) {
          record[key] = await this._fields[key].read(stream2, options);
        }
      }
      return record;
    }
  }
  function arraysEqual(a2, b2) {
    if (a2 === b2)
      return true;
    if (a2 == null || b2 == null)
      return false;
    if (a2.length !== b2.length)
      return false;
    for (let i2 = 0;i2 < a2.length; ++i2) {
      if (a2[i2] !== b2[i2])
        return false;
    }
    return true;
  }

  class AvroReader {
    get blockOffset() {
      return this._blockOffset;
    }
    get objectIndex() {
      return this._objectIndex;
    }
    constructor(dataStream, headerStream, currentBlockOffset, indexWithinCurrentBlock) {
      this._dataStream = dataStream;
      this._headerStream = headerStream || dataStream;
      this._initialized = false;
      this._blockOffset = currentBlockOffset || 0;
      this._objectIndex = indexWithinCurrentBlock || 0;
      this._initialBlockOffset = currentBlockOffset || 0;
    }
    async initialize(options = {}) {
      const header = await AvroParser.readFixedBytes(this._headerStream, AVRO_INIT_BYTES.length, {
        abortSignal: options.abortSignal
      });
      if (!arraysEqual(header, AVRO_INIT_BYTES)) {
        throw new Error("Stream is not an Avro file.");
      }
      this._metadata = await AvroParser.readMap(this._headerStream, AvroParser.readString, {
        abortSignal: options.abortSignal
      });
      const codec = this._metadata[AVRO_CODEC_KEY];
      if (!(codec === undefined || codec === null || codec === "null")) {
        throw new Error("Codecs are not supported");
      }
      this._syncMarker = await AvroParser.readFixedBytes(this._headerStream, AVRO_SYNC_MARKER_SIZE, {
        abortSignal: options.abortSignal
      });
      const schema = JSON.parse(this._metadata[AVRO_SCHEMA_KEY]);
      this._itemType = AvroType.fromSchema(schema);
      if (this._blockOffset === 0) {
        this._blockOffset = this._initialBlockOffset + this._dataStream.position;
      }
      this._itemsRemainingInBlock = await AvroParser.readLong(this._dataStream, {
        abortSignal: options.abortSignal
      });
      await AvroParser.readLong(this._dataStream, { abortSignal: options.abortSignal });
      this._initialized = true;
      if (this._objectIndex && this._objectIndex > 0) {
        for (let i2 = 0;i2 < this._objectIndex; i2++) {
          await this._itemType.read(this._dataStream, { abortSignal: options.abortSignal });
          this._itemsRemainingInBlock--;
        }
      }
    }
    hasNext() {
      return !this._initialized || this._itemsRemainingInBlock > 0;
    }
    parseObjects() {
      return tslib2.__asyncGenerator(this, arguments, function* parseObjects_1(options = {}) {
        if (!this._initialized) {
          yield tslib2.__await(this.initialize(options));
        }
        while (this.hasNext()) {
          const result = yield tslib2.__await(this._itemType.read(this._dataStream, {
            abortSignal: options.abortSignal
          }));
          this._itemsRemainingInBlock--;
          this._objectIndex++;
          if (this._itemsRemainingInBlock === 0) {
            const marker2 = yield tslib2.__await(AvroParser.readFixedBytes(this._dataStream, AVRO_SYNC_MARKER_SIZE, {
              abortSignal: options.abortSignal
            }));
            this._blockOffset = this._initialBlockOffset + this._dataStream.position;
            this._objectIndex = 0;
            if (!arraysEqual(this._syncMarker, marker2)) {
              throw new Error("Stream is not a valid Avro file.");
            }
            try {
              this._itemsRemainingInBlock = yield tslib2.__await(AvroParser.readLong(this._dataStream, {
                abortSignal: options.abortSignal
              }));
            } catch (_a3) {
              this._itemsRemainingInBlock = 0;
            }
            if (this._itemsRemainingInBlock > 0) {
              yield tslib2.__await(AvroParser.readLong(this._dataStream, { abortSignal: options.abortSignal }));
            }
          }
          yield yield tslib2.__await(result);
        }
      });
    }
  }

  class AvroReadable {
  }
  var ABORT_ERROR = new abortController.AbortError("Reading from the avro stream was aborted.");

  class AvroReadableFromStream extends AvroReadable {
    toUint8Array(data) {
      if (typeof data === "string") {
        return Buffer.from(data);
      }
      return data;
    }
    constructor(readable) {
      super();
      this._readable = readable;
      this._position = 0;
    }
    get position() {
      return this._position;
    }
    async read(size, options = {}) {
      var _a3;
      if ((_a3 = options.abortSignal) === null || _a3 === undefined ? undefined : _a3.aborted) {
        throw ABORT_ERROR;
      }
      if (size < 0) {
        throw new Error(`size parameter should be positive: ${size}`);
      }
      if (size === 0) {
        return new Uint8Array;
      }
      if (!this._readable.readable) {
        throw new Error("Stream no longer readable.");
      }
      const chunk = this._readable.read(size);
      if (chunk) {
        this._position += chunk.length;
        return this.toUint8Array(chunk);
      } else {
        return new Promise((resolve5, reject) => {
          const cleanUp = () => {
            this._readable.removeListener("readable", readableCallback);
            this._readable.removeListener("error", rejectCallback);
            this._readable.removeListener("end", rejectCallback);
            this._readable.removeListener("close", rejectCallback);
            if (options.abortSignal) {
              options.abortSignal.removeEventListener("abort", abortHandler);
            }
          };
          const readableCallback = () => {
            const callbackChunk = this._readable.read(size);
            if (callbackChunk) {
              this._position += callbackChunk.length;
              cleanUp();
              resolve5(this.toUint8Array(callbackChunk));
            }
          };
          const rejectCallback = () => {
            cleanUp();
            reject();
          };
          const abortHandler = () => {
            cleanUp();
            reject(ABORT_ERROR);
          };
          this._readable.on("readable", readableCallback);
          this._readable.once("error", rejectCallback);
          this._readable.once("end", rejectCallback);
          this._readable.once("close", rejectCallback);
          if (options.abortSignal) {
            options.abortSignal.addEventListener("abort", abortHandler);
          }
        });
      }
    }
  }

  class BlobQuickQueryStream extends stream.Readable {
    constructor(source, options = {}) {
      super();
      this.avroPaused = true;
      this.source = source;
      this.onProgress = options.onProgress;
      this.onError = options.onError;
      this.avroReader = new AvroReader(new AvroReadableFromStream(this.source));
      this.avroIter = this.avroReader.parseObjects({ abortSignal: options.abortSignal });
    }
    _read() {
      if (this.avroPaused) {
        this.readInternal().catch((err) => {
          this.emit("error", err);
        });
      }
    }
    async readInternal() {
      this.avroPaused = false;
      let avroNext;
      do {
        avroNext = await this.avroIter.next();
        if (avroNext.done) {
          break;
        }
        const obj = avroNext.value;
        const schema = obj.$schema;
        if (typeof schema !== "string") {
          throw Error("Missing schema in avro record.");
        }
        switch (schema) {
          case "com.microsoft.azure.storage.queryBlobContents.resultData":
            {
              const data = obj.data;
              if (data instanceof Uint8Array === false) {
                throw Error("Invalid data in avro result record.");
              }
              if (!this.push(Buffer.from(data))) {
                this.avroPaused = true;
              }
            }
            break;
          case "com.microsoft.azure.storage.queryBlobContents.progress":
            {
              const bytesScanned = obj.bytesScanned;
              if (typeof bytesScanned !== "number") {
                throw Error("Invalid bytesScanned in avro progress record.");
              }
              if (this.onProgress) {
                this.onProgress({ loadedBytes: bytesScanned });
              }
            }
            break;
          case "com.microsoft.azure.storage.queryBlobContents.end":
            if (this.onProgress) {
              const totalBytes = obj.totalBytes;
              if (typeof totalBytes !== "number") {
                throw Error("Invalid totalBytes in avro end record.");
              }
              this.onProgress({ loadedBytes: totalBytes });
            }
            this.push(null);
            break;
          case "com.microsoft.azure.storage.queryBlobContents.error":
            if (this.onError) {
              const fatal = obj.fatal;
              if (typeof fatal !== "boolean") {
                throw Error("Invalid fatal in avro error record.");
              }
              const name = obj.name;
              if (typeof name !== "string") {
                throw Error("Invalid name in avro error record.");
              }
              const description = obj.description;
              if (typeof description !== "string") {
                throw Error("Invalid description in avro error record.");
              }
              const position = obj.position;
              if (typeof position !== "number") {
                throw Error("Invalid position in avro error record.");
              }
              this.onError({
                position,
                name,
                isFatal: fatal,
                description
              });
            }
            break;
          default:
            throw Error(`Unknown schema ${schema} in avro progress record.`);
        }
      } while (!avroNext.done && !this.avroPaused);
    }
  }

  class BlobQueryResponse {
    get acceptRanges() {
      return this.originalResponse.acceptRanges;
    }
    get cacheControl() {
      return this.originalResponse.cacheControl;
    }
    get contentDisposition() {
      return this.originalResponse.contentDisposition;
    }
    get contentEncoding() {
      return this.originalResponse.contentEncoding;
    }
    get contentLanguage() {
      return this.originalResponse.contentLanguage;
    }
    get blobSequenceNumber() {
      return this.originalResponse.blobSequenceNumber;
    }
    get blobType() {
      return this.originalResponse.blobType;
    }
    get contentLength() {
      return this.originalResponse.contentLength;
    }
    get contentMD5() {
      return this.originalResponse.contentMD5;
    }
    get contentRange() {
      return this.originalResponse.contentRange;
    }
    get contentType() {
      return this.originalResponse.contentType;
    }
    get copyCompletedOn() {
      return;
    }
    get copyId() {
      return this.originalResponse.copyId;
    }
    get copyProgress() {
      return this.originalResponse.copyProgress;
    }
    get copySource() {
      return this.originalResponse.copySource;
    }
    get copyStatus() {
      return this.originalResponse.copyStatus;
    }
    get copyStatusDescription() {
      return this.originalResponse.copyStatusDescription;
    }
    get leaseDuration() {
      return this.originalResponse.leaseDuration;
    }
    get leaseState() {
      return this.originalResponse.leaseState;
    }
    get leaseStatus() {
      return this.originalResponse.leaseStatus;
    }
    get date() {
      return this.originalResponse.date;
    }
    get blobCommittedBlockCount() {
      return this.originalResponse.blobCommittedBlockCount;
    }
    get etag() {
      return this.originalResponse.etag;
    }
    get errorCode() {
      return this.originalResponse.errorCode;
    }
    get isServerEncrypted() {
      return this.originalResponse.isServerEncrypted;
    }
    get blobContentMD5() {
      return this.originalResponse.blobContentMD5;
    }
    get lastModified() {
      return this.originalResponse.lastModified;
    }
    get metadata() {
      return this.originalResponse.metadata;
    }
    get requestId() {
      return this.originalResponse.requestId;
    }
    get clientRequestId() {
      return this.originalResponse.clientRequestId;
    }
    get version() {
      return this.originalResponse.version;
    }
    get encryptionKeySha256() {
      return this.originalResponse.encryptionKeySha256;
    }
    get contentCrc64() {
      return this.originalResponse.contentCrc64;
    }
    get blobBody() {
      return;
    }
    get readableStreamBody() {
      return coreUtil.isNode ? this.blobDownloadStream : undefined;
    }
    get _response() {
      return this.originalResponse._response;
    }
    constructor(originalResponse, options = {}) {
      this.originalResponse = originalResponse;
      this.blobDownloadStream = new BlobQuickQueryStream(this.originalResponse.readableStreamBody, options);
    }
  }
  exports.BlockBlobTier = undefined;
  (function(BlockBlobTier) {
    BlockBlobTier["Hot"] = "Hot";
    BlockBlobTier["Cool"] = "Cool";
    BlockBlobTier["Cold"] = "Cold";
    BlockBlobTier["Archive"] = "Archive";
  })(exports.BlockBlobTier || (exports.BlockBlobTier = {}));
  exports.PremiumPageBlobTier = undefined;
  (function(PremiumPageBlobTier) {
    PremiumPageBlobTier["P4"] = "P4";
    PremiumPageBlobTier["P6"] = "P6";
    PremiumPageBlobTier["P10"] = "P10";
    PremiumPageBlobTier["P15"] = "P15";
    PremiumPageBlobTier["P20"] = "P20";
    PremiumPageBlobTier["P30"] = "P30";
    PremiumPageBlobTier["P40"] = "P40";
    PremiumPageBlobTier["P50"] = "P50";
    PremiumPageBlobTier["P60"] = "P60";
    PremiumPageBlobTier["P70"] = "P70";
    PremiumPageBlobTier["P80"] = "P80";
  })(exports.PremiumPageBlobTier || (exports.PremiumPageBlobTier = {}));
  function toAccessTier(tier2) {
    if (tier2 === undefined) {
      return;
    }
    return tier2;
  }
  function ensureCpkIfSpecified(cpk, isHttps) {
    if (cpk && !isHttps) {
      throw new RangeError("Customer-provided encryption key must be used over HTTPS.");
    }
    if (cpk && !cpk.encryptionAlgorithm) {
      cpk.encryptionAlgorithm = EncryptionAlgorithmAES25;
    }
  }
  exports.StorageBlobAudience = undefined;
  (function(StorageBlobAudience) {
    StorageBlobAudience["StorageOAuthScopes"] = "https://storage.azure.com/.default";
    StorageBlobAudience["DiskComputeOAuthScopes"] = "https://disk.compute.azure.com/.default";
  })(exports.StorageBlobAudience || (exports.StorageBlobAudience = {}));
  function getBlobServiceAccountAudience(storageAccountName) {
    return `https://${storageAccountName}.blob.core.windows.net/.default`;
  }
  function rangeResponseFromModel(response) {
    const pageRange = (response._response.parsedBody.pageRange || []).map((x2) => ({
      offset: x2.start,
      count: x2.end - x2.start
    }));
    const clearRange = (response._response.parsedBody.clearRange || []).map((x2) => ({
      offset: x2.start,
      count: x2.end - x2.start
    }));
    return Object.assign(Object.assign({}, response), {
      pageRange,
      clearRange,
      _response: Object.assign(Object.assign({}, response._response), { parsedBody: {
        pageRange,
        clearRange
      } })
    });
  }

  class BlobBeginCopyFromUrlPoller extends coreLro.Poller {
    constructor(options) {
      const { blobClient, copySource: copySource2, intervalInMs = 15000, onProgress, resumeFrom, startCopyFromURLOptions } = options;
      let state2;
      if (resumeFrom) {
        state2 = JSON.parse(resumeFrom).state;
      }
      const operation = makeBlobBeginCopyFromURLPollOperation(Object.assign(Object.assign({}, state2), {
        blobClient,
        copySource: copySource2,
        startCopyFromURLOptions
      }));
      super(operation);
      if (typeof onProgress === "function") {
        this.onProgress(onProgress);
      }
      this.intervalInMs = intervalInMs;
    }
    delay() {
      return coreUtil.delay(this.intervalInMs);
    }
  }
  var cancel = async function cancel(options = {}) {
    const state2 = this.state;
    const { copyId: copyId2 } = state2;
    if (state2.isCompleted) {
      return makeBlobBeginCopyFromURLPollOperation(state2);
    }
    if (!copyId2) {
      state2.isCancelled = true;
      return makeBlobBeginCopyFromURLPollOperation(state2);
    }
    await state2.blobClient.abortCopyFromURL(copyId2, {
      abortSignal: options.abortSignal
    });
    state2.isCancelled = true;
    return makeBlobBeginCopyFromURLPollOperation(state2);
  };
  var update2 = async function update(options = {}) {
    const state2 = this.state;
    const { blobClient, copySource: copySource2, startCopyFromURLOptions } = state2;
    if (!state2.isStarted) {
      state2.isStarted = true;
      const result = await blobClient.startCopyFromURL(copySource2, startCopyFromURLOptions);
      state2.copyId = result.copyId;
      if (result.copyStatus === "success") {
        state2.result = result;
        state2.isCompleted = true;
      }
    } else if (!state2.isCompleted) {
      try {
        const result = await state2.blobClient.getProperties({ abortSignal: options.abortSignal });
        const { copyStatus, copyProgress } = result;
        const prevCopyProgress = state2.copyProgress;
        if (copyProgress) {
          state2.copyProgress = copyProgress;
        }
        if (copyStatus === "pending" && copyProgress !== prevCopyProgress && typeof options.fireProgress === "function") {
          options.fireProgress(state2);
        } else if (copyStatus === "success") {
          state2.result = result;
          state2.isCompleted = true;
        } else if (copyStatus === "failed") {
          state2.error = new Error(`Blob copy failed with reason: "${result.copyStatusDescription || "unknown"}"`);
          state2.isCompleted = true;
        }
      } catch (err) {
        state2.error = err;
        state2.isCompleted = true;
      }
    }
    return makeBlobBeginCopyFromURLPollOperation(state2);
  };
  var toString = function toString() {
    return JSON.stringify({ state: this.state }, (key, value) => {
      if (key === "blobClient") {
        return;
      }
      return value;
    });
  };
  function makeBlobBeginCopyFromURLPollOperation(state2) {
    return {
      state: Object.assign({}, state2),
      cancel,
      toString,
      update: update2
    };
  }
  function rangeToString(iRange) {
    if (iRange.offset < 0) {
      throw new RangeError(`Range.offset cannot be smaller than 0.`);
    }
    if (iRange.count && iRange.count <= 0) {
      throw new RangeError(`Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.`);
    }
    return iRange.count ? `bytes=${iRange.offset}-${iRange.offset + iRange.count - 1}` : `bytes=${iRange.offset}-`;
  }
  var BatchStates;
  (function(BatchStates2) {
    BatchStates2[BatchStates2["Good"] = 0] = "Good";
    BatchStates2[BatchStates2["Error"] = 1] = "Error";
  })(BatchStates || (BatchStates = {}));

  class Batch {
    constructor(concurrency = 5) {
      this.actives = 0;
      this.completed = 0;
      this.offset = 0;
      this.operations = [];
      this.state = BatchStates.Good;
      if (concurrency < 1) {
        throw new RangeError("concurrency must be larger than 0");
      }
      this.concurrency = concurrency;
      this.emitter = new events.EventEmitter;
    }
    addOperation(operation) {
      this.operations.push(async () => {
        try {
          this.actives++;
          await operation();
          this.actives--;
          this.completed++;
          this.parallelExecute();
        } catch (error) {
          this.emitter.emit("error", error);
        }
      });
    }
    async do() {
      if (this.operations.length === 0) {
        return Promise.resolve();
      }
      this.parallelExecute();
      return new Promise((resolve5, reject) => {
        this.emitter.on("finish", resolve5);
        this.emitter.on("error", (error) => {
          this.state = BatchStates.Error;
          reject(error);
        });
      });
    }
    nextOperation() {
      if (this.offset < this.operations.length) {
        return this.operations[this.offset++];
      }
      return null;
    }
    parallelExecute() {
      if (this.state === BatchStates.Error) {
        return;
      }
      if (this.completed >= this.operations.length) {
        this.emitter.emit("finish");
        return;
      }
      while (this.actives < this.concurrency) {
        const operation = this.nextOperation();
        if (operation) {
          operation();
        } else {
          return;
        }
      }
    }
  }

  class BuffersStream extends stream.Readable {
    constructor(buffers, byteLength, options) {
      super(options);
      this.buffers = buffers;
      this.byteLength = byteLength;
      this.byteOffsetInCurrentBuffer = 0;
      this.bufferIndex = 0;
      this.pushedBytesLength = 0;
      let buffersLength = 0;
      for (const buf of this.buffers) {
        buffersLength += buf.byteLength;
      }
      if (buffersLength < this.byteLength) {
        throw new Error("Data size shouldn't be larger than the total length of buffers.");
      }
    }
    _read(size) {
      if (this.pushedBytesLength >= this.byteLength) {
        this.push(null);
      }
      if (!size) {
        size = this.readableHighWaterMark;
      }
      const outBuffers = [];
      let i2 = 0;
      while (i2 < size && this.pushedBytesLength < this.byteLength) {
        const remainingDataInAllBuffers = this.byteLength - this.pushedBytesLength;
        const remainingCapacityInThisBuffer = this.buffers[this.bufferIndex].byteLength - this.byteOffsetInCurrentBuffer;
        const remaining = Math.min(remainingCapacityInThisBuffer, remainingDataInAllBuffers);
        if (remaining > size - i2) {
          const end = this.byteOffsetInCurrentBuffer + size - i2;
          outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
          this.pushedBytesLength += size - i2;
          this.byteOffsetInCurrentBuffer = end;
          i2 = size;
          break;
        } else {
          const end = this.byteOffsetInCurrentBuffer + remaining;
          outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end));
          if (remaining === remainingCapacityInThisBuffer) {
            this.byteOffsetInCurrentBuffer = 0;
            this.bufferIndex++;
          } else {
            this.byteOffsetInCurrentBuffer = end;
          }
          this.pushedBytesLength += remaining;
          i2 += remaining;
        }
      }
      if (outBuffers.length > 1) {
        this.push(Buffer.concat(outBuffers));
      } else if (outBuffers.length === 1) {
        this.push(outBuffers[0]);
      }
    }
  }
  var maxBufferLength = buffer.constants.MAX_LENGTH;

  class PooledBuffer {
    get size() {
      return this._size;
    }
    constructor(capacity, buffers, totalLength) {
      this.buffers = [];
      this.capacity = capacity;
      this._size = 0;
      const bufferNum = Math.ceil(capacity / maxBufferLength);
      for (let i2 = 0;i2 < bufferNum; i2++) {
        let len = i2 === bufferNum - 1 ? capacity % maxBufferLength : maxBufferLength;
        if (len === 0) {
          len = maxBufferLength;
        }
        this.buffers.push(Buffer.allocUnsafe(len));
      }
      if (buffers) {
        this.fill(buffers, totalLength);
      }
    }
    fill(buffers, totalLength) {
      this._size = Math.min(this.capacity, totalLength);
      let i2 = 0, j2 = 0, targetOffset = 0, sourceOffset = 0, totalCopiedNum = 0;
      while (totalCopiedNum < this._size) {
        const source = buffers[i2];
        const target = this.buffers[j2];
        const copiedNum = source.copy(target, targetOffset, sourceOffset);
        totalCopiedNum += copiedNum;
        sourceOffset += copiedNum;
        targetOffset += copiedNum;
        if (sourceOffset === source.length) {
          i2++;
          sourceOffset = 0;
        }
        if (targetOffset === target.length) {
          j2++;
          targetOffset = 0;
        }
      }
      buffers.splice(0, i2);
      if (buffers.length > 0) {
        buffers[0] = buffers[0].slice(sourceOffset);
      }
    }
    getReadableStream() {
      return new BuffersStream(this.buffers, this.size);
    }
  }

  class BufferScheduler {
    constructor(readable, bufferSize, maxBuffers, outgoingHandler, concurrency, encoding) {
      this.emitter = new events.EventEmitter;
      this.offset = 0;
      this.isStreamEnd = false;
      this.isError = false;
      this.executingOutgoingHandlers = 0;
      this.numBuffers = 0;
      this.unresolvedDataArray = [];
      this.unresolvedLength = 0;
      this.incoming = [];
      this.outgoing = [];
      if (bufferSize <= 0) {
        throw new RangeError(`bufferSize must be larger than 0, current is ${bufferSize}`);
      }
      if (maxBuffers <= 0) {
        throw new RangeError(`maxBuffers must be larger than 0, current is ${maxBuffers}`);
      }
      if (concurrency <= 0) {
        throw new RangeError(`concurrency must be larger than 0, current is ${concurrency}`);
      }
      this.bufferSize = bufferSize;
      this.maxBuffers = maxBuffers;
      this.readable = readable;
      this.outgoingHandler = outgoingHandler;
      this.concurrency = concurrency;
      this.encoding = encoding;
    }
    async do() {
      return new Promise((resolve5, reject) => {
        this.readable.on("data", (data) => {
          data = typeof data === "string" ? Buffer.from(data, this.encoding) : data;
          this.appendUnresolvedData(data);
          if (!this.resolveData()) {
            this.readable.pause();
          }
        });
        this.readable.on("error", (err) => {
          this.emitter.emit("error", err);
        });
        this.readable.on("end", () => {
          this.isStreamEnd = true;
          this.emitter.emit("checkEnd");
        });
        this.emitter.on("error", (err) => {
          this.isError = true;
          this.readable.pause();
          reject(err);
        });
        this.emitter.on("checkEnd", () => {
          if (this.outgoing.length > 0) {
            this.triggerOutgoingHandlers();
            return;
          }
          if (this.isStreamEnd && this.executingOutgoingHandlers === 0) {
            if (this.unresolvedLength > 0 && this.unresolvedLength < this.bufferSize) {
              const buffer2 = this.shiftBufferFromUnresolvedDataArray();
              this.outgoingHandler(() => buffer2.getReadableStream(), buffer2.size, this.offset).then(resolve5).catch(reject);
            } else if (this.unresolvedLength >= this.bufferSize) {
              return;
            } else {
              resolve5();
            }
          }
        });
      });
    }
    appendUnresolvedData(data) {
      this.unresolvedDataArray.push(data);
      this.unresolvedLength += data.length;
    }
    shiftBufferFromUnresolvedDataArray(buffer2) {
      if (!buffer2) {
        buffer2 = new PooledBuffer(this.bufferSize, this.unresolvedDataArray, this.unresolvedLength);
      } else {
        buffer2.fill(this.unresolvedDataArray, this.unresolvedLength);
      }
      this.unresolvedLength -= buffer2.size;
      return buffer2;
    }
    resolveData() {
      while (this.unresolvedLength >= this.bufferSize) {
        let buffer2;
        if (this.incoming.length > 0) {
          buffer2 = this.incoming.shift();
          this.shiftBufferFromUnresolvedDataArray(buffer2);
        } else {
          if (this.numBuffers < this.maxBuffers) {
            buffer2 = this.shiftBufferFromUnresolvedDataArray();
            this.numBuffers++;
          } else {
            return false;
          }
        }
        this.outgoing.push(buffer2);
        this.triggerOutgoingHandlers();
      }
      return true;
    }
    async triggerOutgoingHandlers() {
      let buffer2;
      do {
        if (this.executingOutgoingHandlers >= this.concurrency) {
          return;
        }
        buffer2 = this.outgoing.shift();
        if (buffer2) {
          this.triggerOutgoingHandler(buffer2);
        }
      } while (buffer2);
    }
    async triggerOutgoingHandler(buffer2) {
      const bufferLength = buffer2.size;
      this.executingOutgoingHandlers++;
      this.offset += bufferLength;
      try {
        await this.outgoingHandler(() => buffer2.getReadableStream(), bufferLength, this.offset - bufferLength);
      } catch (err) {
        this.emitter.emit("error", err);
        return;
      }
      this.executingOutgoingHandlers--;
      this.reuseBuffer(buffer2);
      this.emitter.emit("checkEnd");
    }
    reuseBuffer(buffer2) {
      this.incoming.push(buffer2);
      if (!this.isError && this.resolveData() && !this.isStreamEnd) {
        this.readable.resume();
      }
    }
  }
  async function streamToBuffer(stream2, buffer2, offset, end, encoding) {
    let pos = 0;
    const count = end - offset;
    return new Promise((resolve5, reject) => {
      const timeout = setTimeout(() => reject(new Error(`The operation cannot be completed in timeout.`)), REQUEST_TIMEOUT);
      stream2.on("readable", () => {
        if (pos >= count) {
          clearTimeout(timeout);
          resolve5();
          return;
        }
        let chunk = stream2.read();
        if (!chunk) {
          return;
        }
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk, encoding);
        }
        const chunkLength = pos + chunk.length > count ? count - pos : chunk.length;
        buffer2.fill(chunk.slice(0, chunkLength), offset + pos, offset + pos + chunkLength);
        pos += chunkLength;
      });
      stream2.on("end", () => {
        clearTimeout(timeout);
        if (pos < count) {
          reject(new Error(`Stream drains before getting enough data needed. Data read: ${pos}, data need: ${count}`));
        }
        resolve5();
      });
      stream2.on("error", (msg) => {
        clearTimeout(timeout);
        reject(msg);
      });
    });
  }
  async function streamToBuffer2(stream2, buffer2, encoding) {
    let pos = 0;
    const bufferSize = buffer2.length;
    return new Promise((resolve5, reject) => {
      stream2.on("readable", () => {
        let chunk = stream2.read();
        if (!chunk) {
          return;
        }
        if (typeof chunk === "string") {
          chunk = Buffer.from(chunk, encoding);
        }
        if (pos + chunk.length > bufferSize) {
          reject(new Error(`Stream exceeds buffer size. Buffer size: ${bufferSize}`));
          return;
        }
        buffer2.fill(chunk, pos, pos + chunk.length);
        pos += chunk.length;
      });
      stream2.on("end", () => {
        resolve5(pos);
      });
      stream2.on("error", reject);
    });
  }
  async function readStreamToLocalFile(rs, file) {
    return new Promise((resolve5, reject) => {
      const ws = fs__namespace.createWriteStream(file);
      rs.on("error", (err) => {
        reject(err);
      });
      ws.on("error", (err) => {
        reject(err);
      });
      ws.on("close", resolve5);
      rs.pipe(ws);
    });
  }
  var fsStat = util__namespace.promisify(fs__namespace.stat);
  var fsCreateReadStream = fs__namespace.createReadStream;

  class BlobClient extends StorageClient {
    get name() {
      return this._name;
    }
    get containerName() {
      return this._containerName;
    }
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
      options = options || {};
      let pipeline;
      let url2;
      if (isPipelineLike(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline = credentialOrPipelineOrContainerName;
      } else if (coreUtil.isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        options = blobNameOrOptions;
        pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url2 = urlOrConnectionString;
        if (blobNameOrOptions && typeof blobNameOrOptions !== "string") {
          options = blobNameOrOptions;
        }
        pipeline = newPipeline(new AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (coreUtil.isNode) {
            const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options.proxyOptions) {
              options.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
            }
            pipeline = newPipeline(sharedKeyCredential, options);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline = newPipeline(new AnonymousCredential, options);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url2, pipeline);
      ({ blobName: this._name, containerName: this._containerName } = this.getBlobAndContainerNamesFromUrl());
      this.blobContext = this.storageClientContext.blob;
      this._snapshot = getURLParameter(this.url, URLConstants.Parameters.SNAPSHOT);
      this._versionId = getURLParameter(this.url, URLConstants.Parameters.VERSIONID);
    }
    withSnapshot(snapshot2) {
      return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot2.length === 0 ? undefined : snapshot2), this.pipeline);
    }
    withVersion(versionId2) {
      return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.VERSIONID, versionId2.length === 0 ? undefined : versionId2), this.pipeline);
    }
    getAppendBlobClient() {
      return new AppendBlobClient(this.url, this.pipeline);
    }
    getBlockBlobClient() {
      return new BlockBlobClient(this.url, this.pipeline);
    }
    getPageBlobClient() {
      return new PageBlobClient(this.url, this.pipeline);
    }
    async download(offset = 0, count, options = {}) {
      options.conditions = options.conditions || {};
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlobClient-download", options, async (updatedOptions) => {
        var _a3;
        const res = assertResponse(await this.blobContext.download({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          requestOptions: {
            onDownloadProgress: coreUtil.isNode ? undefined : options.onProgress
          },
          range: offset === 0 && !count ? undefined : rangeToString({ offset, count }),
          rangeGetContentMD5: options.rangeGetContentMD5,
          rangeGetContentCRC64: options.rangeGetContentCrc64,
          snapshot: options.snapshot,
          cpkInfo: options.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedRes = Object.assign(Object.assign({}, res), { _response: res._response, objectReplicationDestinationPolicyId: res.objectReplicationPolicyId, objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules) });
        if (!coreUtil.isNode) {
          return wrappedRes;
        }
        if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {
          options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;
        }
        if (res.contentLength === undefined) {
          throw new RangeError(`File download response doesn't contain valid content length header`);
        }
        if (!res.etag) {
          throw new RangeError(`File download response doesn't contain valid etag header`);
        }
        return new BlobDownloadResponse(wrappedRes, async (start) => {
          var _a4;
          const updatedDownloadOptions = {
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ifMatch: options.conditions.ifMatch || res.etag,
              ifModifiedSince: options.conditions.ifModifiedSince,
              ifNoneMatch: options.conditions.ifNoneMatch,
              ifUnmodifiedSince: options.conditions.ifUnmodifiedSince,
              ifTags: (_a4 = options.conditions) === null || _a4 === undefined ? undefined : _a4.tagConditions
            },
            range: rangeToString({
              count: offset + res.contentLength - start,
              offset: start
            }),
            rangeGetContentMD5: options.rangeGetContentMD5,
            rangeGetContentCRC64: options.rangeGetContentCrc64,
            snapshot: options.snapshot,
            cpkInfo: options.customerProvidedKey
          };
          return (await this.blobContext.download(Object.assign({ abortSignal: options.abortSignal }, updatedDownloadOptions))).readableStreamBody;
        }, offset, res.contentLength, {
          maxRetryRequests: options.maxRetryRequests,
          onProgress: options.onProgress
        });
      });
    }
    async exists(options = {}) {
      return tracingClient.withSpan("BlobClient-exists", options, async (updatedOptions) => {
        try {
          ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
          await this.getProperties({
            abortSignal: options.abortSignal,
            customerProvidedKey: options.customerProvidedKey,
            conditions: options.conditions,
            tracingOptions: updatedOptions.tracingOptions
          });
          return true;
        } catch (e2) {
          if (e2.statusCode === 404) {
            return false;
          } else if (e2.statusCode === 409 && (e2.details.errorCode === BlobUsesCustomerSpecifiedEncryptionMsg || e2.details.errorCode === BlobDoesNotUseCustomerSpecifiedEncryption)) {
            return true;
          }
          throw e2;
        }
      });
    }
    async getProperties(options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlobClient-getProperties", options, async (updatedOptions) => {
        var _a3;
        const res = assertResponse(await this.blobContext.getProperties({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          cpkInfo: options.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return Object.assign(Object.assign({}, res), { _response: res._response, objectReplicationDestinationPolicyId: res.objectReplicationPolicyId, objectReplicationSourceProperties: parseObjectReplicationRecord(res.objectReplicationRules) });
      });
    }
    async delete(options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("BlobClient-delete", options, async (updatedOptions) => {
        var _a3;
        return assertResponse(await this.blobContext.delete({
          abortSignal: options.abortSignal,
          deleteSnapshots: options.deleteSnapshots,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async deleteIfExists(options = {}) {
      return tracingClient.withSpan("BlobClient-deleteIfExists", options, async (updatedOptions) => {
        var _a3, _b2;
        try {
          const res = assertResponse(await this.delete(updatedOptions));
          return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });
        } catch (e2) {
          if (((_a3 = e2.details) === null || _a3 === undefined ? undefined : _a3.errorCode) === "BlobNotFound") {
            return Object.assign(Object.assign({ succeeded: false }, (_b2 = e2.response) === null || _b2 === undefined ? undefined : _b2.parsedHeaders), { _response: e2.response });
          }
          throw e2;
        }
      });
    }
    async undelete(options = {}) {
      return tracingClient.withSpan("BlobClient-undelete", options, async (updatedOptions) => {
        return assertResponse(await this.blobContext.undelete({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setHTTPHeaders(blobHTTPHeaders, options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlobClient-setHTTPHeaders", options, async (updatedOptions) => {
        var _a3;
        return assertResponse(await this.blobContext.setHttpHeaders({
          abortSignal: options.abortSignal,
          blobHttpHeaders: blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setMetadata(metadata2, options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlobClient-setMetadata", options, async (updatedOptions) => {
        var _a3;
        return assertResponse(await this.blobContext.setMetadata({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          metadata: metadata2,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setTags(tags2, options = {}) {
      return tracingClient.withSpan("BlobClient-setTags", options, async (updatedOptions) => {
        var _a3;
        return assertResponse(await this.blobContext.setTags({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions,
          tags: toBlobTags(tags2)
        }));
      });
    }
    async getTags(options = {}) {
      return tracingClient.withSpan("BlobClient-getTags", options, async (updatedOptions) => {
        var _a3;
        const response = assertResponse(await this.blobContext.getTags({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = Object.assign(Object.assign({}, response), { _response: response._response, tags: toTags({ blobTagSet: response.blobTagSet }) || {} });
        return wrappedResponse;
      });
    }
    getBlobLeaseClient(proposeLeaseId) {
      return new BlobLeaseClient(this, proposeLeaseId);
    }
    async createSnapshot(options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlobClient-createSnapshot", options, async (updatedOptions) => {
        var _a3;
        return assertResponse(await this.blobContext.createSnapshot({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async beginCopyFromURL(copySource2, options = {}) {
      const client = {
        abortCopyFromURL: (...args) => this.abortCopyFromURL(...args),
        getProperties: (...args) => this.getProperties(...args),
        startCopyFromURL: (...args) => this.startCopyFromURL(...args)
      };
      const poller = new BlobBeginCopyFromUrlPoller({
        blobClient: client,
        copySource: copySource2,
        intervalInMs: options.intervalInMs,
        onProgress: options.onProgress,
        resumeFrom: options.resumeFrom,
        startCopyFromURLOptions: options
      });
      await poller.poll();
      return poller;
    }
    async abortCopyFromURL(copyId2, options = {}) {
      return tracingClient.withSpan("BlobClient-abortCopyFromURL", options, async (updatedOptions) => {
        return assertResponse(await this.blobContext.abortCopyFromURL(copyId2, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async syncCopyFromURL(copySource2, options = {}) {
      options.conditions = options.conditions || {};
      options.sourceConditions = options.sourceConditions || {};
      return tracingClient.withSpan("BlobClient-syncCopyFromURL", options, async (updatedOptions) => {
        var _a3, _b2, _c2, _d2, _e2, _f, _g;
        return assertResponse(await this.blobContext.copyFromURL(copySource2, {
          abortSignal: options.abortSignal,
          metadata: options.metadata,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          sourceModifiedAccessConditions: {
            sourceIfMatch: (_b2 = options.sourceConditions) === null || _b2 === undefined ? undefined : _b2.ifMatch,
            sourceIfModifiedSince: (_c2 = options.sourceConditions) === null || _c2 === undefined ? undefined : _c2.ifModifiedSince,
            sourceIfNoneMatch: (_d2 = options.sourceConditions) === null || _d2 === undefined ? undefined : _d2.ifNoneMatch,
            sourceIfUnmodifiedSince: (_e2 = options.sourceConditions) === null || _e2 === undefined ? undefined : _e2.ifUnmodifiedSince
          },
          sourceContentMD5: options.sourceContentMD5,
          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),
          tier: toAccessTier(options.tier),
          blobTagsString: toBlobTagsString(options.tags),
          immutabilityPolicyExpiry: (_f = options.immutabilityPolicy) === null || _f === undefined ? undefined : _f.expiriesOn,
          immutabilityPolicyMode: (_g = options.immutabilityPolicy) === null || _g === undefined ? undefined : _g.policyMode,
          legalHold: options.legalHold,
          encryptionScope: options.encryptionScope,
          copySourceTags: options.copySourceTags,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setAccessTier(tier2, options = {}) {
      return tracingClient.withSpan("BlobClient-setAccessTier", options, async (updatedOptions) => {
        var _a3;
        return assertResponse(await this.blobContext.setTier(toAccessTier(tier2), {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          rehydratePriority: options.rehydratePriority,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async downloadToBuffer(param1, param2, param3, param4 = {}) {
      var _a3;
      let buffer2;
      let offset = 0;
      let count = 0;
      let options = param4;
      if (param1 instanceof Buffer) {
        buffer2 = param1;
        offset = param2 || 0;
        count = typeof param3 === "number" ? param3 : 0;
      } else {
        offset = typeof param1 === "number" ? param1 : 0;
        count = typeof param2 === "number" ? param2 : 0;
        options = param3 || {};
      }
      let blockSize = (_a3 = options.blockSize) !== null && _a3 !== undefined ? _a3 : 0;
      if (blockSize < 0) {
        throw new RangeError("blockSize option must be >= 0");
      }
      if (blockSize === 0) {
        blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
      }
      if (offset < 0) {
        throw new RangeError("offset option must be >= 0");
      }
      if (count && count <= 0) {
        throw new RangeError("count option must be greater than 0");
      }
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracingClient.withSpan("BlobClient-downloadToBuffer", options, async (updatedOptions) => {
        if (!count) {
          const response = await this.getProperties(Object.assign(Object.assign({}, options), { tracingOptions: updatedOptions.tracingOptions }));
          count = response.contentLength - offset;
          if (count < 0) {
            throw new RangeError(`offset ${offset} shouldn't be larger than blob size ${response.contentLength}`);
          }
        }
        if (!buffer2) {
          try {
            buffer2 = Buffer.alloc(count);
          } catch (error) {
            throw new Error(`Unable to allocate the buffer of size: ${count}(in bytes). Please try passing your own buffer to the "downloadToBuffer" method or try using other methods like "download" or "downloadToFile".\t ${error.message}`);
          }
        }
        if (buffer2.length < count) {
          throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${count}`);
        }
        let transferProgress = 0;
        const batch = new Batch(options.concurrency);
        for (let off = offset;off < offset + count; off = off + blockSize) {
          batch.addOperation(async () => {
            let chunkEnd = offset + count;
            if (off + blockSize < chunkEnd) {
              chunkEnd = off + blockSize;
            }
            const response = await this.download(off, chunkEnd - off, {
              abortSignal: options.abortSignal,
              conditions: options.conditions,
              maxRetryRequests: options.maxRetryRequestsPerBlock,
              customerProvidedKey: options.customerProvidedKey,
              tracingOptions: updatedOptions.tracingOptions
            });
            const stream2 = response.readableStreamBody;
            await streamToBuffer(stream2, buffer2, off - offset, chunkEnd - offset);
            transferProgress += chunkEnd - off;
            if (options.onProgress) {
              options.onProgress({ loadedBytes: transferProgress });
            }
          });
        }
        await batch.do();
        return buffer2;
      });
    }
    async downloadToFile(filePath, offset = 0, count, options = {}) {
      return tracingClient.withSpan("BlobClient-downloadToFile", options, async (updatedOptions) => {
        const response = await this.download(offset, count, Object.assign(Object.assign({}, options), { tracingOptions: updatedOptions.tracingOptions }));
        if (response.readableStreamBody) {
          await readStreamToLocalFile(response.readableStreamBody, filePath);
        }
        response.blobDownloadStream = undefined;
        return response;
      });
    }
    getBlobAndContainerNamesFromUrl() {
      let containerName;
      let blobName;
      try {
        const parsedUrl = new URL(this.url);
        if (parsedUrl.host.split(".")[1] === "blob") {
          const pathComponents = parsedUrl.pathname.match("/([^/]*)(/(.*))?");
          containerName = pathComponents[1];
          blobName = pathComponents[3];
        } else if (isIpEndpointStyle(parsedUrl)) {
          const pathComponents = parsedUrl.pathname.match("/([^/]*)/([^/]*)(/(.*))?");
          containerName = pathComponents[2];
          blobName = pathComponents[4];
        } else {
          const pathComponents = parsedUrl.pathname.match("/([^/]*)(/(.*))?");
          containerName = pathComponents[1];
          blobName = pathComponents[3];
        }
        containerName = decodeURIComponent(containerName);
        blobName = decodeURIComponent(blobName);
        blobName = blobName.replace(/\\/g, "/");
        if (!containerName) {
          throw new Error("Provided containerName is invalid.");
        }
        return { blobName, containerName };
      } catch (error) {
        throw new Error("Unable to extract blobName and containerName with provided information.");
      }
    }
    async startCopyFromURL(copySource2, options = {}) {
      return tracingClient.withSpan("BlobClient-startCopyFromURL", options, async (updatedOptions) => {
        var _a3, _b2, _c2;
        options.conditions = options.conditions || {};
        options.sourceConditions = options.sourceConditions || {};
        return assertResponse(await this.blobContext.startCopyFromURL(copySource2, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          sourceModifiedAccessConditions: {
            sourceIfMatch: options.sourceConditions.ifMatch,
            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,
            sourceIfTags: options.sourceConditions.tagConditions
          },
          immutabilityPolicyExpiry: (_b2 = options.immutabilityPolicy) === null || _b2 === undefined ? undefined : _b2.expiriesOn,
          immutabilityPolicyMode: (_c2 = options.immutabilityPolicy) === null || _c2 === undefined ? undefined : _c2.policyMode,
          legalHold: options.legalHold,
          rehydratePriority: options.rehydratePriority,
          tier: toAccessTier(options.tier),
          blobTagsString: toBlobTagsString(options.tags),
          sealBlob: options.sealBlob,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    generateSasUrl(options) {
      return new Promise((resolve5) => {
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
          throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        const sas = generateBlobSASQueryParameters(Object.assign({ containerName: this._containerName, blobName: this._name, snapshotTime: this._snapshot, versionId: this._versionId }, options), this.credential).toString();
        resolve5(appendToURLQuery(this.url, sas));
      });
    }
    generateSasStringToSign(options) {
      if (!(this.credential instanceof StorageSharedKeyCredential)) {
        throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
      }
      return generateBlobSASQueryParametersInternal(Object.assign({ containerName: this._containerName, blobName: this._name, snapshotTime: this._snapshot, versionId: this._versionId }, options), this.credential).stringToSign;
    }
    generateUserDelegationSasUrl(options, userDelegationKey) {
      return new Promise((resolve5) => {
        const sas = generateBlobSASQueryParameters(Object.assign({ containerName: this._containerName, blobName: this._name, snapshotTime: this._snapshot, versionId: this._versionId }, options), userDelegationKey, this.accountName).toString();
        resolve5(appendToURLQuery(this.url, sas));
      });
    }
    generateUserDelegationSasStringToSign(options, userDelegationKey) {
      return generateBlobSASQueryParametersInternal(Object.assign({ containerName: this._containerName, blobName: this._name, snapshotTime: this._snapshot, versionId: this._versionId }, options), userDelegationKey, this.accountName).stringToSign;
    }
    async deleteImmutabilityPolicy(options = {}) {
      return tracingClient.withSpan("BlobClient-deleteImmutabilityPolicy", options, async (updatedOptions) => {
        return assertResponse(await this.blobContext.deleteImmutabilityPolicy({
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setImmutabilityPolicy(immutabilityPolicy, options = {}) {
      return tracingClient.withSpan("BlobClient-setImmutabilityPolicy", options, async (updatedOptions) => {
        return assertResponse(await this.blobContext.setImmutabilityPolicy({
          immutabilityPolicyExpiry: immutabilityPolicy.expiriesOn,
          immutabilityPolicyMode: immutabilityPolicy.policyMode,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setLegalHold(legalHoldEnabled, options = {}) {
      return tracingClient.withSpan("BlobClient-setLegalHold", options, async (updatedOptions) => {
        return assertResponse(await this.blobContext.setLegalHold(legalHoldEnabled, {
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getAccountInfo(options = {}) {
      return tracingClient.withSpan("BlobClient-getAccountInfo", options, async (updatedOptions) => {
        return assertResponse(await this.blobContext.getAccountInfo({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }

  class AppendBlobClient extends BlobClient {
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
      let pipeline;
      let url2;
      options = options || {};
      if (isPipelineLike(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline = credentialOrPipelineOrContainerName;
      } else if (coreUtil.isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        options = blobNameOrOptions;
        pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url2 = urlOrConnectionString;
        pipeline = newPipeline(new AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (coreUtil.isNode) {
            const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options.proxyOptions) {
              options.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
            }
            pipeline = newPipeline(sharedKeyCredential, options);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline = newPipeline(new AnonymousCredential, options);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url2, pipeline);
      this.appendBlobContext = this.storageClientContext.appendBlob;
    }
    withSnapshot(snapshot2) {
      return new AppendBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot2.length === 0 ? undefined : snapshot2), this.pipeline);
    }
    async create(options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("AppendBlobClient-create", options, async (updatedOptions) => {
        var _a3, _b2, _c2;
        return assertResponse(await this.appendBlobContext.create(0, {
          abortSignal: options.abortSignal,
          blobHttpHeaders: options.blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          immutabilityPolicyExpiry: (_b2 = options.immutabilityPolicy) === null || _b2 === undefined ? undefined : _b2.expiriesOn,
          immutabilityPolicyMode: (_c2 = options.immutabilityPolicy) === null || _c2 === undefined ? undefined : _c2.policyMode,
          legalHold: options.legalHold,
          blobTagsString: toBlobTagsString(options.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async createIfNotExists(options = {}) {
      const conditions = { ifNoneMatch: ETagAny };
      return tracingClient.withSpan("AppendBlobClient-createIfNotExists", options, async (updatedOptions) => {
        var _a3, _b2;
        try {
          const res = assertResponse(await this.create(Object.assign(Object.assign({}, updatedOptions), { conditions })));
          return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });
        } catch (e2) {
          if (((_a3 = e2.details) === null || _a3 === undefined ? undefined : _a3.errorCode) === "BlobAlreadyExists") {
            return Object.assign(Object.assign({ succeeded: false }, (_b2 = e2.response) === null || _b2 === undefined ? undefined : _b2.parsedHeaders), { _response: e2.response });
          }
          throw e2;
        }
      });
    }
    async seal(options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("AppendBlobClient-seal", options, async (updatedOptions) => {
        var _a3;
        return assertResponse(await this.appendBlobContext.seal({
          abortSignal: options.abortSignal,
          appendPositionAccessConditions: options.conditions,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async appendBlock(body2, contentLength2, options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("AppendBlobClient-appendBlock", options, async (updatedOptions) => {
        var _a3;
        return assertResponse(await this.appendBlobContext.appendBlock(contentLength2, body2, {
          abortSignal: options.abortSignal,
          appendPositionAccessConditions: options.conditions,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          requestOptions: {
            onUploadProgress: options.onProgress
          },
          transactionalContentMD5: options.transactionalContentMD5,
          transactionalContentCrc64: options.transactionalContentCrc64,
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async appendBlockFromURL(sourceURL, sourceOffset, count, options = {}) {
      options.conditions = options.conditions || {};
      options.sourceConditions = options.sourceConditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("AppendBlobClient-appendBlockFromURL", options, async (updatedOptions) => {
        var _a3, _b2, _c2, _d2, _e2;
        return assertResponse(await this.appendBlobContext.appendBlockFromUrl(sourceURL, 0, {
          abortSignal: options.abortSignal,
          sourceRange: rangeToString({ offset: sourceOffset, count }),
          sourceContentMD5: options.sourceContentMD5,
          sourceContentCrc64: options.sourceContentCrc64,
          leaseAccessConditions: options.conditions,
          appendPositionAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          sourceModifiedAccessConditions: {
            sourceIfMatch: (_b2 = options.sourceConditions) === null || _b2 === undefined ? undefined : _b2.ifMatch,
            sourceIfModifiedSince: (_c2 = options.sourceConditions) === null || _c2 === undefined ? undefined : _c2.ifModifiedSince,
            sourceIfNoneMatch: (_d2 = options.sourceConditions) === null || _d2 === undefined ? undefined : _d2.ifNoneMatch,
            sourceIfUnmodifiedSince: (_e2 = options.sourceConditions) === null || _e2 === undefined ? undefined : _e2.ifUnmodifiedSince
          },
          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }

  class BlockBlobClient extends BlobClient {
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
      let pipeline;
      let url2;
      options = options || {};
      if (isPipelineLike(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline = credentialOrPipelineOrContainerName;
      } else if (coreUtil.isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        options = blobNameOrOptions;
        pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url2 = urlOrConnectionString;
        if (blobNameOrOptions && typeof blobNameOrOptions !== "string") {
          options = blobNameOrOptions;
        }
        pipeline = newPipeline(new AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (coreUtil.isNode) {
            const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options.proxyOptions) {
              options.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
            }
            pipeline = newPipeline(sharedKeyCredential, options);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline = newPipeline(new AnonymousCredential, options);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url2, pipeline);
      this.blockBlobContext = this.storageClientContext.blockBlob;
      this._blobContext = this.storageClientContext.blob;
    }
    withSnapshot(snapshot2) {
      return new BlockBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot2.length === 0 ? undefined : snapshot2), this.pipeline);
    }
    async query(query, options = {}) {
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      if (!coreUtil.isNode) {
        throw new Error("This operation currently is only supported in Node.js.");
      }
      return tracingClient.withSpan("BlockBlobClient-query", options, async (updatedOptions) => {
        var _a3;
        const response = assertResponse(await this._blobContext.query({
          abortSignal: options.abortSignal,
          queryRequest: {
            queryType: "SQL",
            expression: query,
            inputSerialization: toQuerySerialization(options.inputTextConfiguration),
            outputSerialization: toQuerySerialization(options.outputTextConfiguration)
          },
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          cpkInfo: options.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return new BlobQueryResponse(response, {
          abortSignal: options.abortSignal,
          onProgress: options.onProgress,
          onError: options.onError
        });
      });
    }
    async upload(body2, contentLength2, options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlockBlobClient-upload", options, async (updatedOptions) => {
        var _a3, _b2, _c2;
        return assertResponse(await this.blockBlobContext.upload(contentLength2, body2, {
          abortSignal: options.abortSignal,
          blobHttpHeaders: options.blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          requestOptions: {
            onUploadProgress: options.onProgress
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          immutabilityPolicyExpiry: (_b2 = options.immutabilityPolicy) === null || _b2 === undefined ? undefined : _b2.expiriesOn,
          immutabilityPolicyMode: (_c2 = options.immutabilityPolicy) === null || _c2 === undefined ? undefined : _c2.policyMode,
          legalHold: options.legalHold,
          tier: toAccessTier(options.tier),
          blobTagsString: toBlobTagsString(options.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async syncUploadFromURL(sourceURL, options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlockBlobClient-syncUploadFromURL", options, async (updatedOptions) => {
        var _a3, _b2, _c2, _d2, _e2, _f;
        return assertResponse(await this.blockBlobContext.putBlobFromUrl(0, sourceURL, Object.assign(Object.assign({}, options), { blobHttpHeaders: options.blobHTTPHeaders, leaseAccessConditions: options.conditions, modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }), sourceModifiedAccessConditions: {
          sourceIfMatch: (_b2 = options.sourceConditions) === null || _b2 === undefined ? undefined : _b2.ifMatch,
          sourceIfModifiedSince: (_c2 = options.sourceConditions) === null || _c2 === undefined ? undefined : _c2.ifModifiedSince,
          sourceIfNoneMatch: (_d2 = options.sourceConditions) === null || _d2 === undefined ? undefined : _d2.ifNoneMatch,
          sourceIfUnmodifiedSince: (_e2 = options.sourceConditions) === null || _e2 === undefined ? undefined : _e2.ifUnmodifiedSince,
          sourceIfTags: (_f = options.sourceConditions) === null || _f === undefined ? undefined : _f.tagConditions
        }, cpkInfo: options.customerProvidedKey, copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization), tier: toAccessTier(options.tier), blobTagsString: toBlobTagsString(options.tags), copySourceTags: options.copySourceTags, tracingOptions: updatedOptions.tracingOptions })));
      });
    }
    async stageBlock(blockId2, body2, contentLength2, options = {}) {
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlockBlobClient-stageBlock", options, async (updatedOptions) => {
        return assertResponse(await this.blockBlobContext.stageBlock(blockId2, contentLength2, body2, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          requestOptions: {
            onUploadProgress: options.onProgress
          },
          transactionalContentMD5: options.transactionalContentMD5,
          transactionalContentCrc64: options.transactionalContentCrc64,
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async stageBlockFromURL(blockId2, sourceURL, offset = 0, count, options = {}) {
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlockBlobClient-stageBlockFromURL", options, async (updatedOptions) => {
        return assertResponse(await this.blockBlobContext.stageBlockFromURL(blockId2, 0, sourceURL, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          sourceContentMD5: options.sourceContentMD5,
          sourceContentCrc64: options.sourceContentCrc64,
          sourceRange: offset === 0 && !count ? undefined : rangeToString({ offset, count }),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async commitBlockList(blocks2, options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("BlockBlobClient-commitBlockList", options, async (updatedOptions) => {
        var _a3, _b2, _c2;
        return assertResponse(await this.blockBlobContext.commitBlockList({ latest: blocks2 }, {
          abortSignal: options.abortSignal,
          blobHttpHeaders: options.blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          immutabilityPolicyExpiry: (_b2 = options.immutabilityPolicy) === null || _b2 === undefined ? undefined : _b2.expiriesOn,
          immutabilityPolicyMode: (_c2 = options.immutabilityPolicy) === null || _c2 === undefined ? undefined : _c2.policyMode,
          legalHold: options.legalHold,
          tier: toAccessTier(options.tier),
          blobTagsString: toBlobTagsString(options.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getBlockList(listType2, options = {}) {
      return tracingClient.withSpan("BlockBlobClient-getBlockList", options, async (updatedOptions) => {
        var _a3;
        const res = assertResponse(await this.blockBlobContext.getBlockList(listType2, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        if (!res.committedBlocks) {
          res.committedBlocks = [];
        }
        if (!res.uncommittedBlocks) {
          res.uncommittedBlocks = [];
        }
        return res;
      });
    }
    async uploadData(data, options = {}) {
      return tracingClient.withSpan("BlockBlobClient-uploadData", options, async (updatedOptions) => {
        if (coreUtil.isNode) {
          let buffer2;
          if (data instanceof Buffer) {
            buffer2 = data;
          } else if (data instanceof ArrayBuffer) {
            buffer2 = Buffer.from(data);
          } else {
            data = data;
            buffer2 = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
          }
          return this.uploadSeekableInternal((offset, size) => buffer2.slice(offset, offset + size), buffer2.byteLength, updatedOptions);
        } else {
          const browserBlob = new Blob([data]);
          return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
        }
      });
    }
    async uploadBrowserData(browserData, options = {}) {
      return tracingClient.withSpan("BlockBlobClient-uploadBrowserData", options, async (updatedOptions) => {
        const browserBlob = new Blob([browserData]);
        return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
      });
    }
    async uploadSeekableInternal(bodyFactory, size, options = {}) {
      var _a3, _b2;
      let blockSize = (_a3 = options.blockSize) !== null && _a3 !== undefined ? _a3 : 0;
      if (blockSize < 0 || blockSize > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) {
        throw new RangeError(`blockSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES}`);
      }
      const maxSingleShotSize = (_b2 = options.maxSingleShotSize) !== null && _b2 !== undefined ? _b2 : BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;
      if (maxSingleShotSize < 0 || maxSingleShotSize > BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES) {
        throw new RangeError(`maxSingleShotSize option must be >= 0 and <= ${BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}`);
      }
      if (blockSize === 0) {
        if (size > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * BLOCK_BLOB_MAX_BLOCKS) {
          throw new RangeError(`${size} is too larger to upload to a block blob.`);
        }
        if (size > maxSingleShotSize) {
          blockSize = Math.ceil(size / BLOCK_BLOB_MAX_BLOCKS);
          if (blockSize < DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) {
            blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
          }
        }
      }
      if (!options.blobHTTPHeaders) {
        options.blobHTTPHeaders = {};
      }
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracingClient.withSpan("BlockBlobClient-uploadSeekableInternal", options, async (updatedOptions) => {
        if (size <= maxSingleShotSize) {
          return assertResponse(await this.upload(bodyFactory(0, size), size, updatedOptions));
        }
        const numBlocks = Math.floor((size - 1) / blockSize) + 1;
        if (numBlocks > BLOCK_BLOB_MAX_BLOCKS) {
          throw new RangeError(`The buffer's size is too big or the BlockSize is too small;` + `the number of blocks must be <= ${BLOCK_BLOB_MAX_BLOCKS}`);
        }
        const blockList = [];
        const blockIDPrefix = coreUtil.randomUUID();
        let transferProgress = 0;
        const batch = new Batch(options.concurrency);
        for (let i2 = 0;i2 < numBlocks; i2++) {
          batch.addOperation(async () => {
            const blockID = generateBlockID(blockIDPrefix, i2);
            const start = blockSize * i2;
            const end = i2 === numBlocks - 1 ? size : start + blockSize;
            const contentLength2 = end - start;
            blockList.push(blockID);
            await this.stageBlock(blockID, bodyFactory(start, contentLength2), contentLength2, {
              abortSignal: options.abortSignal,
              conditions: options.conditions,
              encryptionScope: options.encryptionScope,
              tracingOptions: updatedOptions.tracingOptions
            });
            transferProgress += contentLength2;
            if (options.onProgress) {
              options.onProgress({
                loadedBytes: transferProgress
              });
            }
          });
        }
        await batch.do();
        return this.commitBlockList(blockList, updatedOptions);
      });
    }
    async uploadFile(filePath, options = {}) {
      return tracingClient.withSpan("BlockBlobClient-uploadFile", options, async (updatedOptions) => {
        const size = (await fsStat(filePath)).size;
        return this.uploadSeekableInternal((offset, count) => {
          return () => fsCreateReadStream(filePath, {
            autoClose: true,
            end: count ? offset + count - 1 : Infinity,
            start: offset
          });
        }, size, Object.assign(Object.assign({}, options), { tracingOptions: updatedOptions.tracingOptions }));
      });
    }
    async uploadStream(stream2, bufferSize = DEFAULT_BLOCK_BUFFER_SIZE_BYTES, maxConcurrency = 5, options = {}) {
      if (!options.blobHTTPHeaders) {
        options.blobHTTPHeaders = {};
      }
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracingClient.withSpan("BlockBlobClient-uploadStream", options, async (updatedOptions) => {
        let blockNum = 0;
        const blockIDPrefix = coreUtil.randomUUID();
        let transferProgress = 0;
        const blockList = [];
        const scheduler = new BufferScheduler(stream2, bufferSize, maxConcurrency, async (body2, length) => {
          const blockID = generateBlockID(blockIDPrefix, blockNum);
          blockList.push(blockID);
          blockNum++;
          await this.stageBlock(blockID, body2, length, {
            customerProvidedKey: options.customerProvidedKey,
            conditions: options.conditions,
            encryptionScope: options.encryptionScope,
            tracingOptions: updatedOptions.tracingOptions
          });
          transferProgress += length;
          if (options.onProgress) {
            options.onProgress({ loadedBytes: transferProgress });
          }
        }, Math.ceil(maxConcurrency / 4 * 3));
        await scheduler.do();
        return assertResponse(await this.commitBlockList(blockList, Object.assign(Object.assign({}, options), { tracingOptions: updatedOptions.tracingOptions })));
      });
    }
  }

  class PageBlobClient extends BlobClient {
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
      let pipeline;
      let url2;
      options = options || {};
      if (isPipelineLike(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline = credentialOrPipelineOrContainerName;
      } else if (coreUtil.isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        options = blobNameOrOptions;
        pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url2 = urlOrConnectionString;
        pipeline = newPipeline(new AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const blobName = blobNameOrOptions;
        const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (coreUtil.isNode) {
            const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
            if (!options.proxyOptions) {
              options.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
            }
            pipeline = newPipeline(sharedKeyCredential, options);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url2 = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas;
          pipeline = newPipeline(new AnonymousCredential, options);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName and blobName parameters");
      }
      super(url2, pipeline);
      this.pageBlobContext = this.storageClientContext.pageBlob;
    }
    withSnapshot(snapshot2) {
      return new PageBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot2.length === 0 ? undefined : snapshot2), this.pipeline);
    }
    async create(size, options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("PageBlobClient-create", options, async (updatedOptions) => {
        var _a3, _b2, _c2;
        return assertResponse(await this.pageBlobContext.create(0, size, {
          abortSignal: options.abortSignal,
          blobHttpHeaders: options.blobHTTPHeaders,
          blobSequenceNumber: options.blobSequenceNumber,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          immutabilityPolicyExpiry: (_b2 = options.immutabilityPolicy) === null || _b2 === undefined ? undefined : _b2.expiriesOn,
          immutabilityPolicyMode: (_c2 = options.immutabilityPolicy) === null || _c2 === undefined ? undefined : _c2.policyMode,
          legalHold: options.legalHold,
          tier: toAccessTier(options.tier),
          blobTagsString: toBlobTagsString(options.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async createIfNotExists(size, options = {}) {
      return tracingClient.withSpan("PageBlobClient-createIfNotExists", options, async (updatedOptions) => {
        var _a3, _b2;
        try {
          const conditions = { ifNoneMatch: ETagAny };
          const res = assertResponse(await this.create(size, Object.assign(Object.assign({}, options), { conditions, tracingOptions: updatedOptions.tracingOptions })));
          return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });
        } catch (e2) {
          if (((_a3 = e2.details) === null || _a3 === undefined ? undefined : _a3.errorCode) === "BlobAlreadyExists") {
            return Object.assign(Object.assign({ succeeded: false }, (_b2 = e2.response) === null || _b2 === undefined ? undefined : _b2.parsedHeaders), { _response: e2.response });
          }
          throw e2;
        }
      });
    }
    async uploadPages(body2, offset, count, options = {}) {
      options.conditions = options.conditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("PageBlobClient-uploadPages", options, async (updatedOptions) => {
        var _a3;
        return assertResponse(await this.pageBlobContext.uploadPages(count, body2, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          requestOptions: {
            onUploadProgress: options.onProgress
          },
          range: rangeToString({ offset, count }),
          sequenceNumberAccessConditions: options.conditions,
          transactionalContentMD5: options.transactionalContentMD5,
          transactionalContentCrc64: options.transactionalContentCrc64,
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async uploadPagesFromURL(sourceURL, sourceOffset, destOffset, count, options = {}) {
      options.conditions = options.conditions || {};
      options.sourceConditions = options.sourceConditions || {};
      ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
      return tracingClient.withSpan("PageBlobClient-uploadPagesFromURL", options, async (updatedOptions) => {
        var _a3, _b2, _c2, _d2, _e2;
        return assertResponse(await this.pageBlobContext.uploadPagesFromURL(sourceURL, rangeToString({ offset: sourceOffset, count }), 0, rangeToString({ offset: destOffset, count }), {
          abortSignal: options.abortSignal,
          sourceContentMD5: options.sourceContentMD5,
          sourceContentCrc64: options.sourceContentCrc64,
          leaseAccessConditions: options.conditions,
          sequenceNumberAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          sourceModifiedAccessConditions: {
            sourceIfMatch: (_b2 = options.sourceConditions) === null || _b2 === undefined ? undefined : _b2.ifMatch,
            sourceIfModifiedSince: (_c2 = options.sourceConditions) === null || _c2 === undefined ? undefined : _c2.ifModifiedSince,
            sourceIfNoneMatch: (_d2 = options.sourceConditions) === null || _d2 === undefined ? undefined : _d2.ifNoneMatch,
            sourceIfUnmodifiedSince: (_e2 = options.sourceConditions) === null || _e2 === undefined ? undefined : _e2.ifUnmodifiedSince
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async clearPages(offset = 0, count, options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("PageBlobClient-clearPages", options, async (updatedOptions) => {
        var _a3;
        return assertResponse(await this.pageBlobContext.clearPages(0, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          range: rangeToString({ offset, count }),
          sequenceNumberAccessConditions: options.conditions,
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getPageRanges(offset = 0, count, options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("PageBlobClient-getPageRanges", options, async (updatedOptions) => {
        var _a3;
        const response = assertResponse(await this.pageBlobContext.getPageRanges({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          range: rangeToString({ offset, count }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return rangeResponseFromModel(response);
      });
    }
    async listPageRangesSegment(offset = 0, count, marker2, options = {}) {
      return tracingClient.withSpan("PageBlobClient-getPageRangesSegment", options, async (updatedOptions) => {
        var _a3;
        return assertResponse(await this.pageBlobContext.getPageRanges({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          range: rangeToString({ offset, count }),
          marker: marker2,
          maxPageSize: options.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    listPageRangeItemSegments() {
      return tslib2.__asyncGenerator(this, arguments, function* listPageRangeItemSegments_1(offset = 0, count, marker2, options = {}) {
        let getPageRangeItemSegmentsResponse;
        if (!!marker2 || marker2 === undefined) {
          do {
            getPageRangeItemSegmentsResponse = yield tslib2.__await(this.listPageRangesSegment(offset, count, marker2, options));
            marker2 = getPageRangeItemSegmentsResponse.continuationToken;
            yield yield tslib2.__await(yield tslib2.__await(getPageRangeItemSegmentsResponse));
          } while (marker2);
        }
      });
    }
    listPageRangeItems() {
      return tslib2.__asyncGenerator(this, arguments, function* listPageRangeItems_1(offset = 0, count, options = {}) {
        var _a3, e_1, _b2, _c2;
        let marker2;
        try {
          for (var _d2 = true, _e2 = tslib2.__asyncValues(this.listPageRangeItemSegments(offset, count, marker2, options)), _f;_f = yield tslib2.__await(_e2.next()), _a3 = _f.done, !_a3; _d2 = true) {
            _c2 = _f.value;
            _d2 = false;
            const getPageRangesSegment = _c2;
            yield tslib2.__await(yield* tslib2.__asyncDelegator(tslib2.__asyncValues(ExtractPageRangeInfoItems(getPageRangesSegment))));
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d2 && !_a3 && (_b2 = _e2.return))
              yield tslib2.__await(_b2.call(_e2));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    listPageRanges(offset = 0, count, options = {}) {
      options.conditions = options.conditions || {};
      const iter = this.listPageRangeItems(offset, count, options);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listPageRangeItemSegments(offset, count, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options));
        }
      };
    }
    async getPageRangesDiff(offset, count, prevSnapshot, options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("PageBlobClient-getPageRangesDiff", options, async (updatedOptions) => {
        var _a3;
        const result = assertResponse(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          prevsnapshot: prevSnapshot,
          range: rangeToString({ offset, count }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return rangeResponseFromModel(result);
      });
    }
    async listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker2, options = {}) {
      return tracingClient.withSpan("PageBlobClient-getPageRangesDiffSegment", options, async (updatedOptions) => {
        var _a3;
        return assertResponse(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options === null || options === undefined ? undefined : options.abortSignal,
          leaseAccessConditions: options === null || options === undefined ? undefined : options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options === null || options === undefined ? undefined : options.conditions), { ifTags: (_a3 = options === null || options === undefined ? undefined : options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          prevsnapshot: prevSnapshotOrUrl,
          range: rangeToString({
            offset,
            count
          }),
          marker: marker2,
          maxPageSize: options === null || options === undefined ? undefined : options.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker2, options) {
      return tslib2.__asyncGenerator(this, arguments, function* listPageRangeDiffItemSegments_1() {
        let getPageRangeItemSegmentsResponse;
        if (!!marker2 || marker2 === undefined) {
          do {
            getPageRangeItemSegmentsResponse = yield tslib2.__await(this.listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker2, options));
            marker2 = getPageRangeItemSegmentsResponse.continuationToken;
            yield yield tslib2.__await(yield tslib2.__await(getPageRangeItemSegmentsResponse));
          } while (marker2);
        }
      });
    }
    listPageRangeDiffItems(offset, count, prevSnapshotOrUrl, options) {
      return tslib2.__asyncGenerator(this, arguments, function* listPageRangeDiffItems_1() {
        var _a3, e_2, _b2, _c2;
        let marker2;
        try {
          for (var _d2 = true, _e2 = tslib2.__asyncValues(this.listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker2, options)), _f;_f = yield tslib2.__await(_e2.next()), _a3 = _f.done, !_a3; _d2 = true) {
            _c2 = _f.value;
            _d2 = false;
            const getPageRangesSegment = _c2;
            yield tslib2.__await(yield* tslib2.__asyncDelegator(tslib2.__asyncValues(ExtractPageRangeInfoItems(getPageRangesSegment))));
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (!_d2 && !_a3 && (_b2 = _e2.return))
              yield tslib2.__await(_b2.call(_e2));
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      });
    }
    listPageRangesDiff(offset, count, prevSnapshot, options = {}) {
      options.conditions = options.conditions || {};
      const iter = this.listPageRangeDiffItems(offset, count, prevSnapshot, Object.assign({}, options));
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listPageRangeDiffItemSegments(offset, count, prevSnapshot, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options));
        }
      };
    }
    async getPageRangesDiffForManagedDisks(offset, count, prevSnapshotUrl2, options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("PageBlobClient-GetPageRangesDiffForManagedDisks", options, async (updatedOptions) => {
        var _a3;
        const response = assertResponse(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          prevSnapshotUrl: prevSnapshotUrl2,
          range: rangeToString({ offset, count }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return rangeResponseFromModel(response);
      });
    }
    async resize(size, options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("PageBlobClient-resize", options, async (updatedOptions) => {
        var _a3;
        return assertResponse(await this.pageBlobContext.resize(size, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async updateSequenceNumber(sequenceNumberAction2, sequenceNumber, options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("PageBlobClient-updateSequenceNumber", options, async (updatedOptions) => {
        var _a3;
        return assertResponse(await this.pageBlobContext.updateSequenceNumber(sequenceNumberAction2, {
          abortSignal: options.abortSignal,
          blobSequenceNumber: sequenceNumber,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async startCopyIncremental(copySource2, options = {}) {
      return tracingClient.withSpan("PageBlobClient-startCopyIncremental", options, async (updatedOptions) => {
        var _a3;
        return assertResponse(await this.pageBlobContext.copyIncremental(copySource2, {
          abortSignal: options.abortSignal,
          modifiedAccessConditions: Object.assign(Object.assign({}, options.conditions), { ifTags: (_a3 = options.conditions) === null || _a3 === undefined ? undefined : _a3.tagConditions }),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }
  async function getBodyAsText(batchResponse) {
    let buffer2 = Buffer.alloc(BATCH_MAX_PAYLOAD_IN_BYTES);
    const responseLength = await streamToBuffer2(batchResponse.readableStreamBody, buffer2);
    buffer2 = buffer2.slice(0, responseLength);
    return buffer2.toString();
  }
  function utf8ByteLength(str) {
    return Buffer.byteLength(str);
  }
  var HTTP_HEADER_DELIMITER = ": ";
  var SPACE_DELIMITER = " ";
  var NOT_FOUND = -1;

  class BatchResponseParser {
    constructor(batchResponse, subRequests) {
      if (!batchResponse || !batchResponse.contentType) {
        throw new RangeError("batchResponse is malformed or doesn't contain valid content-type.");
      }
      if (!subRequests || subRequests.size === 0) {
        throw new RangeError("Invalid state: subRequests is not provided or size is 0.");
      }
      this.batchResponse = batchResponse;
      this.subRequests = subRequests;
      this.responseBatchBoundary = this.batchResponse.contentType.split("=")[1];
      this.perResponsePrefix = `--${this.responseBatchBoundary}${HTTP_LINE_ENDING}`;
      this.batchResponseEnding = `--${this.responseBatchBoundary}--`;
    }
    async parseBatchResponse() {
      if (this.batchResponse._response.status !== HTTPURLConnection.HTTP_ACCEPTED) {
        throw new Error(`Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`);
      }
      const responseBodyAsText = await getBodyAsText(this.batchResponse);
      const subResponses = responseBodyAsText.split(this.batchResponseEnding)[0].split(this.perResponsePrefix).slice(1);
      const subResponseCount = subResponses.length;
      if (subResponseCount !== this.subRequests.size && subResponseCount !== 1) {
        throw new Error("Invalid state: sub responses' count is not equal to sub requests' count.");
      }
      const deserializedSubResponses = new Array(subResponseCount);
      let subResponsesSucceededCount = 0;
      let subResponsesFailedCount = 0;
      for (let index = 0;index < subResponseCount; index++) {
        const subResponse = subResponses[index];
        const deserializedSubResponse = {};
        deserializedSubResponse.headers = coreHttpCompat.toHttpHeadersLike(coreRestPipeline.createHttpHeaders());
        const responseLines = subResponse.split(`${HTTP_LINE_ENDING}`);
        let subRespHeaderStartFound = false;
        let subRespHeaderEndFound = false;
        let subRespFailed = false;
        let contentId = NOT_FOUND;
        for (const responseLine of responseLines) {
          if (!subRespHeaderStartFound) {
            if (responseLine.startsWith(HeaderConstants.CONTENT_ID)) {
              contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);
            }
            if (responseLine.startsWith(HTTP_VERSION_1_1)) {
              subRespHeaderStartFound = true;
              const tokens = responseLine.split(SPACE_DELIMITER);
              deserializedSubResponse.status = parseInt(tokens[1]);
              deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);
            }
            continue;
          }
          if (responseLine.trim() === "") {
            if (!subRespHeaderEndFound) {
              subRespHeaderEndFound = true;
            }
            continue;
          }
          if (!subRespHeaderEndFound) {
            if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) {
              throw new Error(`Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`);
            }
            const tokens = responseLine.split(HTTP_HEADER_DELIMITER);
            deserializedSubResponse.headers.set(tokens[0], tokens[1]);
            if (tokens[0] === HeaderConstants.X_MS_ERROR_CODE) {
              deserializedSubResponse.errorCode = tokens[1];
              subRespFailed = true;
            }
          } else {
            if (!deserializedSubResponse.bodyAsText) {
              deserializedSubResponse.bodyAsText = "";
            }
            deserializedSubResponse.bodyAsText += responseLine;
          }
        }
        if (contentId !== NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < this.subRequests.size && deserializedSubResponses[contentId] === undefined) {
          deserializedSubResponse._request = this.subRequests.get(contentId);
          deserializedSubResponses[contentId] = deserializedSubResponse;
        } else {
          logger4.error(`subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`);
        }
        if (subRespFailed) {
          subResponsesFailedCount++;
        } else {
          subResponsesSucceededCount++;
        }
      }
      return {
        subResponses: deserializedSubResponses,
        subResponsesSucceededCount,
        subResponsesFailedCount
      };
    }
  }
  var MutexLockStatus;
  (function(MutexLockStatus2) {
    MutexLockStatus2[MutexLockStatus2["LOCKED"] = 0] = "LOCKED";
    MutexLockStatus2[MutexLockStatus2["UNLOCKED"] = 1] = "UNLOCKED";
  })(MutexLockStatus || (MutexLockStatus = {}));

  class Mutex {
    static async lock(key) {
      return new Promise((resolve5) => {
        if (this.keys[key] === undefined || this.keys[key] === MutexLockStatus.UNLOCKED) {
          this.keys[key] = MutexLockStatus.LOCKED;
          resolve5();
        } else {
          this.onUnlockEvent(key, () => {
            this.keys[key] = MutexLockStatus.LOCKED;
            resolve5();
          });
        }
      });
    }
    static async unlock(key) {
      return new Promise((resolve5) => {
        if (this.keys[key] === MutexLockStatus.LOCKED) {
          this.emitUnlockEvent(key);
        }
        delete this.keys[key];
        resolve5();
      });
    }
    static onUnlockEvent(key, handler2) {
      if (this.listeners[key] === undefined) {
        this.listeners[key] = [handler2];
      } else {
        this.listeners[key].push(handler2);
      }
    }
    static emitUnlockEvent(key) {
      if (this.listeners[key] !== undefined && this.listeners[key].length > 0) {
        const handler2 = this.listeners[key].shift();
        setImmediate(() => {
          handler2.call(this);
        });
      }
    }
  }
  Mutex.keys = {};
  Mutex.listeners = {};

  class BlobBatch {
    constructor() {
      this.batch = "batch";
      this.batchRequest = new InnerBatchRequest;
    }
    getMultiPartContentType() {
      return this.batchRequest.getMultipartContentType();
    }
    getHttpRequestBody() {
      return this.batchRequest.getHttpRequestBody();
    }
    getSubRequests() {
      return this.batchRequest.getSubRequests();
    }
    async addSubRequestInternal(subRequest, assembleSubRequestFunc) {
      await Mutex.lock(this.batch);
      try {
        this.batchRequest.preAddSubRequest(subRequest);
        await assembleSubRequestFunc();
        this.batchRequest.postAddSubRequest(subRequest);
      } finally {
        await Mutex.unlock(this.batch);
      }
    }
    setBatchType(batchType) {
      if (!this.batchType) {
        this.batchType = batchType;
      }
      if (this.batchType !== batchType) {
        throw new RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`);
      }
    }
    async deleteBlob(urlOrBlobClient, credentialOrOptions, options) {
      let url2;
      let credential;
      if (typeof urlOrBlobClient === "string" && (coreUtil.isNode && credentialOrOptions instanceof StorageSharedKeyCredential || credentialOrOptions instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrOptions))) {
        url2 = urlOrBlobClient;
        credential = credentialOrOptions;
      } else if (urlOrBlobClient instanceof BlobClient) {
        url2 = urlOrBlobClient.url;
        credential = urlOrBlobClient.credential;
        options = credentialOrOptions;
      } else {
        throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
      }
      if (!options) {
        options = {};
      }
      return tracingClient.withSpan("BatchDeleteRequest-addSubRequest", options, async (updatedOptions) => {
        this.setBatchType("delete");
        await this.addSubRequestInternal({
          url: url2,
          credential
        }, async () => {
          await new BlobClient(url2, this.batchRequest.createPipeline(credential)).delete(updatedOptions);
        });
      });
    }
    async setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options) {
      let url2;
      let credential;
      let tier2;
      if (typeof urlOrBlobClient === "string" && (coreUtil.isNode && credentialOrTier instanceof StorageSharedKeyCredential || credentialOrTier instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrTier))) {
        url2 = urlOrBlobClient;
        credential = credentialOrTier;
        tier2 = tierOrOptions;
      } else if (urlOrBlobClient instanceof BlobClient) {
        url2 = urlOrBlobClient.url;
        credential = urlOrBlobClient.credential;
        tier2 = credentialOrTier;
        options = tierOrOptions;
      } else {
        throw new RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
      }
      if (!options) {
        options = {};
      }
      return tracingClient.withSpan("BatchSetTierRequest-addSubRequest", options, async (updatedOptions) => {
        this.setBatchType("setAccessTier");
        await this.addSubRequestInternal({
          url: url2,
          credential
        }, async () => {
          await new BlobClient(url2, this.batchRequest.createPipeline(credential)).setAccessTier(tier2, updatedOptions);
        });
      });
    }
  }

  class InnerBatchRequest {
    constructor() {
      this.operationCount = 0;
      this.body = "";
      const tempGuid = coreUtil.randomUUID();
      this.boundary = `batch_${tempGuid}`;
      this.subRequestPrefix = `--${this.boundary}${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TYPE}: application/http${HTTP_LINE_ENDING}${HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`;
      this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`;
      this.batchRequestEnding = `--${this.boundary}--`;
      this.subRequests = new Map;
    }
    createPipeline(credential) {
      const corePipeline = coreRestPipeline.createEmptyPipeline();
      corePipeline.addPolicy(coreClient.serializationPolicy({
        stringifyXML: coreXml.stringifyXML,
        serializerOptions: {
          xml: {
            xmlCharKey: "#"
          }
        }
      }), { phase: "Serialize" });
      corePipeline.addPolicy(batchHeaderFilterPolicy());
      corePipeline.addPolicy(batchRequestAssemblePolicy(this), { afterPhase: "Sign" });
      if (coreAuth.isTokenCredential(credential)) {
        corePipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
          credential,
          scopes: StorageOAuthScopes,
          challengeCallbacks: { authorizeRequestOnChallenge: coreClient.authorizeRequestOnTenantChallenge }
        }), { phase: "Sign" });
      } else if (credential instanceof StorageSharedKeyCredential) {
        corePipeline.addPolicy(storageSharedKeyCredentialPolicy({
          accountName: credential.accountName,
          accountKey: credential.accountKey
        }), { phase: "Sign" });
      }
      const pipeline = new Pipeline([]);
      pipeline._credential = credential;
      pipeline._corePipeline = corePipeline;
      return pipeline;
    }
    appendSubRequestToBody(request9) {
      this.body += [
        this.subRequestPrefix,
        `${HeaderConstants.CONTENT_ID}: ${this.operationCount}`,
        "",
        `${request9.method.toString()} ${getURLPathAndQuery(request9.url)} ${HTTP_VERSION_1_1}${HTTP_LINE_ENDING}`
      ].join(HTTP_LINE_ENDING);
      for (const [name, value] of request9.headers) {
        this.body += `${name}: ${value}${HTTP_LINE_ENDING}`;
      }
      this.body += HTTP_LINE_ENDING;
    }
    preAddSubRequest(subRequest) {
      if (this.operationCount >= BATCH_MAX_REQUEST) {
        throw new RangeError(`Cannot exceed ${BATCH_MAX_REQUEST} sub requests in a single batch`);
      }
      const path2 = getURLPath(subRequest.url);
      if (!path2 || path2 === "") {
        throw new RangeError(`Invalid url for sub request: '${subRequest.url}'`);
      }
    }
    postAddSubRequest(subRequest) {
      this.subRequests.set(this.operationCount, subRequest);
      this.operationCount++;
    }
    getHttpRequestBody() {
      return `${this.body}${this.batchRequestEnding}${HTTP_LINE_ENDING}`;
    }
    getMultipartContentType() {
      return this.multipartContentType;
    }
    getSubRequests() {
      return this.subRequests;
    }
  }
  function batchRequestAssemblePolicy(batchRequest) {
    return {
      name: "batchRequestAssemblePolicy",
      async sendRequest(request9) {
        batchRequest.appendSubRequestToBody(request9);
        return {
          request: request9,
          status: 200,
          headers: coreRestPipeline.createHttpHeaders()
        };
      }
    };
  }
  function batchHeaderFilterPolicy() {
    return {
      name: "batchHeaderFilterPolicy",
      async sendRequest(request9, next) {
        let xMsHeaderName = "";
        for (const [name] of request9.headers) {
          if (iEqual(name, HeaderConstants.X_MS_VERSION)) {
            xMsHeaderName = name;
          }
        }
        if (xMsHeaderName !== "") {
          request9.headers.delete(xMsHeaderName);
        }
        return next(request9);
      }
    };
  }

  class BlobBatchClient {
    constructor(url2, credentialOrPipeline, options) {
      let pipeline;
      if (isPipelineLike(credentialOrPipeline)) {
        pipeline = credentialOrPipeline;
      } else if (!credentialOrPipeline) {
        pipeline = newPipeline(new AnonymousCredential, options);
      } else {
        pipeline = newPipeline(credentialOrPipeline, options);
      }
      const storageClientContext = new StorageContextClient(url2, getCoreClientOptions(pipeline));
      const path2 = getURLPath(url2);
      if (path2 && path2 !== "/") {
        this.serviceOrContainerContext = storageClientContext.container;
      } else {
        this.serviceOrContainerContext = storageClientContext.service;
      }
    }
    createBatch() {
      return new BlobBatch;
    }
    async deleteBlobs(urlsOrBlobClients, credentialOrOptions, options) {
      const batch = new BlobBatch;
      for (const urlOrBlobClient of urlsOrBlobClients) {
        if (typeof urlOrBlobClient === "string") {
          await batch.deleteBlob(urlOrBlobClient, credentialOrOptions, options);
        } else {
          await batch.deleteBlob(urlOrBlobClient, credentialOrOptions);
        }
      }
      return this.submitBatch(batch);
    }
    async setBlobsAccessTier(urlsOrBlobClients, credentialOrTier, tierOrOptions, options) {
      const batch = new BlobBatch;
      for (const urlOrBlobClient of urlsOrBlobClients) {
        if (typeof urlOrBlobClient === "string") {
          await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options);
        } else {
          await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions);
        }
      }
      return this.submitBatch(batch);
    }
    async submitBatch(batchRequest, options = {}) {
      if (!batchRequest || batchRequest.getSubRequests().size === 0) {
        throw new RangeError("Batch request should contain one or more sub requests.");
      }
      return tracingClient.withSpan("BlobBatchClient-submitBatch", options, async (updatedOptions) => {
        const batchRequestBody = batchRequest.getHttpRequestBody();
        const rawBatchResponse = assertResponse(await this.serviceOrContainerContext.submitBatch(utf8ByteLength(batchRequestBody), batchRequest.getMultiPartContentType(), batchRequestBody, Object.assign({}, updatedOptions)));
        const batchResponseParser = new BatchResponseParser(rawBatchResponse, batchRequest.getSubRequests());
        const responseSummary = await batchResponseParser.parseBatchResponse();
        const res = {
          _response: rawBatchResponse._response,
          contentType: rawBatchResponse.contentType,
          errorCode: rawBatchResponse.errorCode,
          requestId: rawBatchResponse.requestId,
          clientRequestId: rawBatchResponse.clientRequestId,
          version: rawBatchResponse.version,
          subResponses: responseSummary.subResponses,
          subResponsesSucceededCount: responseSummary.subResponsesSucceededCount,
          subResponsesFailedCount: responseSummary.subResponsesFailedCount
        };
        return res;
      });
    }
  }

  class ContainerClient extends StorageClient {
    get containerName() {
      return this._containerName;
    }
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, options) {
      let pipeline;
      let url2;
      options = options || {};
      if (isPipelineLike(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline = credentialOrPipelineOrContainerName;
      } else if (coreUtil.isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipelineOrContainerName)) {
        url2 = urlOrConnectionString;
        pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
      } else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        url2 = urlOrConnectionString;
        pipeline = newPipeline(new AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string") {
        const containerName = credentialOrPipelineOrContainerName;
        const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString") {
          if (coreUtil.isNode) {
            const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            url2 = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName));
            if (!options.proxyOptions) {
              options.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
            }
            pipeline = newPipeline(sharedKeyCredential, options);
          } else {
            throw new Error("Account connection string is only supported in Node.js environment");
          }
        } else if (extractedCreds.kind === "SASConnString") {
          url2 = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)) + "?" + extractedCreds.accountSas;
          pipeline = newPipeline(new AnonymousCredential, options);
        } else {
          throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
      } else {
        throw new Error("Expecting non-empty strings for containerName parameter");
      }
      super(url2, pipeline);
      this._containerName = this.getContainerNameFromUrl();
      this.containerContext = this.storageClientContext.container;
    }
    async create(options = {}) {
      return tracingClient.withSpan("ContainerClient-create", options, async (updatedOptions) => {
        return assertResponse(await this.containerContext.create(updatedOptions));
      });
    }
    async createIfNotExists(options = {}) {
      return tracingClient.withSpan("ContainerClient-createIfNotExists", options, async (updatedOptions) => {
        var _a3, _b2;
        try {
          const res = await this.create(updatedOptions);
          return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });
        } catch (e2) {
          if (((_a3 = e2.details) === null || _a3 === undefined ? undefined : _a3.errorCode) === "ContainerAlreadyExists") {
            return Object.assign(Object.assign({ succeeded: false }, (_b2 = e2.response) === null || _b2 === undefined ? undefined : _b2.parsedHeaders), { _response: e2.response });
          } else {
            throw e2;
          }
        }
      });
    }
    async exists(options = {}) {
      return tracingClient.withSpan("ContainerClient-exists", options, async (updatedOptions) => {
        try {
          await this.getProperties({
            abortSignal: options.abortSignal,
            tracingOptions: updatedOptions.tracingOptions
          });
          return true;
        } catch (e2) {
          if (e2.statusCode === 404) {
            return false;
          }
          throw e2;
        }
      });
    }
    getBlobClient(blobName) {
      return new BlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);
    }
    getAppendBlobClient(blobName) {
      return new AppendBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);
    }
    getBlockBlobClient(blobName) {
      return new BlockBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);
    }
    getPageBlobClient(blobName) {
      return new PageBlobClient(appendToURLPath(this.url, EscapePath(blobName)), this.pipeline);
    }
    async getProperties(options = {}) {
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracingClient.withSpan("ContainerClient-getProperties", options, async (updatedOptions) => {
        return assertResponse(await this.containerContext.getProperties(Object.assign(Object.assign({ abortSignal: options.abortSignal }, options.conditions), { tracingOptions: updatedOptions.tracingOptions })));
      });
    }
    async delete(options = {}) {
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracingClient.withSpan("ContainerClient-delete", options, async (updatedOptions) => {
        return assertResponse(await this.containerContext.delete({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async deleteIfExists(options = {}) {
      return tracingClient.withSpan("ContainerClient-deleteIfExists", options, async (updatedOptions) => {
        var _a3, _b2;
        try {
          const res = await this.delete(updatedOptions);
          return Object.assign(Object.assign({ succeeded: true }, res), { _response: res._response });
        } catch (e2) {
          if (((_a3 = e2.details) === null || _a3 === undefined ? undefined : _a3.errorCode) === "ContainerNotFound") {
            return Object.assign(Object.assign({ succeeded: false }, (_b2 = e2.response) === null || _b2 === undefined ? undefined : _b2.parsedHeaders), { _response: e2.response });
          }
          throw e2;
        }
      });
    }
    async setMetadata(metadata2, options = {}) {
      if (!options.conditions) {
        options.conditions = {};
      }
      if (options.conditions.ifUnmodifiedSince) {
        throw new RangeError("the IfUnmodifiedSince must have their default values because they are ignored by the blob service");
      }
      return tracingClient.withSpan("ContainerClient-setMetadata", options, async (updatedOptions) => {
        return assertResponse(await this.containerContext.setMetadata({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          metadata: metadata2,
          modifiedAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getAccessPolicy(options = {}) {
      if (!options.conditions) {
        options.conditions = {};
      }
      return tracingClient.withSpan("ContainerClient-getAccessPolicy", options, async (updatedOptions) => {
        const response = assertResponse(await this.containerContext.getAccessPolicy({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const res = {
          _response: response._response,
          blobPublicAccess: response.blobPublicAccess,
          date: response.date,
          etag: response.etag,
          errorCode: response.errorCode,
          lastModified: response.lastModified,
          requestId: response.requestId,
          clientRequestId: response.clientRequestId,
          signedIdentifiers: [],
          version: response.version
        };
        for (const identifier of response) {
          let accessPolicy = undefined;
          if (identifier.accessPolicy) {
            accessPolicy = {
              permissions: identifier.accessPolicy.permissions
            };
            if (identifier.accessPolicy.expiresOn) {
              accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);
            }
            if (identifier.accessPolicy.startsOn) {
              accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);
            }
          }
          res.signedIdentifiers.push({
            accessPolicy,
            id: identifier.id
          });
        }
        return res;
      });
    }
    async setAccessPolicy(access2, containerAcl2, options = {}) {
      options.conditions = options.conditions || {};
      return tracingClient.withSpan("ContainerClient-setAccessPolicy", options, async (updatedOptions) => {
        const acl = [];
        for (const identifier of containerAcl2 || []) {
          acl.push({
            accessPolicy: {
              expiresOn: identifier.accessPolicy.expiresOn ? truncatedISO8061Date(identifier.accessPolicy.expiresOn) : "",
              permissions: identifier.accessPolicy.permissions,
              startsOn: identifier.accessPolicy.startsOn ? truncatedISO8061Date(identifier.accessPolicy.startsOn) : ""
            },
            id: identifier.id
          });
        }
        return assertResponse(await this.containerContext.setAccessPolicy({
          abortSignal: options.abortSignal,
          access: access2,
          containerAcl: acl,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    getBlobLeaseClient(proposeLeaseId) {
      return new BlobLeaseClient(this, proposeLeaseId);
    }
    async uploadBlockBlob(blobName, body2, contentLength2, options = {}) {
      return tracingClient.withSpan("ContainerClient-uploadBlockBlob", options, async (updatedOptions) => {
        const blockBlobClient = this.getBlockBlobClient(blobName);
        const response = await blockBlobClient.upload(body2, contentLength2, updatedOptions);
        return {
          blockBlobClient,
          response
        };
      });
    }
    async deleteBlob(blobName, options = {}) {
      return tracingClient.withSpan("ContainerClient-deleteBlob", options, async (updatedOptions) => {
        let blobClient = this.getBlobClient(blobName);
        if (options.versionId) {
          blobClient = blobClient.withVersion(options.versionId);
        }
        return blobClient.delete(updatedOptions);
      });
    }
    async listBlobFlatSegment(marker2, options = {}) {
      return tracingClient.withSpan("ContainerClient-listBlobFlatSegment", options, async (updatedOptions) => {
        const response = assertResponse(await this.containerContext.listBlobFlatSegment(Object.assign(Object.assign({ marker: marker2 }, options), { tracingOptions: updatedOptions.tracingOptions })));
        const wrappedResponse = Object.assign(Object.assign({}, response), { _response: Object.assign(Object.assign({}, response._response), { parsedBody: ConvertInternalResponseOfListBlobFlat(response._response.parsedBody) }), segment: Object.assign(Object.assign({}, response.segment), { blobItems: response.segment.blobItems.map((blobItemInternal) => {
          const blobItem = Object.assign(Object.assign({}, blobItemInternal), { name: BlobNameToString(blobItemInternal.name), tags: toTags(blobItemInternal.blobTags), objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInternal.objectReplicationMetadata) });
          return blobItem;
        }) }) });
        return wrappedResponse;
      });
    }
    async listBlobHierarchySegment(delimiter2, marker2, options = {}) {
      return tracingClient.withSpan("ContainerClient-listBlobHierarchySegment", options, async (updatedOptions) => {
        var _a3;
        const response = assertResponse(await this.containerContext.listBlobHierarchySegment(delimiter2, Object.assign(Object.assign({ marker: marker2 }, options), { tracingOptions: updatedOptions.tracingOptions })));
        const wrappedResponse = Object.assign(Object.assign({}, response), { _response: Object.assign(Object.assign({}, response._response), { parsedBody: ConvertInternalResponseOfListBlobHierarchy(response._response.parsedBody) }), segment: Object.assign(Object.assign({}, response.segment), { blobItems: response.segment.blobItems.map((blobItemInternal) => {
          const blobItem = Object.assign(Object.assign({}, blobItemInternal), { name: BlobNameToString(blobItemInternal.name), tags: toTags(blobItemInternal.blobTags), objectReplicationSourceProperties: parseObjectReplicationRecord(blobItemInternal.objectReplicationMetadata) });
          return blobItem;
        }), blobPrefixes: (_a3 = response.segment.blobPrefixes) === null || _a3 === undefined ? undefined : _a3.map((blobPrefixInternal) => {
          const blobPrefix = Object.assign(Object.assign({}, blobPrefixInternal), { name: BlobNameToString(blobPrefixInternal.name) });
          return blobPrefix;
        }) }) });
        return wrappedResponse;
      });
    }
    listSegments(marker_1) {
      return tslib2.__asyncGenerator(this, arguments, function* listSegments_1(marker2, options = {}) {
        let listBlobsFlatSegmentResponse;
        if (!!marker2 || marker2 === undefined) {
          do {
            listBlobsFlatSegmentResponse = yield tslib2.__await(this.listBlobFlatSegment(marker2, options));
            marker2 = listBlobsFlatSegmentResponse.continuationToken;
            yield yield tslib2.__await(yield tslib2.__await(listBlobsFlatSegmentResponse));
          } while (marker2);
        }
      });
    }
    listItems() {
      return tslib2.__asyncGenerator(this, arguments, function* listItems_1(options = {}) {
        var _a3, e_1, _b2, _c2;
        let marker2;
        try {
          for (var _d2 = true, _e2 = tslib2.__asyncValues(this.listSegments(marker2, options)), _f;_f = yield tslib2.__await(_e2.next()), _a3 = _f.done, !_a3; _d2 = true) {
            _c2 = _f.value;
            _d2 = false;
            const listBlobsFlatSegmentResponse = _c2;
            yield tslib2.__await(yield* tslib2.__asyncDelegator(tslib2.__asyncValues(listBlobsFlatSegmentResponse.segment.blobItems)));
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d2 && !_a3 && (_b2 = _e2.return))
              yield tslib2.__await(_b2.call(_e2));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    listBlobsFlat(options = {}) {
      const include2 = [];
      if (options.includeCopy) {
        include2.push("copy");
      }
      if (options.includeDeleted) {
        include2.push("deleted");
      }
      if (options.includeMetadata) {
        include2.push("metadata");
      }
      if (options.includeSnapshots) {
        include2.push("snapshots");
      }
      if (options.includeVersions) {
        include2.push("versions");
      }
      if (options.includeUncommitedBlobs) {
        include2.push("uncommittedblobs");
      }
      if (options.includeTags) {
        include2.push("tags");
      }
      if (options.includeDeletedWithVersions) {
        include2.push("deletedwithversions");
      }
      if (options.includeImmutabilityPolicy) {
        include2.push("immutabilitypolicy");
      }
      if (options.includeLegalHold) {
        include2.push("legalhold");
      }
      if (options.prefix === "") {
        options.prefix = undefined;
      }
      const updatedOptions = Object.assign(Object.assign({}, options), include2.length > 0 ? { include: include2 } : {});
      const iter = this.listItems(updatedOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listSegments(settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, updatedOptions));
        }
      };
    }
    listHierarchySegments(delimiter_1, marker_1) {
      return tslib2.__asyncGenerator(this, arguments, function* listHierarchySegments_1(delimiter2, marker2, options = {}) {
        let listBlobsHierarchySegmentResponse;
        if (!!marker2 || marker2 === undefined) {
          do {
            listBlobsHierarchySegmentResponse = yield tslib2.__await(this.listBlobHierarchySegment(delimiter2, marker2, options));
            marker2 = listBlobsHierarchySegmentResponse.continuationToken;
            yield yield tslib2.__await(yield tslib2.__await(listBlobsHierarchySegmentResponse));
          } while (marker2);
        }
      });
    }
    listItemsByHierarchy(delimiter_1) {
      return tslib2.__asyncGenerator(this, arguments, function* listItemsByHierarchy_1(delimiter2, options = {}) {
        var _a3, e_2, _b2, _c2;
        let marker2;
        try {
          for (var _d2 = true, _e2 = tslib2.__asyncValues(this.listHierarchySegments(delimiter2, marker2, options)), _f;_f = yield tslib2.__await(_e2.next()), _a3 = _f.done, !_a3; _d2 = true) {
            _c2 = _f.value;
            _d2 = false;
            const listBlobsHierarchySegmentResponse = _c2;
            const segment = listBlobsHierarchySegmentResponse.segment;
            if (segment.blobPrefixes) {
              for (const prefix2 of segment.blobPrefixes) {
                yield yield tslib2.__await(Object.assign({ kind: "prefix" }, prefix2));
              }
            }
            for (const blob of segment.blobItems) {
              yield yield tslib2.__await(Object.assign({ kind: "blob" }, blob));
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (!_d2 && !_a3 && (_b2 = _e2.return))
              yield tslib2.__await(_b2.call(_e2));
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      });
    }
    listBlobsByHierarchy(delimiter2, options = {}) {
      if (delimiter2 === "") {
        throw new RangeError("delimiter should contain one or more characters");
      }
      const include2 = [];
      if (options.includeCopy) {
        include2.push("copy");
      }
      if (options.includeDeleted) {
        include2.push("deleted");
      }
      if (options.includeMetadata) {
        include2.push("metadata");
      }
      if (options.includeSnapshots) {
        include2.push("snapshots");
      }
      if (options.includeVersions) {
        include2.push("versions");
      }
      if (options.includeUncommitedBlobs) {
        include2.push("uncommittedblobs");
      }
      if (options.includeTags) {
        include2.push("tags");
      }
      if (options.includeDeletedWithVersions) {
        include2.push("deletedwithversions");
      }
      if (options.includeImmutabilityPolicy) {
        include2.push("immutabilitypolicy");
      }
      if (options.includeLegalHold) {
        include2.push("legalhold");
      }
      if (options.prefix === "") {
        options.prefix = undefined;
      }
      const updatedOptions = Object.assign(Object.assign({}, options), include2.length > 0 ? { include: include2 } : {});
      const iter = this.listItemsByHierarchy(delimiter2, updatedOptions);
      return {
        async next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listHierarchySegments(delimiter2, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, updatedOptions));
        }
      };
    }
    async findBlobsByTagsSegment(tagFilterSqlExpression, marker2, options = {}) {
      return tracingClient.withSpan("ContainerClient-findBlobsByTagsSegment", options, async (updatedOptions) => {
        const response = assertResponse(await this.containerContext.filterBlobs({
          abortSignal: options.abortSignal,
          where: tagFilterSqlExpression,
          marker: marker2,
          maxPageSize: options.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = Object.assign(Object.assign({}, response), { _response: response._response, blobs: response.blobs.map((blob) => {
          var _a3;
          let tagValue = "";
          if (((_a3 = blob.tags) === null || _a3 === undefined ? undefined : _a3.blobTagSet.length) === 1) {
            tagValue = blob.tags.blobTagSet[0].value;
          }
          return Object.assign(Object.assign({}, blob), { tags: toTags(blob.tags), tagValue });
        }) });
        return wrappedResponse;
      });
    }
    findBlobsByTagsSegments(tagFilterSqlExpression_1, marker_1) {
      return tslib2.__asyncGenerator(this, arguments, function* findBlobsByTagsSegments_1(tagFilterSqlExpression, marker2, options = {}) {
        let response;
        if (!!marker2 || marker2 === undefined) {
          do {
            response = yield tslib2.__await(this.findBlobsByTagsSegment(tagFilterSqlExpression, marker2, options));
            response.blobs = response.blobs || [];
            marker2 = response.continuationToken;
            yield yield tslib2.__await(response);
          } while (marker2);
        }
      });
    }
    findBlobsByTagsItems(tagFilterSqlExpression_1) {
      return tslib2.__asyncGenerator(this, arguments, function* findBlobsByTagsItems_1(tagFilterSqlExpression, options = {}) {
        var _a3, e_3, _b2, _c2;
        let marker2;
        try {
          for (var _d2 = true, _e2 = tslib2.__asyncValues(this.findBlobsByTagsSegments(tagFilterSqlExpression, marker2, options)), _f;_f = yield tslib2.__await(_e2.next()), _a3 = _f.done, !_a3; _d2 = true) {
            _c2 = _f.value;
            _d2 = false;
            const segment = _c2;
            yield tslib2.__await(yield* tslib2.__asyncDelegator(tslib2.__asyncValues(segment.blobs)));
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (!_d2 && !_a3 && (_b2 = _e2.return))
              yield tslib2.__await(_b2.call(_e2));
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
      });
    }
    findBlobsByTags(tagFilterSqlExpression, options = {}) {
      const listSegmentOptions = Object.assign({}, options);
      const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, listSegmentOptions));
        }
      };
    }
    async getAccountInfo(options = {}) {
      return tracingClient.withSpan("ContainerClient-getAccountInfo", options, async (updatedOptions) => {
        return assertResponse(await this.containerContext.getAccountInfo({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    getContainerNameFromUrl() {
      let containerName;
      try {
        const parsedUrl = new URL(this.url);
        if (parsedUrl.hostname.split(".")[1] === "blob") {
          containerName = parsedUrl.pathname.split("/")[1];
        } else if (isIpEndpointStyle(parsedUrl)) {
          containerName = parsedUrl.pathname.split("/")[2];
        } else {
          containerName = parsedUrl.pathname.split("/")[1];
        }
        containerName = decodeURIComponent(containerName);
        if (!containerName) {
          throw new Error("Provided containerName is invalid.");
        }
        return containerName;
      } catch (error) {
        throw new Error("Unable to extract containerName with provided information.");
      }
    }
    generateSasUrl(options) {
      return new Promise((resolve5) => {
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
          throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        const sas = generateBlobSASQueryParameters(Object.assign({ containerName: this._containerName }, options), this.credential).toString();
        resolve5(appendToURLQuery(this.url, sas));
      });
    }
    generateSasStringToSign(options) {
      if (!(this.credential instanceof StorageSharedKeyCredential)) {
        throw new RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
      }
      return generateBlobSASQueryParametersInternal(Object.assign({ containerName: this._containerName }, options), this.credential).stringToSign;
    }
    generateUserDelegationSasUrl(options, userDelegationKey) {
      return new Promise((resolve5) => {
        const sas = generateBlobSASQueryParameters(Object.assign({ containerName: this._containerName }, options), userDelegationKey, this.accountName).toString();
        resolve5(appendToURLQuery(this.url, sas));
      });
    }
    generateUserDelegationSasStringToSign(options, userDelegationKey) {
      return generateBlobSASQueryParametersInternal(Object.assign({ containerName: this._containerName }, options), userDelegationKey, this.accountName).stringToSign;
    }
    getBlobBatchClient() {
      return new BlobBatchClient(this.url, this.pipeline);
    }
  }

  class AccountSASPermissions {
    constructor() {
      this.read = false;
      this.write = false;
      this.delete = false;
      this.deleteVersion = false;
      this.list = false;
      this.add = false;
      this.create = false;
      this.update = false;
      this.process = false;
      this.tag = false;
      this.filter = false;
      this.setImmutabilityPolicy = false;
      this.permanentDelete = false;
    }
    static parse(permissions) {
      const accountSASPermissions = new AccountSASPermissions;
      for (const c2 of permissions) {
        switch (c2) {
          case "r":
            accountSASPermissions.read = true;
            break;
          case "w":
            accountSASPermissions.write = true;
            break;
          case "d":
            accountSASPermissions.delete = true;
            break;
          case "x":
            accountSASPermissions.deleteVersion = true;
            break;
          case "l":
            accountSASPermissions.list = true;
            break;
          case "a":
            accountSASPermissions.add = true;
            break;
          case "c":
            accountSASPermissions.create = true;
            break;
          case "u":
            accountSASPermissions.update = true;
            break;
          case "p":
            accountSASPermissions.process = true;
            break;
          case "t":
            accountSASPermissions.tag = true;
            break;
          case "f":
            accountSASPermissions.filter = true;
            break;
          case "i":
            accountSASPermissions.setImmutabilityPolicy = true;
            break;
          case "y":
            accountSASPermissions.permanentDelete = true;
            break;
          default:
            throw new RangeError(`Invalid permission character: ${c2}`);
        }
      }
      return accountSASPermissions;
    }
    static from(permissionLike) {
      const accountSASPermissions = new AccountSASPermissions;
      if (permissionLike.read) {
        accountSASPermissions.read = true;
      }
      if (permissionLike.write) {
        accountSASPermissions.write = true;
      }
      if (permissionLike.delete) {
        accountSASPermissions.delete = true;
      }
      if (permissionLike.deleteVersion) {
        accountSASPermissions.deleteVersion = true;
      }
      if (permissionLike.filter) {
        accountSASPermissions.filter = true;
      }
      if (permissionLike.tag) {
        accountSASPermissions.tag = true;
      }
      if (permissionLike.list) {
        accountSASPermissions.list = true;
      }
      if (permissionLike.add) {
        accountSASPermissions.add = true;
      }
      if (permissionLike.create) {
        accountSASPermissions.create = true;
      }
      if (permissionLike.update) {
        accountSASPermissions.update = true;
      }
      if (permissionLike.process) {
        accountSASPermissions.process = true;
      }
      if (permissionLike.setImmutabilityPolicy) {
        accountSASPermissions.setImmutabilityPolicy = true;
      }
      if (permissionLike.permanentDelete) {
        accountSASPermissions.permanentDelete = true;
      }
      return accountSASPermissions;
    }
    toString() {
      const permissions = [];
      if (this.read) {
        permissions.push("r");
      }
      if (this.write) {
        permissions.push("w");
      }
      if (this.delete) {
        permissions.push("d");
      }
      if (this.deleteVersion) {
        permissions.push("x");
      }
      if (this.filter) {
        permissions.push("f");
      }
      if (this.tag) {
        permissions.push("t");
      }
      if (this.list) {
        permissions.push("l");
      }
      if (this.add) {
        permissions.push("a");
      }
      if (this.create) {
        permissions.push("c");
      }
      if (this.update) {
        permissions.push("u");
      }
      if (this.process) {
        permissions.push("p");
      }
      if (this.setImmutabilityPolicy) {
        permissions.push("i");
      }
      if (this.permanentDelete) {
        permissions.push("y");
      }
      return permissions.join("");
    }
  }

  class AccountSASResourceTypes {
    constructor() {
      this.service = false;
      this.container = false;
      this.object = false;
    }
    static parse(resourceTypes) {
      const accountSASResourceTypes = new AccountSASResourceTypes;
      for (const c2 of resourceTypes) {
        switch (c2) {
          case "s":
            accountSASResourceTypes.service = true;
            break;
          case "c":
            accountSASResourceTypes.container = true;
            break;
          case "o":
            accountSASResourceTypes.object = true;
            break;
          default:
            throw new RangeError(`Invalid resource type: ${c2}`);
        }
      }
      return accountSASResourceTypes;
    }
    toString() {
      const resourceTypes = [];
      if (this.service) {
        resourceTypes.push("s");
      }
      if (this.container) {
        resourceTypes.push("c");
      }
      if (this.object) {
        resourceTypes.push("o");
      }
      return resourceTypes.join("");
    }
  }

  class AccountSASServices {
    constructor() {
      this.blob = false;
      this.file = false;
      this.queue = false;
      this.table = false;
    }
    static parse(services) {
      const accountSASServices = new AccountSASServices;
      for (const c2 of services) {
        switch (c2) {
          case "b":
            accountSASServices.blob = true;
            break;
          case "f":
            accountSASServices.file = true;
            break;
          case "q":
            accountSASServices.queue = true;
            break;
          case "t":
            accountSASServices.table = true;
            break;
          default:
            throw new RangeError(`Invalid service character: ${c2}`);
        }
      }
      return accountSASServices;
    }
    toString() {
      const services = [];
      if (this.blob) {
        services.push("b");
      }
      if (this.table) {
        services.push("t");
      }
      if (this.queue) {
        services.push("q");
      }
      if (this.file) {
        services.push("f");
      }
      return services.join("");
    }
  }
  function generateAccountSASQueryParameters(accountSASSignatureValues, sharedKeyCredential) {
    return generateAccountSASQueryParametersInternal(accountSASSignatureValues, sharedKeyCredential).sasQueryParameters;
  }
  function generateAccountSASQueryParametersInternal(accountSASSignatureValues, sharedKeyCredential) {
    const version2 = accountSASSignatureValues.version ? accountSASSignatureValues.version : SERVICE_VERSION;
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.setImmutabilityPolicy && version2 < "2020-08-04") {
      throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.deleteVersion && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when provided 'x' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.permanentDelete && version2 < "2019-10-10") {
      throw RangeError("'version' must be >= '2019-10-10' when provided 'y' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.tag && version2 < "2019-12-12") {
      throw RangeError("'version' must be >= '2019-12-12' when provided 't' permission.");
    }
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.filter && version2 < "2019-12-12") {
      throw RangeError("'version' must be >= '2019-12-12' when provided 'f' permission.");
    }
    if (accountSASSignatureValues.encryptionScope && version2 < "2020-12-06") {
      throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
    }
    const parsedPermissions = AccountSASPermissions.parse(accountSASSignatureValues.permissions.toString());
    const parsedServices = AccountSASServices.parse(accountSASSignatureValues.services).toString();
    const parsedResourceTypes = AccountSASResourceTypes.parse(accountSASSignatureValues.resourceTypes).toString();
    let stringToSign;
    if (version2 >= "2020-12-06") {
      stringToSign = [
        sharedKeyCredential.accountName,
        parsedPermissions,
        parsedServices,
        parsedResourceTypes,
        accountSASSignatureValues.startsOn ? truncatedISO8061Date(accountSASSignatureValues.startsOn, false) : "",
        truncatedISO8061Date(accountSASSignatureValues.expiresOn, false),
        accountSASSignatureValues.ipRange ? ipRangeToString(accountSASSignatureValues.ipRange) : "",
        accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
        version2,
        accountSASSignatureValues.encryptionScope ? accountSASSignatureValues.encryptionScope : "",
        ""
      ].join(`
`);
    } else {
      stringToSign = [
        sharedKeyCredential.accountName,
        parsedPermissions,
        parsedServices,
        parsedResourceTypes,
        accountSASSignatureValues.startsOn ? truncatedISO8061Date(accountSASSignatureValues.startsOn, false) : "",
        truncatedISO8061Date(accountSASSignatureValues.expiresOn, false),
        accountSASSignatureValues.ipRange ? ipRangeToString(accountSASSignatureValues.ipRange) : "",
        accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
        version2,
        ""
      ].join(`
`);
    }
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters(version2, signature, parsedPermissions.toString(), parsedServices, parsedResourceTypes, accountSASSignatureValues.protocol, accountSASSignatureValues.startsOn, accountSASSignatureValues.expiresOn, accountSASSignatureValues.ipRange, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, accountSASSignatureValues.encryptionScope),
      stringToSign
    };
  }

  class BlobServiceClient extends StorageClient {
    static fromConnectionString(connectionString, options) {
      options = options || {};
      const extractedCreds = extractConnectionStringParts(connectionString);
      if (extractedCreds.kind === "AccountConnString") {
        if (coreUtil.isNode) {
          const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
          if (!options.proxyOptions) {
            options.proxyOptions = coreRestPipeline.getDefaultProxySettings(extractedCreds.proxyUri);
          }
          const pipeline = newPipeline(sharedKeyCredential, options);
          return new BlobServiceClient(extractedCreds.url, pipeline);
        } else {
          throw new Error("Account connection string is only supported in Node.js environment");
        }
      } else if (extractedCreds.kind === "SASConnString") {
        const pipeline = newPipeline(new AnonymousCredential, options);
        return new BlobServiceClient(extractedCreds.url + "?" + extractedCreds.accountSas, pipeline);
      } else {
        throw new Error("Connection string must be either an Account connection string or a SAS connection string");
      }
    }
    constructor(url2, credentialOrPipeline, options) {
      let pipeline;
      if (isPipelineLike(credentialOrPipeline)) {
        pipeline = credentialOrPipeline;
      } else if (coreUtil.isNode && credentialOrPipeline instanceof StorageSharedKeyCredential || credentialOrPipeline instanceof AnonymousCredential || coreAuth.isTokenCredential(credentialOrPipeline)) {
        pipeline = newPipeline(credentialOrPipeline, options);
      } else {
        pipeline = newPipeline(new AnonymousCredential, options);
      }
      super(url2, pipeline);
      this.serviceContext = this.storageClientContext.service;
    }
    getContainerClient(containerName) {
      return new ContainerClient(appendToURLPath(this.url, encodeURIComponent(containerName)), this.pipeline);
    }
    async createContainer(containerName, options = {}) {
      return tracingClient.withSpan("BlobServiceClient-createContainer", options, async (updatedOptions) => {
        const containerClient = this.getContainerClient(containerName);
        const containerCreateResponse = await containerClient.create(updatedOptions);
        return {
          containerClient,
          containerCreateResponse
        };
      });
    }
    async deleteContainer(containerName, options = {}) {
      return tracingClient.withSpan("BlobServiceClient-deleteContainer", options, async (updatedOptions) => {
        const containerClient = this.getContainerClient(containerName);
        return containerClient.delete(updatedOptions);
      });
    }
    async undeleteContainer(deletedContainerName2, deletedContainerVersion2, options = {}) {
      return tracingClient.withSpan("BlobServiceClient-undeleteContainer", options, async (updatedOptions) => {
        const containerClient = this.getContainerClient(options.destinationContainerName || deletedContainerName2);
        const containerContext = containerClient["storageClientContext"].container;
        const containerUndeleteResponse = assertResponse(await containerContext.restore({
          deletedContainerName: deletedContainerName2,
          deletedContainerVersion: deletedContainerVersion2,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return { containerClient, containerUndeleteResponse };
      });
    }
    async renameContainer(sourceContainerName2, destinationContainerName, options = {}) {
      return tracingClient.withSpan("BlobServiceClient-renameContainer", options, async (updatedOptions) => {
        var _a3;
        const containerClient = this.getContainerClient(destinationContainerName);
        const containerContext = containerClient["storageClientContext"].container;
        const containerRenameResponse = assertResponse(await containerContext.rename(sourceContainerName2, Object.assign(Object.assign({}, updatedOptions), { sourceLeaseId: (_a3 = options.sourceCondition) === null || _a3 === undefined ? undefined : _a3.leaseId })));
        return { containerClient, containerRenameResponse };
      });
    }
    async getProperties(options = {}) {
      return tracingClient.withSpan("BlobServiceClient-getProperties", options, async (updatedOptions) => {
        return assertResponse(await this.serviceContext.getProperties({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setProperties(properties, options = {}) {
      return tracingClient.withSpan("BlobServiceClient-setProperties", options, async (updatedOptions) => {
        return assertResponse(await this.serviceContext.setProperties(properties, {
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getStatistics(options = {}) {
      return tracingClient.withSpan("BlobServiceClient-getStatistics", options, async (updatedOptions) => {
        return assertResponse(await this.serviceContext.getStatistics({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getAccountInfo(options = {}) {
      return tracingClient.withSpan("BlobServiceClient-getAccountInfo", options, async (updatedOptions) => {
        return assertResponse(await this.serviceContext.getAccountInfo({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async listContainersSegment(marker2, options = {}) {
      return tracingClient.withSpan("BlobServiceClient-listContainersSegment", options, async (updatedOptions) => {
        return assertResponse(await this.serviceContext.listContainersSegment(Object.assign(Object.assign({ abortSignal: options.abortSignal, marker: marker2 }, options), { include: typeof options.include === "string" ? [options.include] : options.include, tracingOptions: updatedOptions.tracingOptions })));
      });
    }
    async findBlobsByTagsSegment(tagFilterSqlExpression, marker2, options = {}) {
      return tracingClient.withSpan("BlobServiceClient-findBlobsByTagsSegment", options, async (updatedOptions) => {
        const response = assertResponse(await this.serviceContext.filterBlobs({
          abortSignal: options.abortSignal,
          where: tagFilterSqlExpression,
          marker: marker2,
          maxPageSize: options.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const wrappedResponse = Object.assign(Object.assign({}, response), { _response: response._response, blobs: response.blobs.map((blob) => {
          var _a3;
          let tagValue = "";
          if (((_a3 = blob.tags) === null || _a3 === undefined ? undefined : _a3.blobTagSet.length) === 1) {
            tagValue = blob.tags.blobTagSet[0].value;
          }
          return Object.assign(Object.assign({}, blob), { tags: toTags(blob.tags), tagValue });
        }) });
        return wrappedResponse;
      });
    }
    findBlobsByTagsSegments(tagFilterSqlExpression_1, marker_1) {
      return tslib2.__asyncGenerator(this, arguments, function* findBlobsByTagsSegments_1(tagFilterSqlExpression, marker2, options = {}) {
        let response;
        if (!!marker2 || marker2 === undefined) {
          do {
            response = yield tslib2.__await(this.findBlobsByTagsSegment(tagFilterSqlExpression, marker2, options));
            response.blobs = response.blobs || [];
            marker2 = response.continuationToken;
            yield yield tslib2.__await(response);
          } while (marker2);
        }
      });
    }
    findBlobsByTagsItems(tagFilterSqlExpression_1) {
      return tslib2.__asyncGenerator(this, arguments, function* findBlobsByTagsItems_1(tagFilterSqlExpression, options = {}) {
        var _a3, e_1, _b2, _c2;
        let marker2;
        try {
          for (var _d2 = true, _e2 = tslib2.__asyncValues(this.findBlobsByTagsSegments(tagFilterSqlExpression, marker2, options)), _f;_f = yield tslib2.__await(_e2.next()), _a3 = _f.done, !_a3; _d2 = true) {
            _c2 = _f.value;
            _d2 = false;
            const segment = _c2;
            yield tslib2.__await(yield* tslib2.__asyncDelegator(tslib2.__asyncValues(segment.blobs)));
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d2 && !_a3 && (_b2 = _e2.return))
              yield tslib2.__await(_b2.call(_e2));
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      });
    }
    findBlobsByTags(tagFilterSqlExpression, options = {}) {
      const listSegmentOptions = Object.assign({}, options);
      const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, listSegmentOptions));
        }
      };
    }
    listSegments(marker_1) {
      return tslib2.__asyncGenerator(this, arguments, function* listSegments_1(marker2, options = {}) {
        let listContainersSegmentResponse;
        if (!!marker2 || marker2 === undefined) {
          do {
            listContainersSegmentResponse = yield tslib2.__await(this.listContainersSegment(marker2, options));
            listContainersSegmentResponse.containerItems = listContainersSegmentResponse.containerItems || [];
            marker2 = listContainersSegmentResponse.continuationToken;
            yield yield tslib2.__await(yield tslib2.__await(listContainersSegmentResponse));
          } while (marker2);
        }
      });
    }
    listItems() {
      return tslib2.__asyncGenerator(this, arguments, function* listItems_1(options = {}) {
        var _a3, e_2, _b2, _c2;
        let marker2;
        try {
          for (var _d2 = true, _e2 = tslib2.__asyncValues(this.listSegments(marker2, options)), _f;_f = yield tslib2.__await(_e2.next()), _a3 = _f.done, !_a3; _d2 = true) {
            _c2 = _f.value;
            _d2 = false;
            const segment = _c2;
            yield tslib2.__await(yield* tslib2.__asyncDelegator(tslib2.__asyncValues(segment.containerItems)));
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (!_d2 && !_a3 && (_b2 = _e2.return))
              yield tslib2.__await(_b2.call(_e2));
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      });
    }
    listContainers(options = {}) {
      if (options.prefix === "") {
        options.prefix = undefined;
      }
      const include2 = [];
      if (options.includeDeleted) {
        include2.push("deleted");
      }
      if (options.includeMetadata) {
        include2.push("metadata");
      }
      if (options.includeSystem) {
        include2.push("system");
      }
      const listSegmentOptions = Object.assign(Object.assign({}, options), include2.length > 0 ? { include: include2 } : {});
      const iter = this.listItems(listSegmentOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listSegments(settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, listSegmentOptions));
        }
      };
    }
    async getUserDelegationKey(startsOn, expiresOn2, options = {}) {
      return tracingClient.withSpan("BlobServiceClient-getUserDelegationKey", options, async (updatedOptions) => {
        const response = assertResponse(await this.serviceContext.getUserDelegationKey({
          startsOn: truncatedISO8061Date(startsOn, false),
          expiresOn: truncatedISO8061Date(expiresOn2, false)
        }, {
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
        const userDelegationKey = {
          signedObjectId: response.signedObjectId,
          signedTenantId: response.signedTenantId,
          signedStartsOn: new Date(response.signedStartsOn),
          signedExpiresOn: new Date(response.signedExpiresOn),
          signedService: response.signedService,
          signedVersion: response.signedVersion,
          value: response.value
        };
        const res = Object.assign({ _response: response._response, requestId: response.requestId, clientRequestId: response.clientRequestId, version: response.version, date: response.date, errorCode: response.errorCode }, userDelegationKey);
        return res;
      });
    }
    getBlobBatchClient() {
      return new BlobBatchClient(this.url, this.pipeline);
    }
    generateAccountSasUrl(expiresOn2, permissions = AccountSASPermissions.parse("r"), resourceTypes = "sco", options = {}) {
      if (!(this.credential instanceof StorageSharedKeyCredential)) {
        throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
      }
      if (expiresOn2 === undefined) {
        const now = new Date;
        expiresOn2 = new Date(now.getTime() + 3600 * 1000);
      }
      const sas = generateAccountSASQueryParameters(Object.assign({
        permissions,
        expiresOn: expiresOn2,
        resourceTypes,
        services: AccountSASServices.parse("b").toString()
      }, options), this.credential).toString();
      return appendToURLQuery(this.url, sas);
    }
    generateSasStringToSign(expiresOn2, permissions = AccountSASPermissions.parse("r"), resourceTypes = "sco", options = {}) {
      if (!(this.credential instanceof StorageSharedKeyCredential)) {
        throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
      }
      if (expiresOn2 === undefined) {
        const now = new Date;
        expiresOn2 = new Date(now.getTime() + 3600 * 1000);
      }
      return generateAccountSASQueryParametersInternal(Object.assign({
        permissions,
        expiresOn: expiresOn2,
        resourceTypes,
        services: AccountSASServices.parse("b").toString()
      }, options), this.credential).stringToSign;
    }
  }
  exports.KnownEncryptionAlgorithmType = undefined;
  (function(KnownEncryptionAlgorithmType) {
    KnownEncryptionAlgorithmType["AES256"] = "AES256";
  })(exports.KnownEncryptionAlgorithmType || (exports.KnownEncryptionAlgorithmType = {}));
  Object.defineProperty(exports, "RestError", {
    enumerable: true,
    get: function() {
      return coreRestPipeline.RestError;
    }
  });
  exports.AccountSASPermissions = AccountSASPermissions;
  exports.AccountSASResourceTypes = AccountSASResourceTypes;
  exports.AccountSASServices = AccountSASServices;
  exports.AnonymousCredential = AnonymousCredential;
  exports.AnonymousCredentialPolicy = AnonymousCredentialPolicy;
  exports.AppendBlobClient = AppendBlobClient;
  exports.BaseRequestPolicy = BaseRequestPolicy;
  exports.BlobBatch = BlobBatch;
  exports.BlobBatchClient = BlobBatchClient;
  exports.BlobClient = BlobClient;
  exports.BlobLeaseClient = BlobLeaseClient;
  exports.BlobSASPermissions = BlobSASPermissions;
  exports.BlobServiceClient = BlobServiceClient;
  exports.BlockBlobClient = BlockBlobClient;
  exports.ContainerClient = ContainerClient;
  exports.ContainerSASPermissions = ContainerSASPermissions;
  exports.Credential = Credential;
  exports.CredentialPolicy = CredentialPolicy;
  exports.PageBlobClient = PageBlobClient;
  exports.Pipeline = Pipeline;
  exports.SASQueryParameters = SASQueryParameters;
  exports.StorageBrowserPolicy = StorageBrowserPolicy;
  exports.StorageBrowserPolicyFactory = StorageBrowserPolicyFactory;
  exports.StorageOAuthScopes = StorageOAuthScopes;
  exports.StorageRetryPolicy = StorageRetryPolicy;
  exports.StorageRetryPolicyFactory = StorageRetryPolicyFactory;
  exports.StorageSharedKeyCredential = StorageSharedKeyCredential;
  exports.StorageSharedKeyCredentialPolicy = StorageSharedKeyCredentialPolicy;
  exports.generateAccountSASQueryParameters = generateAccountSASQueryParameters;
  exports.generateBlobSASQueryParameters = generateBlobSASQueryParameters;
  exports.getBlobServiceAccountAudience = getBlobServiceAccountAudience;
  exports.isPipelineLike = isPipelineLike;
  exports.logger = logger4;
  exports.newPipeline = newPipeline;
});

// node_modules/@actions/cache/lib/internal/shared/errors.js
var require_errors4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UsageError = exports.NetworkError = exports.GHESNotSupportedError = exports.CacheNotFoundError = exports.InvalidResponseError = exports.FilesNotFoundError = undefined;

  class FilesNotFoundError extends Error {
    constructor(files = []) {
      let message = "No files were found to upload";
      if (files.length > 0) {
        message += `: ${files.join(", ")}`;
      }
      super(message);
      this.files = files;
      this.name = "FilesNotFoundError";
    }
  }
  exports.FilesNotFoundError = FilesNotFoundError;

  class InvalidResponseError extends Error {
    constructor(message) {
      super(message);
      this.name = "InvalidResponseError";
    }
  }
  exports.InvalidResponseError = InvalidResponseError;

  class CacheNotFoundError extends Error {
    constructor(message = "Cache not found") {
      super(message);
      this.name = "CacheNotFoundError";
    }
  }
  exports.CacheNotFoundError = CacheNotFoundError;

  class GHESNotSupportedError extends Error {
    constructor(message = "@actions/cache v4.1.4+, actions/cache/save@v4+ and actions/cache/restore@v4+ are not currently supported on GHES.") {
      super(message);
      this.name = "GHESNotSupportedError";
    }
  }
  exports.GHESNotSupportedError = GHESNotSupportedError;

  class NetworkError extends Error {
    constructor(code) {
      const message = `Unable to make request: ${code}
If you are using self-hosted runners, please make sure your runner has access to all GitHub endpoints: https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#communication-between-self-hosted-runners-and-github`;
      super(message);
      this.code = code;
      this.name = "NetworkError";
    }
  }
  exports.NetworkError = NetworkError;
  NetworkError.isNetworkErrorCode = (code) => {
    if (!code)
      return false;
    return [
      "ECONNRESET",
      "ENOTFOUND",
      "ETIMEDOUT",
      "ECONNREFUSED",
      "EHOSTUNREACH"
    ].includes(code);
  };

  class UsageError extends Error {
    constructor() {
      const message = `Cache storage quota has been hit. Unable to upload any new cache entries. Usage is recalculated every 6-12 hours.
More info on storage limits: https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#calculating-minute-and-storage-spending`;
      super(message);
      this.name = "UsageError";
    }
  }
  exports.UsageError = UsageError;
  UsageError.isUsageErrorMessage = (msg) => {
    if (!msg)
      return false;
    return msg.includes("insufficient usage");
  };
});

// node_modules/@actions/cache/lib/internal/uploadUtils.js
var require_uploadUtils = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve5, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uploadCacheArchiveSDK = exports.UploadProgress = undefined;
  var core = __importStar2(require_core());
  var storage_blob_1 = require_dist7();
  var errors_1 = require_errors4();

  class UploadProgress {
    constructor(contentLength) {
      this.contentLength = contentLength;
      this.sentBytes = 0;
      this.displayedComplete = false;
      this.startTime = Date.now();
    }
    setSentBytes(sentBytes) {
      this.sentBytes = sentBytes;
    }
    getTransferredBytes() {
      return this.sentBytes;
    }
    isDone() {
      return this.getTransferredBytes() === this.contentLength;
    }
    display() {
      if (this.displayedComplete) {
        return;
      }
      const transferredBytes = this.sentBytes;
      const percentage = (100 * (transferredBytes / this.contentLength)).toFixed(1);
      const elapsedTime = Date.now() - this.startTime;
      const uploadSpeed = (transferredBytes / (1024 * 1024) / (elapsedTime / 1000)).toFixed(1);
      core.info(`Sent ${transferredBytes} of ${this.contentLength} (${percentage}%), ${uploadSpeed} MBs/sec`);
      if (this.isDone()) {
        this.displayedComplete = true;
      }
    }
    onProgress() {
      return (progress) => {
        this.setSentBytes(progress.loadedBytes);
      };
    }
    startDisplayTimer(delayInMs = 1000) {
      const displayCallback = () => {
        this.display();
        if (!this.isDone()) {
          this.timeoutHandle = setTimeout(displayCallback, delayInMs);
        }
      };
      this.timeoutHandle = setTimeout(displayCallback, delayInMs);
    }
    stopDisplayTimer() {
      if (this.timeoutHandle) {
        clearTimeout(this.timeoutHandle);
        this.timeoutHandle = undefined;
      }
      this.display();
    }
  }
  exports.UploadProgress = UploadProgress;
  function uploadCacheArchiveSDK(signedUploadURL, archivePath, options) {
    var _a3;
    return __awaiter2(this, undefined, undefined, function* () {
      const blobClient = new storage_blob_1.BlobClient(signedUploadURL);
      const blockBlobClient = blobClient.getBlockBlobClient();
      const uploadProgress = new UploadProgress((_a3 = options === null || options === undefined ? undefined : options.archiveSizeBytes) !== null && _a3 !== undefined ? _a3 : 0);
      const uploadOptions = {
        blockSize: options === null || options === undefined ? undefined : options.uploadChunkSize,
        concurrency: options === null || options === undefined ? undefined : options.uploadConcurrency,
        maxSingleShotSize: 128 * 1024 * 1024,
        onProgress: uploadProgress.onProgress()
      };
      try {
        uploadProgress.startDisplayTimer();
        core.debug(`BlobClient: ${blobClient.name}:${blobClient.accountName}:${blobClient.containerName}`);
        const response = yield blockBlobClient.uploadFile(archivePath, uploadOptions);
        if (response._response.status >= 400) {
          throw new errors_1.InvalidResponseError(`uploadCacheArchiveSDK: upload failed with status code ${response._response.status}`);
        }
        return response;
      } catch (error) {
        core.warning(`uploadCacheArchiveSDK: internal error uploading cache archive: ${error.message}`);
        throw error;
      } finally {
        uploadProgress.stopDisplayTimer();
      }
    });
  }
  exports.uploadCacheArchiveSDK = uploadCacheArchiveSDK;
});

// node_modules/@actions/cache/lib/internal/requestUtils.js
var require_requestUtils = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve5, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retryHttpClientResponse = exports.retryTypedResponse = exports.retry = exports.isRetryableStatusCode = exports.isServerErrorStatusCode = exports.isSuccessStatusCode = undefined;
  var core = __importStar2(require_core());
  var http_client_1 = require_lib();
  var constants_1 = require_constants6();
  function isSuccessStatusCode(statusCode) {
    if (!statusCode) {
      return false;
    }
    return statusCode >= 200 && statusCode < 300;
  }
  exports.isSuccessStatusCode = isSuccessStatusCode;
  function isServerErrorStatusCode(statusCode) {
    if (!statusCode) {
      return true;
    }
    return statusCode >= 500;
  }
  exports.isServerErrorStatusCode = isServerErrorStatusCode;
  function isRetryableStatusCode(statusCode) {
    if (!statusCode) {
      return false;
    }
    const retryableStatusCodes = [
      http_client_1.HttpCodes.BadGateway,
      http_client_1.HttpCodes.ServiceUnavailable,
      http_client_1.HttpCodes.GatewayTimeout
    ];
    return retryableStatusCodes.includes(statusCode);
  }
  exports.isRetryableStatusCode = isRetryableStatusCode;
  function sleep(milliseconds) {
    return __awaiter2(this, undefined, undefined, function* () {
      return new Promise((resolve5) => setTimeout(resolve5, milliseconds));
    });
  }
  function retry(name, method, getStatusCode, maxAttempts = constants_1.DefaultRetryAttempts, delay3 = constants_1.DefaultRetryDelay, onError = undefined) {
    return __awaiter2(this, undefined, undefined, function* () {
      let errorMessage = "";
      let attempt = 1;
      while (attempt <= maxAttempts) {
        let response = undefined;
        let statusCode = undefined;
        let isRetryable = false;
        try {
          response = yield method();
        } catch (error) {
          if (onError) {
            response = onError(error);
          }
          isRetryable = true;
          errorMessage = error.message;
        }
        if (response) {
          statusCode = getStatusCode(response);
          if (!isServerErrorStatusCode(statusCode)) {
            return response;
          }
        }
        if (statusCode) {
          isRetryable = isRetryableStatusCode(statusCode);
          errorMessage = `Cache service responded with ${statusCode}`;
        }
        core.debug(`${name} - Attempt ${attempt} of ${maxAttempts} failed with error: ${errorMessage}`);
        if (!isRetryable) {
          core.debug(`${name} - Error is not retryable`);
          break;
        }
        yield sleep(delay3);
        attempt++;
      }
      throw Error(`${name} failed: ${errorMessage}`);
    });
  }
  exports.retry = retry;
  function retryTypedResponse(name, method, maxAttempts = constants_1.DefaultRetryAttempts, delay3 = constants_1.DefaultRetryDelay) {
    return __awaiter2(this, undefined, undefined, function* () {
      return yield retry(name, method, (response) => response.statusCode, maxAttempts, delay3, (error) => {
        if (error instanceof http_client_1.HttpClientError) {
          return {
            statusCode: error.statusCode,
            result: null,
            headers: {},
            error
          };
        } else {
          return;
        }
      });
    });
  }
  exports.retryTypedResponse = retryTypedResponse;
  function retryHttpClientResponse(name, method, maxAttempts = constants_1.DefaultRetryAttempts, delay3 = constants_1.DefaultRetryDelay) {
    return __awaiter2(this, undefined, undefined, function* () {
      return yield retry(name, method, (response) => response.message.statusCode, maxAttempts, delay3);
    });
  }
  exports.retryHttpClientResponse = retryHttpClientResponse;
});

// node_modules/@azure/abort-controller/dist/index.js
var require_dist8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var listenersMap = new WeakMap;
  var abortedMap = new WeakMap;

  class AbortSignal2 {
    constructor() {
      this.onabort = null;
      listenersMap.set(this, []);
      abortedMap.set(this, false);
    }
    get aborted() {
      if (!abortedMap.has(this)) {
        throw new TypeError("Expected `this` to be an instance of AbortSignal.");
      }
      return abortedMap.get(this);
    }
    static get none() {
      return new AbortSignal2;
    }
    addEventListener(_type, listener) {
      if (!listenersMap.has(this)) {
        throw new TypeError("Expected `this` to be an instance of AbortSignal.");
      }
      const listeners = listenersMap.get(this);
      listeners.push(listener);
    }
    removeEventListener(_type, listener) {
      if (!listenersMap.has(this)) {
        throw new TypeError("Expected `this` to be an instance of AbortSignal.");
      }
      const listeners = listenersMap.get(this);
      const index = listeners.indexOf(listener);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    }
    dispatchEvent(_event) {
      throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
    }
  }
  function abortSignal(signal) {
    if (signal.aborted) {
      return;
    }
    if (signal.onabort) {
      signal.onabort.call(signal);
    }
    const listeners = listenersMap.get(signal);
    if (listeners) {
      listeners.slice().forEach((listener) => {
        listener.call(signal, { type: "abort" });
      });
    }
    abortedMap.set(signal, true);
  }

  class AbortError3 extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  }

  class AbortController2 {
    constructor(parentSignals) {
      this._signal = new AbortSignal2;
      if (!parentSignals) {
        return;
      }
      if (!Array.isArray(parentSignals)) {
        parentSignals = arguments;
      }
      for (const parentSignal of parentSignals) {
        if (parentSignal.aborted) {
          this.abort();
        } else {
          parentSignal.addEventListener("abort", () => {
            this.abort();
          });
        }
      }
    }
    get signal() {
      return this._signal;
    }
    abort() {
      abortSignal(this._signal);
    }
    static timeout(ms) {
      const signal = new AbortSignal2;
      const timer = setTimeout(abortSignal, ms, signal);
      if (typeof timer.unref === "function") {
        timer.unref();
      }
      return signal;
    }
  }
  exports.AbortController = AbortController2;
  exports.AbortError = AbortError3;
  exports.AbortSignal = AbortSignal2;
});

// node_modules/@actions/cache/lib/internal/downloadUtils.js
var require_downloadUtils = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve5, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.downloadCacheStorageSDK = exports.downloadCacheHttpClientConcurrent = exports.downloadCacheHttpClient = exports.DownloadProgress = undefined;
  var core = __importStar2(require_core());
  var http_client_1 = require_lib();
  var storage_blob_1 = require_dist7();
  var buffer = __importStar2(__require("buffer"));
  var fs2 = __importStar2(__require("fs"));
  var stream = __importStar2(__require("stream"));
  var util2 = __importStar2(__require("util"));
  var utils = __importStar2(require_cacheUtils());
  var constants_1 = require_constants6();
  var requestUtils_1 = require_requestUtils();
  var abort_controller_1 = require_dist8();
  function pipeResponseToStream(response, output) {
    return __awaiter2(this, undefined, undefined, function* () {
      const pipeline = util2.promisify(stream.pipeline);
      yield pipeline(response.message, output);
    });
  }

  class DownloadProgress {
    constructor(contentLength) {
      this.contentLength = contentLength;
      this.segmentIndex = 0;
      this.segmentSize = 0;
      this.segmentOffset = 0;
      this.receivedBytes = 0;
      this.displayedComplete = false;
      this.startTime = Date.now();
    }
    nextSegment(segmentSize) {
      this.segmentOffset = this.segmentOffset + this.segmentSize;
      this.segmentIndex = this.segmentIndex + 1;
      this.segmentSize = segmentSize;
      this.receivedBytes = 0;
      core.debug(`Downloading segment at offset ${this.segmentOffset} with length ${this.segmentSize}...`);
    }
    setReceivedBytes(receivedBytes) {
      this.receivedBytes = receivedBytes;
    }
    getTransferredBytes() {
      return this.segmentOffset + this.receivedBytes;
    }
    isDone() {
      return this.getTransferredBytes() === this.contentLength;
    }
    display() {
      if (this.displayedComplete) {
        return;
      }
      const transferredBytes = this.segmentOffset + this.receivedBytes;
      const percentage = (100 * (transferredBytes / this.contentLength)).toFixed(1);
      const elapsedTime = Date.now() - this.startTime;
      const downloadSpeed = (transferredBytes / (1024 * 1024) / (elapsedTime / 1000)).toFixed(1);
      core.info(`Received ${transferredBytes} of ${this.contentLength} (${percentage}%), ${downloadSpeed} MBs/sec`);
      if (this.isDone()) {
        this.displayedComplete = true;
      }
    }
    onProgress() {
      return (progress) => {
        this.setReceivedBytes(progress.loadedBytes);
      };
    }
    startDisplayTimer(delayInMs = 1000) {
      const displayCallback = () => {
        this.display();
        if (!this.isDone()) {
          this.timeoutHandle = setTimeout(displayCallback, delayInMs);
        }
      };
      this.timeoutHandle = setTimeout(displayCallback, delayInMs);
    }
    stopDisplayTimer() {
      if (this.timeoutHandle) {
        clearTimeout(this.timeoutHandle);
        this.timeoutHandle = undefined;
      }
      this.display();
    }
  }
  exports.DownloadProgress = DownloadProgress;
  function downloadCacheHttpClient(archiveLocation, archivePath) {
    return __awaiter2(this, undefined, undefined, function* () {
      const writeStream = fs2.createWriteStream(archivePath);
      const httpClient = new http_client_1.HttpClient("actions/cache");
      const downloadResponse = yield (0, requestUtils_1.retryHttpClientResponse)("downloadCache", () => __awaiter2(this, undefined, undefined, function* () {
        return httpClient.get(archiveLocation);
      }));
      downloadResponse.message.socket.setTimeout(constants_1.SocketTimeout, () => {
        downloadResponse.message.destroy();
        core.debug(`Aborting download, socket timed out after ${constants_1.SocketTimeout} ms`);
      });
      yield pipeResponseToStream(downloadResponse, writeStream);
      const contentLengthHeader = downloadResponse.message.headers["content-length"];
      if (contentLengthHeader) {
        const expectedLength = parseInt(contentLengthHeader);
        const actualLength = utils.getArchiveFileSizeInBytes(archivePath);
        if (actualLength !== expectedLength) {
          throw new Error(`Incomplete download. Expected file size: ${expectedLength}, actual file size: ${actualLength}`);
        }
      } else {
        core.debug("Unable to validate download, no Content-Length header");
      }
    });
  }
  exports.downloadCacheHttpClient = downloadCacheHttpClient;
  function downloadCacheHttpClientConcurrent(archiveLocation, archivePath, options) {
    var _a3;
    return __awaiter2(this, undefined, undefined, function* () {
      const archiveDescriptor = yield fs2.promises.open(archivePath, "w");
      const httpClient = new http_client_1.HttpClient("actions/cache", undefined, {
        socketTimeout: options.timeoutInMs,
        keepAlive: true
      });
      try {
        const res = yield (0, requestUtils_1.retryHttpClientResponse)("downloadCacheMetadata", () => __awaiter2(this, undefined, undefined, function* () {
          return yield httpClient.request("HEAD", archiveLocation, null, {});
        }));
        const lengthHeader = res.message.headers["content-length"];
        if (lengthHeader === undefined || lengthHeader === null) {
          throw new Error("Content-Length not found on blob response");
        }
        const length = parseInt(lengthHeader);
        if (Number.isNaN(length)) {
          throw new Error(`Could not interpret Content-Length: ${length}`);
        }
        const downloads = [];
        const blockSize = 4 * 1024 * 1024;
        for (let offset = 0;offset < length; offset += blockSize) {
          const count = Math.min(blockSize, length - offset);
          downloads.push({
            offset,
            promiseGetter: () => __awaiter2(this, undefined, undefined, function* () {
              return yield downloadSegmentRetry(httpClient, archiveLocation, offset, count);
            })
          });
        }
        downloads.reverse();
        let actives = 0;
        let bytesDownloaded = 0;
        const progress = new DownloadProgress(length);
        progress.startDisplayTimer();
        const progressFn = progress.onProgress();
        const activeDownloads = [];
        let nextDownload;
        const waitAndWrite = () => __awaiter2(this, undefined, undefined, function* () {
          const segment = yield Promise.race(Object.values(activeDownloads));
          yield archiveDescriptor.write(segment.buffer, 0, segment.count, segment.offset);
          actives--;
          delete activeDownloads[segment.offset];
          bytesDownloaded += segment.count;
          progressFn({ loadedBytes: bytesDownloaded });
        });
        while (nextDownload = downloads.pop()) {
          activeDownloads[nextDownload.offset] = nextDownload.promiseGetter();
          actives++;
          if (actives >= ((_a3 = options.downloadConcurrency) !== null && _a3 !== undefined ? _a3 : 10)) {
            yield waitAndWrite();
          }
        }
        while (actives > 0) {
          yield waitAndWrite();
        }
      } finally {
        httpClient.dispose();
        yield archiveDescriptor.close();
      }
    });
  }
  exports.downloadCacheHttpClientConcurrent = downloadCacheHttpClientConcurrent;
  function downloadSegmentRetry(httpClient, archiveLocation, offset, count) {
    return __awaiter2(this, undefined, undefined, function* () {
      const retries = 5;
      let failures = 0;
      while (true) {
        try {
          const timeout = 30000;
          const result = yield promiseWithTimeout(timeout, downloadSegment(httpClient, archiveLocation, offset, count));
          if (typeof result === "string") {
            throw new Error("downloadSegmentRetry failed due to timeout");
          }
          return result;
        } catch (err) {
          if (failures >= retries) {
            throw err;
          }
          failures++;
        }
      }
    });
  }
  function downloadSegment(httpClient, archiveLocation, offset, count) {
    return __awaiter2(this, undefined, undefined, function* () {
      const partRes = yield (0, requestUtils_1.retryHttpClientResponse)("downloadCachePart", () => __awaiter2(this, undefined, undefined, function* () {
        return yield httpClient.get(archiveLocation, {
          Range: `bytes=${offset}-${offset + count - 1}`
        });
      }));
      if (!partRes.readBodyBuffer) {
        throw new Error("Expected HttpClientResponse to implement readBodyBuffer");
      }
      return {
        offset,
        count,
        buffer: yield partRes.readBodyBuffer()
      };
    });
  }
  function downloadCacheStorageSDK(archiveLocation, archivePath, options) {
    var _a3;
    return __awaiter2(this, undefined, undefined, function* () {
      const client = new storage_blob_1.BlockBlobClient(archiveLocation, undefined, {
        retryOptions: {
          tryTimeoutInMs: options.timeoutInMs
        }
      });
      const properties = yield client.getProperties();
      const contentLength = (_a3 = properties.contentLength) !== null && _a3 !== undefined ? _a3 : -1;
      if (contentLength < 0) {
        core.debug("Unable to determine content length, downloading file with http-client...");
        yield downloadCacheHttpClient(archiveLocation, archivePath);
      } else {
        const maxSegmentSize = Math.min(134217728, buffer.constants.MAX_LENGTH);
        const downloadProgress = new DownloadProgress(contentLength);
        const fd = fs2.openSync(archivePath, "w");
        try {
          downloadProgress.startDisplayTimer();
          const controller = new abort_controller_1.AbortController;
          const abortSignal = controller.signal;
          while (!downloadProgress.isDone()) {
            const segmentStart = downloadProgress.segmentOffset + downloadProgress.segmentSize;
            const segmentSize = Math.min(maxSegmentSize, contentLength - segmentStart);
            downloadProgress.nextSegment(segmentSize);
            const result = yield promiseWithTimeout(options.segmentTimeoutInMs || 3600000, client.downloadToBuffer(segmentStart, segmentSize, {
              abortSignal,
              concurrency: options.downloadConcurrency,
              onProgress: downloadProgress.onProgress()
            }));
            if (result === "timeout") {
              controller.abort();
              throw new Error("Aborting cache download as the download time exceeded the timeout.");
            } else if (Buffer.isBuffer(result)) {
              fs2.writeFileSync(fd, result);
            }
          }
        } finally {
          downloadProgress.stopDisplayTimer();
          fs2.closeSync(fd);
        }
      }
    });
  }
  exports.downloadCacheStorageSDK = downloadCacheStorageSDK;
  var promiseWithTimeout = (timeoutMs, promise) => __awaiter2(undefined, undefined, undefined, function* () {
    let timeoutHandle;
    const timeoutPromise = new Promise((resolve5) => {
      timeoutHandle = setTimeout(() => resolve5("timeout"), timeoutMs);
    });
    return Promise.race([promise, timeoutPromise]).then((result) => {
      clearTimeout(timeoutHandle);
      return result;
    });
  });
});

// node_modules/@actions/cache/lib/options.js
var require_options2 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getDownloadOptions = exports.getUploadOptions = undefined;
  var core = __importStar2(require_core());
  function getUploadOptions(copy) {
    const result = {
      useAzureSdk: false,
      uploadConcurrency: 4,
      uploadChunkSize: 32 * 1024 * 1024
    };
    if (copy) {
      if (typeof copy.useAzureSdk === "boolean") {
        result.useAzureSdk = copy.useAzureSdk;
      }
      if (typeof copy.uploadConcurrency === "number") {
        result.uploadConcurrency = copy.uploadConcurrency;
      }
      if (typeof copy.uploadChunkSize === "number") {
        result.uploadChunkSize = copy.uploadChunkSize;
      }
    }
    result.uploadConcurrency = !isNaN(Number(process.env["CACHE_UPLOAD_CONCURRENCY"])) ? Math.min(32, Number(process.env["CACHE_UPLOAD_CONCURRENCY"])) : result.uploadConcurrency;
    result.uploadChunkSize = !isNaN(Number(process.env["CACHE_UPLOAD_CHUNK_SIZE"])) ? Math.min(128 * 1024 * 1024, Number(process.env["CACHE_UPLOAD_CHUNK_SIZE"]) * 1024 * 1024) : result.uploadChunkSize;
    core.debug(`Use Azure SDK: ${result.useAzureSdk}`);
    core.debug(`Upload concurrency: ${result.uploadConcurrency}`);
    core.debug(`Upload chunk size: ${result.uploadChunkSize}`);
    return result;
  }
  exports.getUploadOptions = getUploadOptions;
  function getDownloadOptions(copy) {
    const result = {
      useAzureSdk: false,
      concurrentBlobDownloads: true,
      downloadConcurrency: 8,
      timeoutInMs: 30000,
      segmentTimeoutInMs: 600000,
      lookupOnly: false
    };
    if (copy) {
      if (typeof copy.useAzureSdk === "boolean") {
        result.useAzureSdk = copy.useAzureSdk;
      }
      if (typeof copy.concurrentBlobDownloads === "boolean") {
        result.concurrentBlobDownloads = copy.concurrentBlobDownloads;
      }
      if (typeof copy.downloadConcurrency === "number") {
        result.downloadConcurrency = copy.downloadConcurrency;
      }
      if (typeof copy.timeoutInMs === "number") {
        result.timeoutInMs = copy.timeoutInMs;
      }
      if (typeof copy.segmentTimeoutInMs === "number") {
        result.segmentTimeoutInMs = copy.segmentTimeoutInMs;
      }
      if (typeof copy.lookupOnly === "boolean") {
        result.lookupOnly = copy.lookupOnly;
      }
    }
    const segmentDownloadTimeoutMins = process.env["SEGMENT_DOWNLOAD_TIMEOUT_MINS"];
    if (segmentDownloadTimeoutMins && !isNaN(Number(segmentDownloadTimeoutMins)) && isFinite(Number(segmentDownloadTimeoutMins))) {
      result.segmentTimeoutInMs = Number(segmentDownloadTimeoutMins) * 60 * 1000;
    }
    core.debug(`Use Azure SDK: ${result.useAzureSdk}`);
    core.debug(`Download concurrency: ${result.downloadConcurrency}`);
    core.debug(`Request timeout (ms): ${result.timeoutInMs}`);
    core.debug(`Cache segment download timeout mins env var: ${process.env["SEGMENT_DOWNLOAD_TIMEOUT_MINS"]}`);
    core.debug(`Segment download timeout (ms): ${result.segmentTimeoutInMs}`);
    core.debug(`Lookup only: ${result.lookupOnly}`);
    return result;
  }
  exports.getDownloadOptions = getDownloadOptions;
});

// node_modules/@actions/cache/lib/internal/config.js
var require_config = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getCacheServiceURL = exports.getCacheServiceVersion = exports.isGhes = undefined;
  function isGhes() {
    const ghUrl = new URL(process.env["GITHUB_SERVER_URL"] || "https://github.com");
    const hostname = ghUrl.hostname.trimEnd().toUpperCase();
    const isGitHubHost = hostname === "GITHUB.COM";
    const isGheHost = hostname.endsWith(".GHE.COM");
    const isLocalHost = hostname.endsWith(".LOCALHOST");
    return !isGitHubHost && !isGheHost && !isLocalHost;
  }
  exports.isGhes = isGhes;
  function getCacheServiceVersion() {
    if (isGhes())
      return "v1";
    return process.env["ACTIONS_CACHE_SERVICE_V2"] ? "v2" : "v1";
  }
  exports.getCacheServiceVersion = getCacheServiceVersion;
  function getCacheServiceURL() {
    const version = getCacheServiceVersion();
    switch (version) {
      case "v1":
        return process.env["ACTIONS_CACHE_URL"] || process.env["ACTIONS_RESULTS_URL"] || "";
      case "v2":
        return process.env["ACTIONS_RESULTS_URL"] || "";
      default:
        throw new Error(`Unsupported cache service version: ${version}`);
    }
  }
  exports.getCacheServiceURL = getCacheServiceURL;
});

// node_modules/@actions/cache/package.json
var require_package2 = __commonJS((exports, module) => {
  module.exports = {
    name: "@actions/cache",
    version: "4.0.3",
    preview: true,
    description: "Actions cache lib",
    keywords: [
      "github",
      "actions",
      "cache"
    ],
    homepage: "https://github.com/actions/toolkit/tree/main/packages/cache",
    license: "MIT",
    main: "lib/cache.js",
    types: "lib/cache.d.ts",
    directories: {
      lib: "lib",
      test: "__tests__"
    },
    files: [
      "lib",
      "!.DS_Store"
    ],
    publishConfig: {
      access: "public"
    },
    repository: {
      type: "git",
      url: "git+https://github.com/actions/toolkit.git",
      directory: "packages/cache"
    },
    scripts: {
      "audit-moderate": "npm install && npm audit --json --audit-level=moderate > audit.json",
      test: 'echo "Error: run tests from root" && exit 1',
      tsc: "tsc"
    },
    bugs: {
      url: "https://github.com/actions/toolkit/issues"
    },
    dependencies: {
      "@actions/core": "^1.11.1",
      "@actions/exec": "^1.0.1",
      "@actions/glob": "^0.1.0",
      "@actions/http-client": "^2.1.1",
      "@actions/io": "^1.0.1",
      "@azure/abort-controller": "^1.1.0",
      "@azure/ms-rest-js": "^2.6.0",
      "@azure/storage-blob": "^12.13.0",
      "@protobuf-ts/plugin": "^2.9.4",
      semver: "^6.3.1"
    },
    devDependencies: {
      "@types/node": "^22.13.9",
      "@types/semver": "^6.0.0",
      typescript: "^5.2.2"
    }
  };
});

// node_modules/@actions/cache/lib/internal/shared/user-agent.js
var require_user_agent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getUserAgentString = undefined;
  var packageJson = require_package2();
  function getUserAgentString3() {
    return `@actions/cache-${packageJson.version}`;
  }
  exports.getUserAgentString = getUserAgentString3;
});

// node_modules/@actions/cache/lib/internal/cacheHttpClient.js
var require_cacheHttpClient = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve5, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.saveCache = exports.reserveCache = exports.downloadCache = exports.getCacheEntry = undefined;
  var core = __importStar2(require_core());
  var http_client_1 = require_lib();
  var auth_1 = require_auth();
  var fs2 = __importStar2(__require("fs"));
  var url_1 = __require("url");
  var utils = __importStar2(require_cacheUtils());
  var uploadUtils_1 = require_uploadUtils();
  var downloadUtils_1 = require_downloadUtils();
  var options_1 = require_options2();
  var requestUtils_1 = require_requestUtils();
  var config_1 = require_config();
  var user_agent_1 = require_user_agent();
  function getCacheApiUrl(resource) {
    const baseUrl = (0, config_1.getCacheServiceURL)();
    if (!baseUrl) {
      throw new Error("Cache Service Url not found, unable to restore cache.");
    }
    const url = `${baseUrl}_apis/artifactcache/${resource}`;
    core.debug(`Resource Url: ${url}`);
    return url;
  }
  function createAcceptHeader(type3, apiVersion) {
    return `${type3};api-version=${apiVersion}`;
  }
  function getRequestOptions() {
    const requestOptions = {
      headers: {
        Accept: createAcceptHeader("application/json", "6.0-preview.1")
      }
    };
    return requestOptions;
  }
  function createHttpClient() {
    const token = process.env["ACTIONS_RUNTIME_TOKEN"] || "";
    const bearerCredentialHandler = new auth_1.BearerCredentialHandler(token);
    return new http_client_1.HttpClient((0, user_agent_1.getUserAgentString)(), [bearerCredentialHandler], getRequestOptions());
  }
  function getCacheEntry(keys, paths, options) {
    return __awaiter2(this, undefined, undefined, function* () {
      const httpClient = createHttpClient();
      const version = utils.getCacheVersion(paths, options === null || options === undefined ? undefined : options.compressionMethod, options === null || options === undefined ? undefined : options.enableCrossOsArchive);
      const resource = `cache?keys=${encodeURIComponent(keys.join(","))}&version=${version}`;
      const response = yield (0, requestUtils_1.retryTypedResponse)("getCacheEntry", () => __awaiter2(this, undefined, undefined, function* () {
        return httpClient.getJson(getCacheApiUrl(resource));
      }));
      if (response.statusCode === 204) {
        if (core.isDebug()) {
          yield printCachesListForDiagnostics(keys[0], httpClient, version);
        }
        return null;
      }
      if (!(0, requestUtils_1.isSuccessStatusCode)(response.statusCode)) {
        throw new Error(`Cache service responded with ${response.statusCode}`);
      }
      const cacheResult = response.result;
      const cacheDownloadUrl = cacheResult === null || cacheResult === undefined ? undefined : cacheResult.archiveLocation;
      if (!cacheDownloadUrl) {
        throw new Error("Cache not found.");
      }
      core.setSecret(cacheDownloadUrl);
      core.debug(`Cache Result:`);
      core.debug(JSON.stringify(cacheResult));
      return cacheResult;
    });
  }
  exports.getCacheEntry = getCacheEntry;
  function printCachesListForDiagnostics(key, httpClient, version) {
    return __awaiter2(this, undefined, undefined, function* () {
      const resource = `caches?key=${encodeURIComponent(key)}`;
      const response = yield (0, requestUtils_1.retryTypedResponse)("listCache", () => __awaiter2(this, undefined, undefined, function* () {
        return httpClient.getJson(getCacheApiUrl(resource));
      }));
      if (response.statusCode === 200) {
        const cacheListResult = response.result;
        const totalCount = cacheListResult === null || cacheListResult === undefined ? undefined : cacheListResult.totalCount;
        if (totalCount && totalCount > 0) {
          core.debug(`No matching cache found for cache key '${key}', version '${version} and scope ${process.env["GITHUB_REF"]}. There exist one or more cache(s) with similar key but they have different version or scope. See more info on cache matching here: https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#matching-a-cache-key 
Other caches with similar key:`);
          for (const cacheEntry of (cacheListResult === null || cacheListResult === undefined ? undefined : cacheListResult.artifactCaches) || []) {
            core.debug(`Cache Key: ${cacheEntry === null || cacheEntry === undefined ? undefined : cacheEntry.cacheKey}, Cache Version: ${cacheEntry === null || cacheEntry === undefined ? undefined : cacheEntry.cacheVersion}, Cache Scope: ${cacheEntry === null || cacheEntry === undefined ? undefined : cacheEntry.scope}, Cache Created: ${cacheEntry === null || cacheEntry === undefined ? undefined : cacheEntry.creationTime}`);
          }
        }
      }
    });
  }
  function downloadCache(archiveLocation, archivePath, options) {
    return __awaiter2(this, undefined, undefined, function* () {
      const archiveUrl = new url_1.URL(archiveLocation);
      const downloadOptions = (0, options_1.getDownloadOptions)(options);
      if (archiveUrl.hostname.endsWith(".blob.core.windows.net")) {
        if (downloadOptions.useAzureSdk) {
          yield (0, downloadUtils_1.downloadCacheStorageSDK)(archiveLocation, archivePath, downloadOptions);
        } else if (downloadOptions.concurrentBlobDownloads) {
          yield (0, downloadUtils_1.downloadCacheHttpClientConcurrent)(archiveLocation, archivePath, downloadOptions);
        } else {
          yield (0, downloadUtils_1.downloadCacheHttpClient)(archiveLocation, archivePath);
        }
      } else {
        yield (0, downloadUtils_1.downloadCacheHttpClient)(archiveLocation, archivePath);
      }
    });
  }
  exports.downloadCache = downloadCache;
  function reserveCache(key, paths, options) {
    return __awaiter2(this, undefined, undefined, function* () {
      const httpClient = createHttpClient();
      const version = utils.getCacheVersion(paths, options === null || options === undefined ? undefined : options.compressionMethod, options === null || options === undefined ? undefined : options.enableCrossOsArchive);
      const reserveCacheRequest = {
        key,
        version,
        cacheSize: options === null || options === undefined ? undefined : options.cacheSize
      };
      const response = yield (0, requestUtils_1.retryTypedResponse)("reserveCache", () => __awaiter2(this, undefined, undefined, function* () {
        return httpClient.postJson(getCacheApiUrl("caches"), reserveCacheRequest);
      }));
      return response;
    });
  }
  exports.reserveCache = reserveCache;
  function getContentRange(start, end) {
    return `bytes ${start}-${end}/*`;
  }
  function uploadChunk(httpClient, resourceUrl, openStream, start, end) {
    return __awaiter2(this, undefined, undefined, function* () {
      core.debug(`Uploading chunk of size ${end - start + 1} bytes at offset ${start} with content range: ${getContentRange(start, end)}`);
      const additionalHeaders = {
        "Content-Type": "application/octet-stream",
        "Content-Range": getContentRange(start, end)
      };
      const uploadChunkResponse = yield (0, requestUtils_1.retryHttpClientResponse)(`uploadChunk (start: ${start}, end: ${end})`, () => __awaiter2(this, undefined, undefined, function* () {
        return httpClient.sendStream("PATCH", resourceUrl, openStream(), additionalHeaders);
      }));
      if (!(0, requestUtils_1.isSuccessStatusCode)(uploadChunkResponse.message.statusCode)) {
        throw new Error(`Cache service responded with ${uploadChunkResponse.message.statusCode} during upload chunk.`);
      }
    });
  }
  function uploadFile(httpClient, cacheId, archivePath, options) {
    return __awaiter2(this, undefined, undefined, function* () {
      const fileSize = utils.getArchiveFileSizeInBytes(archivePath);
      const resourceUrl = getCacheApiUrl(`caches/${cacheId.toString()}`);
      const fd = fs2.openSync(archivePath, "r");
      const uploadOptions = (0, options_1.getUploadOptions)(options);
      const concurrency = utils.assertDefined("uploadConcurrency", uploadOptions.uploadConcurrency);
      const maxChunkSize = utils.assertDefined("uploadChunkSize", uploadOptions.uploadChunkSize);
      const parallelUploads = [...new Array(concurrency).keys()];
      core.debug("Awaiting all uploads");
      let offset = 0;
      try {
        yield Promise.all(parallelUploads.map(() => __awaiter2(this, undefined, undefined, function* () {
          while (offset < fileSize) {
            const chunkSize = Math.min(fileSize - offset, maxChunkSize);
            const start = offset;
            const end = offset + chunkSize - 1;
            offset += maxChunkSize;
            yield uploadChunk(httpClient, resourceUrl, () => fs2.createReadStream(archivePath, {
              fd,
              start,
              end,
              autoClose: false
            }).on("error", (error) => {
              throw new Error(`Cache upload failed because file read failed with ${error.message}`);
            }), start, end);
          }
        })));
      } finally {
        fs2.closeSync(fd);
      }
      return;
    });
  }
  function commitCache(httpClient, cacheId, filesize) {
    return __awaiter2(this, undefined, undefined, function* () {
      const commitCacheRequest = { size: filesize };
      return yield (0, requestUtils_1.retryTypedResponse)("commitCache", () => __awaiter2(this, undefined, undefined, function* () {
        return httpClient.postJson(getCacheApiUrl(`caches/${cacheId.toString()}`), commitCacheRequest);
      }));
    });
  }
  function saveCache(cacheId, archivePath, signedUploadURL, options) {
    return __awaiter2(this, undefined, undefined, function* () {
      const uploadOptions = (0, options_1.getUploadOptions)(options);
      if (uploadOptions.useAzureSdk) {
        if (!signedUploadURL) {
          throw new Error("Azure Storage SDK can only be used when a signed URL is provided.");
        }
        yield (0, uploadUtils_1.uploadCacheArchiveSDK)(signedUploadURL, archivePath, options);
      } else {
        const httpClient = createHttpClient();
        core.debug("Upload cache");
        yield uploadFile(httpClient, cacheId, archivePath, options);
        core.debug("Commiting cache");
        const cacheSize = utils.getArchiveFileSizeInBytes(archivePath);
        core.info(`Cache Size: ~${Math.round(cacheSize / (1024 * 1024))} MB (${cacheSize} B)`);
        const commitCacheResponse = yield commitCache(httpClient, cacheId, cacheSize);
        if (!(0, requestUtils_1.isSuccessStatusCode)(commitCacheResponse.statusCode)) {
          throw new Error(`Cache service responded with ${commitCacheResponse.statusCode} during commit cache.`);
        }
        core.info("Cache saved successfully");
      }
    });
  }
  exports.saveCache = saveCache;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/json-typings.js
var require_json_typings = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isJsonObject = exports.typeofJsonValue = undefined;
  function typeofJsonValue(value) {
    let t2 = typeof value;
    if (t2 == "object") {
      if (Array.isArray(value))
        return "array";
      if (value === null)
        return "null";
    }
    return t2;
  }
  exports.typeofJsonValue = typeofJsonValue;
  function isJsonObject(value) {
    return value !== null && typeof value == "object" && !Array.isArray(value);
  }
  exports.isJsonObject = isJsonObject;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/base64.js
var require_base642 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.base64encode = exports.base64decode = undefined;
  var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  var decTable = [];
  for (let i2 = 0;i2 < encTable.length; i2++)
    decTable[encTable[i2].charCodeAt(0)] = i2;
  decTable[45] = encTable.indexOf("+");
  decTable[95] = encTable.indexOf("/");
  function base64decode(base64Str) {
    let es = base64Str.length * 3 / 4;
    if (base64Str[base64Str.length - 2] == "=")
      es -= 2;
    else if (base64Str[base64Str.length - 1] == "=")
      es -= 1;
    let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b2, p2 = 0;
    for (let i2 = 0;i2 < base64Str.length; i2++) {
      b2 = decTable[base64Str.charCodeAt(i2)];
      if (b2 === undefined) {
        switch (base64Str[i2]) {
          case "=":
            groupPos = 0;
          case `
`:
          case "\r":
          case "\t":
          case " ":
            continue;
          default:
            throw Error(`invalid base64 string.`);
        }
      }
      switch (groupPos) {
        case 0:
          p2 = b2;
          groupPos = 1;
          break;
        case 1:
          bytes[bytePos++] = p2 << 2 | (b2 & 48) >> 4;
          p2 = b2;
          groupPos = 2;
          break;
        case 2:
          bytes[bytePos++] = (p2 & 15) << 4 | (b2 & 60) >> 2;
          p2 = b2;
          groupPos = 3;
          break;
        case 3:
          bytes[bytePos++] = (p2 & 3) << 6 | b2;
          groupPos = 0;
          break;
      }
    }
    if (groupPos == 1)
      throw Error(`invalid base64 string.`);
    return bytes.subarray(0, bytePos);
  }
  exports.base64decode = base64decode;
  function base64encode2(bytes) {
    let base64 = "", groupPos = 0, b2, p2 = 0;
    for (let i2 = 0;i2 < bytes.length; i2++) {
      b2 = bytes[i2];
      switch (groupPos) {
        case 0:
          base64 += encTable[b2 >> 2];
          p2 = (b2 & 3) << 4;
          groupPos = 1;
          break;
        case 1:
          base64 += encTable[p2 | b2 >> 4];
          p2 = (b2 & 15) << 2;
          groupPos = 2;
          break;
        case 2:
          base64 += encTable[p2 | b2 >> 6];
          base64 += encTable[b2 & 63];
          groupPos = 0;
          break;
      }
    }
    if (groupPos) {
      base64 += encTable[p2];
      base64 += "=";
      if (groupPos == 1)
        base64 += "=";
    }
    return base64;
  }
  exports.base64encode = base64encode2;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/protobufjs-utf8.js
var require_protobufjs_utf8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.utf8read = undefined;
  var fromCharCodes = (chunk) => String.fromCharCode.apply(String, chunk);
  function utf8read(bytes) {
    if (bytes.length < 1)
      return "";
    let pos = 0, parts = [], chunk = [], i2 = 0, t2;
    let len = bytes.length;
    while (pos < len) {
      t2 = bytes[pos++];
      if (t2 < 128)
        chunk[i2++] = t2;
      else if (t2 > 191 && t2 < 224)
        chunk[i2++] = (t2 & 31) << 6 | bytes[pos++] & 63;
      else if (t2 > 239 && t2 < 365) {
        t2 = ((t2 & 7) << 18 | (bytes[pos++] & 63) << 12 | (bytes[pos++] & 63) << 6 | bytes[pos++] & 63) - 65536;
        chunk[i2++] = 55296 + (t2 >> 10);
        chunk[i2++] = 56320 + (t2 & 1023);
      } else
        chunk[i2++] = (t2 & 15) << 12 | (bytes[pos++] & 63) << 6 | bytes[pos++] & 63;
      if (i2 > 8191) {
        parts.push(fromCharCodes(chunk));
        i2 = 0;
      }
    }
    if (parts.length) {
      if (i2)
        parts.push(fromCharCodes(chunk.slice(0, i2)));
      return parts.join("");
    }
    return fromCharCodes(chunk.slice(0, i2));
  }
  exports.utf8read = utf8read;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/binary-format-contract.js
var require_binary_format_contract = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WireType = exports.mergeBinaryOptions = exports.UnknownFieldHandler = undefined;
  var UnknownFieldHandler;
  (function(UnknownFieldHandler2) {
    UnknownFieldHandler2.symbol = Symbol.for("protobuf-ts/unknown");
    UnknownFieldHandler2.onRead = (typeName, message, fieldNo, wireType, data) => {
      let container = is(message) ? message[UnknownFieldHandler2.symbol] : message[UnknownFieldHandler2.symbol] = [];
      container.push({ no: fieldNo, wireType, data });
    };
    UnknownFieldHandler2.onWrite = (typeName, message, writer) => {
      for (let { no, wireType, data } of UnknownFieldHandler2.list(message))
        writer.tag(no, wireType).raw(data);
    };
    UnknownFieldHandler2.list = (message, fieldNo) => {
      if (is(message)) {
        let all = message[UnknownFieldHandler2.symbol];
        return fieldNo ? all.filter((uf) => uf.no == fieldNo) : all;
      }
      return [];
    };
    UnknownFieldHandler2.last = (message, fieldNo) => UnknownFieldHandler2.list(message, fieldNo).slice(-1)[0];
    const is = (message) => message && Array.isArray(message[UnknownFieldHandler2.symbol]);
  })(UnknownFieldHandler = exports.UnknownFieldHandler || (exports.UnknownFieldHandler = {}));
  function mergeBinaryOptions(a2, b2) {
    return Object.assign(Object.assign({}, a2), b2);
  }
  exports.mergeBinaryOptions = mergeBinaryOptions;
  var WireType;
  (function(WireType2) {
    WireType2[WireType2["Varint"] = 0] = "Varint";
    WireType2[WireType2["Bit64"] = 1] = "Bit64";
    WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
    WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
    WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
    WireType2[WireType2["Bit32"] = 5] = "Bit32";
  })(WireType = exports.WireType || (exports.WireType = {}));
});

// node_modules/@protobuf-ts/runtime/build/commonjs/goog-varint.js
var require_goog_varint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.varint32read = exports.varint32write = exports.int64toString = exports.int64fromString = exports.varint64write = exports.varint64read = undefined;
  function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0;shift < 28; shift += 7) {
      let b2 = this.buf[this.pos++];
      lowBits |= (b2 & 127) << shift;
      if ((b2 & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    let middleByte = this.buf[this.pos++];
    lowBits |= (middleByte & 15) << 28;
    highBits = (middleByte & 112) >> 4;
    if ((middleByte & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
    for (let shift = 3;shift <= 31; shift += 7) {
      let b2 = this.buf[this.pos++];
      highBits |= (b2 & 127) << shift;
      if ((b2 & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    throw new Error("invalid varint");
  }
  exports.varint64read = varint64read;
  function varint64write(lo, hi, bytes) {
    for (let i2 = 0;i2 < 28; i2 = i2 + 7) {
      const shift = lo >>> i2;
      const hasNext = !(shift >>> 7 == 0 && hi == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
    const hasMoreBits = !(hi >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
    if (!hasMoreBits) {
      return;
    }
    for (let i2 = 3;i2 < 31; i2 = i2 + 7) {
      const shift = hi >>> i2;
      const hasNext = !(shift >>> 7 == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    bytes.push(hi >>> 31 & 1);
  }
  exports.varint64write = varint64write;
  var TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
  function int64fromString(dec) {
    let minus = dec[0] == "-";
    if (minus)
      dec = dec.slice(1);
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
      const digit1e6 = Number(dec.slice(begin, end));
      highBits *= base;
      lowBits = lowBits * base + digit1e6;
      if (lowBits >= TWO_PWR_32_DBL) {
        highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
        lowBits = lowBits % TWO_PWR_32_DBL;
      }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return [minus, lowBits, highBits];
  }
  exports.int64fromString = int64fromString;
  function int64toString(bitsLow, bitsHigh) {
    if (bitsHigh >>> 0 <= 2097151) {
      return "" + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));
    }
    let low = bitsLow & 16777215;
    let mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
    let high = bitsHigh >> 16 & 65535;
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    let base = 1e7;
    if (digitA >= base) {
      digitB += Math.floor(digitA / base);
      digitA %= base;
    }
    if (digitB >= base) {
      digitC += Math.floor(digitB / base);
      digitB %= base;
    }
    function decimalFrom1e7(digit1e7, needLeadingZeros) {
      let partial = digit1e7 ? String(digit1e7) : "";
      if (needLeadingZeros) {
        return "0000000".slice(partial.length) + partial;
      }
      return partial;
    }
    return decimalFrom1e7(digitC, 0) + decimalFrom1e7(digitB, digitC) + decimalFrom1e7(digitA, 1);
  }
  exports.int64toString = int64toString;
  function varint32write(value, bytes) {
    if (value >= 0) {
      while (value > 127) {
        bytes.push(value & 127 | 128);
        value = value >>> 7;
      }
      bytes.push(value);
    } else {
      for (let i2 = 0;i2 < 9; i2++) {
        bytes.push(value & 127 | 128);
        value = value >> 7;
      }
      bytes.push(1);
    }
  }
  exports.varint32write = varint32write;
  function varint32read() {
    let b2 = this.buf[this.pos++];
    let result = b2 & 127;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b2 = this.buf[this.pos++];
    result |= (b2 & 127) << 7;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b2 = this.buf[this.pos++];
    result |= (b2 & 127) << 14;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b2 = this.buf[this.pos++];
    result |= (b2 & 127) << 21;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b2 = this.buf[this.pos++];
    result |= (b2 & 15) << 28;
    for (let readBytes = 5;(b2 & 128) !== 0 && readBytes < 10; readBytes++)
      b2 = this.buf[this.pos++];
    if ((b2 & 128) != 0)
      throw new Error("invalid varint");
    this.assertBounds();
    return result >>> 0;
  }
  exports.varint32read = varint32read;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/pb-long.js
var require_pb_long = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PbLong = exports.PbULong = exports.detectBi = undefined;
  var goog_varint_1 = require_goog_varint();
  var BI;
  function detectBi() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = globalThis.BigInt !== undefined && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function";
    BI = ok ? {
      MIN: BigInt("-9223372036854775808"),
      MAX: BigInt("9223372036854775807"),
      UMIN: BigInt("0"),
      UMAX: BigInt("18446744073709551615"),
      C: BigInt,
      V: dv
    } : undefined;
  }
  exports.detectBi = detectBi;
  detectBi();
  function assertBi(bi) {
    if (!bi)
      throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
  }
  var RE_DECIMAL_STR = /^-?[0-9]+$/;
  var TWO_PWR_32_DBL = 4294967296;
  var HALF_2_PWR_32 = 2147483648;

  class SharedPbLong {
    constructor(lo, hi) {
      this.lo = lo | 0;
      this.hi = hi | 0;
    }
    isZero() {
      return this.lo == 0 && this.hi == 0;
    }
    toNumber() {
      let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
      if (!Number.isSafeInteger(result))
        throw new Error("cannot convert to safe number");
      return result;
    }
  }

  class PbULong extends SharedPbLong {
    static from(value) {
      if (BI)
        switch (typeof value) {
          case "string":
            if (value == "0")
              return this.ZERO;
            if (value == "")
              throw new Error("string is no integer");
            value = BI.C(value);
          case "number":
            if (value === 0)
              return this.ZERO;
            value = BI.C(value);
          case "bigint":
            if (!value)
              return this.ZERO;
            if (value < BI.UMIN)
              throw new Error("signed value for ulong");
            if (value > BI.UMAX)
              throw new Error("ulong too large");
            BI.V.setBigUint64(0, value, true);
            return new PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
        }
      else
        switch (typeof value) {
          case "string":
            if (value == "0")
              return this.ZERO;
            value = value.trim();
            if (!RE_DECIMAL_STR.test(value))
              throw new Error("string is no integer");
            let [minus, lo, hi] = goog_varint_1.int64fromString(value);
            if (minus)
              throw new Error("signed value for ulong");
            return new PbULong(lo, hi);
          case "number":
            if (value == 0)
              return this.ZERO;
            if (!Number.isSafeInteger(value))
              throw new Error("number is no integer");
            if (value < 0)
              throw new Error("signed value for ulong");
            return new PbULong(value, value / TWO_PWR_32_DBL);
        }
      throw new Error("unknown value " + typeof value);
    }
    toString() {
      return BI ? this.toBigInt().toString() : goog_varint_1.int64toString(this.lo, this.hi);
    }
    toBigInt() {
      assertBi(BI);
      BI.V.setInt32(0, this.lo, true);
      BI.V.setInt32(4, this.hi, true);
      return BI.V.getBigUint64(0, true);
    }
  }
  exports.PbULong = PbULong;
  PbULong.ZERO = new PbULong(0, 0);

  class PbLong extends SharedPbLong {
    static from(value) {
      if (BI)
        switch (typeof value) {
          case "string":
            if (value == "0")
              return this.ZERO;
            if (value == "")
              throw new Error("string is no integer");
            value = BI.C(value);
          case "number":
            if (value === 0)
              return this.ZERO;
            value = BI.C(value);
          case "bigint":
            if (!value)
              return this.ZERO;
            if (value < BI.MIN)
              throw new Error("signed long too small");
            if (value > BI.MAX)
              throw new Error("signed long too large");
            BI.V.setBigInt64(0, value, true);
            return new PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
        }
      else
        switch (typeof value) {
          case "string":
            if (value == "0")
              return this.ZERO;
            value = value.trim();
            if (!RE_DECIMAL_STR.test(value))
              throw new Error("string is no integer");
            let [minus, lo, hi] = goog_varint_1.int64fromString(value);
            if (minus) {
              if (hi > HALF_2_PWR_32 || hi == HALF_2_PWR_32 && lo != 0)
                throw new Error("signed long too small");
            } else if (hi >= HALF_2_PWR_32)
              throw new Error("signed long too large");
            let pbl = new PbLong(lo, hi);
            return minus ? pbl.negate() : pbl;
          case "number":
            if (value == 0)
              return this.ZERO;
            if (!Number.isSafeInteger(value))
              throw new Error("number is no integer");
            return value > 0 ? new PbLong(value, value / TWO_PWR_32_DBL) : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();
        }
      throw new Error("unknown value " + typeof value);
    }
    isNegative() {
      return (this.hi & HALF_2_PWR_32) !== 0;
    }
    negate() {
      let hi = ~this.hi, lo = this.lo;
      if (lo)
        lo = ~lo + 1;
      else
        hi += 1;
      return new PbLong(lo, hi);
    }
    toString() {
      if (BI)
        return this.toBigInt().toString();
      if (this.isNegative()) {
        let n2 = this.negate();
        return "-" + goog_varint_1.int64toString(n2.lo, n2.hi);
      }
      return goog_varint_1.int64toString(this.lo, this.hi);
    }
    toBigInt() {
      assertBi(BI);
      BI.V.setInt32(0, this.lo, true);
      BI.V.setInt32(4, this.hi, true);
      return BI.V.getBigInt64(0, true);
    }
  }
  exports.PbLong = PbLong;
  PbLong.ZERO = new PbLong(0, 0);
});

// node_modules/@protobuf-ts/runtime/build/commonjs/binary-reader.js
var require_binary_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BinaryReader = exports.binaryReadOptions = undefined;
  var binary_format_contract_1 = require_binary_format_contract();
  var pb_long_1 = require_pb_long();
  var goog_varint_1 = require_goog_varint();
  var defaultsRead = {
    readUnknownField: true,
    readerFactory: (bytes) => new BinaryReader(bytes)
  };
  function binaryReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
  }
  exports.binaryReadOptions = binaryReadOptions;

  class BinaryReader {
    constructor(buf, textDecoder) {
      this.varint64 = goog_varint_1.varint64read;
      this.uint32 = goog_varint_1.varint32read;
      this.buf = buf;
      this.len = buf.length;
      this.pos = 0;
      this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      this.textDecoder = textDecoder !== null && textDecoder !== undefined ? textDecoder : new TextDecoder("utf-8", {
        fatal: true,
        ignoreBOM: true
      });
    }
    tag() {
      let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
      if (fieldNo <= 0 || wireType < 0 || wireType > 5)
        throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
      return [fieldNo, wireType];
    }
    skip(wireType) {
      let start = this.pos;
      switch (wireType) {
        case binary_format_contract_1.WireType.Varint:
          while (this.buf[this.pos++] & 128) {
          }
          break;
        case binary_format_contract_1.WireType.Bit64:
          this.pos += 4;
        case binary_format_contract_1.WireType.Bit32:
          this.pos += 4;
          break;
        case binary_format_contract_1.WireType.LengthDelimited:
          let len = this.uint32();
          this.pos += len;
          break;
        case binary_format_contract_1.WireType.StartGroup:
          let t2;
          while ((t2 = this.tag()[1]) !== binary_format_contract_1.WireType.EndGroup) {
            this.skip(t2);
          }
          break;
        default:
          throw new Error("cant skip wire type " + wireType);
      }
      this.assertBounds();
      return this.buf.subarray(start, this.pos);
    }
    assertBounds() {
      if (this.pos > this.len)
        throw new RangeError("premature EOF");
    }
    int32() {
      return this.uint32() | 0;
    }
    sint32() {
      let zze = this.uint32();
      return zze >>> 1 ^ -(zze & 1);
    }
    int64() {
      return new pb_long_1.PbLong(...this.varint64());
    }
    uint64() {
      return new pb_long_1.PbULong(...this.varint64());
    }
    sint64() {
      let [lo, hi] = this.varint64();
      let s2 = -(lo & 1);
      lo = (lo >>> 1 | (hi & 1) << 31) ^ s2;
      hi = hi >>> 1 ^ s2;
      return new pb_long_1.PbLong(lo, hi);
    }
    bool() {
      let [lo, hi] = this.varint64();
      return lo !== 0 || hi !== 0;
    }
    fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, true);
    }
    sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, true);
    }
    fixed64() {
      return new pb_long_1.PbULong(this.sfixed32(), this.sfixed32());
    }
    sfixed64() {
      return new pb_long_1.PbLong(this.sfixed32(), this.sfixed32());
    }
    float() {
      return this.view.getFloat32((this.pos += 4) - 4, true);
    }
    double() {
      return this.view.getFloat64((this.pos += 8) - 8, true);
    }
    bytes() {
      let len = this.uint32();
      let start = this.pos;
      this.pos += len;
      this.assertBounds();
      return this.buf.subarray(start, start + len);
    }
    string() {
      return this.textDecoder.decode(this.bytes());
    }
  }
  exports.BinaryReader = BinaryReader;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/assert.js
var require_assert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assertFloat32 = exports.assertUInt32 = exports.assertInt32 = exports.assertNever = exports.assert = undefined;
  function assert(condition, msg) {
    if (!condition) {
      throw new Error(msg);
    }
  }
  exports.assert = assert;
  function assertNever(value, msg) {
    throw new Error(msg !== null && msg !== undefined ? msg : "Unexpected object: " + value);
  }
  exports.assertNever = assertNever;
  var FLOAT32_MAX = 340282346638528860000000000000000000000;
  var FLOAT32_MIN = -340282346638528860000000000000000000000;
  var UINT32_MAX = 4294967295;
  var INT32_MAX = 2147483647;
  var INT32_MIN = -2147483648;
  function assertInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid int 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
      throw new Error("invalid int 32: " + arg);
  }
  exports.assertInt32 = assertInt32;
  function assertUInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid uint 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
      throw new Error("invalid uint 32: " + arg);
  }
  exports.assertUInt32 = assertUInt32;
  function assertFloat32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid float 32: " + typeof arg);
    if (!Number.isFinite(arg))
      return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
      throw new Error("invalid float 32: " + arg);
  }
  exports.assertFloat32 = assertFloat32;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/binary-writer.js
var require_binary_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BinaryWriter = exports.binaryWriteOptions = undefined;
  var pb_long_1 = require_pb_long();
  var goog_varint_1 = require_goog_varint();
  var assert_1 = require_assert();
  var defaultsWrite = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter
  };
  function binaryWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
  }
  exports.binaryWriteOptions = binaryWriteOptions;

  class BinaryWriter {
    constructor(textEncoder) {
      this.stack = [];
      this.textEncoder = textEncoder !== null && textEncoder !== undefined ? textEncoder : new TextEncoder;
      this.chunks = [];
      this.buf = [];
    }
    finish() {
      this.chunks.push(new Uint8Array(this.buf));
      let len = 0;
      for (let i2 = 0;i2 < this.chunks.length; i2++)
        len += this.chunks[i2].length;
      let bytes = new Uint8Array(len);
      let offset = 0;
      for (let i2 = 0;i2 < this.chunks.length; i2++) {
        bytes.set(this.chunks[i2], offset);
        offset += this.chunks[i2].length;
      }
      this.chunks = [];
      return bytes;
    }
    fork() {
      this.stack.push({ chunks: this.chunks, buf: this.buf });
      this.chunks = [];
      this.buf = [];
      return this;
    }
    join() {
      let chunk = this.finish();
      let prev = this.stack.pop();
      if (!prev)
        throw new Error("invalid state, fork stack empty");
      this.chunks = prev.chunks;
      this.buf = prev.buf;
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    tag(fieldNo, type3) {
      return this.uint32((fieldNo << 3 | type3) >>> 0);
    }
    raw(chunk) {
      if (this.buf.length) {
        this.chunks.push(new Uint8Array(this.buf));
        this.buf = [];
      }
      this.chunks.push(chunk);
      return this;
    }
    uint32(value) {
      assert_1.assertUInt32(value);
      while (value > 127) {
        this.buf.push(value & 127 | 128);
        value = value >>> 7;
      }
      this.buf.push(value);
      return this;
    }
    int32(value) {
      assert_1.assertInt32(value);
      goog_varint_1.varint32write(value, this.buf);
      return this;
    }
    bool(value) {
      this.buf.push(value ? 1 : 0);
      return this;
    }
    bytes(value) {
      this.uint32(value.byteLength);
      return this.raw(value);
    }
    string(value) {
      let chunk = this.textEncoder.encode(value);
      this.uint32(chunk.byteLength);
      return this.raw(chunk);
    }
    float(value) {
      assert_1.assertFloat32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setFloat32(0, value, true);
      return this.raw(chunk);
    }
    double(value) {
      let chunk = new Uint8Array(8);
      new DataView(chunk.buffer).setFloat64(0, value, true);
      return this.raw(chunk);
    }
    fixed32(value) {
      assert_1.assertUInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setUint32(0, value, true);
      return this.raw(chunk);
    }
    sfixed32(value) {
      assert_1.assertInt32(value);
      let chunk = new Uint8Array(4);
      new DataView(chunk.buffer).setInt32(0, value, true);
      return this.raw(chunk);
    }
    sint32(value) {
      assert_1.assertInt32(value);
      value = (value << 1 ^ value >> 31) >>> 0;
      goog_varint_1.varint32write(value, this.buf);
      return this;
    }
    sfixed64(value) {
      let chunk = new Uint8Array(8);
      let view = new DataView(chunk.buffer);
      let long = pb_long_1.PbLong.from(value);
      view.setInt32(0, long.lo, true);
      view.setInt32(4, long.hi, true);
      return this.raw(chunk);
    }
    fixed64(value) {
      let chunk = new Uint8Array(8);
      let view = new DataView(chunk.buffer);
      let long = pb_long_1.PbULong.from(value);
      view.setInt32(0, long.lo, true);
      view.setInt32(4, long.hi, true);
      return this.raw(chunk);
    }
    int64(value) {
      let long = pb_long_1.PbLong.from(value);
      goog_varint_1.varint64write(long.lo, long.hi, this.buf);
      return this;
    }
    sint64(value) {
      let long = pb_long_1.PbLong.from(value), sign = long.hi >> 31, lo = long.lo << 1 ^ sign, hi = (long.hi << 1 | long.lo >>> 31) ^ sign;
      goog_varint_1.varint64write(lo, hi, this.buf);
      return this;
    }
    uint64(value) {
      let long = pb_long_1.PbULong.from(value);
      goog_varint_1.varint64write(long.lo, long.hi, this.buf);
      return this;
    }
  }
  exports.BinaryWriter = BinaryWriter;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/json-format-contract.js
var require_json_format_contract = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeJsonOptions = exports.jsonWriteOptions = exports.jsonReadOptions = undefined;
  var defaultsWrite = {
    emitDefaultValues: false,
    enumAsInteger: false,
    useProtoFieldName: false,
    prettySpaces: 0
  };
  var defaultsRead = {
    ignoreUnknownFields: false
  };
  function jsonReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
  }
  exports.jsonReadOptions = jsonReadOptions;
  function jsonWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
  }
  exports.jsonWriteOptions = jsonWriteOptions;
  function mergeJsonOptions(a2, b2) {
    var _a3, _b2;
    let c2 = Object.assign(Object.assign({}, a2), b2);
    c2.typeRegistry = [...(_a3 = a2 === null || a2 === undefined ? undefined : a2.typeRegistry) !== null && _a3 !== undefined ? _a3 : [], ...(_b2 = b2 === null || b2 === undefined ? undefined : b2.typeRegistry) !== null && _b2 !== undefined ? _b2 : []];
    return c2;
  }
  exports.mergeJsonOptions = mergeJsonOptions;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/message-type-contract.js
var require_message_type_contract = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MESSAGE_TYPE = undefined;
  exports.MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");
});

// node_modules/@protobuf-ts/runtime/build/commonjs/lower-camel-case.js
var require_lower_camel_case = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lowerCamelCase = undefined;
  function lowerCamelCase(snakeCase) {
    let capNext = false;
    const sb = [];
    for (let i2 = 0;i2 < snakeCase.length; i2++) {
      let next = snakeCase.charAt(i2);
      if (next == "_") {
        capNext = true;
      } else if (/\d/.test(next)) {
        sb.push(next);
        capNext = true;
      } else if (capNext) {
        sb.push(next.toUpperCase());
        capNext = false;
      } else if (i2 == 0) {
        sb.push(next.toLowerCase());
      } else {
        sb.push(next);
      }
    }
    return sb.join("");
  }
  exports.lowerCamelCase = lowerCamelCase;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-info.js
var require_reflection_info = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readMessageOption = exports.readFieldOption = exports.readFieldOptions = exports.normalizeFieldInfo = exports.RepeatType = exports.LongType = exports.ScalarType = undefined;
  var lower_camel_case_1 = require_lower_camel_case();
  var ScalarType;
  (function(ScalarType2) {
    ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
    ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
    ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
    ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
    ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
    ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
    ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
    ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
    ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
    ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
    ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
    ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
    ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
    ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
    ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
  })(ScalarType = exports.ScalarType || (exports.ScalarType = {}));
  var LongType;
  (function(LongType2) {
    LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
    LongType2[LongType2["STRING"] = 1] = "STRING";
    LongType2[LongType2["NUMBER"] = 2] = "NUMBER";
  })(LongType = exports.LongType || (exports.LongType = {}));
  var RepeatType;
  (function(RepeatType2) {
    RepeatType2[RepeatType2["NO"] = 0] = "NO";
    RepeatType2[RepeatType2["PACKED"] = 1] = "PACKED";
    RepeatType2[RepeatType2["UNPACKED"] = 2] = "UNPACKED";
  })(RepeatType = exports.RepeatType || (exports.RepeatType = {}));
  function normalizeFieldInfo(field) {
    var _a3, _b2, _c2, _d2;
    field.localName = (_a3 = field.localName) !== null && _a3 !== undefined ? _a3 : lower_camel_case_1.lowerCamelCase(field.name);
    field.jsonName = (_b2 = field.jsonName) !== null && _b2 !== undefined ? _b2 : lower_camel_case_1.lowerCamelCase(field.name);
    field.repeat = (_c2 = field.repeat) !== null && _c2 !== undefined ? _c2 : RepeatType.NO;
    field.opt = (_d2 = field.opt) !== null && _d2 !== undefined ? _d2 : field.repeat ? false : field.oneof ? false : field.kind == "message";
    return field;
  }
  exports.normalizeFieldInfo = normalizeFieldInfo;
  function readFieldOptions(messageType, fieldName, extensionName, extensionType) {
    var _a3;
    const options = (_a3 = messageType.fields.find((m2, i2) => m2.localName == fieldName || i2 == fieldName)) === null || _a3 === undefined ? undefined : _a3.options;
    return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : undefined;
  }
  exports.readFieldOptions = readFieldOptions;
  function readFieldOption(messageType, fieldName, extensionName, extensionType) {
    var _a3;
    const options = (_a3 = messageType.fields.find((m2, i2) => m2.localName == fieldName || i2 == fieldName)) === null || _a3 === undefined ? undefined : _a3.options;
    if (!options) {
      return;
    }
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
      return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
  }
  exports.readFieldOption = readFieldOption;
  function readMessageOption(messageType, extensionName, extensionType) {
    const options = messageType.options;
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
      return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
  }
  exports.readMessageOption = readMessageOption;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/oneof.js
var require_oneof = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSelectedOneofValue = exports.clearOneofValue = exports.setUnknownOneofValue = exports.setOneofValue = exports.getOneofValue = exports.isOneofGroup = undefined;
  function isOneofGroup(any) {
    if (typeof any != "object" || any === null || !any.hasOwnProperty("oneofKind")) {
      return false;
    }
    switch (typeof any.oneofKind) {
      case "string":
        if (any[any.oneofKind] === undefined)
          return false;
        return Object.keys(any).length == 2;
      case "undefined":
        return Object.keys(any).length == 1;
      default:
        return false;
    }
  }
  exports.isOneofGroup = isOneofGroup;
  function getOneofValue(oneof, kind) {
    return oneof[kind];
  }
  exports.getOneofValue = getOneofValue;
  function setOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== undefined) {
      delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = kind;
    if (value !== undefined) {
      oneof[kind] = value;
    }
  }
  exports.setOneofValue = setOneofValue;
  function setUnknownOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== undefined) {
      delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = kind;
    if (value !== undefined && kind !== undefined) {
      oneof[kind] = value;
    }
  }
  exports.setUnknownOneofValue = setUnknownOneofValue;
  function clearOneofValue(oneof) {
    if (oneof.oneofKind !== undefined) {
      delete oneof[oneof.oneofKind];
    }
    oneof.oneofKind = undefined;
  }
  exports.clearOneofValue = clearOneofValue;
  function getSelectedOneofValue(oneof) {
    if (oneof.oneofKind === undefined) {
      return;
    }
    return oneof[oneof.oneofKind];
  }
  exports.getSelectedOneofValue = getSelectedOneofValue;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-type-check.js
var require_reflection_type_check = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReflectionTypeCheck = undefined;
  var reflection_info_1 = require_reflection_info();
  var oneof_1 = require_oneof();

  class ReflectionTypeCheck {
    constructor(info) {
      var _a3;
      this.fields = (_a3 = info.fields) !== null && _a3 !== undefined ? _a3 : [];
    }
    prepare() {
      if (this.data)
        return;
      const req = [], known = [], oneofs = [];
      for (let field of this.fields) {
        if (field.oneof) {
          if (!oneofs.includes(field.oneof)) {
            oneofs.push(field.oneof);
            req.push(field.oneof);
            known.push(field.oneof);
          }
        } else {
          known.push(field.localName);
          switch (field.kind) {
            case "scalar":
            case "enum":
              if (!field.opt || field.repeat)
                req.push(field.localName);
              break;
            case "message":
              if (field.repeat)
                req.push(field.localName);
              break;
            case "map":
              req.push(field.localName);
              break;
          }
        }
      }
      this.data = { req, known, oneofs: Object.values(oneofs) };
    }
    is(message, depth, allowExcessProperties = false) {
      if (depth < 0)
        return true;
      if (message === null || message === undefined || typeof message != "object")
        return false;
      this.prepare();
      let keys = Object.keys(message), data = this.data;
      if (keys.length < data.req.length || data.req.some((n2) => !keys.includes(n2)))
        return false;
      if (!allowExcessProperties) {
        if (keys.some((k2) => !data.known.includes(k2)))
          return false;
      }
      if (depth < 1) {
        return true;
      }
      for (const name of data.oneofs) {
        const group = message[name];
        if (!oneof_1.isOneofGroup(group))
          return false;
        if (group.oneofKind === undefined)
          continue;
        const field = this.fields.find((f2) => f2.localName === group.oneofKind);
        if (!field)
          return false;
        if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
          return false;
      }
      for (const field of this.fields) {
        if (field.oneof !== undefined)
          continue;
        if (!this.field(message[field.localName], field, allowExcessProperties, depth))
          return false;
      }
      return true;
    }
    field(arg, field, allowExcessProperties, depth) {
      let repeated = field.repeat;
      switch (field.kind) {
        case "scalar":
          if (arg === undefined)
            return field.opt;
          if (repeated)
            return this.scalars(arg, field.T, depth, field.L);
          return this.scalar(arg, field.T, field.L);
        case "enum":
          if (arg === undefined)
            return field.opt;
          if (repeated)
            return this.scalars(arg, reflection_info_1.ScalarType.INT32, depth);
          return this.scalar(arg, reflection_info_1.ScalarType.INT32);
        case "message":
          if (arg === undefined)
            return true;
          if (repeated)
            return this.messages(arg, field.T(), allowExcessProperties, depth);
          return this.message(arg, field.T(), allowExcessProperties, depth);
        case "map":
          if (typeof arg != "object" || arg === null)
            return false;
          if (depth < 2)
            return true;
          if (!this.mapKeys(arg, field.K, depth))
            return false;
          switch (field.V.kind) {
            case "scalar":
              return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
            case "enum":
              return this.scalars(Object.values(arg), reflection_info_1.ScalarType.INT32, depth);
            case "message":
              return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
          }
          break;
      }
      return true;
    }
    message(arg, type3, allowExcessProperties, depth) {
      if (allowExcessProperties) {
        return type3.isAssignable(arg, depth);
      }
      return type3.is(arg, depth);
    }
    messages(arg, type3, allowExcessProperties, depth) {
      if (!Array.isArray(arg))
        return false;
      if (depth < 2)
        return true;
      if (allowExcessProperties) {
        for (let i2 = 0;i2 < arg.length && i2 < depth; i2++)
          if (!type3.isAssignable(arg[i2], depth - 1))
            return false;
      } else {
        for (let i2 = 0;i2 < arg.length && i2 < depth; i2++)
          if (!type3.is(arg[i2], depth - 1))
            return false;
      }
      return true;
    }
    scalar(arg, type3, longType) {
      let argType = typeof arg;
      switch (type3) {
        case reflection_info_1.ScalarType.UINT64:
        case reflection_info_1.ScalarType.FIXED64:
        case reflection_info_1.ScalarType.INT64:
        case reflection_info_1.ScalarType.SFIXED64:
        case reflection_info_1.ScalarType.SINT64:
          switch (longType) {
            case reflection_info_1.LongType.BIGINT:
              return argType == "bigint";
            case reflection_info_1.LongType.NUMBER:
              return argType == "number" && !isNaN(arg);
            default:
              return argType == "string";
          }
        case reflection_info_1.ScalarType.BOOL:
          return argType == "boolean";
        case reflection_info_1.ScalarType.STRING:
          return argType == "string";
        case reflection_info_1.ScalarType.BYTES:
          return arg instanceof Uint8Array;
        case reflection_info_1.ScalarType.DOUBLE:
        case reflection_info_1.ScalarType.FLOAT:
          return argType == "number" && !isNaN(arg);
        default:
          return argType == "number" && Number.isInteger(arg);
      }
    }
    scalars(arg, type3, depth, longType) {
      if (!Array.isArray(arg))
        return false;
      if (depth < 2)
        return true;
      if (Array.isArray(arg)) {
        for (let i2 = 0;i2 < arg.length && i2 < depth; i2++)
          if (!this.scalar(arg[i2], type3, longType))
            return false;
      }
      return true;
    }
    mapKeys(map, type3, depth) {
      let keys = Object.keys(map);
      switch (type3) {
        case reflection_info_1.ScalarType.INT32:
        case reflection_info_1.ScalarType.FIXED32:
        case reflection_info_1.ScalarType.SFIXED32:
        case reflection_info_1.ScalarType.SINT32:
        case reflection_info_1.ScalarType.UINT32:
          return this.scalars(keys.slice(0, depth).map((k2) => parseInt(k2)), type3, depth);
        case reflection_info_1.ScalarType.BOOL:
          return this.scalars(keys.slice(0, depth).map((k2) => k2 == "true" ? true : k2 == "false" ? false : k2), type3, depth);
        default:
          return this.scalars(keys, type3, depth, reflection_info_1.LongType.STRING);
      }
    }
  }
  exports.ReflectionTypeCheck = ReflectionTypeCheck;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-long-convert.js
var require_reflection_long_convert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reflectionLongConvert = undefined;
  var reflection_info_1 = require_reflection_info();
  function reflectionLongConvert(long, type3) {
    switch (type3) {
      case reflection_info_1.LongType.BIGINT:
        return long.toBigInt();
      case reflection_info_1.LongType.NUMBER:
        return long.toNumber();
      default:
        return long.toString();
    }
  }
  exports.reflectionLongConvert = reflectionLongConvert;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-json-reader.js
var require_reflection_json_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReflectionJsonReader = undefined;
  var json_typings_1 = require_json_typings();
  var base64_1 = require_base642();
  var reflection_info_1 = require_reflection_info();
  var pb_long_1 = require_pb_long();
  var assert_1 = require_assert();
  var reflection_long_convert_1 = require_reflection_long_convert();

  class ReflectionJsonReader {
    constructor(info) {
      this.info = info;
    }
    prepare() {
      var _a3;
      if (this.fMap === undefined) {
        this.fMap = {};
        const fieldsInput = (_a3 = this.info.fields) !== null && _a3 !== undefined ? _a3 : [];
        for (const field of fieldsInput) {
          this.fMap[field.name] = field;
          this.fMap[field.jsonName] = field;
          this.fMap[field.localName] = field;
        }
      }
    }
    assert(condition, fieldName, jsonValue) {
      if (!condition) {
        let what = json_typings_1.typeofJsonValue(jsonValue);
        if (what == "number" || what == "boolean")
          what = jsonValue.toString();
        throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
      }
    }
    read(input, message, options) {
      this.prepare();
      const oneofsHandled = [];
      for (const [jsonKey, jsonValue] of Object.entries(input)) {
        const field = this.fMap[jsonKey];
        if (!field) {
          if (!options.ignoreUnknownFields)
            throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
          continue;
        }
        const localName = field.localName;
        let target;
        if (field.oneof) {
          if (jsonValue === null && (field.kind !== "enum" || field.T()[0] !== "google.protobuf.NullValue")) {
            continue;
          }
          if (oneofsHandled.includes(field.oneof))
            throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
          oneofsHandled.push(field.oneof);
          target = message[field.oneof] = {
            oneofKind: localName
          };
        } else {
          target = message;
        }
        if (field.kind == "map") {
          if (jsonValue === null) {
            continue;
          }
          this.assert(json_typings_1.isJsonObject(jsonValue), field.name, jsonValue);
          const fieldObj = target[localName];
          for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
            this.assert(jsonObjValue !== null, field.name + " map value", null);
            let val;
            switch (field.V.kind) {
              case "message":
                val = field.V.T().internalJsonRead(jsonObjValue, options);
                break;
              case "enum":
                val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
                if (val === false)
                  continue;
                break;
              case "scalar":
                val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
                break;
            }
            this.assert(val !== undefined, field.name + " map value", jsonObjValue);
            let key = jsonObjKey;
            if (field.K == reflection_info_1.ScalarType.BOOL)
              key = key == "true" ? true : key == "false" ? false : key;
            key = this.scalar(key, field.K, reflection_info_1.LongType.STRING, field.name).toString();
            fieldObj[key] = val;
          }
        } else if (field.repeat) {
          if (jsonValue === null)
            continue;
          this.assert(Array.isArray(jsonValue), field.name, jsonValue);
          const fieldArr = target[localName];
          for (const jsonItem of jsonValue) {
            this.assert(jsonItem !== null, field.name, null);
            let val;
            switch (field.kind) {
              case "message":
                val = field.T().internalJsonRead(jsonItem, options);
                break;
              case "enum":
                val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
                if (val === false)
                  continue;
                break;
              case "scalar":
                val = this.scalar(jsonItem, field.T, field.L, field.name);
                break;
            }
            this.assert(val !== undefined, field.name, jsonValue);
            fieldArr.push(val);
          }
        } else {
          switch (field.kind) {
            case "message":
              if (jsonValue === null && field.T().typeName != "google.protobuf.Value") {
                this.assert(field.oneof === undefined, field.name + " (oneof member)", null);
                continue;
              }
              target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
              break;
            case "enum":
              if (jsonValue === null)
                continue;
              let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              target[localName] = val;
              break;
            case "scalar":
              if (jsonValue === null)
                continue;
              target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
              break;
          }
        }
      }
    }
    enum(type3, json, fieldName, ignoreUnknownFields) {
      if (type3[0] == "google.protobuf.NullValue")
        assert_1.assert(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type3[0]} only accepts null.`);
      if (json === null)
        return 0;
      switch (typeof json) {
        case "number":
          assert_1.assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
          return json;
        case "string":
          let localEnumName = json;
          if (type3[2] && json.substring(0, type3[2].length) === type3[2])
            localEnumName = json.substring(type3[2].length);
          let enumNumber = type3[1][localEnumName];
          if (typeof enumNumber === "undefined" && ignoreUnknownFields) {
            return false;
          }
          assert_1.assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type3[0]} has no value for "${json}".`);
          return enumNumber;
      }
      assert_1.assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
    }
    scalar(json, type3, longType, fieldName) {
      let e2;
      try {
        switch (type3) {
          case reflection_info_1.ScalarType.DOUBLE:
          case reflection_info_1.ScalarType.FLOAT:
            if (json === null)
              return 0;
            if (json === "NaN")
              return Number.NaN;
            if (json === "Infinity")
              return Number.POSITIVE_INFINITY;
            if (json === "-Infinity")
              return Number.NEGATIVE_INFINITY;
            if (json === "") {
              e2 = "empty string";
              break;
            }
            if (typeof json == "string" && json.trim().length !== json.length) {
              e2 = "extra whitespace";
              break;
            }
            if (typeof json != "string" && typeof json != "number") {
              break;
            }
            let float = Number(json);
            if (Number.isNaN(float)) {
              e2 = "not a number";
              break;
            }
            if (!Number.isFinite(float)) {
              e2 = "too large or small";
              break;
            }
            if (type3 == reflection_info_1.ScalarType.FLOAT)
              assert_1.assertFloat32(float);
            return float;
          case reflection_info_1.ScalarType.INT32:
          case reflection_info_1.ScalarType.FIXED32:
          case reflection_info_1.ScalarType.SFIXED32:
          case reflection_info_1.ScalarType.SINT32:
          case reflection_info_1.ScalarType.UINT32:
            if (json === null)
              return 0;
            let int32;
            if (typeof json == "number")
              int32 = json;
            else if (json === "")
              e2 = "empty string";
            else if (typeof json == "string") {
              if (json.trim().length !== json.length)
                e2 = "extra whitespace";
              else
                int32 = Number(json);
            }
            if (int32 === undefined)
              break;
            if (type3 == reflection_info_1.ScalarType.UINT32)
              assert_1.assertUInt32(int32);
            else
              assert_1.assertInt32(int32);
            return int32;
          case reflection_info_1.ScalarType.INT64:
          case reflection_info_1.ScalarType.SFIXED64:
          case reflection_info_1.ScalarType.SINT64:
            if (json === null)
              return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbLong.ZERO, longType);
            if (typeof json != "number" && typeof json != "string")
              break;
            return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbLong.from(json), longType);
          case reflection_info_1.ScalarType.FIXED64:
          case reflection_info_1.ScalarType.UINT64:
            if (json === null)
              return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbULong.ZERO, longType);
            if (typeof json != "number" && typeof json != "string")
              break;
            return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbULong.from(json), longType);
          case reflection_info_1.ScalarType.BOOL:
            if (json === null)
              return false;
            if (typeof json !== "boolean")
              break;
            return json;
          case reflection_info_1.ScalarType.STRING:
            if (json === null)
              return "";
            if (typeof json !== "string") {
              e2 = "extra whitespace";
              break;
            }
            try {
              encodeURIComponent(json);
            } catch (e3) {
              e3 = "invalid UTF8";
              break;
            }
            return json;
          case reflection_info_1.ScalarType.BYTES:
            if (json === null || json === "")
              return new Uint8Array(0);
            if (typeof json !== "string")
              break;
            return base64_1.base64decode(json);
        }
      } catch (error) {
        e2 = error.message;
      }
      this.assert(false, fieldName + (e2 ? " - " + e2 : ""), json);
    }
  }
  exports.ReflectionJsonReader = ReflectionJsonReader;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-json-writer.js
var require_reflection_json_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReflectionJsonWriter = undefined;
  var base64_1 = require_base642();
  var pb_long_1 = require_pb_long();
  var reflection_info_1 = require_reflection_info();
  var assert_1 = require_assert();

  class ReflectionJsonWriter {
    constructor(info) {
      var _a3;
      this.fields = (_a3 = info.fields) !== null && _a3 !== undefined ? _a3 : [];
    }
    write(message, options) {
      const json = {}, source = message;
      for (const field of this.fields) {
        if (!field.oneof) {
          let jsonValue2 = this.field(field, source[field.localName], options);
          if (jsonValue2 !== undefined)
            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue2;
          continue;
        }
        const group = source[field.oneof];
        if (group.oneofKind !== field.localName)
          continue;
        const opt = field.kind == "scalar" || field.kind == "enum" ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
        let jsonValue = this.field(field, group[field.localName], opt);
        assert_1.assert(jsonValue !== undefined);
        json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
      }
      return json;
    }
    field(field, value, options) {
      let jsonValue = undefined;
      if (field.kind == "map") {
        assert_1.assert(typeof value == "object" && value !== null);
        const jsonObj = {};
        switch (field.V.kind) {
          case "scalar":
            for (const [entryKey, entryValue] of Object.entries(value)) {
              const val = this.scalar(field.V.T, entryValue, field.name, false, true);
              assert_1.assert(val !== undefined);
              jsonObj[entryKey.toString()] = val;
            }
            break;
          case "message":
            const messageType = field.V.T();
            for (const [entryKey, entryValue] of Object.entries(value)) {
              const val = this.message(messageType, entryValue, field.name, options);
              assert_1.assert(val !== undefined);
              jsonObj[entryKey.toString()] = val;
            }
            break;
          case "enum":
            const enumInfo = field.V.T();
            for (const [entryKey, entryValue] of Object.entries(value)) {
              assert_1.assert(entryValue === undefined || typeof entryValue == "number");
              const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
              assert_1.assert(val !== undefined);
              jsonObj[entryKey.toString()] = val;
            }
            break;
        }
        if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
          jsonValue = jsonObj;
      } else if (field.repeat) {
        assert_1.assert(Array.isArray(value));
        const jsonArr = [];
        switch (field.kind) {
          case "scalar":
            for (let i2 = 0;i2 < value.length; i2++) {
              const val = this.scalar(field.T, value[i2], field.name, field.opt, true);
              assert_1.assert(val !== undefined);
              jsonArr.push(val);
            }
            break;
          case "enum":
            const enumInfo = field.T();
            for (let i2 = 0;i2 < value.length; i2++) {
              assert_1.assert(value[i2] === undefined || typeof value[i2] == "number");
              const val = this.enum(enumInfo, value[i2], field.name, field.opt, true, options.enumAsInteger);
              assert_1.assert(val !== undefined);
              jsonArr.push(val);
            }
            break;
          case "message":
            const messageType = field.T();
            for (let i2 = 0;i2 < value.length; i2++) {
              const val = this.message(messageType, value[i2], field.name, options);
              assert_1.assert(val !== undefined);
              jsonArr.push(val);
            }
            break;
        }
        if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
          jsonValue = jsonArr;
      } else {
        switch (field.kind) {
          case "scalar":
            jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
            break;
          case "enum":
            jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
            break;
          case "message":
            jsonValue = this.message(field.T(), value, field.name, options);
            break;
        }
      }
      return jsonValue;
    }
    enum(type3, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
      if (type3[0] == "google.protobuf.NullValue")
        return !emitDefaultValues && !optional ? undefined : null;
      if (value === undefined) {
        assert_1.assert(optional);
        return;
      }
      if (value === 0 && !emitDefaultValues && !optional)
        return;
      assert_1.assert(typeof value == "number");
      assert_1.assert(Number.isInteger(value));
      if (enumAsInteger || !type3[1].hasOwnProperty(value))
        return value;
      if (type3[2])
        return type3[2] + type3[1][value];
      return type3[1][value];
    }
    message(type3, value, fieldName, options) {
      if (value === undefined)
        return options.emitDefaultValues ? null : undefined;
      return type3.internalJsonWrite(value, options);
    }
    scalar(type3, value, fieldName, optional, emitDefaultValues) {
      if (value === undefined) {
        assert_1.assert(optional);
        return;
      }
      const ed = emitDefaultValues || optional;
      switch (type3) {
        case reflection_info_1.ScalarType.INT32:
        case reflection_info_1.ScalarType.SFIXED32:
        case reflection_info_1.ScalarType.SINT32:
          if (value === 0)
            return ed ? 0 : undefined;
          assert_1.assertInt32(value);
          return value;
        case reflection_info_1.ScalarType.FIXED32:
        case reflection_info_1.ScalarType.UINT32:
          if (value === 0)
            return ed ? 0 : undefined;
          assert_1.assertUInt32(value);
          return value;
        case reflection_info_1.ScalarType.FLOAT:
          assert_1.assertFloat32(value);
        case reflection_info_1.ScalarType.DOUBLE:
          if (value === 0)
            return ed ? 0 : undefined;
          assert_1.assert(typeof value == "number");
          if (Number.isNaN(value))
            return "NaN";
          if (value === Number.POSITIVE_INFINITY)
            return "Infinity";
          if (value === Number.NEGATIVE_INFINITY)
            return "-Infinity";
          return value;
        case reflection_info_1.ScalarType.STRING:
          if (value === "")
            return ed ? "" : undefined;
          assert_1.assert(typeof value == "string");
          return value;
        case reflection_info_1.ScalarType.BOOL:
          if (value === false)
            return ed ? false : undefined;
          assert_1.assert(typeof value == "boolean");
          return value;
        case reflection_info_1.ScalarType.UINT64:
        case reflection_info_1.ScalarType.FIXED64:
          assert_1.assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
          let ulong = pb_long_1.PbULong.from(value);
          if (ulong.isZero() && !ed)
            return;
          return ulong.toString();
        case reflection_info_1.ScalarType.INT64:
        case reflection_info_1.ScalarType.SFIXED64:
        case reflection_info_1.ScalarType.SINT64:
          assert_1.assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
          let long = pb_long_1.PbLong.from(value);
          if (long.isZero() && !ed)
            return;
          return long.toString();
        case reflection_info_1.ScalarType.BYTES:
          assert_1.assert(value instanceof Uint8Array);
          if (!value.byteLength)
            return ed ? "" : undefined;
          return base64_1.base64encode(value);
      }
    }
  }
  exports.ReflectionJsonWriter = ReflectionJsonWriter;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-scalar-default.js
var require_reflection_scalar_default = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reflectionScalarDefault = undefined;
  var reflection_info_1 = require_reflection_info();
  var reflection_long_convert_1 = require_reflection_long_convert();
  var pb_long_1 = require_pb_long();
  function reflectionScalarDefault(type3, longType = reflection_info_1.LongType.STRING) {
    switch (type3) {
      case reflection_info_1.ScalarType.BOOL:
        return false;
      case reflection_info_1.ScalarType.UINT64:
      case reflection_info_1.ScalarType.FIXED64:
        return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbULong.ZERO, longType);
      case reflection_info_1.ScalarType.INT64:
      case reflection_info_1.ScalarType.SFIXED64:
      case reflection_info_1.ScalarType.SINT64:
        return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbLong.ZERO, longType);
      case reflection_info_1.ScalarType.DOUBLE:
      case reflection_info_1.ScalarType.FLOAT:
        return 0;
      case reflection_info_1.ScalarType.BYTES:
        return new Uint8Array(0);
      case reflection_info_1.ScalarType.STRING:
        return "";
      default:
        return 0;
    }
  }
  exports.reflectionScalarDefault = reflectionScalarDefault;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-binary-reader.js
var require_reflection_binary_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReflectionBinaryReader = undefined;
  var binary_format_contract_1 = require_binary_format_contract();
  var reflection_info_1 = require_reflection_info();
  var reflection_long_convert_1 = require_reflection_long_convert();
  var reflection_scalar_default_1 = require_reflection_scalar_default();

  class ReflectionBinaryReader {
    constructor(info) {
      this.info = info;
    }
    prepare() {
      var _a3;
      if (!this.fieldNoToField) {
        const fieldsInput = (_a3 = this.info.fields) !== null && _a3 !== undefined ? _a3 : [];
        this.fieldNoToField = new Map(fieldsInput.map((field) => [field.no, field]));
      }
    }
    read(reader, message, options, length) {
      this.prepare();
      const end = length === undefined ? reader.len : reader.pos + length;
      while (reader.pos < end) {
        const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
        if (!field) {
          let u2 = options.readUnknownField;
          if (u2 == "throw")
            throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
          let d2 = reader.skip(wireType);
          if (u2 !== false)
            (u2 === true ? binary_format_contract_1.UnknownFieldHandler.onRead : u2)(this.info.typeName, message, fieldNo, wireType, d2);
          continue;
        }
        let target = message, repeated = field.repeat, localName = field.localName;
        if (field.oneof) {
          target = target[field.oneof];
          if (target.oneofKind !== localName)
            target = message[field.oneof] = {
              oneofKind: localName
            };
        }
        switch (field.kind) {
          case "scalar":
          case "enum":
            let T2 = field.kind == "enum" ? reflection_info_1.ScalarType.INT32 : field.T;
            let L2 = field.kind == "scalar" ? field.L : undefined;
            if (repeated) {
              let arr = target[localName];
              if (wireType == binary_format_contract_1.WireType.LengthDelimited && T2 != reflection_info_1.ScalarType.STRING && T2 != reflection_info_1.ScalarType.BYTES) {
                let e2 = reader.uint32() + reader.pos;
                while (reader.pos < e2)
                  arr.push(this.scalar(reader, T2, L2));
              } else
                arr.push(this.scalar(reader, T2, L2));
            } else
              target[localName] = this.scalar(reader, T2, L2);
            break;
          case "message":
            if (repeated) {
              let arr = target[localName];
              let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
              arr.push(msg);
            } else
              target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
            break;
          case "map":
            let [mapKey, mapVal] = this.mapEntry(field, reader, options);
            target[localName][mapKey] = mapVal;
            break;
        }
      }
    }
    mapEntry(field, reader, options) {
      let length = reader.uint32();
      let end = reader.pos + length;
      let key = undefined;
      let val = undefined;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            if (field.K == reflection_info_1.ScalarType.BOOL)
              key = reader.bool().toString();
            else
              key = this.scalar(reader, field.K, reflection_info_1.LongType.STRING);
            break;
          case 2:
            switch (field.V.kind) {
              case "scalar":
                val = this.scalar(reader, field.V.T, field.V.L);
                break;
              case "enum":
                val = reader.int32();
                break;
              case "message":
                val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
                break;
            }
            break;
          default:
            throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
        }
      }
      if (key === undefined) {
        let keyRaw = reflection_scalar_default_1.reflectionScalarDefault(field.K);
        key = field.K == reflection_info_1.ScalarType.BOOL ? keyRaw.toString() : keyRaw;
      }
      if (val === undefined)
        switch (field.V.kind) {
          case "scalar":
            val = reflection_scalar_default_1.reflectionScalarDefault(field.V.T, field.V.L);
            break;
          case "enum":
            val = 0;
            break;
          case "message":
            val = field.V.T().create();
            break;
        }
      return [key, val];
    }
    scalar(reader, type3, longType) {
      switch (type3) {
        case reflection_info_1.ScalarType.INT32:
          return reader.int32();
        case reflection_info_1.ScalarType.STRING:
          return reader.string();
        case reflection_info_1.ScalarType.BOOL:
          return reader.bool();
        case reflection_info_1.ScalarType.DOUBLE:
          return reader.double();
        case reflection_info_1.ScalarType.FLOAT:
          return reader.float();
        case reflection_info_1.ScalarType.INT64:
          return reflection_long_convert_1.reflectionLongConvert(reader.int64(), longType);
        case reflection_info_1.ScalarType.UINT64:
          return reflection_long_convert_1.reflectionLongConvert(reader.uint64(), longType);
        case reflection_info_1.ScalarType.FIXED64:
          return reflection_long_convert_1.reflectionLongConvert(reader.fixed64(), longType);
        case reflection_info_1.ScalarType.FIXED32:
          return reader.fixed32();
        case reflection_info_1.ScalarType.BYTES:
          return reader.bytes();
        case reflection_info_1.ScalarType.UINT32:
          return reader.uint32();
        case reflection_info_1.ScalarType.SFIXED32:
          return reader.sfixed32();
        case reflection_info_1.ScalarType.SFIXED64:
          return reflection_long_convert_1.reflectionLongConvert(reader.sfixed64(), longType);
        case reflection_info_1.ScalarType.SINT32:
          return reader.sint32();
        case reflection_info_1.ScalarType.SINT64:
          return reflection_long_convert_1.reflectionLongConvert(reader.sint64(), longType);
      }
    }
  }
  exports.ReflectionBinaryReader = ReflectionBinaryReader;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-binary-writer.js
var require_reflection_binary_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReflectionBinaryWriter = undefined;
  var binary_format_contract_1 = require_binary_format_contract();
  var reflection_info_1 = require_reflection_info();
  var assert_1 = require_assert();
  var pb_long_1 = require_pb_long();

  class ReflectionBinaryWriter {
    constructor(info) {
      this.info = info;
    }
    prepare() {
      if (!this.fields) {
        const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
        this.fields = fieldsInput.sort((a2, b2) => a2.no - b2.no);
      }
    }
    write(message, writer, options) {
      this.prepare();
      for (const field of this.fields) {
        let value, emitDefault, repeated = field.repeat, localName = field.localName;
        if (field.oneof) {
          const group = message[field.oneof];
          if (group.oneofKind !== localName)
            continue;
          value = group[localName];
          emitDefault = true;
        } else {
          value = message[localName];
          emitDefault = false;
        }
        switch (field.kind) {
          case "scalar":
          case "enum":
            let T2 = field.kind == "enum" ? reflection_info_1.ScalarType.INT32 : field.T;
            if (repeated) {
              assert_1.assert(Array.isArray(value));
              if (repeated == reflection_info_1.RepeatType.PACKED)
                this.packed(writer, T2, field.no, value);
              else
                for (const item of value)
                  this.scalar(writer, T2, field.no, item, true);
            } else if (value === undefined)
              assert_1.assert(field.opt);
            else
              this.scalar(writer, T2, field.no, value, emitDefault || field.opt);
            break;
          case "message":
            if (repeated) {
              assert_1.assert(Array.isArray(value));
              for (const item of value)
                this.message(writer, options, field.T(), field.no, item);
            } else {
              this.message(writer, options, field.T(), field.no, value);
            }
            break;
          case "map":
            assert_1.assert(typeof value == "object" && value !== null);
            for (const [key, val] of Object.entries(value))
              this.mapEntry(writer, options, field, key, val);
            break;
        }
      }
      let u2 = options.writeUnknownFields;
      if (u2 !== false)
        (u2 === true ? binary_format_contract_1.UnknownFieldHandler.onWrite : u2)(this.info.typeName, message, writer);
    }
    mapEntry(writer, options, field, key, value) {
      writer.tag(field.no, binary_format_contract_1.WireType.LengthDelimited);
      writer.fork();
      let keyValue = key;
      switch (field.K) {
        case reflection_info_1.ScalarType.INT32:
        case reflection_info_1.ScalarType.FIXED32:
        case reflection_info_1.ScalarType.UINT32:
        case reflection_info_1.ScalarType.SFIXED32:
        case reflection_info_1.ScalarType.SINT32:
          keyValue = Number.parseInt(key);
          break;
        case reflection_info_1.ScalarType.BOOL:
          assert_1.assert(key == "true" || key == "false");
          keyValue = key == "true";
          break;
      }
      this.scalar(writer, field.K, 1, keyValue, true);
      switch (field.V.kind) {
        case "scalar":
          this.scalar(writer, field.V.T, 2, value, true);
          break;
        case "enum":
          this.scalar(writer, reflection_info_1.ScalarType.INT32, 2, value, true);
          break;
        case "message":
          this.message(writer, options, field.V.T(), 2, value);
          break;
      }
      writer.join();
    }
    message(writer, options, handler2, fieldNo, value) {
      if (value === undefined)
        return;
      handler2.internalBinaryWrite(value, writer.tag(fieldNo, binary_format_contract_1.WireType.LengthDelimited).fork(), options);
      writer.join();
    }
    scalar(writer, type3, fieldNo, value, emitDefault) {
      let [wireType, method, isDefault] = this.scalarInfo(type3, value);
      if (!isDefault || emitDefault) {
        writer.tag(fieldNo, wireType);
        writer[method](value);
      }
    }
    packed(writer, type3, fieldNo, value) {
      if (!value.length)
        return;
      assert_1.assert(type3 !== reflection_info_1.ScalarType.BYTES && type3 !== reflection_info_1.ScalarType.STRING);
      writer.tag(fieldNo, binary_format_contract_1.WireType.LengthDelimited);
      writer.fork();
      let [, method] = this.scalarInfo(type3);
      for (let i2 = 0;i2 < value.length; i2++)
        writer[method](value[i2]);
      writer.join();
    }
    scalarInfo(type3, value) {
      let t2 = binary_format_contract_1.WireType.Varint;
      let m2;
      let i2 = value === undefined;
      let d2 = value === 0;
      switch (type3) {
        case reflection_info_1.ScalarType.INT32:
          m2 = "int32";
          break;
        case reflection_info_1.ScalarType.STRING:
          d2 = i2 || !value.length;
          t2 = binary_format_contract_1.WireType.LengthDelimited;
          m2 = "string";
          break;
        case reflection_info_1.ScalarType.BOOL:
          d2 = value === false;
          m2 = "bool";
          break;
        case reflection_info_1.ScalarType.UINT32:
          m2 = "uint32";
          break;
        case reflection_info_1.ScalarType.DOUBLE:
          t2 = binary_format_contract_1.WireType.Bit64;
          m2 = "double";
          break;
        case reflection_info_1.ScalarType.FLOAT:
          t2 = binary_format_contract_1.WireType.Bit32;
          m2 = "float";
          break;
        case reflection_info_1.ScalarType.INT64:
          d2 = i2 || pb_long_1.PbLong.from(value).isZero();
          m2 = "int64";
          break;
        case reflection_info_1.ScalarType.UINT64:
          d2 = i2 || pb_long_1.PbULong.from(value).isZero();
          m2 = "uint64";
          break;
        case reflection_info_1.ScalarType.FIXED64:
          d2 = i2 || pb_long_1.PbULong.from(value).isZero();
          t2 = binary_format_contract_1.WireType.Bit64;
          m2 = "fixed64";
          break;
        case reflection_info_1.ScalarType.BYTES:
          d2 = i2 || !value.byteLength;
          t2 = binary_format_contract_1.WireType.LengthDelimited;
          m2 = "bytes";
          break;
        case reflection_info_1.ScalarType.FIXED32:
          t2 = binary_format_contract_1.WireType.Bit32;
          m2 = "fixed32";
          break;
        case reflection_info_1.ScalarType.SFIXED32:
          t2 = binary_format_contract_1.WireType.Bit32;
          m2 = "sfixed32";
          break;
        case reflection_info_1.ScalarType.SFIXED64:
          d2 = i2 || pb_long_1.PbLong.from(value).isZero();
          t2 = binary_format_contract_1.WireType.Bit64;
          m2 = "sfixed64";
          break;
        case reflection_info_1.ScalarType.SINT32:
          m2 = "sint32";
          break;
        case reflection_info_1.ScalarType.SINT64:
          d2 = i2 || pb_long_1.PbLong.from(value).isZero();
          m2 = "sint64";
          break;
      }
      return [t2, m2, i2 || d2];
    }
  }
  exports.ReflectionBinaryWriter = ReflectionBinaryWriter;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-create.js
var require_reflection_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reflectionCreate = undefined;
  var reflection_scalar_default_1 = require_reflection_scalar_default();
  var message_type_contract_1 = require_message_type_contract();
  function reflectionCreate(type3) {
    const msg = type3.messagePrototype ? Object.create(type3.messagePrototype) : Object.defineProperty({}, message_type_contract_1.MESSAGE_TYPE, { value: type3 });
    for (let field of type3.fields) {
      let name = field.localName;
      if (field.opt)
        continue;
      if (field.oneof)
        msg[field.oneof] = { oneofKind: undefined };
      else if (field.repeat)
        msg[name] = [];
      else
        switch (field.kind) {
          case "scalar":
            msg[name] = reflection_scalar_default_1.reflectionScalarDefault(field.T, field.L);
            break;
          case "enum":
            msg[name] = 0;
            break;
          case "map":
            msg[name] = {};
            break;
        }
    }
    return msg;
  }
  exports.reflectionCreate = reflectionCreate;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-merge-partial.js
var require_reflection_merge_partial = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reflectionMergePartial = undefined;
  function reflectionMergePartial(info, target, source) {
    let fieldValue, input = source, output;
    for (let field of info.fields) {
      let name = field.localName;
      if (field.oneof) {
        const group = input[field.oneof];
        if ((group === null || group === undefined ? undefined : group.oneofKind) == undefined) {
          continue;
        }
        fieldValue = group[name];
        output = target[field.oneof];
        output.oneofKind = group.oneofKind;
        if (fieldValue == undefined) {
          delete output[name];
          continue;
        }
      } else {
        fieldValue = input[name];
        output = target;
        if (fieldValue == undefined) {
          continue;
        }
      }
      if (field.repeat)
        output[name].length = fieldValue.length;
      switch (field.kind) {
        case "scalar":
        case "enum":
          if (field.repeat)
            for (let i2 = 0;i2 < fieldValue.length; i2++)
              output[name][i2] = fieldValue[i2];
          else
            output[name] = fieldValue;
          break;
        case "message":
          let T2 = field.T();
          if (field.repeat)
            for (let i2 = 0;i2 < fieldValue.length; i2++)
              output[name][i2] = T2.create(fieldValue[i2]);
          else if (output[name] === undefined)
            output[name] = T2.create(fieldValue);
          else
            T2.mergePartial(output[name], fieldValue);
          break;
        case "map":
          switch (field.V.kind) {
            case "scalar":
            case "enum":
              Object.assign(output[name], fieldValue);
              break;
            case "message":
              let T3 = field.V.T();
              for (let k2 of Object.keys(fieldValue))
                output[name][k2] = T3.create(fieldValue[k2]);
              break;
          }
          break;
      }
    }
  }
  exports.reflectionMergePartial = reflectionMergePartial;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-equals.js
var require_reflection_equals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reflectionEquals = undefined;
  var reflection_info_1 = require_reflection_info();
  function reflectionEquals(info, a2, b2) {
    if (a2 === b2)
      return true;
    if (!a2 || !b2)
      return false;
    for (let field of info.fields) {
      let localName = field.localName;
      let val_a = field.oneof ? a2[field.oneof][localName] : a2[localName];
      let val_b = field.oneof ? b2[field.oneof][localName] : b2[localName];
      switch (field.kind) {
        case "enum":
        case "scalar":
          let t2 = field.kind == "enum" ? reflection_info_1.ScalarType.INT32 : field.T;
          if (!(field.repeat ? repeatedPrimitiveEq(t2, val_a, val_b) : primitiveEq(t2, val_a, val_b)))
            return false;
          break;
        case "map":
          if (!(field.V.kind == "message" ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b)) : repeatedPrimitiveEq(field.V.kind == "enum" ? reflection_info_1.ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
            return false;
          break;
        case "message":
          let T2 = field.T();
          if (!(field.repeat ? repeatedMsgEq(T2, val_a, val_b) : T2.equals(val_a, val_b)))
            return false;
          break;
      }
    }
    return true;
  }
  exports.reflectionEquals = reflectionEquals;
  var objectValues = Object.values;
  function primitiveEq(type3, a2, b2) {
    if (a2 === b2)
      return true;
    if (type3 !== reflection_info_1.ScalarType.BYTES)
      return false;
    let ba = a2;
    let bb = b2;
    if (ba.length !== bb.length)
      return false;
    for (let i2 = 0;i2 < ba.length; i2++)
      if (ba[i2] != bb[i2])
        return false;
    return true;
  }
  function repeatedPrimitiveEq(type3, a2, b2) {
    if (a2.length !== b2.length)
      return false;
    for (let i2 = 0;i2 < a2.length; i2++)
      if (!primitiveEq(type3, a2[i2], b2[i2]))
        return false;
    return true;
  }
  function repeatedMsgEq(type3, a2, b2) {
    if (a2.length !== b2.length)
      return false;
    for (let i2 = 0;i2 < a2.length; i2++)
      if (!type3.equals(a2[i2], b2[i2]))
        return false;
    return true;
  }
});

// node_modules/@protobuf-ts/runtime/build/commonjs/message-type.js
var require_message_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageType = undefined;
  var message_type_contract_1 = require_message_type_contract();
  var reflection_info_1 = require_reflection_info();
  var reflection_type_check_1 = require_reflection_type_check();
  var reflection_json_reader_1 = require_reflection_json_reader();
  var reflection_json_writer_1 = require_reflection_json_writer();
  var reflection_binary_reader_1 = require_reflection_binary_reader();
  var reflection_binary_writer_1 = require_reflection_binary_writer();
  var reflection_create_1 = require_reflection_create();
  var reflection_merge_partial_1 = require_reflection_merge_partial();
  var json_typings_1 = require_json_typings();
  var json_format_contract_1 = require_json_format_contract();
  var reflection_equals_1 = require_reflection_equals();
  var binary_writer_1 = require_binary_writer();
  var binary_reader_1 = require_binary_reader();
  var baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
  var messageTypeDescriptor = baseDescriptors[message_type_contract_1.MESSAGE_TYPE] = {};

  class MessageType {
    constructor(name, fields, options) {
      this.defaultCheckDepth = 16;
      this.typeName = name;
      this.fields = fields.map(reflection_info_1.normalizeFieldInfo);
      this.options = options !== null && options !== undefined ? options : {};
      messageTypeDescriptor.value = this;
      this.messagePrototype = Object.create(null, baseDescriptors);
      this.refTypeCheck = new reflection_type_check_1.ReflectionTypeCheck(this);
      this.refJsonReader = new reflection_json_reader_1.ReflectionJsonReader(this);
      this.refJsonWriter = new reflection_json_writer_1.ReflectionJsonWriter(this);
      this.refBinReader = new reflection_binary_reader_1.ReflectionBinaryReader(this);
      this.refBinWriter = new reflection_binary_writer_1.ReflectionBinaryWriter(this);
    }
    create(value) {
      let message = reflection_create_1.reflectionCreate(this);
      if (value !== undefined) {
        reflection_merge_partial_1.reflectionMergePartial(this, message, value);
      }
      return message;
    }
    clone(message) {
      let copy = this.create();
      reflection_merge_partial_1.reflectionMergePartial(this, copy, message);
      return copy;
    }
    equals(a2, b2) {
      return reflection_equals_1.reflectionEquals(this, a2, b2);
    }
    is(arg, depth = this.defaultCheckDepth) {
      return this.refTypeCheck.is(arg, depth, false);
    }
    isAssignable(arg, depth = this.defaultCheckDepth) {
      return this.refTypeCheck.is(arg, depth, true);
    }
    mergePartial(target, source) {
      reflection_merge_partial_1.reflectionMergePartial(this, target, source);
    }
    fromBinary(data, options) {
      let opt = binary_reader_1.binaryReadOptions(options);
      return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
    }
    fromJson(json, options) {
      return this.internalJsonRead(json, json_format_contract_1.jsonReadOptions(options));
    }
    fromJsonString(json, options) {
      let value = JSON.parse(json);
      return this.fromJson(value, options);
    }
    toJson(message, options) {
      return this.internalJsonWrite(message, json_format_contract_1.jsonWriteOptions(options));
    }
    toJsonString(message, options) {
      var _a3;
      let value = this.toJson(message, options);
      return JSON.stringify(value, null, (_a3 = options === null || options === undefined ? undefined : options.prettySpaces) !== null && _a3 !== undefined ? _a3 : 0);
    }
    toBinary(message, options) {
      let opt = binary_writer_1.binaryWriteOptions(options);
      return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
    }
    internalJsonRead(json, options, target) {
      if (json !== null && typeof json == "object" && !Array.isArray(json)) {
        let message = target !== null && target !== undefined ? target : this.create();
        this.refJsonReader.read(json, message, options);
        return message;
      }
      throw new Error(`Unable to parse message ${this.typeName} from JSON ${json_typings_1.typeofJsonValue(json)}.`);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.write(message, options);
    }
    internalBinaryWrite(message, writer, options) {
      this.refBinWriter.write(message, writer, options);
      return writer;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create();
      this.refBinReader.read(reader, message, options, length);
      return message;
    }
  }
  exports.MessageType = MessageType;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-contains-message-type.js
var require_reflection_contains_message_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.containsMessageType = undefined;
  var message_type_contract_1 = require_message_type_contract();
  function containsMessageType(msg) {
    return msg[message_type_contract_1.MESSAGE_TYPE] != null;
  }
  exports.containsMessageType = containsMessageType;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/enum-object.js
var require_enum_object = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.listEnumNumbers = exports.listEnumNames = exports.listEnumValues = exports.isEnumObject = undefined;
  function isEnumObject(arg) {
    if (typeof arg != "object" || arg === null) {
      return false;
    }
    if (!arg.hasOwnProperty(0)) {
      return false;
    }
    for (let k2 of Object.keys(arg)) {
      let num = parseInt(k2);
      if (!Number.isNaN(num)) {
        let nam = arg[num];
        if (nam === undefined)
          return false;
        if (arg[nam] !== num)
          return false;
      } else {
        let num2 = arg[k2];
        if (num2 === undefined)
          return false;
        if (typeof num2 !== "number")
          return false;
        if (arg[num2] === undefined)
          return false;
      }
    }
    return true;
  }
  exports.isEnumObject = isEnumObject;
  function listEnumValues(enumObject) {
    if (!isEnumObject(enumObject))
      throw new Error("not a typescript enum object");
    let values = [];
    for (let [name, number] of Object.entries(enumObject))
      if (typeof number == "number")
        values.push({ name, number });
    return values;
  }
  exports.listEnumValues = listEnumValues;
  function listEnumNames(enumObject) {
    return listEnumValues(enumObject).map((val) => val.name);
  }
  exports.listEnumNames = listEnumNames;
  function listEnumNumbers(enumObject) {
    return listEnumValues(enumObject).map((val) => val.number).filter((num, index, arr) => arr.indexOf(num) == index);
  }
  exports.listEnumNumbers = listEnumNumbers;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/index.js
var require_commonjs13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var json_typings_1 = require_json_typings();
  Object.defineProperty(exports, "typeofJsonValue", { enumerable: true, get: function() {
    return json_typings_1.typeofJsonValue;
  } });
  Object.defineProperty(exports, "isJsonObject", { enumerable: true, get: function() {
    return json_typings_1.isJsonObject;
  } });
  var base64_1 = require_base642();
  Object.defineProperty(exports, "base64decode", { enumerable: true, get: function() {
    return base64_1.base64decode;
  } });
  Object.defineProperty(exports, "base64encode", { enumerable: true, get: function() {
    return base64_1.base64encode;
  } });
  var protobufjs_utf8_1 = require_protobufjs_utf8();
  Object.defineProperty(exports, "utf8read", { enumerable: true, get: function() {
    return protobufjs_utf8_1.utf8read;
  } });
  var binary_format_contract_1 = require_binary_format_contract();
  Object.defineProperty(exports, "WireType", { enumerable: true, get: function() {
    return binary_format_contract_1.WireType;
  } });
  Object.defineProperty(exports, "mergeBinaryOptions", { enumerable: true, get: function() {
    return binary_format_contract_1.mergeBinaryOptions;
  } });
  Object.defineProperty(exports, "UnknownFieldHandler", { enumerable: true, get: function() {
    return binary_format_contract_1.UnknownFieldHandler;
  } });
  var binary_reader_1 = require_binary_reader();
  Object.defineProperty(exports, "BinaryReader", { enumerable: true, get: function() {
    return binary_reader_1.BinaryReader;
  } });
  Object.defineProperty(exports, "binaryReadOptions", { enumerable: true, get: function() {
    return binary_reader_1.binaryReadOptions;
  } });
  var binary_writer_1 = require_binary_writer();
  Object.defineProperty(exports, "BinaryWriter", { enumerable: true, get: function() {
    return binary_writer_1.BinaryWriter;
  } });
  Object.defineProperty(exports, "binaryWriteOptions", { enumerable: true, get: function() {
    return binary_writer_1.binaryWriteOptions;
  } });
  var pb_long_1 = require_pb_long();
  Object.defineProperty(exports, "PbLong", { enumerable: true, get: function() {
    return pb_long_1.PbLong;
  } });
  Object.defineProperty(exports, "PbULong", { enumerable: true, get: function() {
    return pb_long_1.PbULong;
  } });
  var json_format_contract_1 = require_json_format_contract();
  Object.defineProperty(exports, "jsonReadOptions", { enumerable: true, get: function() {
    return json_format_contract_1.jsonReadOptions;
  } });
  Object.defineProperty(exports, "jsonWriteOptions", { enumerable: true, get: function() {
    return json_format_contract_1.jsonWriteOptions;
  } });
  Object.defineProperty(exports, "mergeJsonOptions", { enumerable: true, get: function() {
    return json_format_contract_1.mergeJsonOptions;
  } });
  var message_type_contract_1 = require_message_type_contract();
  Object.defineProperty(exports, "MESSAGE_TYPE", { enumerable: true, get: function() {
    return message_type_contract_1.MESSAGE_TYPE;
  } });
  var message_type_1 = require_message_type();
  Object.defineProperty(exports, "MessageType", { enumerable: true, get: function() {
    return message_type_1.MessageType;
  } });
  var reflection_info_1 = require_reflection_info();
  Object.defineProperty(exports, "ScalarType", { enumerable: true, get: function() {
    return reflection_info_1.ScalarType;
  } });
  Object.defineProperty(exports, "LongType", { enumerable: true, get: function() {
    return reflection_info_1.LongType;
  } });
  Object.defineProperty(exports, "RepeatType", { enumerable: true, get: function() {
    return reflection_info_1.RepeatType;
  } });
  Object.defineProperty(exports, "normalizeFieldInfo", { enumerable: true, get: function() {
    return reflection_info_1.normalizeFieldInfo;
  } });
  Object.defineProperty(exports, "readFieldOptions", { enumerable: true, get: function() {
    return reflection_info_1.readFieldOptions;
  } });
  Object.defineProperty(exports, "readFieldOption", { enumerable: true, get: function() {
    return reflection_info_1.readFieldOption;
  } });
  Object.defineProperty(exports, "readMessageOption", { enumerable: true, get: function() {
    return reflection_info_1.readMessageOption;
  } });
  var reflection_type_check_1 = require_reflection_type_check();
  Object.defineProperty(exports, "ReflectionTypeCheck", { enumerable: true, get: function() {
    return reflection_type_check_1.ReflectionTypeCheck;
  } });
  var reflection_create_1 = require_reflection_create();
  Object.defineProperty(exports, "reflectionCreate", { enumerable: true, get: function() {
    return reflection_create_1.reflectionCreate;
  } });
  var reflection_scalar_default_1 = require_reflection_scalar_default();
  Object.defineProperty(exports, "reflectionScalarDefault", { enumerable: true, get: function() {
    return reflection_scalar_default_1.reflectionScalarDefault;
  } });
  var reflection_merge_partial_1 = require_reflection_merge_partial();
  Object.defineProperty(exports, "reflectionMergePartial", { enumerable: true, get: function() {
    return reflection_merge_partial_1.reflectionMergePartial;
  } });
  var reflection_equals_1 = require_reflection_equals();
  Object.defineProperty(exports, "reflectionEquals", { enumerable: true, get: function() {
    return reflection_equals_1.reflectionEquals;
  } });
  var reflection_binary_reader_1 = require_reflection_binary_reader();
  Object.defineProperty(exports, "ReflectionBinaryReader", { enumerable: true, get: function() {
    return reflection_binary_reader_1.ReflectionBinaryReader;
  } });
  var reflection_binary_writer_1 = require_reflection_binary_writer();
  Object.defineProperty(exports, "ReflectionBinaryWriter", { enumerable: true, get: function() {
    return reflection_binary_writer_1.ReflectionBinaryWriter;
  } });
  var reflection_json_reader_1 = require_reflection_json_reader();
  Object.defineProperty(exports, "ReflectionJsonReader", { enumerable: true, get: function() {
    return reflection_json_reader_1.ReflectionJsonReader;
  } });
  var reflection_json_writer_1 = require_reflection_json_writer();
  Object.defineProperty(exports, "ReflectionJsonWriter", { enumerable: true, get: function() {
    return reflection_json_writer_1.ReflectionJsonWriter;
  } });
  var reflection_contains_message_type_1 = require_reflection_contains_message_type();
  Object.defineProperty(exports, "containsMessageType", { enumerable: true, get: function() {
    return reflection_contains_message_type_1.containsMessageType;
  } });
  var oneof_1 = require_oneof();
  Object.defineProperty(exports, "isOneofGroup", { enumerable: true, get: function() {
    return oneof_1.isOneofGroup;
  } });
  Object.defineProperty(exports, "setOneofValue", { enumerable: true, get: function() {
    return oneof_1.setOneofValue;
  } });
  Object.defineProperty(exports, "getOneofValue", { enumerable: true, get: function() {
    return oneof_1.getOneofValue;
  } });
  Object.defineProperty(exports, "clearOneofValue", { enumerable: true, get: function() {
    return oneof_1.clearOneofValue;
  } });
  Object.defineProperty(exports, "getSelectedOneofValue", { enumerable: true, get: function() {
    return oneof_1.getSelectedOneofValue;
  } });
  var enum_object_1 = require_enum_object();
  Object.defineProperty(exports, "listEnumValues", { enumerable: true, get: function() {
    return enum_object_1.listEnumValues;
  } });
  Object.defineProperty(exports, "listEnumNames", { enumerable: true, get: function() {
    return enum_object_1.listEnumNames;
  } });
  Object.defineProperty(exports, "listEnumNumbers", { enumerable: true, get: function() {
    return enum_object_1.listEnumNumbers;
  } });
  Object.defineProperty(exports, "isEnumObject", { enumerable: true, get: function() {
    return enum_object_1.isEnumObject;
  } });
  var lower_camel_case_1 = require_lower_camel_case();
  Object.defineProperty(exports, "lowerCamelCase", { enumerable: true, get: function() {
    return lower_camel_case_1.lowerCamelCase;
  } });
  var assert_1 = require_assert();
  Object.defineProperty(exports, "assert", { enumerable: true, get: function() {
    return assert_1.assert;
  } });
  Object.defineProperty(exports, "assertNever", { enumerable: true, get: function() {
    return assert_1.assertNever;
  } });
  Object.defineProperty(exports, "assertInt32", { enumerable: true, get: function() {
    return assert_1.assertInt32;
  } });
  Object.defineProperty(exports, "assertUInt32", { enumerable: true, get: function() {
    return assert_1.assertUInt32;
  } });
  Object.defineProperty(exports, "assertFloat32", { enumerable: true, get: function() {
    return assert_1.assertFloat32;
  } });
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/reflection-info.js
var require_reflection_info2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readServiceOption = exports.readMethodOption = exports.readMethodOptions = exports.normalizeMethodInfo = undefined;
  var runtime_1 = require_commonjs13();
  function normalizeMethodInfo(method, service) {
    var _a3, _b2, _c2;
    let m2 = method;
    m2.service = service;
    m2.localName = (_a3 = m2.localName) !== null && _a3 !== undefined ? _a3 : runtime_1.lowerCamelCase(m2.name);
    m2.serverStreaming = !!m2.serverStreaming;
    m2.clientStreaming = !!m2.clientStreaming;
    m2.options = (_b2 = m2.options) !== null && _b2 !== undefined ? _b2 : {};
    m2.idempotency = (_c2 = m2.idempotency) !== null && _c2 !== undefined ? _c2 : undefined;
    return m2;
  }
  exports.normalizeMethodInfo = normalizeMethodInfo;
  function readMethodOptions(service, methodName, extensionName, extensionType) {
    var _a3;
    const options = (_a3 = service.methods.find((m2, i2) => m2.localName === methodName || i2 === methodName)) === null || _a3 === undefined ? undefined : _a3.options;
    return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : undefined;
  }
  exports.readMethodOptions = readMethodOptions;
  function readMethodOption(service, methodName, extensionName, extensionType) {
    var _a3;
    const options = (_a3 = service.methods.find((m2, i2) => m2.localName === methodName || i2 === methodName)) === null || _a3 === undefined ? undefined : _a3.options;
    if (!options) {
      return;
    }
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
      return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
  }
  exports.readMethodOption = readMethodOption;
  function readServiceOption(service, extensionName, extensionType) {
    const options = service.options;
    if (!options) {
      return;
    }
    const optionVal = options[extensionName];
    if (optionVal === undefined) {
      return optionVal;
    }
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
  }
  exports.readServiceOption = readServiceOption;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/service-type.js
var require_service_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServiceType = undefined;
  var reflection_info_1 = require_reflection_info2();

  class ServiceType {
    constructor(typeName, methods, options) {
      this.typeName = typeName;
      this.methods = methods.map((i2) => reflection_info_1.normalizeMethodInfo(i2, this));
      this.options = options !== null && options !== undefined ? options : {};
    }
  }
  exports.ServiceType = ServiceType;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/rpc-error.js
var require_rpc_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RpcError = undefined;

  class RpcError extends Error {
    constructor(message, code = "UNKNOWN", meta) {
      super(message);
      this.name = "RpcError";
      Object.setPrototypeOf(this, new.target.prototype);
      this.code = code;
      this.meta = meta !== null && meta !== undefined ? meta : {};
    }
    toString() {
      const l2 = [this.name + ": " + this.message];
      if (this.code) {
        l2.push("");
        l2.push("Code: " + this.code);
      }
      if (this.serviceName && this.methodName) {
        l2.push("Method: " + this.serviceName + "/" + this.methodName);
      }
      let m2 = Object.entries(this.meta);
      if (m2.length) {
        l2.push("");
        l2.push("Meta:");
        for (let [k2, v2] of m2) {
          l2.push(`  ${k2}: ${v2}`);
        }
      }
      return l2.join(`
`);
    }
  }
  exports.RpcError = RpcError;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/rpc-options.js
var require_rpc_options = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeRpcOptions = undefined;
  var runtime_1 = require_commonjs13();
  function mergeRpcOptions(defaults, options) {
    if (!options)
      return defaults;
    let o2 = {};
    copy(defaults, o2);
    copy(options, o2);
    for (let key of Object.keys(options)) {
      let val = options[key];
      switch (key) {
        case "jsonOptions":
          o2.jsonOptions = runtime_1.mergeJsonOptions(defaults.jsonOptions, o2.jsonOptions);
          break;
        case "binaryOptions":
          o2.binaryOptions = runtime_1.mergeBinaryOptions(defaults.binaryOptions, o2.binaryOptions);
          break;
        case "meta":
          o2.meta = {};
          copy(defaults.meta, o2.meta);
          copy(options.meta, o2.meta);
          break;
        case "interceptors":
          o2.interceptors = defaults.interceptors ? defaults.interceptors.concat(val) : val.concat();
          break;
      }
    }
    return o2;
  }
  exports.mergeRpcOptions = mergeRpcOptions;
  function copy(a2, into) {
    if (!a2)
      return;
    let c2 = into;
    for (let [k2, v2] of Object.entries(a2)) {
      if (v2 instanceof Date)
        c2[k2] = new Date(v2.getTime());
      else if (Array.isArray(v2))
        c2[k2] = v2.concat();
      else
        c2[k2] = v2;
    }
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/deferred.js
var require_deferred = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deferred = exports.DeferredState = undefined;
  var DeferredState;
  (function(DeferredState2) {
    DeferredState2[DeferredState2["PENDING"] = 0] = "PENDING";
    DeferredState2[DeferredState2["REJECTED"] = 1] = "REJECTED";
    DeferredState2[DeferredState2["RESOLVED"] = 2] = "RESOLVED";
  })(DeferredState = exports.DeferredState || (exports.DeferredState = {}));

  class Deferred {
    constructor(preventUnhandledRejectionWarning = true) {
      this._state = DeferredState.PENDING;
      this._promise = new Promise((resolve5, reject) => {
        this._resolve = resolve5;
        this._reject = reject;
      });
      if (preventUnhandledRejectionWarning) {
        this._promise.catch((_2) => {
        });
      }
    }
    get state() {
      return this._state;
    }
    get promise() {
      return this._promise;
    }
    resolve(value) {
      if (this.state !== DeferredState.PENDING)
        throw new Error(`cannot resolve ${DeferredState[this.state].toLowerCase()}`);
      this._resolve(value);
      this._state = DeferredState.RESOLVED;
    }
    reject(reason) {
      if (this.state !== DeferredState.PENDING)
        throw new Error(`cannot reject ${DeferredState[this.state].toLowerCase()}`);
      this._reject(reason);
      this._state = DeferredState.REJECTED;
    }
    resolvePending(val) {
      if (this._state === DeferredState.PENDING)
        this.resolve(val);
    }
    rejectPending(reason) {
      if (this._state === DeferredState.PENDING)
        this.reject(reason);
    }
  }
  exports.Deferred = Deferred;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/rpc-output-stream.js
var require_rpc_output_stream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RpcOutputStreamController = undefined;
  var deferred_1 = require_deferred();
  var runtime_1 = require_commonjs13();

  class RpcOutputStreamController {
    constructor() {
      this._lis = {
        nxt: [],
        msg: [],
        err: [],
        cmp: []
      };
      this._closed = false;
      this._itState = { q: [] };
    }
    onNext(callback) {
      return this.addLis(callback, this._lis.nxt);
    }
    onMessage(callback) {
      return this.addLis(callback, this._lis.msg);
    }
    onError(callback) {
      return this.addLis(callback, this._lis.err);
    }
    onComplete(callback) {
      return this.addLis(callback, this._lis.cmp);
    }
    addLis(callback, list) {
      list.push(callback);
      return () => {
        let i2 = list.indexOf(callback);
        if (i2 >= 0)
          list.splice(i2, 1);
      };
    }
    clearLis() {
      for (let l2 of Object.values(this._lis))
        l2.splice(0, l2.length);
    }
    get closed() {
      return this._closed !== false;
    }
    notifyNext(message, error, complete) {
      runtime_1.assert((message ? 1 : 0) + (error ? 1 : 0) + (complete ? 1 : 0) <= 1, "only one emission at a time");
      if (message)
        this.notifyMessage(message);
      if (error)
        this.notifyError(error);
      if (complete)
        this.notifyComplete();
    }
    notifyMessage(message) {
      runtime_1.assert(!this.closed, "stream is closed");
      this.pushIt({ value: message, done: false });
      this._lis.msg.forEach((l2) => l2(message));
      this._lis.nxt.forEach((l2) => l2(message, undefined, false));
    }
    notifyError(error) {
      runtime_1.assert(!this.closed, "stream is closed");
      this._closed = error;
      this.pushIt(error);
      this._lis.err.forEach((l2) => l2(error));
      this._lis.nxt.forEach((l2) => l2(undefined, error, false));
      this.clearLis();
    }
    notifyComplete() {
      runtime_1.assert(!this.closed, "stream is closed");
      this._closed = true;
      this.pushIt({ value: null, done: true });
      this._lis.cmp.forEach((l2) => l2());
      this._lis.nxt.forEach((l2) => l2(undefined, undefined, true));
      this.clearLis();
    }
    [Symbol.asyncIterator]() {
      if (this._closed === true)
        this.pushIt({ value: null, done: true });
      else if (this._closed !== false)
        this.pushIt(this._closed);
      return {
        next: () => {
          let state2 = this._itState;
          runtime_1.assert(state2, "bad state");
          runtime_1.assert(!state2.p, "iterator contract broken");
          let first = state2.q.shift();
          if (first)
            return "value" in first ? Promise.resolve(first) : Promise.reject(first);
          state2.p = new deferred_1.Deferred;
          return state2.p.promise;
        }
      };
    }
    pushIt(result) {
      let state2 = this._itState;
      if (state2.p) {
        const p2 = state2.p;
        runtime_1.assert(p2.state == deferred_1.DeferredState.PENDING, "iterator contract broken");
        "value" in result ? p2.resolve(result) : p2.reject(result);
        delete state2.p;
      } else {
        state2.q.push(result);
      }
    }
  }
  exports.RpcOutputStreamController = RpcOutputStreamController;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/unary-call.js
var require_unary_call = __commonJS((exports) => {
  var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve5, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnaryCall = undefined;

  class UnaryCall {
    constructor(method, requestHeaders, request9, headers, response, status, trailers) {
      this.method = method;
      this.requestHeaders = requestHeaders;
      this.request = request9;
      this.headers = headers;
      this.response = response;
      this.status = status;
      this.trailers = trailers;
    }
    then(onfulfilled, onrejected) {
      return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
    }
    promiseFinished() {
      return __awaiter2(this, undefined, undefined, function* () {
        let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
        return {
          method: this.method,
          requestHeaders: this.requestHeaders,
          request: this.request,
          headers,
          response,
          status,
          trailers
        };
      });
    }
  }
  exports.UnaryCall = UnaryCall;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/server-streaming-call.js
var require_server_streaming_call = __commonJS((exports) => {
  var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve5, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerStreamingCall = undefined;

  class ServerStreamingCall {
    constructor(method, requestHeaders, request9, headers, response, status, trailers) {
      this.method = method;
      this.requestHeaders = requestHeaders;
      this.request = request9;
      this.headers = headers;
      this.responses = response;
      this.status = status;
      this.trailers = trailers;
    }
    then(onfulfilled, onrejected) {
      return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
    }
    promiseFinished() {
      return __awaiter2(this, undefined, undefined, function* () {
        let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
        return {
          method: this.method,
          requestHeaders: this.requestHeaders,
          request: this.request,
          headers,
          status,
          trailers
        };
      });
    }
  }
  exports.ServerStreamingCall = ServerStreamingCall;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/client-streaming-call.js
var require_client_streaming_call = __commonJS((exports) => {
  var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve5, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ClientStreamingCall = undefined;

  class ClientStreamingCall {
    constructor(method, requestHeaders, request9, headers, response, status, trailers) {
      this.method = method;
      this.requestHeaders = requestHeaders;
      this.requests = request9;
      this.headers = headers;
      this.response = response;
      this.status = status;
      this.trailers = trailers;
    }
    then(onfulfilled, onrejected) {
      return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
    }
    promiseFinished() {
      return __awaiter2(this, undefined, undefined, function* () {
        let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
        return {
          method: this.method,
          requestHeaders: this.requestHeaders,
          headers,
          response,
          status,
          trailers
        };
      });
    }
  }
  exports.ClientStreamingCall = ClientStreamingCall;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/duplex-streaming-call.js
var require_duplex_streaming_call = __commonJS((exports) => {
  var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve5, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DuplexStreamingCall = undefined;

  class DuplexStreamingCall {
    constructor(method, requestHeaders, request9, headers, response, status, trailers) {
      this.method = method;
      this.requestHeaders = requestHeaders;
      this.requests = request9;
      this.headers = headers;
      this.responses = response;
      this.status = status;
      this.trailers = trailers;
    }
    then(onfulfilled, onrejected) {
      return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
    }
    promiseFinished() {
      return __awaiter2(this, undefined, undefined, function* () {
        let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
        return {
          method: this.method,
          requestHeaders: this.requestHeaders,
          headers,
          status,
          trailers
        };
      });
    }
  }
  exports.DuplexStreamingCall = DuplexStreamingCall;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/test-transport.js
var require_test_transport = __commonJS((exports) => {
  var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve5, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TestTransport = undefined;
  var rpc_error_1 = require_rpc_error();
  var runtime_1 = require_commonjs13();
  var rpc_output_stream_1 = require_rpc_output_stream();
  var rpc_options_1 = require_rpc_options();
  var unary_call_1 = require_unary_call();
  var server_streaming_call_1 = require_server_streaming_call();
  var client_streaming_call_1 = require_client_streaming_call();
  var duplex_streaming_call_1 = require_duplex_streaming_call();

  class TestTransport {
    constructor(data) {
      this.suppressUncaughtRejections = true;
      this.headerDelay = 10;
      this.responseDelay = 50;
      this.betweenResponseDelay = 10;
      this.afterResponseDelay = 10;
      this.data = data !== null && data !== undefined ? data : {};
    }
    get sentMessages() {
      if (this.lastInput instanceof TestInputStream) {
        return this.lastInput.sent;
      } else if (typeof this.lastInput == "object") {
        return [this.lastInput.single];
      }
      return [];
    }
    get sendComplete() {
      if (this.lastInput instanceof TestInputStream) {
        return this.lastInput.completed;
      } else if (typeof this.lastInput == "object") {
        return true;
      }
      return false;
    }
    promiseHeaders() {
      var _a3;
      const headers = (_a3 = this.data.headers) !== null && _a3 !== undefined ? _a3 : TestTransport.defaultHeaders;
      return headers instanceof rpc_error_1.RpcError ? Promise.reject(headers) : Promise.resolve(headers);
    }
    promiseSingleResponse(method) {
      if (this.data.response instanceof rpc_error_1.RpcError) {
        return Promise.reject(this.data.response);
      }
      let r2;
      if (Array.isArray(this.data.response)) {
        runtime_1.assert(this.data.response.length > 0);
        r2 = this.data.response[0];
      } else if (this.data.response !== undefined) {
        r2 = this.data.response;
      } else {
        r2 = method.O.create();
      }
      runtime_1.assert(method.O.is(r2));
      return Promise.resolve(r2);
    }
    streamResponses(method, stream, abort) {
      return __awaiter2(this, undefined, undefined, function* () {
        const messages = [];
        if (this.data.response === undefined) {
          messages.push(method.O.create());
        } else if (Array.isArray(this.data.response)) {
          for (let msg of this.data.response) {
            runtime_1.assert(method.O.is(msg));
            messages.push(msg);
          }
        } else if (!(this.data.response instanceof rpc_error_1.RpcError)) {
          runtime_1.assert(method.O.is(this.data.response));
          messages.push(this.data.response);
        }
        try {
          yield delay3(this.responseDelay, abort)(undefined);
        } catch (error) {
          stream.notifyError(error);
          return;
        }
        if (this.data.response instanceof rpc_error_1.RpcError) {
          stream.notifyError(this.data.response);
          return;
        }
        for (let msg of messages) {
          stream.notifyMessage(msg);
          try {
            yield delay3(this.betweenResponseDelay, abort)(undefined);
          } catch (error) {
            stream.notifyError(error);
            return;
          }
        }
        if (this.data.status instanceof rpc_error_1.RpcError) {
          stream.notifyError(this.data.status);
          return;
        }
        if (this.data.trailers instanceof rpc_error_1.RpcError) {
          stream.notifyError(this.data.trailers);
          return;
        }
        stream.notifyComplete();
      });
    }
    promiseStatus() {
      var _a3;
      const status = (_a3 = this.data.status) !== null && _a3 !== undefined ? _a3 : TestTransport.defaultStatus;
      return status instanceof rpc_error_1.RpcError ? Promise.reject(status) : Promise.resolve(status);
    }
    promiseTrailers() {
      var _a3;
      const trailers = (_a3 = this.data.trailers) !== null && _a3 !== undefined ? _a3 : TestTransport.defaultTrailers;
      return trailers instanceof rpc_error_1.RpcError ? Promise.reject(trailers) : Promise.resolve(trailers);
    }
    maybeSuppressUncaught(...promise) {
      if (this.suppressUncaughtRejections) {
        for (let p2 of promise) {
          p2.catch(() => {
          });
        }
      }
    }
    mergeOptions(options) {
      return rpc_options_1.mergeRpcOptions({}, options);
    }
    unary(method, input, options) {
      var _a3;
      const requestHeaders = (_a3 = options.meta) !== null && _a3 !== undefined ? _a3 : {}, headersPromise = this.promiseHeaders().then(delay3(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_2) => {
      }).then(delay3(this.responseDelay, options.abort)).then((_2) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_2) => {
      }).then(delay3(this.afterResponseDelay, options.abort)).then((_2) => this.promiseStatus()), trailersPromise = responsePromise.catch((_2) => {
      }).then(delay3(this.afterResponseDelay, options.abort)).then((_2) => this.promiseTrailers());
      this.maybeSuppressUncaught(statusPromise, trailersPromise);
      this.lastInput = { single: input };
      return new unary_call_1.UnaryCall(method, requestHeaders, input, headersPromise, responsePromise, statusPromise, trailersPromise);
    }
    serverStreaming(method, input, options) {
      var _a3;
      const requestHeaders = (_a3 = options.meta) !== null && _a3 !== undefined ? _a3 : {}, headersPromise = this.promiseHeaders().then(delay3(this.headerDelay, options.abort)), outputStream = new rpc_output_stream_1.RpcOutputStreamController, responseStreamClosedPromise = headersPromise.then(delay3(this.responseDelay, options.abort)).catch(() => {
      }).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay3(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
      this.maybeSuppressUncaught(statusPromise, trailersPromise);
      this.lastInput = { single: input };
      return new server_streaming_call_1.ServerStreamingCall(method, requestHeaders, input, headersPromise, outputStream, statusPromise, trailersPromise);
    }
    clientStreaming(method, options) {
      var _a3;
      const requestHeaders = (_a3 = options.meta) !== null && _a3 !== undefined ? _a3 : {}, headersPromise = this.promiseHeaders().then(delay3(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_2) => {
      }).then(delay3(this.responseDelay, options.abort)).then((_2) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_2) => {
      }).then(delay3(this.afterResponseDelay, options.abort)).then((_2) => this.promiseStatus()), trailersPromise = responsePromise.catch((_2) => {
      }).then(delay3(this.afterResponseDelay, options.abort)).then((_2) => this.promiseTrailers());
      this.maybeSuppressUncaught(statusPromise, trailersPromise);
      this.lastInput = new TestInputStream(this.data, options.abort);
      return new client_streaming_call_1.ClientStreamingCall(method, requestHeaders, this.lastInput, headersPromise, responsePromise, statusPromise, trailersPromise);
    }
    duplex(method, options) {
      var _a3;
      const requestHeaders = (_a3 = options.meta) !== null && _a3 !== undefined ? _a3 : {}, headersPromise = this.promiseHeaders().then(delay3(this.headerDelay, options.abort)), outputStream = new rpc_output_stream_1.RpcOutputStreamController, responseStreamClosedPromise = headersPromise.then(delay3(this.responseDelay, options.abort)).catch(() => {
      }).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay3(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
      this.maybeSuppressUncaught(statusPromise, trailersPromise);
      this.lastInput = new TestInputStream(this.data, options.abort);
      return new duplex_streaming_call_1.DuplexStreamingCall(method, requestHeaders, this.lastInput, headersPromise, outputStream, statusPromise, trailersPromise);
    }
  }
  exports.TestTransport = TestTransport;
  TestTransport.defaultHeaders = {
    responseHeader: "test"
  };
  TestTransport.defaultStatus = {
    code: "OK",
    detail: "all good"
  };
  TestTransport.defaultTrailers = {
    responseTrailer: "test"
  };
  function delay3(ms, abort) {
    return (v2) => new Promise((resolve5, reject) => {
      if (abort === null || abort === undefined ? undefined : abort.aborted) {
        reject(new rpc_error_1.RpcError("user cancel", "CANCELLED"));
      } else {
        const id = setTimeout(() => resolve5(v2), ms);
        if (abort) {
          abort.addEventListener("abort", (ev) => {
            clearTimeout(id);
            reject(new rpc_error_1.RpcError("user cancel", "CANCELLED"));
          });
        }
      }
    });
  }

  class TestInputStream {
    constructor(data, abort) {
      this._completed = false;
      this._sent = [];
      this.data = data;
      this.abort = abort;
    }
    get sent() {
      return this._sent;
    }
    get completed() {
      return this._completed;
    }
    send(message) {
      if (this.data.inputMessage instanceof rpc_error_1.RpcError) {
        return Promise.reject(this.data.inputMessage);
      }
      const delayMs = this.data.inputMessage === undefined ? 10 : this.data.inputMessage;
      return Promise.resolve(undefined).then(() => {
        this._sent.push(message);
      }).then(delay3(delayMs, this.abort));
    }
    complete() {
      if (this.data.inputComplete instanceof rpc_error_1.RpcError) {
        return Promise.reject(this.data.inputComplete);
      }
      const delayMs = this.data.inputComplete === undefined ? 10 : this.data.inputComplete;
      return Promise.resolve(undefined).then(() => {
        this._completed = true;
      }).then(delay3(delayMs, this.abort));
    }
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/rpc-interceptor.js
var require_rpc_interceptor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.stackDuplexStreamingInterceptors = exports.stackClientStreamingInterceptors = exports.stackServerStreamingInterceptors = exports.stackUnaryInterceptors = exports.stackIntercept = undefined;
  var runtime_1 = require_commonjs13();
  function stackIntercept(kind, transport, method, options, input) {
    var _a3, _b2, _c2, _d2;
    if (kind == "unary") {
      let tail = (mtd, inp, opt) => transport.unary(mtd, inp, opt);
      for (const curr of ((_a3 = options.interceptors) !== null && _a3 !== undefined ? _a3 : []).filter((i2) => i2.interceptUnary).reverse()) {
        const next = tail;
        tail = (mtd, inp, opt) => curr.interceptUnary(next, mtd, inp, opt);
      }
      return tail(method, input, options);
    }
    if (kind == "serverStreaming") {
      let tail = (mtd, inp, opt) => transport.serverStreaming(mtd, inp, opt);
      for (const curr of ((_b2 = options.interceptors) !== null && _b2 !== undefined ? _b2 : []).filter((i2) => i2.interceptServerStreaming).reverse()) {
        const next = tail;
        tail = (mtd, inp, opt) => curr.interceptServerStreaming(next, mtd, inp, opt);
      }
      return tail(method, input, options);
    }
    if (kind == "clientStreaming") {
      let tail = (mtd, opt) => transport.clientStreaming(mtd, opt);
      for (const curr of ((_c2 = options.interceptors) !== null && _c2 !== undefined ? _c2 : []).filter((i2) => i2.interceptClientStreaming).reverse()) {
        const next = tail;
        tail = (mtd, opt) => curr.interceptClientStreaming(next, mtd, opt);
      }
      return tail(method, options);
    }
    if (kind == "duplex") {
      let tail = (mtd, opt) => transport.duplex(mtd, opt);
      for (const curr of ((_d2 = options.interceptors) !== null && _d2 !== undefined ? _d2 : []).filter((i2) => i2.interceptDuplex).reverse()) {
        const next = tail;
        tail = (mtd, opt) => curr.interceptDuplex(next, mtd, opt);
      }
      return tail(method, options);
    }
    runtime_1.assertNever(kind);
  }
  exports.stackIntercept = stackIntercept;
  function stackUnaryInterceptors(transport, method, input, options) {
    return stackIntercept("unary", transport, method, options, input);
  }
  exports.stackUnaryInterceptors = stackUnaryInterceptors;
  function stackServerStreamingInterceptors(transport, method, input, options) {
    return stackIntercept("serverStreaming", transport, method, options, input);
  }
  exports.stackServerStreamingInterceptors = stackServerStreamingInterceptors;
  function stackClientStreamingInterceptors(transport, method, options) {
    return stackIntercept("clientStreaming", transport, method, options);
  }
  exports.stackClientStreamingInterceptors = stackClientStreamingInterceptors;
  function stackDuplexStreamingInterceptors(transport, method, options) {
    return stackIntercept("duplex", transport, method, options);
  }
  exports.stackDuplexStreamingInterceptors = stackDuplexStreamingInterceptors;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/server-call-context.js
var require_server_call_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerCallContextController = undefined;

  class ServerCallContextController {
    constructor(method, headers, deadline, sendResponseHeadersFn, defaultStatus = { code: "OK", detail: "" }) {
      this._cancelled = false;
      this._listeners = [];
      this.method = method;
      this.headers = headers;
      this.deadline = deadline;
      this.trailers = {};
      this._sendRH = sendResponseHeadersFn;
      this.status = defaultStatus;
    }
    notifyCancelled() {
      if (!this._cancelled) {
        this._cancelled = true;
        for (let l2 of this._listeners) {
          l2();
        }
      }
    }
    sendResponseHeaders(data) {
      this._sendRH(data);
    }
    get cancelled() {
      return this._cancelled;
    }
    onCancel(callback) {
      const l2 = this._listeners;
      l2.push(callback);
      return () => {
        let i2 = l2.indexOf(callback);
        if (i2 >= 0)
          l2.splice(i2, 1);
      };
    }
  }
  exports.ServerCallContextController = ServerCallContextController;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/index.js
var require_commonjs14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var service_type_1 = require_service_type();
  Object.defineProperty(exports, "ServiceType", { enumerable: true, get: function() {
    return service_type_1.ServiceType;
  } });
  var reflection_info_1 = require_reflection_info2();
  Object.defineProperty(exports, "readMethodOptions", { enumerable: true, get: function() {
    return reflection_info_1.readMethodOptions;
  } });
  Object.defineProperty(exports, "readMethodOption", { enumerable: true, get: function() {
    return reflection_info_1.readMethodOption;
  } });
  Object.defineProperty(exports, "readServiceOption", { enumerable: true, get: function() {
    return reflection_info_1.readServiceOption;
  } });
  var rpc_error_1 = require_rpc_error();
  Object.defineProperty(exports, "RpcError", { enumerable: true, get: function() {
    return rpc_error_1.RpcError;
  } });
  var rpc_options_1 = require_rpc_options();
  Object.defineProperty(exports, "mergeRpcOptions", { enumerable: true, get: function() {
    return rpc_options_1.mergeRpcOptions;
  } });
  var rpc_output_stream_1 = require_rpc_output_stream();
  Object.defineProperty(exports, "RpcOutputStreamController", { enumerable: true, get: function() {
    return rpc_output_stream_1.RpcOutputStreamController;
  } });
  var test_transport_1 = require_test_transport();
  Object.defineProperty(exports, "TestTransport", { enumerable: true, get: function() {
    return test_transport_1.TestTransport;
  } });
  var deferred_1 = require_deferred();
  Object.defineProperty(exports, "Deferred", { enumerable: true, get: function() {
    return deferred_1.Deferred;
  } });
  Object.defineProperty(exports, "DeferredState", { enumerable: true, get: function() {
    return deferred_1.DeferredState;
  } });
  var duplex_streaming_call_1 = require_duplex_streaming_call();
  Object.defineProperty(exports, "DuplexStreamingCall", { enumerable: true, get: function() {
    return duplex_streaming_call_1.DuplexStreamingCall;
  } });
  var client_streaming_call_1 = require_client_streaming_call();
  Object.defineProperty(exports, "ClientStreamingCall", { enumerable: true, get: function() {
    return client_streaming_call_1.ClientStreamingCall;
  } });
  var server_streaming_call_1 = require_server_streaming_call();
  Object.defineProperty(exports, "ServerStreamingCall", { enumerable: true, get: function() {
    return server_streaming_call_1.ServerStreamingCall;
  } });
  var unary_call_1 = require_unary_call();
  Object.defineProperty(exports, "UnaryCall", { enumerable: true, get: function() {
    return unary_call_1.UnaryCall;
  } });
  var rpc_interceptor_1 = require_rpc_interceptor();
  Object.defineProperty(exports, "stackIntercept", { enumerable: true, get: function() {
    return rpc_interceptor_1.stackIntercept;
  } });
  Object.defineProperty(exports, "stackDuplexStreamingInterceptors", { enumerable: true, get: function() {
    return rpc_interceptor_1.stackDuplexStreamingInterceptors;
  } });
  Object.defineProperty(exports, "stackClientStreamingInterceptors", { enumerable: true, get: function() {
    return rpc_interceptor_1.stackClientStreamingInterceptors;
  } });
  Object.defineProperty(exports, "stackServerStreamingInterceptors", { enumerable: true, get: function() {
    return rpc_interceptor_1.stackServerStreamingInterceptors;
  } });
  Object.defineProperty(exports, "stackUnaryInterceptors", { enumerable: true, get: function() {
    return rpc_interceptor_1.stackUnaryInterceptors;
  } });
  var server_call_context_1 = require_server_call_context();
  Object.defineProperty(exports, "ServerCallContextController", { enumerable: true, get: function() {
    return server_call_context_1.ServerCallContextController;
  } });
});

// node_modules/@actions/cache/lib/generated/results/entities/v1/cachescope.js
var require_cachescope = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CacheScope = undefined;
  var runtime_1 = require_commonjs13();
  var runtime_2 = require_commonjs13();
  var runtime_3 = require_commonjs13();
  var runtime_4 = require_commonjs13();
  var runtime_5 = require_commonjs13();

  class CacheScope$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.entities.v1.CacheScope", [
        { no: 1, name: "scope", kind: "scalar", T: 9 },
        { no: 2, name: "permission", kind: "scalar", T: 3 }
      ]);
    }
    create(value) {
      const message = { scope: "", permission: "0" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.scope = reader.string();
            break;
          case 2:
            message.permission = reader.int64().toString();
            break;
          default:
            let u2 = options.readUnknownField;
            if (u2 === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d2 = reader.skip(wireType);
            if (u2 !== false)
              (u2 === true ? runtime_2.UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d2);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.scope !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.scope);
      if (message.permission !== "0")
        writer.tag(2, runtime_1.WireType.Varint).int64(message.permission);
      let u2 = options.writeUnknownFields;
      if (u2 !== false)
        (u2 == true ? runtime_2.UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.CacheScope = new CacheScope$Type;
});

// node_modules/@actions/cache/lib/generated/results/entities/v1/cachemetadata.js
var require_cachemetadata = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CacheMetadata = undefined;
  var runtime_1 = require_commonjs13();
  var runtime_2 = require_commonjs13();
  var runtime_3 = require_commonjs13();
  var runtime_4 = require_commonjs13();
  var runtime_5 = require_commonjs13();
  var cachescope_1 = require_cachescope();

  class CacheMetadata$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.entities.v1.CacheMetadata", [
        { no: 1, name: "repository_id", kind: "scalar", T: 3 },
        { no: 2, name: "scope", kind: "message", repeat: 1, T: () => cachescope_1.CacheScope }
      ]);
    }
    create(value) {
      const message = { repositoryId: "0", scope: [] };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.repositoryId = reader.int64().toString();
            break;
          case 2:
            message.scope.push(cachescope_1.CacheScope.internalBinaryRead(reader, reader.uint32(), options));
            break;
          default:
            let u2 = options.readUnknownField;
            if (u2 === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d2 = reader.skip(wireType);
            if (u2 !== false)
              (u2 === true ? runtime_2.UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d2);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.repositoryId !== "0")
        writer.tag(1, runtime_1.WireType.Varint).int64(message.repositoryId);
      for (let i2 = 0;i2 < message.scope.length; i2++)
        cachescope_1.CacheScope.internalBinaryWrite(message.scope[i2], writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
      let u2 = options.writeUnknownFields;
      if (u2 !== false)
        (u2 == true ? runtime_2.UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.CacheMetadata = new CacheMetadata$Type;
});

// node_modules/@actions/cache/lib/generated/results/api/v1/cache.js
var require_cache2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CacheService = exports.GetCacheEntryDownloadURLResponse = exports.GetCacheEntryDownloadURLRequest = exports.FinalizeCacheEntryUploadResponse = exports.FinalizeCacheEntryUploadRequest = exports.CreateCacheEntryResponse = exports.CreateCacheEntryRequest = undefined;
  var runtime_rpc_1 = require_commonjs14();
  var runtime_1 = require_commonjs13();
  var runtime_2 = require_commonjs13();
  var runtime_3 = require_commonjs13();
  var runtime_4 = require_commonjs13();
  var runtime_5 = require_commonjs13();
  var cachemetadata_1 = require_cachemetadata();

  class CreateCacheEntryRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.CreateCacheEntryRequest", [
        { no: 1, name: "metadata", kind: "message", T: () => cachemetadata_1.CacheMetadata },
        { no: 2, name: "key", kind: "scalar", T: 9 },
        { no: 3, name: "version", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { key: "", version: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.metadata = cachemetadata_1.CacheMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
            break;
          case 2:
            message.key = reader.string();
            break;
          case 3:
            message.version = reader.string();
            break;
          default:
            let u2 = options.readUnknownField;
            if (u2 === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d2 = reader.skip(wireType);
            if (u2 !== false)
              (u2 === true ? runtime_2.UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d2);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.metadata)
        cachemetadata_1.CacheMetadata.internalBinaryWrite(message.metadata, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.key !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.key);
      if (message.version !== "")
        writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.version);
      let u2 = options.writeUnknownFields;
      if (u2 !== false)
        (u2 == true ? runtime_2.UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.CreateCacheEntryRequest = new CreateCacheEntryRequest$Type;

  class CreateCacheEntryResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.CreateCacheEntryResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "signed_upload_url", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { ok: false, signedUploadUrl: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.signedUploadUrl = reader.string();
            break;
          default:
            let u2 = options.readUnknownField;
            if (u2 === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d2 = reader.skip(wireType);
            if (u2 !== false)
              (u2 === true ? runtime_2.UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d2);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== false)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.signedUploadUrl !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.signedUploadUrl);
      let u2 = options.writeUnknownFields;
      if (u2 !== false)
        (u2 == true ? runtime_2.UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.CreateCacheEntryResponse = new CreateCacheEntryResponse$Type;

  class FinalizeCacheEntryUploadRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.FinalizeCacheEntryUploadRequest", [
        { no: 1, name: "metadata", kind: "message", T: () => cachemetadata_1.CacheMetadata },
        { no: 2, name: "key", kind: "scalar", T: 9 },
        { no: 3, name: "size_bytes", kind: "scalar", T: 3 },
        { no: 4, name: "version", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { key: "", sizeBytes: "0", version: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.metadata = cachemetadata_1.CacheMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
            break;
          case 2:
            message.key = reader.string();
            break;
          case 3:
            message.sizeBytes = reader.int64().toString();
            break;
          case 4:
            message.version = reader.string();
            break;
          default:
            let u2 = options.readUnknownField;
            if (u2 === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d2 = reader.skip(wireType);
            if (u2 !== false)
              (u2 === true ? runtime_2.UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d2);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.metadata)
        cachemetadata_1.CacheMetadata.internalBinaryWrite(message.metadata, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.key !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.key);
      if (message.sizeBytes !== "0")
        writer.tag(3, runtime_1.WireType.Varint).int64(message.sizeBytes);
      if (message.version !== "")
        writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.version);
      let u2 = options.writeUnknownFields;
      if (u2 !== false)
        (u2 == true ? runtime_2.UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.FinalizeCacheEntryUploadRequest = new FinalizeCacheEntryUploadRequest$Type;

  class FinalizeCacheEntryUploadResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.FinalizeCacheEntryUploadResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "entry_id", kind: "scalar", T: 3 }
      ]);
    }
    create(value) {
      const message = { ok: false, entryId: "0" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.entryId = reader.int64().toString();
            break;
          default:
            let u2 = options.readUnknownField;
            if (u2 === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d2 = reader.skip(wireType);
            if (u2 !== false)
              (u2 === true ? runtime_2.UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d2);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== false)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.entryId !== "0")
        writer.tag(2, runtime_1.WireType.Varint).int64(message.entryId);
      let u2 = options.writeUnknownFields;
      if (u2 !== false)
        (u2 == true ? runtime_2.UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.FinalizeCacheEntryUploadResponse = new FinalizeCacheEntryUploadResponse$Type;

  class GetCacheEntryDownloadURLRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.GetCacheEntryDownloadURLRequest", [
        { no: 1, name: "metadata", kind: "message", T: () => cachemetadata_1.CacheMetadata },
        { no: 2, name: "key", kind: "scalar", T: 9 },
        { no: 3, name: "restore_keys", kind: "scalar", repeat: 2, T: 9 },
        { no: 4, name: "version", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { key: "", restoreKeys: [], version: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.metadata = cachemetadata_1.CacheMetadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
            break;
          case 2:
            message.key = reader.string();
            break;
          case 3:
            message.restoreKeys.push(reader.string());
            break;
          case 4:
            message.version = reader.string();
            break;
          default:
            let u2 = options.readUnknownField;
            if (u2 === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d2 = reader.skip(wireType);
            if (u2 !== false)
              (u2 === true ? runtime_2.UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d2);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.metadata)
        cachemetadata_1.CacheMetadata.internalBinaryWrite(message.metadata, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.key !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.key);
      for (let i2 = 0;i2 < message.restoreKeys.length; i2++)
        writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.restoreKeys[i2]);
      if (message.version !== "")
        writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.version);
      let u2 = options.writeUnknownFields;
      if (u2 !== false)
        (u2 == true ? runtime_2.UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.GetCacheEntryDownloadURLRequest = new GetCacheEntryDownloadURLRequest$Type;

  class GetCacheEntryDownloadURLResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.GetCacheEntryDownloadURLResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "signed_download_url", kind: "scalar", T: 9 },
        { no: 3, name: "matched_key", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      const message = { ok: false, signedDownloadUrl: "", matchedKey: "" };
      globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
      if (value !== undefined)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== undefined ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.signedDownloadUrl = reader.string();
            break;
          case 3:
            message.matchedKey = reader.string();
            break;
          default:
            let u2 = options.readUnknownField;
            if (u2 === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d2 = reader.skip(wireType);
            if (u2 !== false)
              (u2 === true ? runtime_2.UnknownFieldHandler.onRead : u2)(this.typeName, message, fieldNo, wireType, d2);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== false)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.signedDownloadUrl !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.signedDownloadUrl);
      if (message.matchedKey !== "")
        writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.matchedKey);
      let u2 = options.writeUnknownFields;
      if (u2 !== false)
        (u2 == true ? runtime_2.UnknownFieldHandler.onWrite : u2)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.GetCacheEntryDownloadURLResponse = new GetCacheEntryDownloadURLResponse$Type;
  exports.CacheService = new runtime_rpc_1.ServiceType("github.actions.results.api.v1.CacheService", [
    { name: "CreateCacheEntry", options: {}, I: exports.CreateCacheEntryRequest, O: exports.CreateCacheEntryResponse },
    { name: "FinalizeCacheEntryUpload", options: {}, I: exports.FinalizeCacheEntryUploadRequest, O: exports.FinalizeCacheEntryUploadResponse },
    { name: "GetCacheEntryDownloadURL", options: {}, I: exports.GetCacheEntryDownloadURLRequest, O: exports.GetCacheEntryDownloadURLResponse }
  ]);
});

// node_modules/@actions/cache/lib/generated/results/api/v1/cache.twirp-client.js
var require_cache_twirp_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CacheServiceClientProtobuf = exports.CacheServiceClientJSON = undefined;
  var cache_1 = require_cache2();

  class CacheServiceClientJSON {
    constructor(rpc) {
      this.rpc = rpc;
      this.CreateCacheEntry.bind(this);
      this.FinalizeCacheEntryUpload.bind(this);
      this.GetCacheEntryDownloadURL.bind(this);
    }
    CreateCacheEntry(request9) {
      const data = cache_1.CreateCacheEntryRequest.toJson(request9, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "CreateCacheEntry", "application/json", data);
      return promise.then((data2) => cache_1.CreateCacheEntryResponse.fromJson(data2, {
        ignoreUnknownFields: true
      }));
    }
    FinalizeCacheEntryUpload(request9) {
      const data = cache_1.FinalizeCacheEntryUploadRequest.toJson(request9, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "FinalizeCacheEntryUpload", "application/json", data);
      return promise.then((data2) => cache_1.FinalizeCacheEntryUploadResponse.fromJson(data2, {
        ignoreUnknownFields: true
      }));
    }
    GetCacheEntryDownloadURL(request9) {
      const data = cache_1.GetCacheEntryDownloadURLRequest.toJson(request9, {
        useProtoFieldName: true,
        emitDefaultValues: false
      });
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "GetCacheEntryDownloadURL", "application/json", data);
      return promise.then((data2) => cache_1.GetCacheEntryDownloadURLResponse.fromJson(data2, {
        ignoreUnknownFields: true
      }));
    }
  }
  exports.CacheServiceClientJSON = CacheServiceClientJSON;

  class CacheServiceClientProtobuf {
    constructor(rpc) {
      this.rpc = rpc;
      this.CreateCacheEntry.bind(this);
      this.FinalizeCacheEntryUpload.bind(this);
      this.GetCacheEntryDownloadURL.bind(this);
    }
    CreateCacheEntry(request9) {
      const data = cache_1.CreateCacheEntryRequest.toBinary(request9);
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "CreateCacheEntry", "application/protobuf", data);
      return promise.then((data2) => cache_1.CreateCacheEntryResponse.fromBinary(data2));
    }
    FinalizeCacheEntryUpload(request9) {
      const data = cache_1.FinalizeCacheEntryUploadRequest.toBinary(request9);
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "FinalizeCacheEntryUpload", "application/protobuf", data);
      return promise.then((data2) => cache_1.FinalizeCacheEntryUploadResponse.fromBinary(data2));
    }
    GetCacheEntryDownloadURL(request9) {
      const data = cache_1.GetCacheEntryDownloadURLRequest.toBinary(request9);
      const promise = this.rpc.request("github.actions.results.api.v1.CacheService", "GetCacheEntryDownloadURL", "application/protobuf", data);
      return promise.then((data2) => cache_1.GetCacheEntryDownloadURLResponse.fromBinary(data2));
    }
  }
  exports.CacheServiceClientProtobuf = CacheServiceClientProtobuf;
});

// node_modules/@actions/cache/lib/internal/shared/util.js
var require_util9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.maskSecretUrls = exports.maskSigUrl = undefined;
  var core_1 = require_core();
  function maskSigUrl(url) {
    if (!url)
      return;
    try {
      const parsedUrl = new URL(url);
      const signature = parsedUrl.searchParams.get("sig");
      if (signature) {
        (0, core_1.setSecret)(signature);
        (0, core_1.setSecret)(encodeURIComponent(signature));
      }
    } catch (error) {
      (0, core_1.debug)(`Failed to parse URL: ${url} ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  exports.maskSigUrl = maskSigUrl;
  function maskSecretUrls(body) {
    if (typeof body !== "object" || body === null) {
      (0, core_1.debug)("body is not an object or is null");
      return;
    }
    if ("signed_upload_url" in body && typeof body.signed_upload_url === "string") {
      maskSigUrl(body.signed_upload_url);
    }
    if ("signed_download_url" in body && typeof body.signed_download_url === "string") {
      maskSigUrl(body.signed_download_url);
    }
  }
  exports.maskSecretUrls = maskSecretUrls;
});

// node_modules/@actions/cache/lib/internal/shared/cacheTwirpClient.js
var require_cacheTwirpClient = __commonJS((exports) => {
  var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve5, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.internalCacheTwirpClient = undefined;
  var core_1 = require_core();
  var user_agent_1 = require_user_agent();
  var errors_1 = require_errors4();
  var config_1 = require_config();
  var cacheUtils_1 = require_cacheUtils();
  var auth_1 = require_auth();
  var http_client_1 = require_lib();
  var cache_twirp_client_1 = require_cache_twirp_client();
  var util_1 = require_util9();

  class CacheServiceClient {
    constructor(userAgent7, maxAttempts, baseRetryIntervalMilliseconds, retryMultiplier) {
      this.maxAttempts = 5;
      this.baseRetryIntervalMilliseconds = 3000;
      this.retryMultiplier = 1.5;
      const token = (0, cacheUtils_1.getRuntimeToken)();
      this.baseUrl = (0, config_1.getCacheServiceURL)();
      if (maxAttempts) {
        this.maxAttempts = maxAttempts;
      }
      if (baseRetryIntervalMilliseconds) {
        this.baseRetryIntervalMilliseconds = baseRetryIntervalMilliseconds;
      }
      if (retryMultiplier) {
        this.retryMultiplier = retryMultiplier;
      }
      this.httpClient = new http_client_1.HttpClient(userAgent7, [
        new auth_1.BearerCredentialHandler(token)
      ]);
    }
    request(service, method, contentType, data) {
      return __awaiter2(this, undefined, undefined, function* () {
        const url = new URL(`/twirp/${service}/${method}`, this.baseUrl).href;
        (0, core_1.debug)(`[Request] ${method} ${url}`);
        const headers = {
          "Content-Type": contentType
        };
        try {
          const { body } = yield this.retryableRequest(() => __awaiter2(this, undefined, undefined, function* () {
            return this.httpClient.post(url, JSON.stringify(data), headers);
          }));
          return body;
        } catch (error) {
          throw new Error(`Failed to ${method}: ${error.message}`);
        }
      });
    }
    retryableRequest(operation) {
      return __awaiter2(this, undefined, undefined, function* () {
        let attempt = 0;
        let errorMessage = "";
        let rawBody = "";
        while (attempt < this.maxAttempts) {
          let isRetryable = false;
          try {
            const response = yield operation();
            const statusCode = response.message.statusCode;
            rawBody = yield response.readBody();
            (0, core_1.debug)(`[Response] - ${response.message.statusCode}`);
            (0, core_1.debug)(`Headers: ${JSON.stringify(response.message.headers, null, 2)}`);
            const body = JSON.parse(rawBody);
            (0, util_1.maskSecretUrls)(body);
            (0, core_1.debug)(`Body: ${JSON.stringify(body, null, 2)}`);
            if (this.isSuccessStatusCode(statusCode)) {
              return { response, body };
            }
            isRetryable = this.isRetryableHttpStatusCode(statusCode);
            errorMessage = `Failed request: (${statusCode}) ${response.message.statusMessage}`;
            if (body.msg) {
              if (errors_1.UsageError.isUsageErrorMessage(body.msg)) {
                throw new errors_1.UsageError;
              }
              errorMessage = `${errorMessage}: ${body.msg}`;
            }
          } catch (error) {
            if (error instanceof SyntaxError) {
              (0, core_1.debug)(`Raw Body: ${rawBody}`);
            }
            if (error instanceof errors_1.UsageError) {
              throw error;
            }
            if (errors_1.NetworkError.isNetworkErrorCode(error === null || error === undefined ? undefined : error.code)) {
              throw new errors_1.NetworkError(error === null || error === undefined ? undefined : error.code);
            }
            isRetryable = true;
            errorMessage = error.message;
          }
          if (!isRetryable) {
            throw new Error(`Received non-retryable error: ${errorMessage}`);
          }
          if (attempt + 1 === this.maxAttempts) {
            throw new Error(`Failed to make request after ${this.maxAttempts} attempts: ${errorMessage}`);
          }
          const retryTimeMilliseconds = this.getExponentialRetryTimeMilliseconds(attempt);
          (0, core_1.info)(`Attempt ${attempt + 1} of ${this.maxAttempts} failed with error: ${errorMessage}. Retrying request in ${retryTimeMilliseconds} ms...`);
          yield this.sleep(retryTimeMilliseconds);
          attempt++;
        }
        throw new Error(`Request failed`);
      });
    }
    isSuccessStatusCode(statusCode) {
      if (!statusCode)
        return false;
      return statusCode >= 200 && statusCode < 300;
    }
    isRetryableHttpStatusCode(statusCode) {
      if (!statusCode)
        return false;
      const retryableStatusCodes = [
        http_client_1.HttpCodes.BadGateway,
        http_client_1.HttpCodes.GatewayTimeout,
        http_client_1.HttpCodes.InternalServerError,
        http_client_1.HttpCodes.ServiceUnavailable,
        http_client_1.HttpCodes.TooManyRequests
      ];
      return retryableStatusCodes.includes(statusCode);
    }
    sleep(milliseconds) {
      return __awaiter2(this, undefined, undefined, function* () {
        return new Promise((resolve5) => setTimeout(resolve5, milliseconds));
      });
    }
    getExponentialRetryTimeMilliseconds(attempt) {
      if (attempt < 0) {
        throw new Error("attempt should be a positive integer");
      }
      if (attempt === 0) {
        return this.baseRetryIntervalMilliseconds;
      }
      const minTime = this.baseRetryIntervalMilliseconds * Math.pow(this.retryMultiplier, attempt);
      const maxTime = minTime * this.retryMultiplier;
      return Math.trunc(Math.random() * (maxTime - minTime) + minTime);
    }
  }
  function internalCacheTwirpClient(options) {
    const client = new CacheServiceClient((0, user_agent_1.getUserAgentString)(), options === null || options === undefined ? undefined : options.maxAttempts, options === null || options === undefined ? undefined : options.retryIntervalMs, options === null || options === undefined ? undefined : options.retryMultiplier);
    return new cache_twirp_client_1.CacheServiceClientJSON(client);
  }
  exports.internalCacheTwirpClient = internalCacheTwirpClient;
});

// node_modules/@actions/cache/lib/internal/tar.js
var require_tar = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve5, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createTar = exports.extractTar = exports.listTar = undefined;
  var exec_1 = require_exec();
  var io = __importStar2(require_io());
  var fs_1 = __require("fs");
  var path2 = __importStar2(__require("path"));
  var utils = __importStar2(require_cacheUtils());
  var constants_1 = require_constants6();
  var IS_WINDOWS = process.platform === "win32";
  function getTarPath() {
    return __awaiter2(this, undefined, undefined, function* () {
      switch (process.platform) {
        case "win32": {
          const gnuTar = yield utils.getGnuTarPathOnWindows();
          const systemTar = constants_1.SystemTarPathOnWindows;
          if (gnuTar) {
            return { path: gnuTar, type: constants_1.ArchiveToolType.GNU };
          } else if ((0, fs_1.existsSync)(systemTar)) {
            return { path: systemTar, type: constants_1.ArchiveToolType.BSD };
          }
          break;
        }
        case "darwin": {
          const gnuTar = yield io.which("gtar", false);
          if (gnuTar) {
            return { path: gnuTar, type: constants_1.ArchiveToolType.GNU };
          } else {
            return {
              path: yield io.which("tar", true),
              type: constants_1.ArchiveToolType.BSD
            };
          }
        }
        default:
          break;
      }
      return {
        path: yield io.which("tar", true),
        type: constants_1.ArchiveToolType.GNU
      };
    });
  }
  function getTarArgs(tarPath, compressionMethod, type3, archivePath = "") {
    return __awaiter2(this, undefined, undefined, function* () {
      const args = [`"${tarPath.path}"`];
      const cacheFileName = utils.getCacheFileName(compressionMethod);
      const tarFile = "cache.tar";
      const workingDirectory = getWorkingDirectory();
      const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
      switch (type3) {
        case "create":
          args.push("--posix", "-cf", BSD_TAR_ZSTD ? tarFile : cacheFileName.replace(new RegExp(`\\${path2.sep}`, "g"), "/"), "--exclude", BSD_TAR_ZSTD ? tarFile : cacheFileName.replace(new RegExp(`\\${path2.sep}`, "g"), "/"), "-P", "-C", workingDirectory.replace(new RegExp(`\\${path2.sep}`, "g"), "/"), "--files-from", constants_1.ManifestFilename);
          break;
        case "extract":
          args.push("-xf", BSD_TAR_ZSTD ? tarFile : archivePath.replace(new RegExp(`\\${path2.sep}`, "g"), "/"), "-P", "-C", workingDirectory.replace(new RegExp(`\\${path2.sep}`, "g"), "/"));
          break;
        case "list":
          args.push("-tf", BSD_TAR_ZSTD ? tarFile : archivePath.replace(new RegExp(`\\${path2.sep}`, "g"), "/"), "-P");
          break;
      }
      if (tarPath.type === constants_1.ArchiveToolType.GNU) {
        switch (process.platform) {
          case "win32":
            args.push("--force-local");
            break;
          case "darwin":
            args.push("--delay-directory-restore");
            break;
        }
      }
      return args;
    });
  }
  function getCommands(compressionMethod, type3, archivePath = "") {
    return __awaiter2(this, undefined, undefined, function* () {
      let args;
      const tarPath = yield getTarPath();
      const tarArgs = yield getTarArgs(tarPath, compressionMethod, type3, archivePath);
      const compressionArgs = type3 !== "create" ? yield getDecompressionProgram(tarPath, compressionMethod, archivePath) : yield getCompressionProgram(tarPath, compressionMethod);
      const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
      if (BSD_TAR_ZSTD && type3 !== "create") {
        args = [[...compressionArgs].join(" "), [...tarArgs].join(" ")];
      } else {
        args = [[...tarArgs].join(" "), [...compressionArgs].join(" ")];
      }
      if (BSD_TAR_ZSTD) {
        return args;
      }
      return [args.join(" ")];
    });
  }
  function getWorkingDirectory() {
    var _a3;
    return (_a3 = process.env["GITHUB_WORKSPACE"]) !== null && _a3 !== undefined ? _a3 : process.cwd();
  }
  function getDecompressionProgram(tarPath, compressionMethod, archivePath) {
    return __awaiter2(this, undefined, undefined, function* () {
      const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
      switch (compressionMethod) {
        case constants_1.CompressionMethod.Zstd:
          return BSD_TAR_ZSTD ? [
            "zstd -d --long=30 --force -o",
            constants_1.TarFilename,
            archivePath.replace(new RegExp(`\\${path2.sep}`, "g"), "/")
          ] : [
            "--use-compress-program",
            IS_WINDOWS ? '"zstd -d --long=30"' : "unzstd --long=30"
          ];
        case constants_1.CompressionMethod.ZstdWithoutLong:
          return BSD_TAR_ZSTD ? [
            "zstd -d --force -o",
            constants_1.TarFilename,
            archivePath.replace(new RegExp(`\\${path2.sep}`, "g"), "/")
          ] : ["--use-compress-program", IS_WINDOWS ? '"zstd -d"' : "unzstd"];
        default:
          return ["-z"];
      }
    });
  }
  function getCompressionProgram(tarPath, compressionMethod) {
    return __awaiter2(this, undefined, undefined, function* () {
      const cacheFileName = utils.getCacheFileName(compressionMethod);
      const BSD_TAR_ZSTD = tarPath.type === constants_1.ArchiveToolType.BSD && compressionMethod !== constants_1.CompressionMethod.Gzip && IS_WINDOWS;
      switch (compressionMethod) {
        case constants_1.CompressionMethod.Zstd:
          return BSD_TAR_ZSTD ? [
            "zstd -T0 --long=30 --force -o",
            cacheFileName.replace(new RegExp(`\\${path2.sep}`, "g"), "/"),
            constants_1.TarFilename
          ] : [
            "--use-compress-program",
            IS_WINDOWS ? '"zstd -T0 --long=30"' : "zstdmt --long=30"
          ];
        case constants_1.CompressionMethod.ZstdWithoutLong:
          return BSD_TAR_ZSTD ? [
            "zstd -T0 --force -o",
            cacheFileName.replace(new RegExp(`\\${path2.sep}`, "g"), "/"),
            constants_1.TarFilename
          ] : ["--use-compress-program", IS_WINDOWS ? '"zstd -T0"' : "zstdmt"];
        default:
          return ["-z"];
      }
    });
  }
  function execCommands(commands, cwd) {
    return __awaiter2(this, undefined, undefined, function* () {
      for (const command of commands) {
        try {
          yield (0, exec_1.exec)(command, undefined, {
            cwd,
            env: Object.assign(Object.assign({}, process.env), { MSYS: "winsymlinks:nativestrict" })
          });
        } catch (error) {
          throw new Error(`${command.split(" ")[0]} failed with error: ${error === null || error === undefined ? undefined : error.message}`);
        }
      }
    });
  }
  function listTar(archivePath, compressionMethod) {
    return __awaiter2(this, undefined, undefined, function* () {
      const commands = yield getCommands(compressionMethod, "list", archivePath);
      yield execCommands(commands);
    });
  }
  exports.listTar = listTar;
  function extractTar(archivePath, compressionMethod) {
    return __awaiter2(this, undefined, undefined, function* () {
      const workingDirectory = getWorkingDirectory();
      yield io.mkdirP(workingDirectory);
      const commands = yield getCommands(compressionMethod, "extract", archivePath);
      yield execCommands(commands);
    });
  }
  exports.extractTar = extractTar;
  function createTar(archiveFolder, sourceDirectories, compressionMethod) {
    return __awaiter2(this, undefined, undefined, function* () {
      (0, fs_1.writeFileSync)(path2.join(archiveFolder, constants_1.ManifestFilename), sourceDirectories.join(`
`));
      const commands = yield getCommands(compressionMethod, "create");
      yield execCommands(commands, archiveFolder);
    });
  }
  exports.createTar = createTar;
});

// node_modules/@actions/cache/lib/cache.js
var require_cache3 = __commonJS((exports) => {
  var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o2, k22, desc);
  } : function(o2, m2, k2, k22) {
    if (k22 === undefined)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve5, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.saveCache = exports.restoreCache = exports.isFeatureAvailable = exports.ReserveCacheError = exports.ValidationError = undefined;
  var core = __importStar2(require_core());
  var path2 = __importStar2(__require("path"));
  var utils = __importStar2(require_cacheUtils());
  var cacheHttpClient = __importStar2(require_cacheHttpClient());
  var cacheTwirpClient = __importStar2(require_cacheTwirpClient());
  var config_1 = require_config();
  var tar_1 = require_tar();
  var constants_1 = require_constants6();

  class ValidationError extends Error {
    constructor(message) {
      super(message);
      this.name = "ValidationError";
      Object.setPrototypeOf(this, ValidationError.prototype);
    }
  }
  exports.ValidationError = ValidationError;

  class ReserveCacheError extends Error {
    constructor(message) {
      super(message);
      this.name = "ReserveCacheError";
      Object.setPrototypeOf(this, ReserveCacheError.prototype);
    }
  }
  exports.ReserveCacheError = ReserveCacheError;
  function checkPaths(paths) {
    if (!paths || paths.length === 0) {
      throw new ValidationError(`Path Validation Error: At least one directory or file path is required`);
    }
  }
  function checkKey(key) {
    if (key.length > 512) {
      throw new ValidationError(`Key Validation Error: ${key} cannot be larger than 512 characters.`);
    }
    const regex = /^[^,]*$/;
    if (!regex.test(key)) {
      throw new ValidationError(`Key Validation Error: ${key} cannot contain commas.`);
    }
  }
  function isFeatureAvailable() {
    return !!process.env["ACTIONS_CACHE_URL"];
  }
  exports.isFeatureAvailable = isFeatureAvailable;
  function restoreCache(paths, primaryKey, restoreKeys, options, enableCrossOsArchive = false) {
    return __awaiter2(this, undefined, undefined, function* () {
      const cacheServiceVersion = (0, config_1.getCacheServiceVersion)();
      core.debug(`Cache service version: ${cacheServiceVersion}`);
      checkPaths(paths);
      switch (cacheServiceVersion) {
        case "v2":
          return yield restoreCacheV2(paths, primaryKey, restoreKeys, options, enableCrossOsArchive);
        case "v1":
        default:
          return yield restoreCacheV1(paths, primaryKey, restoreKeys, options, enableCrossOsArchive);
      }
    });
  }
  exports.restoreCache = restoreCache;
  function restoreCacheV1(paths, primaryKey, restoreKeys, options, enableCrossOsArchive = false) {
    return __awaiter2(this, undefined, undefined, function* () {
      restoreKeys = restoreKeys || [];
      const keys = [primaryKey, ...restoreKeys];
      core.debug("Resolved Keys:");
      core.debug(JSON.stringify(keys));
      if (keys.length > 10) {
        throw new ValidationError(`Key Validation Error: Keys are limited to a maximum of 10.`);
      }
      for (const key of keys) {
        checkKey(key);
      }
      const compressionMethod = yield utils.getCompressionMethod();
      let archivePath = "";
      try {
        const cacheEntry = yield cacheHttpClient.getCacheEntry(keys, paths, {
          compressionMethod,
          enableCrossOsArchive
        });
        if (!(cacheEntry === null || cacheEntry === undefined ? undefined : cacheEntry.archiveLocation)) {
          return;
        }
        if (options === null || options === undefined ? undefined : options.lookupOnly) {
          core.info("Lookup only - skipping download");
          return cacheEntry.cacheKey;
        }
        archivePath = path2.join(yield utils.createTempDirectory(), utils.getCacheFileName(compressionMethod));
        core.debug(`Archive Path: ${archivePath}`);
        yield cacheHttpClient.downloadCache(cacheEntry.archiveLocation, archivePath, options);
        if (core.isDebug()) {
          yield (0, tar_1.listTar)(archivePath, compressionMethod);
        }
        const archiveFileSize = utils.getArchiveFileSizeInBytes(archivePath);
        core.info(`Cache Size: ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B)`);
        yield (0, tar_1.extractTar)(archivePath, compressionMethod);
        core.info("Cache restored successfully");
        return cacheEntry.cacheKey;
      } catch (error) {
        const typedError = error;
        if (typedError.name === ValidationError.name) {
          throw error;
        } else {
          core.warning(`Failed to restore: ${error.message}`);
        }
      } finally {
        try {
          yield utils.unlinkFile(archivePath);
        } catch (error) {
          core.debug(`Failed to delete archive: ${error}`);
        }
      }
      return;
    });
  }
  function restoreCacheV2(paths, primaryKey, restoreKeys, options, enableCrossOsArchive = false) {
    return __awaiter2(this, undefined, undefined, function* () {
      options = Object.assign(Object.assign({}, options), { useAzureSdk: true });
      restoreKeys = restoreKeys || [];
      const keys = [primaryKey, ...restoreKeys];
      core.debug("Resolved Keys:");
      core.debug(JSON.stringify(keys));
      if (keys.length > 10) {
        throw new ValidationError(`Key Validation Error: Keys are limited to a maximum of 10.`);
      }
      for (const key of keys) {
        checkKey(key);
      }
      let archivePath = "";
      try {
        const twirpClient = cacheTwirpClient.internalCacheTwirpClient();
        const compressionMethod = yield utils.getCompressionMethod();
        const request9 = {
          key: primaryKey,
          restoreKeys,
          version: utils.getCacheVersion(paths, compressionMethod, enableCrossOsArchive)
        };
        const response = yield twirpClient.GetCacheEntryDownloadURL(request9);
        if (!response.ok) {
          core.debug(`Cache not found for version ${request9.version} of keys: ${keys.join(", ")}`);
          return;
        }
        core.info(`Cache hit for: ${request9.key}`);
        if (options === null || options === undefined ? undefined : options.lookupOnly) {
          core.info("Lookup only - skipping download");
          return response.matchedKey;
        }
        archivePath = path2.join(yield utils.createTempDirectory(), utils.getCacheFileName(compressionMethod));
        core.debug(`Archive path: ${archivePath}`);
        core.debug(`Starting download of archive to: ${archivePath}`);
        yield cacheHttpClient.downloadCache(response.signedDownloadUrl, archivePath, options);
        const archiveFileSize = utils.getArchiveFileSizeInBytes(archivePath);
        core.info(`Cache Size: ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B)`);
        if (core.isDebug()) {
          yield (0, tar_1.listTar)(archivePath, compressionMethod);
        }
        yield (0, tar_1.extractTar)(archivePath, compressionMethod);
        core.info("Cache restored successfully");
        return response.matchedKey;
      } catch (error) {
        const typedError = error;
        if (typedError.name === ValidationError.name) {
          throw error;
        } else {
          core.warning(`Failed to restore: ${error.message}`);
        }
      } finally {
        try {
          if (archivePath) {
            yield utils.unlinkFile(archivePath);
          }
        } catch (error) {
          core.debug(`Failed to delete archive: ${error}`);
        }
      }
      return;
    });
  }
  function saveCache(paths, key, options, enableCrossOsArchive = false) {
    return __awaiter2(this, undefined, undefined, function* () {
      const cacheServiceVersion = (0, config_1.getCacheServiceVersion)();
      core.debug(`Cache service version: ${cacheServiceVersion}`);
      checkPaths(paths);
      checkKey(key);
      switch (cacheServiceVersion) {
        case "v2":
          return yield saveCacheV2(paths, key, options, enableCrossOsArchive);
        case "v1":
        default:
          return yield saveCacheV1(paths, key, options, enableCrossOsArchive);
      }
    });
  }
  exports.saveCache = saveCache;
  function saveCacheV1(paths, key, options, enableCrossOsArchive = false) {
    var _a3, _b2, _c2, _d2, _e2;
    return __awaiter2(this, undefined, undefined, function* () {
      const compressionMethod = yield utils.getCompressionMethod();
      let cacheId = -1;
      const cachePaths = yield utils.resolvePaths(paths);
      core.debug("Cache Paths:");
      core.debug(`${JSON.stringify(cachePaths)}`);
      if (cachePaths.length === 0) {
        throw new Error(`Path Validation Error: Path(s) specified in the action for caching do(es) not exist, hence no cache is being saved.`);
      }
      const archiveFolder = yield utils.createTempDirectory();
      const archivePath = path2.join(archiveFolder, utils.getCacheFileName(compressionMethod));
      core.debug(`Archive Path: ${archivePath}`);
      try {
        yield (0, tar_1.createTar)(archiveFolder, cachePaths, compressionMethod);
        if (core.isDebug()) {
          yield (0, tar_1.listTar)(archivePath, compressionMethod);
        }
        const fileSizeLimit = 10 * 1024 * 1024 * 1024;
        const archiveFileSize = utils.getArchiveFileSizeInBytes(archivePath);
        core.debug(`File Size: ${archiveFileSize}`);
        if (archiveFileSize > fileSizeLimit && !(0, config_1.isGhes)()) {
          throw new Error(`Cache size of ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B) is over the 10GB limit, not saving cache.`);
        }
        core.debug("Reserving Cache");
        const reserveCacheResponse = yield cacheHttpClient.reserveCache(key, paths, {
          compressionMethod,
          enableCrossOsArchive,
          cacheSize: archiveFileSize
        });
        if ((_a3 = reserveCacheResponse === null || reserveCacheResponse === undefined ? undefined : reserveCacheResponse.result) === null || _a3 === undefined ? undefined : _a3.cacheId) {
          cacheId = (_b2 = reserveCacheResponse === null || reserveCacheResponse === undefined ? undefined : reserveCacheResponse.result) === null || _b2 === undefined ? undefined : _b2.cacheId;
        } else if ((reserveCacheResponse === null || reserveCacheResponse === undefined ? undefined : reserveCacheResponse.statusCode) === 400) {
          throw new Error((_d2 = (_c2 = reserveCacheResponse === null || reserveCacheResponse === undefined ? undefined : reserveCacheResponse.error) === null || _c2 === undefined ? undefined : _c2.message) !== null && _d2 !== undefined ? _d2 : `Cache size of ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B) is over the data cap limit, not saving cache.`);
        } else {
          throw new ReserveCacheError(`Unable to reserve cache with key ${key}, another job may be creating this cache. More details: ${(_e2 = reserveCacheResponse === null || reserveCacheResponse === undefined ? undefined : reserveCacheResponse.error) === null || _e2 === undefined ? undefined : _e2.message}`);
        }
        core.debug(`Saving Cache (ID: ${cacheId})`);
        yield cacheHttpClient.saveCache(cacheId, archivePath, "", options);
      } catch (error) {
        const typedError = error;
        if (typedError.name === ValidationError.name) {
          throw error;
        } else if (typedError.name === ReserveCacheError.name) {
          core.info(`Failed to save: ${typedError.message}`);
        } else {
          core.warning(`Failed to save: ${typedError.message}`);
        }
      } finally {
        try {
          yield utils.unlinkFile(archivePath);
        } catch (error) {
          core.debug(`Failed to delete archive: ${error}`);
        }
      }
      return cacheId;
    });
  }
  function saveCacheV2(paths, key, options, enableCrossOsArchive = false) {
    return __awaiter2(this, undefined, undefined, function* () {
      options = Object.assign(Object.assign({}, options), { uploadChunkSize: 64 * 1024 * 1024, uploadConcurrency: 8, useAzureSdk: true });
      const compressionMethod = yield utils.getCompressionMethod();
      const twirpClient = cacheTwirpClient.internalCacheTwirpClient();
      let cacheId = -1;
      const cachePaths = yield utils.resolvePaths(paths);
      core.debug("Cache Paths:");
      core.debug(`${JSON.stringify(cachePaths)}`);
      if (cachePaths.length === 0) {
        throw new Error(`Path Validation Error: Path(s) specified in the action for caching do(es) not exist, hence no cache is being saved.`);
      }
      const archiveFolder = yield utils.createTempDirectory();
      const archivePath = path2.join(archiveFolder, utils.getCacheFileName(compressionMethod));
      core.debug(`Archive Path: ${archivePath}`);
      try {
        yield (0, tar_1.createTar)(archiveFolder, cachePaths, compressionMethod);
        if (core.isDebug()) {
          yield (0, tar_1.listTar)(archivePath, compressionMethod);
        }
        const archiveFileSize = utils.getArchiveFileSizeInBytes(archivePath);
        core.debug(`File Size: ${archiveFileSize}`);
        if (archiveFileSize > constants_1.CacheFileSizeLimit && !(0, config_1.isGhes)()) {
          throw new Error(`Cache size of ~${Math.round(archiveFileSize / (1024 * 1024))} MB (${archiveFileSize} B) is over the 10GB limit, not saving cache.`);
        }
        options.archiveSizeBytes = archiveFileSize;
        core.debug("Reserving Cache");
        const version = utils.getCacheVersion(paths, compressionMethod, enableCrossOsArchive);
        const request9 = {
          key,
          version
        };
        let signedUploadUrl;
        try {
          const response = yield twirpClient.CreateCacheEntry(request9);
          if (!response.ok) {
            throw new Error("Response was not ok");
          }
          signedUploadUrl = response.signedUploadUrl;
        } catch (error) {
          core.debug(`Failed to reserve cache: ${error}`);
          throw new ReserveCacheError(`Unable to reserve cache with key ${key}, another job may be creating this cache.`);
        }
        core.debug(`Attempting to upload cache located at: ${archivePath}`);
        yield cacheHttpClient.saveCache(cacheId, archivePath, signedUploadUrl, options);
        const finalizeRequest = {
          key,
          version,
          sizeBytes: `${archiveFileSize}`
        };
        const finalizeResponse = yield twirpClient.FinalizeCacheEntryUpload(finalizeRequest);
        core.debug(`FinalizeCacheEntryUploadResponse: ${finalizeResponse.ok}`);
        if (!finalizeResponse.ok) {
          throw new Error(`Unable to finalize cache with key ${key}, another job may be finalizing this cache.`);
        }
        cacheId = parseInt(finalizeResponse.entryId);
      } catch (error) {
        const typedError = error;
        if (typedError.name === ValidationError.name) {
          throw error;
        } else if (typedError.name === ReserveCacheError.name) {
          core.info(`Failed to save: ${typedError.message}`);
        } else {
          core.warning(`Failed to save: ${typedError.message}`);
        }
      } finally {
        try {
          yield utils.unlinkFile(archivePath);
        } catch (error) {
          core.debug(`Failed to delete archive: ${error}`);
        }
      }
      return cacheId;
    });
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS((exports, module) => {
  (function() {
    var undefined2;
    var VERSION23 = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag2 = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag2] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag2] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "c",
      "": "D",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "N",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "Y",
      "": "y",
      "": "y",
      "": "Ae",
      "": "ae",
      "": "Th",
      "": "th",
      "": "ss",
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "D",
      "": "D",
      "": "d",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "H",
      "": "H",
      "": "h",
      "": "h",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "J",
      "": "j",
      "": "K",
      "": "k",
      "": "k",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "R",
      "": "R",
      "": "R",
      "": "r",
      "": "r",
      "": "r",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "T",
      "": "T",
      "": "T",
      "": "t",
      "": "t",
      "": "t",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "W",
      "": "w",
      "": "Y",
      "": "y",
      "": "Y",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "z",
      "": "z",
      "": "z",
      "": "IJ",
      "": "ij",
      "": "Oe",
      "": "oe",
      "": "'n",
      "": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined2 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined2 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index = -1, length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined2) {
          result = result === undefined2 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined2 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator2) {
      var data, result = [];
      while (!(data = iterator2.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set3) {
      var index = -1, result = Array(set3.size);
      set3.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set3) {
      var index = -1, result = Array(set3.size);
      set3.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext(context5) {
      context5 = context5 == null ? root : _2.defaults(root.Object(), context5, _2.pick(root, contextProps));
      var { Array: Array2, Date: Date2, Error: Error2, Function: Function2, Math: Math2, Object: Object2, RegExp: RegExp2, String: String2, TypeError: TypeError2 } = context5;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context5["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context5.Buffer : undefined2, Symbol2 = context5.Symbol, Uint8Array2 = context5.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      var ctxClearTimeout = context5.clearTimeout !== root.clearTimeout && context5.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context5.setTimeout !== root.setTimeout && context5.setTimeout;
      var { ceil: nativeCeil, floor: nativeFloor } = Math2, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context5.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context5.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context5, "DataView"), Map2 = getNative(context5, "Map"), Promise2 = getNative(context5, "Promise"), Set2 = getNative(context5, "Set"), WeakMap2 = getNative(context5, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2;
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
      function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject3(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object;
          object.prototype = undefined2;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined2;
      }
      lodash.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: "",
        imports: {
          _: lodash
        }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type3 = data.type, computed = iteratee2(value);
              if (type3 == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type3 == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined2 : result2;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined2;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined2 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          hash: new Hash,
          map: new (Map2 || ListCache),
          string: new Hash
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache;
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache;
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined2;
      }
      function arraySampleSize(array, n2) {
        return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index < length) {
          result2[index] = skip ? undefined2 : get3(object, paths[index]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined2) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined2) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined2) {
          return result2;
        }
        if (!isObject3(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack);
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined2 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined2 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait2, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined2, args);
        }, wait2);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index, collection2) {
          result2 = !!predicate(value, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined2 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object[key]);
        });
      }
      function baseGet(object, path3) {
        path3 = castPath(path3, object);
        var index = 0, length = path3.length;
        while (object != null && index < length) {
          object = object[toKey(path3[index++])];
        }
        return index && index == length ? object : undefined2;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined2 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result2.length < maxLength) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path3, args) {
        path3 = castPath(path3, object);
        object = parent(object, path3);
        var func = object == null ? object : object[toKey(last(path3))];
        return func == null ? undefined2 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack);
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack);
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined2 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack;
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject3(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag2;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject3(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path3, srcValue) {
        if (isKey(path3) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path3), srcValue);
        }
        return function(object) {
          var objValue = get3(object, path3);
          return objValue === undefined2 && objValue === srcValue ? hasIn(object, path3) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack);
          if (isObject3(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
            if (newValue === undefined2) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
        var isCommon = newValue === undefined2;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject13(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject3(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n2) {
        var length = array.length;
        if (!length) {
          return;
        }
        n2 += n2 < 0 ? length : 0;
        return isIndex(n2, length) ? array[n2] : undefined2;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { criteria, index: ++index, value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path3) {
          return hasIn(object, path3);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path3 = paths[index], value = baseGet(object, path3);
          if (predicate(value, path3)) {
            baseSet(result2, castPath(path3, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path3) {
        return function(object) {
          return baseGet(object, path3);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n2) {
        var result2 = "";
        if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n2 % 2) {
            result2 += string;
          }
          n2 = nativeFloor(n2 / 2);
          if (n2) {
            string += string;
          }
        } while (n2);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n2) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n2, 0, array.length));
      }
      function baseSet(object, path3, value, customizer) {
        if (!isObject3(object)) {
          return object;
        }
        path3 = castPath(path3, object);
        var index = -1, length = path3.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path3[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined2;
            if (newValue === undefined2) {
              newValue = isObject3(objValue) ? objValue : isIndex(path3[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          configurable: true,
          enumerable: false,
          value: constant(string),
          writable: true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index < length) {
          result2[index] = array[index + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index, collection2) {
          result2 = predicate(value, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set4 = iteratee2 ? null : createSet(array);
          if (set4) {
            return setToArray(set4);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache;
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path3) {
        path3 = castPath(path3, object);
        object = parent(object, path3);
        return object == null || delete object[toKey(last(path3))];
      }
      function baseUpdate(object, path3, updater, customizer) {
        return baseSet(object, path3, updater(baseGet(object, path3)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array2(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index < length) {
          var value = index < valsLength ? values2[index] : undefined2;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined2 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array2(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
          if (newValue === undefined2) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined2 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn2.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor;
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject3(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
          }
          var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn2, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
            while (++index2 < length) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn2 = Ctor || createCtor(fn2);
          }
          return fn2.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined2 && other === undefined2) {
            return defaultValue;
          }
          if (value !== undefined2) {
            result2 = value;
          }
          if (other !== undefined2) {
            if (result2 === undefined2) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined2 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn2, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined2;
          }
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined2, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag2) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined2;
        }
        ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined2 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined2;
        }
        var data = isBindKey ? undefined2 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined2, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject3(objValue) && isObject3(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject13(value) ? undefined2 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined2;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined2) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag2:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && (("constructor" in object) && ("constructor" in other)) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined2, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined2;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined2;
          var unmasked = true;
        } catch (e2) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2) != setTag2 || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag2;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data = transforms[index], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { start, end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path3, hasFunc) {
        path3 = castPath(path3, object);
        var index = -1, length = path3.length, result2 = false;
        while (++index < length) {
          var key = toKey(path3[index]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor;
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag2:
            return new Ctor;
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, `{
/* [wrapped with ` + details + `] */
`);
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type3 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type3 == "number" || type3 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject3(object)) {
          return false;
        }
        var type3 = typeof index;
        if (type3 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type3 == "string" && (index in object)) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type3 = typeof value;
        if (type3 == "number" || type3 == "symbol" || type3 == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type3 = typeof value;
        return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject3(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined2 || (key in Object2(object)));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array2(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path3) {
        return path3.length < 2 ? object : baseGet(object, baseSlice(path3, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait2) {
        return root.setTimeout(func, wait2);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined2, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined2 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index < length) {
          result2[resIndex++] = baseSlice(array, index, index += size2);
        }
        return result2;
      }
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat2() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
      });
      function drop(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
        return baseSlice(array, n2 < 0 ? 0 : n2, length);
      }
      function dropRight(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
        n2 = length - n2;
        return baseSlice(array, 0, n2 < 0 ? 0 : n2);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index < length) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined2;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined2;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
      });
      function join5(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined2;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n2) {
        return array && array.length ? baseNth(array, toInteger(n2)) : undefined2;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined2 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n2, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
        return baseSlice(array, 0, n2 < 0 ? 0 : n2);
      }
      function takeRight(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
        n2 = length - n2;
        return baseSlice(array, n2 < 0 ? 0 : n2, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return array && array.length ? baseUniq(array, undefined2, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined2, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined2
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined2);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined2) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
        return { done, value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = undefined2;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined2
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path3, args) {
        var index = -1, isFunc = typeof path3 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply(path3, value, args) : baseInvoke(value, path3, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined2 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n2, guard) {
        if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined2) {
          n2 = 1;
        } else {
          n2 = toInteger(n2);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n2);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag2) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n2, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger(n2);
        return function() {
          if (--n2 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n2, guard) {
        n2 = guard ? undefined2 : n2;
        n2 = func && n2 == null ? func.length : n2;
        return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n2);
      }
      function before(n2, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger(n2);
        return function() {
          if (--n2 > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n2 <= 1) {
            func = undefined2;
          }
          return result2;
        };
      }
      var bind2 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind2));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait2, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait2 = toNumber(wait2) || 0;
        if (isObject3(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait2) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined2;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait2);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait2 - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined2 || timeSinceLastCall >= wait2 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined2;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined2;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined2) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined2;
        }
        function flush() {
          return timerId === undefined2 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined2) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait2);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined2) {
            timerId = setTimeout2(timerExpired, wait2);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay3 = baseRest(function(func, wait2, args) {
        return baseDelay(func, toNumber(wait2) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache);
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined2 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait2, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject3(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait2, {
          leading,
          maxWait: wait2,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array2.isArray;
      var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject13(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag2) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        var result2 = customizer ? customizer(value, other) : undefined2;
        return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
      }
      function isError3(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject13(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction(value) {
        if (!isObject3(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject3(value) {
        var type3 = typeof value;
        return value != null && (type3 == "object" || type3 == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject13(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined2;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag2 ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject3(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject3(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined2;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined2, customDefaultsMerge);
        return apply(mergeWith, undefined2, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get3(object, path3, defaultValue) {
        var result2 = object == null ? undefined2 : baseGet(object, path3);
        return result2 === undefined2 ? defaultValue : result2;
      }
      function has(object, path3) {
        return object != null && hasPath(object, path3, baseHas);
      }
      function hasIn(object, path3) {
        return object != null && hasPath(object, path3, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge7 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit7 = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path3) {
          path3 = castPath(path3, object);
          isDeep || (isDeep = path3.length > 1);
          return path3;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path3) {
          return predicate(value, path3[0]);
        });
      }
      function result(object, path3, defaultValue) {
        path3 = castPath(path3, object);
        var index = -1, length = path3.length;
        if (!length) {
          length = 1;
          object = undefined2;
        }
        while (++index < length) {
          var value = object == null ? undefined2 : object[toKey(path3[index])];
          if (value === undefined2) {
            index = length;
            value = defaultValue;
          }
          object = isFunction(value) ? value.call(object) : value;
        }
        return object;
      }
      function set3(object, path3, value) {
        return object == null ? object : baseSet(object, path3, value);
      }
      function setWith(object, path3, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseSet(object, path3, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor : [];
          } else if (isObject3(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path3) {
        return object == null ? true : baseUnset(object, path3);
      }
      function update2(object, path3, updater) {
        return object == null ? object : baseUpdate(object, path3, castFunction(updater));
      }
      function updateWith(object, path3, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseUpdate(object, path3, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined2) {
          upper = lower;
          lower = undefined2;
        }
        if (upper !== undefined2) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined2) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined2) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined2;
        }
        if (floating === undefined2) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined2;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined2;
          }
        }
        if (lower === undefined2 && upper === undefined2) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined2) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
      }
      function deburr(string) {
        string = toString(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape2(string) {
        string = toString(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n2, guard) {
        if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined2) {
          n2 = 1;
        } else {
          n2 = toInteger(n2);
        }
        return baseRepeat(toString(string), n2);
      }
      function replace() {
        var args = arguments, string = toString(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined2;
        }
        limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined2;
        }
        string = toString(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + `
`;
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += `' +
__e(` + escapeValue + `) +
'`;
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += `';
` + evaluateValue + `;
__p += '`;
          }
          if (interpolateValue) {
            source += `' +
((__t = (` + interpolateValue + `)) == null ? '' : __t) +
'`;
          }
          index = offset + match.length;
          return match;
        });
        source += `';
`;
        var variable = hasOwnProperty.call(options, "variable") && options.variable;
        if (!variable) {
          source = `with (obj) {
` + source + `
}
`;
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + `) {
` + (variable ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? `, __j = Array.prototype.join;
` + `function print() { __p += __j.call(arguments, '') }
` : `;
`) + source + `return __p
}`;
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
        });
        result2.source = source;
        if (isError3(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      function trim2(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject3(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined2) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString(string);
        pattern = guard ? undefined2 : pattern;
        if (pattern === undefined2) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined2, args);
        } catch (e2) {
          return isError3(e2) ? e2 : new Error2(e2);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind2(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path3, srcValue) {
        return baseMatchesProperty(path3, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path3, args) {
        return function(object) {
          return baseInvoke(object, path3, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path3) {
          return baseInvoke(object, path3, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject3(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject3(options) && ("chain" in options)) || !!options.chain, isFunc = isFunction(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ func, args: arguments, thisArg: object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n2) {
        n2 = toInteger(n2);
        return baseRest(function(args) {
          return baseNth(args, n2);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path3) {
        return isKey(path3) ? baseProperty(toKey(path3)) : basePropertyDeep(path3);
      }
      function propertyOf(object) {
        return function(path3) {
          return object == null ? undefined2 : baseGet(object, path3);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n2, iteratee2) {
        n2 = toInteger(n2);
        if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n2 -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index < n2) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind2;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat2;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay3;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge7;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit7;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set3;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.unary = unary;
      lodash.union = union;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update2;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq;
      lodash.escape = escape2;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get3;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = isArrayBuffer2;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError3;
      lodash.isFinite = isFinite2;
      lodash.isFunction = isFunction;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN2;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject3;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject13;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join5;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop2;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt2;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString;
      lodash.toUpper = toUpper;
      lodash.trim = trim2;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape2;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { chain: false });
      lodash.VERSION = VERSION23;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n2) {
          n2 = n2 === undefined2 ? 1 : nativeMax(toInteger(n2), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
          } else {
            result2.__views__.push({
              size: nativeMin(n2, MAX_ARRAY_LENGTH),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n2) {
          return this.reverse()[methodName](n2).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type3 = index + 1, isFilter = type3 == LAZY_FILTER_FLAG || type3 == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type: type3
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path3, args) {
        if (typeof path3 == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path3, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined2) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ func: thru, args: [interceptor], thisArg: undefined2 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ name: methodName, func: lodashFunc });
        }
      });
      realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined2
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    };
    var _2 = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      root._ = _2;
      define(function() {
        return _2;
      });
    } else if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root._ = _2;
    }
  }).call(exports);
});

// node_modules/@dqbd/tiktoken/tiktoken_bg.cjs
var require_tiktoken_bg = __commonJS((exports, module) => {
  var wasm;
  exports.__wbg_set_wasm = function(val) {
    wasm = val;
  };
  var lTextDecoder = typeof TextDecoder === "undefined" ? (0, module.require)("util").TextDecoder : TextDecoder;
  var cachedTextDecoder = new lTextDecoder("utf-8", { ignoreBOM: true, fatal: true });
  cachedTextDecoder.decode();
  var cachedUint8ArrayMemory0 = null;
  function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
  }
  function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
  }
  var heap = new Array(128).fill(undefined);
  heap.push(undefined, null, true, false);
  var heap_next = heap.length;
  function addHeapObject(obj) {
    if (heap_next === heap.length)
      heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
  }
  function handleError(f2, args) {
    try {
      return f2.apply(this, args);
    } catch (e2) {
      wasm.__wbindgen_export_0(addHeapObject(e2));
    }
  }
  function getObject(idx) {
    return heap[idx];
  }
  function dropObject(idx) {
    if (idx < 132)
      return;
    heap[idx] = heap_next;
    heap_next = idx;
  }
  function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
  }
  var WASM_VECTOR_LEN = 0;
  var lTextEncoder = typeof TextEncoder === "undefined" ? (0, module.require)("util").TextEncoder : TextEncoder;
  var cachedTextEncoder = new lTextEncoder("utf-8");
  var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
  } : function(arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
      read: arg.length,
      written: buf.length
    };
  };
  function passStringToWasm0(arg, malloc, realloc) {
    if (realloc === undefined) {
      const buf = cachedTextEncoder.encode(arg);
      const ptr2 = malloc(buf.length, 1) >>> 0;
      getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
      WASM_VECTOR_LEN = buf.length;
      return ptr2;
    }
    let len = arg.length;
    let ptr = malloc(len, 1) >>> 0;
    const mem = getUint8ArrayMemory0();
    let offset = 0;
    for (;offset < len; offset++) {
      const code = arg.charCodeAt(offset);
      if (code > 127)
        break;
      mem[ptr + offset] = code;
    }
    if (offset !== len) {
      if (offset !== 0) {
        arg = arg.slice(offset);
      }
      ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
      const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
      const ret = encodeString(arg, view);
      offset += ret.written;
      ptr = realloc(ptr, len, offset, 1) >>> 0;
    }
    WASM_VECTOR_LEN = offset;
    return ptr;
  }
  function isLikeNone(x2) {
    return x2 === undefined || x2 === null;
  }
  var cachedDataViewMemory0 = null;
  function getDataViewMemory0() {
    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
      cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
    }
    return cachedDataViewMemory0;
  }
  var cachedUint32ArrayMemory0 = null;
  function getUint32ArrayMemory0() {
    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {
      cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);
    }
    return cachedUint32ArrayMemory0;
  }
  function getArrayU32FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);
  }
  function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1, 1) >>> 0;
    getUint8ArrayMemory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
  }
  function passArray32ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 4, 4) >>> 0;
    getUint32ArrayMemory0().set(arg, ptr / 4);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
  }
  function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
  }
  exports.get_encoding = function(encoding, extend_special_tokens) {
    if (wasm == null)
      throw new Error("tiktoken: WASM binary has not been propery initialized.");
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(encoding, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
      const len0 = WASM_VECTOR_LEN;
      wasm.get_encoding(retptr, ptr0, len0, addHeapObject(extend_special_tokens));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return Tiktoken.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  };
  exports.encoding_for_model = function(model2, extend_special_tokens) {
    if (wasm == null)
      throw new Error("tiktoken: WASM binary has not been propery initialized.");
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(model2, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
      const len0 = WASM_VECTOR_LEN;
      wasm.encoding_for_model(retptr, ptr0, len0, addHeapObject(extend_special_tokens));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return Tiktoken.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  };
  var TiktokenFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
  }, unregister: () => {
  } } : new FinalizationRegistry((ptr) => wasm.__wbg_tiktoken_free(ptr >>> 0, 1));

  class Tiktoken {
    constructor(tiktoken_bfe, special_tokens, pat_str) {
      if (wasm == null)
        throw new Error("tiktoken: WASM binary has not been propery initialized.");
      const ptr0 = passStringToWasm0(tiktoken_bfe, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
      const len0 = WASM_VECTOR_LEN;
      const ptr1 = passStringToWasm0(pat_str, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
      const len1 = WASM_VECTOR_LEN;
      const ret = wasm.tiktoken_new(ptr0, len0, addHeapObject(special_tokens), ptr1, len1);
      this.__wbg_ptr = ret >>> 0;
      TiktokenFinalization.register(this, this.__wbg_ptr, this);
      return this;
    }
    get name() {
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.tiktoken_name(retptr, this.__wbg_ptr);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        let v1;
        if (r0 !== 0) {
          v1 = getStringFromWasm0(r0, r1).slice();
          wasm.__wbindgen_export_3(r0, r1 * 1, 1);
        }
        return v1;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(Tiktoken.prototype);
      obj.__wbg_ptr = ptr;
      TiktokenFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      TiktokenFinalization.unregister(this);
      return ptr;
    }
    free() {
      if (wasm == null)
        throw new Error("tiktoken: WASM binary has not been propery initialized.");
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_tiktoken_free(ptr, 0);
    }
    encode(text, allowed_special, disallowed_special) {
      if (wasm == null)
        throw new Error("tiktoken: WASM binary has not been propery initialized.");
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(text, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.tiktoken_encode(retptr, this.__wbg_ptr, ptr0, len0, addHeapObject(allowed_special), addHeapObject(disallowed_special));
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
        var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
        if (r3) {
          throw takeObject(r2);
        }
        var v2 = getArrayU32FromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_3(r0, r1 * 4, 4);
        return v2;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    encode_ordinary(text) {
      if (wasm == null)
        throw new Error("tiktoken: WASM binary has not been propery initialized.");
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(text, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.tiktoken_encode_ordinary(retptr, this.__wbg_ptr, ptr0, len0);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var v2 = getArrayU32FromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_3(r0, r1 * 4, 4);
        return v2;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    encode_with_unstable(text, allowed_special, disallowed_special) {
      if (wasm == null)
        throw new Error("tiktoken: WASM binary has not been propery initialized.");
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(text, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
        const len0 = WASM_VECTOR_LEN;
        wasm.tiktoken_encode_with_unstable(retptr, this.__wbg_ptr, ptr0, len0, addHeapObject(allowed_special), addHeapObject(disallowed_special));
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
        if (r2) {
          throw takeObject(r1);
        }
        return takeObject(r0);
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    encode_single_token(bytes) {
      if (wasm == null)
        throw new Error("tiktoken: WASM binary has not been propery initialized.");
      const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_export_1);
      const len0 = WASM_VECTOR_LEN;
      const ret = wasm.tiktoken_encode_single_token(this.__wbg_ptr, ptr0, len0);
      return ret >>> 0;
    }
    decode(tokens) {
      if (wasm == null)
        throw new Error("tiktoken: WASM binary has not been propery initialized.");
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passArray32ToWasm0(tokens, wasm.__wbindgen_export_1);
        const len0 = WASM_VECTOR_LEN;
        wasm.tiktoken_decode(retptr, this.__wbg_ptr, ptr0, len0);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var v2 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_3(r0, r1 * 1, 1);
        return v2;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    decode_single_token_bytes(token) {
      if (wasm == null)
        throw new Error("tiktoken: WASM binary has not been propery initialized.");
      try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm.tiktoken_decode_single_token_bytes(retptr, this.__wbg_ptr, token);
        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
        var v1 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_3(r0, r1 * 1, 1);
        return v1;
      } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
      }
    }
    token_byte_values() {
      if (wasm == null)
        throw new Error("tiktoken: WASM binary has not been propery initialized.");
      const ret = wasm.tiktoken_token_byte_values(this.__wbg_ptr);
      return takeObject(ret);
    }
  }
  exports.Tiktoken = Tiktoken;
  exports.__wbg_parse_def2e24ef1252aff = function() {
    return handleError(function(arg0, arg1) {
      const ret = JSON.parse(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  exports.__wbg_stringify_f7ed6987935b4a24 = function() {
    return handleError(function(arg0) {
      const ret = JSON.stringify(getObject(arg0));
      return addHeapObject(ret);
    }, arguments);
  };
  exports.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  exports.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject(arg0) === undefined;
    return ret;
  };
  exports.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  exports.__wbindgen_string_get = function(arg0, arg1) {
    if (wasm == null)
      throw new Error("tiktoken: WASM binary has not been propery initialized.");
    const obj = getObject(arg1);
    const ret = typeof obj === "string" ? obj : undefined;
    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_export_1, wasm.__wbindgen_export_2);
    var len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  exports.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
});

// src/1_trigger/action-render.ts
var import_core3 = __toESM(require_core(), 1);

// src/util/config/index.ts
var import_dotenv = __toESM(require_main2(), 1);
var import_core = __toESM(require_core(), 1);

// src/util/config/github.ts
function getGitHubSecrets() {
  const secrets = getGitHubAppSecrets() ?? getGitHubPatSecrets() ?? getGitHubDefaultSecrets();
  if (secrets !== undefined) {
    return secrets;
  }
  throw new Error("No GitHub secrets configured. Please set GITHUB_APP_*, or GITHUB_PAT_TOKEN.");
}
function getGitHubAppSecrets() {
  const appId = getConfig("GITHUB_APP_ID");
  const installationId = getConfig("GITHUB_APP_INSTALLATION_ID");
  const privateKey = getConfig("GITHUB_APP_PRIVATE_KEY");
  if (!appId || !privateKey) {
    return;
  }
  return {
    kind: "app",
    appId,
    installationId: installationId ? parseInt(installationId) : undefined,
    privateKey
  };
}
function getGitHubPatSecrets() {
  const token = getConfig("GITHUB_PAT_TOKEN");
  if (!token) {
    return;
  }
  return {
    kind: "pat",
    token
  };
}
function getGitHubDefaultSecrets() {
  const token = getConfig("GITHUB_TOKEN");
  if (!token) {
    return;
  }
  return {
    kind: "default",
    token
  };
}
// src/util/config/model.ts
var import_yaml = __toESM(require_dist(), 1);
var import_github = __toESM(require_github(), 1);
import fs from "fs";
import path from "path";
function getModelEndpoint(tokenKind) {
  const customEndpoint = getConfig("MODEL_ENDPOINT") || "";
  if (customEndpoint !== "") {
    return customEndpoint;
  }
  switch (tokenKind) {
    case "app":
      return `https://models.github.ai/orgs/${import_github.context.repo.owner}/inference`;
    case "pat":
    case "default":
      return "https://models.github.ai/inference";
    default:
      throw new Error(`Unknown token kind: ${tokenKind}`);
  }
}
function loadPromptFile(promptFilePath) {
  const configPath = getConfig(promptFilePath);
  if (configPath) {
    promptFilePath = configPath;
  }
  if (!promptFilePath.includes(".")) {
    promptFilePath += ".prompt.yaml";
  }
  const directories = [
    "",
    ".github/prompts",
    ".github/Prompts",
    "prompts",
    "Prompts"
  ];
  let yamlBlob;
  for (const directory of directories) {
    const fullPath = path.join(directory, promptFilePath);
    if (fs.existsSync(fullPath)) {
      yamlBlob = fs.readFileSync(fullPath, "utf-8");
    }
  }
  promptFilePath = path.resolve(promptFilePath);
  if (yamlBlob === undefined) {
    throw new Error(`Prompt file "${promptFilePath}" does not exist.`);
  } else if (yamlBlob.trim() === "") {
    throw new Error(`Prompt file "${promptFilePath}" is empty.`);
  }
  return import_yaml.default.parse(yamlBlob);
}
// src/util/config/push.ts
var import_strftime = __toESM(require_strftime(), 1);
// src/util/config/update.ts
var DEFAULT_MARKER = /<!--\s*UPDATE\s*-->/i;

class UpdateDetection {
  static instance;
  static getInstance() {
    if (!UpdateDetection.instance) {
      UpdateDetection.instance = new UpdateDetection;
    }
    return UpdateDetection.instance;
  }
  strategies;
  constructor() {
    let strategies;
    const config = getConfig("UPDATE_DETECTION");
    if (config) {
      strategies = UpdateDetection.parseStrategies(config);
      if (strategies.length === 0) {
        throw new Error('No valid strategies found in the "update_detection" input. See docs.');
      }
    } else {
      strategies = UpdateDetection.defaultStrategies;
    }
    this.strategies = strategies;
  }
  static defaultStrategies = [
    {
      kind: "section",
      section: "Update"
    },
    {
      kind: "marker",
      marker: DEFAULT_MARKER
    },
    {
      kind: "timebox",
      timeframe: "last-week"
    },
    { kind: "skip" }
  ];
  static parseFunctionSyntax(input) {
    const functionCallRegex = /^([a-zA-Z_][a-zA-Z0-9_]*)\(([^)]*)\)$/;
    const match = input.match(functionCallRegex);
    if (match) {
      const [, functionName, argsString] = match;
      const args = argsString.split(",").map((arg) => arg.trim()).map((arg) => arg.replace(/^["']|["']$/g, ""));
      return { name: functionName, args };
    } else {
      return { name: input, args: [] };
    }
  }
  static parseStrategies(configBlob) {
    return configBlob.split(`
`).map((line) => line.trim()).filter((line) => line !== "").map((line) => {
      const { name: funcName, args } = UpdateDetection.parseFunctionSyntax(line);
      switch (funcName) {
        case "skip":
          return { kind: "skip" };
        case "fail":
          return { kind: "fail" };
        case "blame":
          return { kind: "blame" };
      }
      let timeframe = undefined;
      switch (funcName) {
        case "today":
          timeframe = "today";
          break;
        case "lastWeek":
          timeframe = "last-week";
          break;
        case "lastMonth":
          timeframe = "last-month";
          break;
        case "lastYear":
          timeframe = "last-year";
          break;
        case "allTime":
          timeframe = "all-time";
          break;
        default:
          if (args.length > 0) {
            throw new Error(`Invalid function call "${funcName}()" in update_detection config.`);
          }
      }
      if (args.length === 0 && timeframe !== undefined) {
        return {
          kind: "timebox",
          timeframe
        };
      }
      const sectionName = args[0] || funcName;
      switch (sectionName) {
        case "MARKER":
        case "DEFAULT_MARKER":
          return {
            kind: "marker",
            marker: DEFAULT_MARKER,
            timeframe
          };
        default:
          return {
            kind: "section",
            section: sectionName,
            timeframe
          };
      }
    });
  }
}

// src/util/config/index.ts
function getConfig(key, required = false) {
  if (process.env.GITHUB_ACTIONS === "true") {
    const input = import_core.getInput(key, { required });
    if (input !== "") {
      return input;
    }
  }
  import_dotenv.default.config();
  return process.env[key] ?? process.env[key.toUpperCase()] ?? process.env[key.toLowerCase()];
}
var isTrueValue = (value) => {
  return value === "true" || value === "1" || value === "yes" || value === "on" || value === "enabled";
};

// src/4_template/render.ts
import path4 from "path";

// node_modules/ventojs/esm/_dnt.shims.js
var import_shim_deno = __toESM(require_dist3(), 1);
var import_shim_deno2 = __toESM(require_dist3(), 1);
var dntGlobals = {
  Deno: import_shim_deno.Deno
};
var dntGlobalThis = createMergeProxy(globalThis, dntGlobals);
function createMergeProxy(baseObj, extObj) {
  return new Proxy(baseObj, {
    get(_target, prop, _receiver) {
      if (prop in extObj) {
        return extObj[prop];
      } else {
        return baseObj[prop];
      }
    },
    set(_target, prop, value) {
      if (prop in extObj) {
        delete extObj[prop];
      }
      baseObj[prop] = value;
      return true;
    },
    deleteProperty(_target, prop) {
      let success = false;
      if (prop in extObj) {
        delete extObj[prop];
        success = true;
      }
      if (prop in baseObj) {
        delete baseObj[prop];
        success = true;
      }
      return success;
    },
    ownKeys(_target) {
      const baseKeys = Reflect.ownKeys(baseObj);
      const extKeys = Reflect.ownKeys(extObj);
      const extKeysSet = new Set(extKeys);
      return [...baseKeys.filter((k) => !extKeysSet.has(k)), ...extKeys];
    },
    defineProperty(_target, prop, desc) {
      if (prop in extObj) {
        delete extObj[prop];
      }
      Reflect.defineProperty(baseObj, prop, desc);
      return true;
    },
    getOwnPropertyDescriptor(_target, prop) {
      if (prop in extObj) {
        return Reflect.getOwnPropertyDescriptor(extObj, prop);
      } else {
        return Reflect.getOwnPropertyDescriptor(baseObj, prop);
      }
    },
    has(_target, prop) {
      return prop in extObj || prop in baseObj;
    }
  });
}

// node_modules/ventojs/esm/src/js.js
function analyze(source, visitor) {
  const length = source.length;
  const statuses = [];
  let index = 0;
  while (index < length) {
    const char = source.charAt(index++);
    switch (char) {
      case "{": {
        const status = statuses[0];
        if (status === "literal" && source.charAt(index - 2) === "$") {
          statuses.unshift("bracket");
        } else if (status !== "comment" && status !== "single-quote" && status !== "double-quote" && status !== "literal" && status !== "regex" && status !== "line-comment") {
          if (statuses.length === 0 && visitor("open-bracket", index) === false) {
            return;
          }
          statuses.unshift("bracket");
        }
        break;
      }
      case "}": {
        const status = statuses[0];
        if (status === "bracket") {
          statuses.shift();
          if (statuses.length === 0 && visitor("close", index) === false) {
            return;
          }
        }
        break;
      }
      case '"': {
        const status = statuses[0];
        if (status === "double-quote") {
          statuses.shift();
        } else if (status !== "comment" && status !== "single-quote" && status !== "literal" && status !== "regex" && status !== "line-comment") {
          statuses.unshift("double-quote");
        }
        break;
      }
      case "'": {
        const status = statuses[0];
        if (status === "single-quote") {
          statuses.shift();
        } else if (status !== "comment" && status !== "double-quote" && status !== "literal" && status !== "regex" && status !== "line-comment") {
          statuses.unshift("single-quote");
        }
        break;
      }
      case "`": {
        const status = statuses[0];
        if (status === "literal") {
          statuses.shift();
        } else if (status !== "comment" && status !== "double-quote" && status !== "single-quote" && status !== "regex" && status !== "line-comment") {
          statuses.unshift("literal");
        }
        break;
      }
      case "/": {
        const status = statuses[0];
        if (status === "single-quote" || status === "double-quote" || status === "literal" || status === "line-comment") {
          break;
        }
        if (status === "comment") {
          if (source.charAt(index - 2) === "*") {
            statuses.shift();
          }
          break;
        }
        if (status === "regex") {
          if (source.charAt(index - 2) !== "\\") {
            statuses.shift();
          }
          break;
        }
        if (source.charAt(index) === "*") {
          statuses.unshift("comment");
          break;
        }
        if (source.charAt(index - 2) === "/") {
          statuses.unshift("line-comment");
          break;
        }
        const prev = prevChar(source, index - 1);
        if (prev === "(" || prev === "=" || prev === ":" || prev === ",") {
          statuses.unshift("regex");
        }
        break;
      }
      case `
`: {
        const status = statuses[0];
        if (status === "line-comment") {
          statuses.shift();
        }
        break;
      }
      case "|": {
        const status = statuses[0];
        if (status === "bracket" && source.charAt(index) === ">" && visitor("new-filter", index + 1) === false) {
          return;
        }
        break;
      }
    }
  }
  if (statuses.length > 0) {
    visitor("unclosed", index);
  }
}
function prevChar(source, index) {
  while (index > 0) {
    const char = source.charAt(--index);
    if (char !== " " && char !== `
` && char !== "\r" && char !== "\t") {
      return char;
    }
  }
  return "";
}

// node_modules/ventojs/esm/src/tokenizer.js
function tokenize(source) {
  const tokens = [];
  let type = "string";
  let position = 0;
  try {
    while (source.length > 0) {
      if (type === "string") {
        const index = source.indexOf("{{");
        const code = index === -1 ? source : source.slice(0, index);
        tokens.push([type, code, position]);
        if (index === -1) {
          break;
        }
        position += index;
        source = source.slice(index);
        type = source.startsWith("{{#") ? "comment" : "tag";
        continue;
      }
      if (type === "comment") {
        source = source.slice(3);
        const index = source.indexOf("#}}");
        const comment = index === -1 ? source : source.slice(0, index);
        tokens.push([type, comment, position]);
        if (index === -1) {
          break;
        }
        position += index + 3;
        source = source.slice(index + 3);
        type = "string";
        continue;
      }
      if (type === "tag") {
        const indexes = parseTag(source);
        const lastIndex = indexes.length - 1;
        let tag;
        indexes.reduce((prev, curr, index) => {
          const code = source.slice(prev, curr - 2);
          if (index === 1) {
            tag = [type, code, position];
            tokens.push(tag);
            return curr;
          }
          tokens.push(["filter", code]);
          return curr;
        });
        position += indexes[lastIndex];
        source = source.slice(indexes[lastIndex]);
        type = "string";
        if (tag?.[1].match(/^\-?\s*echo\s*\-?$/)) {
          const end = source.match(/{{\-?\s*\/echo\s*\-?}}/);
          if (!end) {
            throw new Error("Unclosed echo tag");
          }
          const rawCode = source.slice(0, end.index);
          tag[1] = `echo ${JSON.stringify(rawCode)}`;
          const length = Number(end.index) + end[0].length;
          source = source.slice(length);
          position += length;
        }
        continue;
      }
    }
  } catch (error) {
    return { tokens, position, error };
  }
  return { tokens, position, error: undefined };
}
function parseTag(source) {
  const indexes = [2];
  analyze(source, (type, index) => {
    if (type === "close") {
      indexes.push(index);
      return false;
    }
    if (type === "new-filter") {
      indexes.push(index);
    } else if (type === "unclosed") {
      throw new Error("Unclosed tag");
    }
  });
  return indexes;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/mod.js
var exports_mod = {};
__export(exports_mod, {
  toNamespacedPath: () => toNamespacedPath3,
  toFileUrl: () => toFileUrl3,
  resolve: () => resolve3,
  relative: () => relative3,
  parse: () => parse3,
  normalizeGlob: () => normalizeGlob3,
  normalize: () => normalize3,
  joinGlobs: () => joinGlobs3,
  join: () => join3,
  isGlob: () => isGlob,
  isAbsolute: () => isAbsolute3,
  globToRegExp: () => globToRegExp3,
  fromFileUrl: () => fromFileUrl3,
  format: () => format3,
  extname: () => extname3,
  dirname: () => dirname3,
  common: () => common2,
  basename: () => basename3,
  SEPARATOR_PATTERN: () => SEPARATOR_PATTERN,
  SEPARATOR: () => SEPARATOR,
  DELIMITER: () => DELIMITER
});

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/_os.js
var isWindows = dntGlobalThis.Deno?.build.os === "windows" || dntGlobalThis.navigator?.platform?.startsWith("Win") || dntGlobalThis.process?.platform?.startsWith("win") || false;

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/_common/assert_path.js
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string, received "${JSON.stringify(path2)}"`);
  }
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/_common/basename.js
function stripSuffix(name, suffix) {
  if (suffix.length >= name.length) {
    return name;
  }
  const lenDiff = name.length - suffix.length;
  for (let i = suffix.length - 1;i >= 0; --i) {
    if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {
      return name;
    }
  }
  return name.slice(0, -suffix.length);
}
function lastPathSegment(path2, isSep, start = 0) {
  let matchedNonSeparator = false;
  let end = path2.length;
  for (let i = path2.length - 1;i >= start; --i) {
    if (isSep(path2.charCodeAt(i))) {
      if (matchedNonSeparator) {
        start = i + 1;
        break;
      }
    } else if (!matchedNonSeparator) {
      matchedNonSeparator = true;
      end = i + 1;
    }
  }
  return path2.slice(start, end);
}
function assertArgs(path2, suffix) {
  assertPath(path2);
  if (path2.length === 0)
    return path2;
  if (typeof suffix !== "string") {
    throw new TypeError(`Suffix must be a string, received "${JSON.stringify(suffix)}"`);
  }
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/_common/strip_trailing_separators.js
function stripTrailingSeparators(segment, isSep) {
  if (segment.length <= 1) {
    return segment;
  }
  let end = segment.length;
  for (let i = segment.length - 1;i > 0; i--) {
    if (isSep(segment.charCodeAt(i))) {
      end = i;
    } else {
      break;
    }
  }
  return segment.slice(0, end);
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/_common/constants.js
var CHAR_UPPERCASE_A = 65;
var CHAR_LOWERCASE_A = 97;
var CHAR_UPPERCASE_Z = 90;
var CHAR_LOWERCASE_Z = 122;
var CHAR_DOT = 46;
var CHAR_FORWARD_SLASH = 47;
var CHAR_BACKWARD_SLASH = 92;
var CHAR_COLON = 58;
var CHAR_QUESTION_MARK = 63;

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/_util.js
function isPosixPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/basename.js
function basename(path2, suffix = "") {
  assertArgs(path2, suffix);
  const lastSegment = lastPathSegment(path2, isPosixPathSeparator);
  const strippedSegment = stripTrailingSeparators(lastSegment, isPosixPathSeparator);
  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/_util.js
function isPosixPathSeparator2(code) {
  return code === CHAR_FORWARD_SLASH;
}
function isPathSeparator(code) {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
}
function isWindowsDeviceRoot(code) {
  return code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z || code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/basename.js
function basename2(path2, suffix = "") {
  assertArgs(path2, suffix);
  let start = 0;
  if (path2.length >= 2) {
    const drive = path2.charCodeAt(0);
    if (isWindowsDeviceRoot(drive)) {
      if (path2.charCodeAt(1) === CHAR_COLON)
        start = 2;
    }
  }
  const lastSegment = lastPathSegment(path2, isPathSeparator, start);
  const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator);
  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/basename.js
function basename3(path2, suffix = "") {
  return isWindows ? basename2(path2, suffix) : basename(path2, suffix);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/constants.js
var DELIMITER = isWindows ? ";" : ":";
var SEPARATOR = isWindows ? "\\" : "/";
var SEPARATOR_PATTERN = isWindows ? /[\\/]+/ : /\/+/;
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/_common/dirname.js
function assertArg(path2) {
  assertPath(path2);
  if (path2.length === 0)
    return ".";
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/dirname.js
function dirname(path2) {
  assertArg(path2);
  let end = -1;
  let matchedNonSeparator = false;
  for (let i = path2.length - 1;i >= 1; --i) {
    if (isPosixPathSeparator(path2.charCodeAt(i))) {
      if (matchedNonSeparator) {
        end = i;
        break;
      }
    } else {
      matchedNonSeparator = true;
    }
  }
  if (end === -1) {
    return isPosixPathSeparator(path2.charCodeAt(0)) ? "/" : ".";
  }
  return stripTrailingSeparators(path2.slice(0, end), isPosixPathSeparator);
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/dirname.js
function dirname2(path2) {
  assertArg(path2);
  const len = path2.length;
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code = path2.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code)) {
      rootEnd = offset = 1;
      if (isPathSeparator(path2.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (;j < len; ++j) {
          if (isPathSeparator(path2.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          last = j;
          for (;j < len; ++j) {
            if (!isPathSeparator(path2.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (;j < len; ++j) {
              if (isPathSeparator(path2.charCodeAt(j)))
                break;
            }
            if (j === len) {
              return path2;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code)) {
      if (path2.charCodeAt(1) === CHAR_COLON) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator(path2.charCodeAt(2)))
            rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator(code)) {
    return path2;
  }
  for (let i = len - 1;i >= offset; --i) {
    if (isPathSeparator(path2.charCodeAt(i))) {
      if (!matchedSlash) {
        end = i;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1)
      return ".";
    else
      end = rootEnd;
  }
  return stripTrailingSeparators(path2.slice(0, end), isPosixPathSeparator2);
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/dirname.js
function dirname3(path2) {
  return isWindows ? dirname2(path2) : dirname(path2);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/extname.js
function extname(path2) {
  assertPath(path2);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i = path2.length - 1;i >= 0; --i) {
    const code = path2.charCodeAt(i);
    if (isPosixPathSeparator(code)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code === CHAR_DOT) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/extname.js
function extname2(path2) {
  assertPath(path2);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path2.length >= 2 && path2.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path2.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i = path2.length - 1;i >= start; --i) {
    const code = path2.charCodeAt(i);
    if (isPathSeparator(code)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code === CHAR_DOT) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path2.slice(startDot, end);
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/extname.js
function extname3(path2) {
  return isWindows ? extname2(path2) : extname(path2);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/_common/format.js
function _format(sep, pathObject) {
  const dir = pathObject.dir || pathObject.root;
  const base = pathObject.base || (pathObject.name ?? "") + (pathObject.ext ?? "");
  if (!dir)
    return base;
  if (base === sep)
    return dir;
  if (dir === pathObject.root)
    return dir + base;
  return dir + sep + base;
}
function assertArg2(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(`The "pathObject" argument must be of type Object, received type "${typeof pathObject}"`);
  }
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/format.js
function format(pathObject) {
  assertArg2(pathObject);
  return _format("/", pathObject);
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/format.js
function format2(pathObject) {
  assertArg2(pathObject);
  return _format("\\", pathObject);
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/format.js
function format3(pathObject) {
  return isWindows ? format2(pathObject) : format(pathObject);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/_common/from_file_url.js
function assertArg3(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol !== "file:") {
    throw new TypeError(`URL must be a file URL: received "${url.protocol}"`);
  }
  return url;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/from_file_url.js
function fromFileUrl(url) {
  url = assertArg3(url);
  return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/from_file_url.js
function fromFileUrl2(url) {
  url = assertArg3(url);
  let path2 = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname !== "") {
    path2 = `\\\\${url.hostname}${path2}`;
  }
  return path2;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/from_file_url.js
function fromFileUrl3(url) {
  return isWindows ? fromFileUrl2(url) : fromFileUrl(url);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/is_absolute.js
function isAbsolute(path2) {
  assertPath(path2);
  return path2.length > 0 && isPosixPathSeparator(path2.charCodeAt(0));
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/is_absolute.js
function isAbsolute2(path2) {
  assertPath(path2);
  const len = path2.length;
  if (len === 0)
    return false;
  const code = path2.charCodeAt(0);
  if (isPathSeparator(code)) {
    return true;
  } else if (isWindowsDeviceRoot(code)) {
    if (len > 2 && path2.charCodeAt(1) === CHAR_COLON) {
      if (isPathSeparator(path2.charCodeAt(2)))
        return true;
    }
  }
  return false;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/is_absolute.js
function isAbsolute3(path2) {
  return isWindows ? isAbsolute2(path2) : isAbsolute(path2);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/_common/normalize.js
function assertArg4(path2) {
  assertPath(path2);
  if (path2.length === 0)
    return ".";
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/_common/normalize_string.js
function normalizeString(path2, allowAboveRoot, separator, isPathSeparator2) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code;
  for (let i = 0;i <= path2.length; ++i) {
    if (i < path2.length)
      code = path2.charCodeAt(i);
    else if (isPathSeparator2(code))
      break;
    else
      code = CHAR_FORWARD_SLASH;
    if (isPathSeparator2(code)) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += `${separator}..`;
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += separator + path2.slice(lastSlash + 1, i);
        else
          res = path2.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/normalize.js
function normalize(path2) {
  assertArg4(path2);
  const isAbsolute4 = isPosixPathSeparator(path2.charCodeAt(0));
  const trailingSeparator = isPosixPathSeparator(path2.charCodeAt(path2.length - 1));
  path2 = normalizeString(path2, !isAbsolute4, "/", isPosixPathSeparator);
  if (path2.length === 0 && !isAbsolute4)
    path2 = ".";
  if (path2.length > 0 && trailingSeparator)
    path2 += "/";
  if (isAbsolute4)
    return `/${path2}`;
  return path2;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/join.js
function join(...paths) {
  if (paths.length === 0)
    return ".";
  paths.forEach((path2) => assertPath(path2));
  const joined = paths.filter((path2) => path2.length > 0).join("/");
  return joined === "" ? "." : normalize(joined);
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/normalize.js
function normalize2(path2) {
  assertArg4(path2);
  const len = path2.length;
  let rootEnd = 0;
  let device;
  let isAbsolute4 = false;
  const code = path2.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code)) {
      isAbsolute4 = true;
      if (isPathSeparator(path2.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (;j < len; ++j) {
          if (isPathSeparator(path2.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          const firstPart = path2.slice(last, j);
          last = j;
          for (;j < len; ++j) {
            if (!isPathSeparator(path2.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (;j < len; ++j) {
              if (isPathSeparator(path2.charCodeAt(j)))
                break;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path2.slice(last)}\\`;
            } else if (j !== last) {
              device = `\\\\${firstPart}\\${path2.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot(code)) {
      if (path2.charCodeAt(1) === CHAR_COLON) {
        device = path2.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator(path2.charCodeAt(2))) {
            isAbsolute4 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator(code)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString(path2.slice(rootEnd), !isAbsolute4, "\\", isPathSeparator);
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute4)
    tail = ".";
  if (tail.length > 0 && isPathSeparator(path2.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === undefined) {
    if (isAbsolute4) {
      if (tail.length > 0)
        return `\\${tail}`;
      else
        return "\\";
    }
    return tail;
  } else if (isAbsolute4) {
    if (tail.length > 0)
      return `${device}\\${tail}`;
    else
      return `${device}\\`;
  }
  return device + tail;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/join.js
function join2(...paths) {
  paths.forEach((path2) => assertPath(path2));
  paths = paths.filter((path2) => path2.length > 0);
  if (paths.length === 0)
    return ".";
  let needsReplace = true;
  let slashCount = 0;
  const firstPart = paths[0];
  if (isPathSeparator(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator(firstPart.charCodeAt(2)))
            ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  let joined = paths.join("\\");
  if (needsReplace) {
    for (;slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator(joined.charCodeAt(slashCount)))
        break;
    }
    if (slashCount >= 2)
      joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize2(joined);
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/join.js
function join3(...paths) {
  return isWindows ? join2(...paths) : join(...paths);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/normalize.js
function normalize3(path2) {
  return isWindows ? normalize2(path2) : normalize(path2);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/parse.js
function parse(path2) {
  assertPath(path2);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  if (path2.length === 0)
    return ret;
  const isAbsolute4 = isPosixPathSeparator(path2.charCodeAt(0));
  let start;
  if (isAbsolute4) {
    ret.root = "/";
    start = 1;
  } else {
    start = 0;
  }
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i = path2.length - 1;
  let preDotState = 0;
  for (;i >= start; --i) {
    const code = path2.charCodeAt(i);
    if (isPosixPathSeparator(code)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code === CHAR_DOT) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      if (startPart === 0 && isAbsolute4) {
        ret.base = ret.name = path2.slice(1, end);
      } else {
        ret.base = ret.name = path2.slice(startPart, end);
      }
    }
    ret.base = ret.base || "/";
  } else {
    if (startPart === 0 && isAbsolute4) {
      ret.name = path2.slice(1, startDot);
      ret.base = path2.slice(1, end);
    } else {
      ret.name = path2.slice(startPart, startDot);
      ret.base = path2.slice(startPart, end);
    }
    ret.ext = path2.slice(startDot, end);
  }
  if (startPart > 0) {
    ret.dir = stripTrailingSeparators(path2.slice(0, startPart - 1), isPosixPathSeparator);
  } else if (isAbsolute4)
    ret.dir = "/";
  return ret;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/parse.js
function parse2(path2) {
  assertPath(path2);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  const len = path2.length;
  if (len === 0)
    return ret;
  let rootEnd = 0;
  let code = path2.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code)) {
      rootEnd = 1;
      if (isPathSeparator(path2.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (;j < len; ++j) {
          if (isPathSeparator(path2.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          last = j;
          for (;j < len; ++j) {
            if (!isPathSeparator(path2.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (;j < len; ++j) {
              if (isPathSeparator(path2.charCodeAt(j)))
                break;
            }
            if (j === len) {
              rootEnd = j;
            } else if (j !== last) {
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code)) {
      if (path2.charCodeAt(1) === CHAR_COLON) {
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator(path2.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path2;
              ret.base = "\\";
              return ret;
            }
            rootEnd = 3;
          }
        } else {
          ret.root = ret.dir = path2;
          return ret;
        }
      }
    }
  } else if (isPathSeparator(code)) {
    ret.root = ret.dir = path2;
    ret.base = "\\";
    return ret;
  }
  if (rootEnd > 0)
    ret.root = path2.slice(0, rootEnd);
  let startDot = -1;
  let startPart = rootEnd;
  let end = -1;
  let matchedSlash = true;
  let i = path2.length - 1;
  let preDotState = 0;
  for (;i >= rootEnd; --i) {
    code = path2.charCodeAt(i);
    if (isPathSeparator(code)) {
      if (!matchedSlash) {
        startPart = i + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i + 1;
    }
    if (code === CHAR_DOT) {
      if (startDot === -1)
        startDot = i;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      ret.base = ret.name = path2.slice(startPart, end);
    }
  } else {
    ret.name = path2.slice(startPart, startDot);
    ret.base = path2.slice(startPart, end);
    ret.ext = path2.slice(startDot, end);
  }
  ret.base = ret.base || "\\";
  if (startPart > 0 && startPart !== rootEnd) {
    ret.dir = path2.slice(0, startPart - 1);
  } else
    ret.dir = ret.root;
  return ret;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/parse.js
function parse3(path2) {
  return isWindows ? parse2(path2) : parse(path2);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/resolve.js
function resolve(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1;i >= -1 && !resolvedAbsolute; i--) {
    let path2;
    if (i >= 0)
      path2 = pathSegments[i];
    else {
      const { Deno: Deno4 } = dntGlobalThis;
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a current working directory (CWD)");
      }
      path2 = Deno4.cwd();
    }
    assertPath(path2);
    if (path2.length === 0) {
      continue;
    }
    resolvedPath = `${path2}/${resolvedPath}`;
    resolvedAbsolute = isPosixPathSeparator(path2.charCodeAt(0));
  }
  resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0)
      return `/${resolvedPath}`;
    else
      return "/";
  } else if (resolvedPath.length > 0)
    return resolvedPath;
  else
    return ".";
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/_common/relative.js
function assertArgs2(from, to) {
  assertPath(from);
  assertPath(to);
  if (from === to)
    return "";
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/relative.js
function relative(from, to) {
  assertArgs2(from, to);
  from = resolve(from);
  to = resolve(to);
  if (from === to)
    return "";
  let fromStart = 1;
  const fromEnd = from.length;
  for (;fromStart < fromEnd; ++fromStart) {
    if (!isPosixPathSeparator(from.charCodeAt(fromStart)))
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to.length;
  for (;toStart < toEnd; ++toStart) {
    if (!isPosixPathSeparator(to.charCodeAt(toStart)))
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (;i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (isPosixPathSeparator(to.charCodeAt(toStart + i))) {
          return to.slice(toStart + i + 1);
        } else if (i === 0) {
          return to.slice(toStart + i);
        }
      } else if (fromLen > length) {
        if (isPosixPathSeparator(from.charCodeAt(fromStart + i))) {
          lastCommonSep = i;
        } else if (i === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from.charCodeAt(fromStart + i);
    const toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (isPosixPathSeparator(fromCode))
      lastCommonSep = i;
  }
  let out = "";
  for (i = fromStart + lastCommonSep + 1;i <= fromEnd; ++i) {
    if (i === fromEnd || isPosixPathSeparator(from.charCodeAt(i))) {
      if (out.length === 0)
        out += "..";
      else
        out += "/..";
    }
  }
  if (out.length > 0)
    return out + to.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (isPosixPathSeparator(to.charCodeAt(toStart)))
      ++toStart;
    return to.slice(toStart);
  }
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/resolve.js
function resolve2(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i = pathSegments.length - 1;i >= -1; i--) {
    let path2;
    const { Deno: Deno4 } = dntGlobalThis;
    if (i >= 0) {
      path2 = pathSegments[i];
    } else if (!resolvedDevice) {
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a current working directory (CWD)");
      }
      path2 = Deno4.cwd();
    } else {
      if (typeof Deno4?.env?.get !== "function" || typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a current working directory (CWD)");
      }
      path2 = Deno4.cwd();
      if (path2 === undefined || path2.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path2 = `${resolvedDevice}\\`;
      }
    }
    assertPath(path2);
    const len = path2.length;
    if (len === 0)
      continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute4 = false;
    const code = path2.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator(code)) {
        isAbsolute4 = true;
        if (isPathSeparator(path2.charCodeAt(1))) {
          let j = 2;
          let last = j;
          for (;j < len; ++j) {
            if (isPathSeparator(path2.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            const firstPart = path2.slice(last, j);
            last = j;
            for (;j < len; ++j) {
              if (!isPathSeparator(path2.charCodeAt(j)))
                break;
            }
            if (j < len && j !== last) {
              last = j;
              for (;j < len; ++j) {
                if (isPathSeparator(path2.charCodeAt(j)))
                  break;
              }
              if (j === len) {
                device = `\\\\${firstPart}\\${path2.slice(last)}`;
                rootEnd = j;
              } else if (j !== last) {
                device = `\\\\${firstPart}\\${path2.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code)) {
        if (path2.charCodeAt(1) === CHAR_COLON) {
          device = path2.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator(path2.charCodeAt(2))) {
              isAbsolute4 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator(code)) {
      rootEnd = 1;
      isAbsolute4 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path2.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute4;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0)
      break;
  }
  resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/relative.js
function relative2(from, to) {
  assertArgs2(from, to);
  const fromOrig = resolve2(from);
  const toOrig = resolve2(to);
  if (fromOrig === toOrig)
    return "";
  from = fromOrig.toLowerCase();
  to = toOrig.toLowerCase();
  if (from === to)
    return "";
  let fromStart = 0;
  let fromEnd = from.length;
  for (;fromStart < fromEnd; ++fromStart) {
    if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH)
      break;
  }
  for (;fromEnd - 1 > fromStart; --fromEnd) {
    if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to.length;
  for (;toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH)
      break;
  }
  for (;toEnd - 1 > toStart; --toEnd) {
    if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i = 0;
  for (;i <= length; ++i) {
    if (i === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {
          return toOrig.slice(toStart + i + 1);
        } else if (i === 2) {
          return toOrig.slice(toStart + i);
        }
      }
      if (fromLen > length) {
        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i;
        } else if (i === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from.charCodeAt(fromStart + i);
    const toCode = to.charCodeAt(toStart + i);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_BACKWARD_SLASH)
      lastCommonSep = i;
  }
  if (i !== length && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1)
    lastCommonSep = 0;
  for (i = fromStart + lastCommonSep + 1;i <= fromEnd; ++i) {
    if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {
      if (out.length === 0)
        out += "..";
      else
        out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH)
      ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/relative.js
function relative3(from, to) {
  return isWindows ? relative2(from, to) : relative(from, to);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/resolve.js
function resolve3(...pathSegments) {
  return isWindows ? resolve2(...pathSegments) : resolve(...pathSegments);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/_common/to_file_url.js
var WHITESPACE_ENCODINGS = {
  "\t": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace(string) {
  return string.replaceAll(/[\s]/g, (c) => {
    return WHITESPACE_ENCODINGS[c] ?? c;
  });
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/to_file_url.js
function toFileUrl(path2) {
  if (!isAbsolute(path2)) {
    throw new TypeError(`Path must be absolute: received "${path2}"`);
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace(path2.replace(/%/g, "%25").replace(/\\/g, "%5C"));
  return url;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/to_file_url.js
function toFileUrl2(path2) {
  if (!isAbsolute2(path2)) {
    throw new TypeError(`Path must be absolute: received "${path2}"`);
  }
  const [, hostname, pathname] = path2.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
  const url = new URL("file:///");
  url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
  if (hostname !== undefined && hostname !== "localhost") {
    url.hostname = hostname;
    if (!url.hostname) {
      throw new TypeError(`Invalid hostname: "${url.hostname}"`);
    }
  }
  return url;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/to_file_url.js
function toFileUrl3(path2) {
  return isWindows ? toFileUrl2(path2) : toFileUrl(path2);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/to_namespaced_path.js
function toNamespacedPath(path2) {
  return path2;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/to_namespaced_path.js
function toNamespacedPath2(path2) {
  if (typeof path2 !== "string")
    return path2;
  if (path2.length === 0)
    return "";
  const resolvedPath = resolve2(path2);
  if (resolvedPath.length >= 3) {
    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
        const code = resolvedPath.charCodeAt(2);
        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
      if (resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
        return `\\\\?\\${resolvedPath}`;
      }
    }
  }
  return path2;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/to_namespaced_path.js
function toNamespacedPath3(path2) {
  return isWindows ? toNamespacedPath2(path2) : toNamespacedPath(path2);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/_common/common.js
function common(paths, sep) {
  const [first = "", ...remaining] = paths;
  const parts = first.split(sep);
  let endOfPrefix = parts.length;
  let append = "";
  for (const path2 of remaining) {
    const compare = path2.split(sep);
    if (compare.length <= endOfPrefix) {
      endOfPrefix = compare.length;
      append = "";
    }
    for (let i = 0;i < endOfPrefix; i++) {
      if (compare[i] !== parts[i]) {
        endOfPrefix = i;
        append = i === 0 ? "" : sep;
        break;
      }
    }
  }
  return parts.slice(0, endOfPrefix).join(sep) + append;
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/common.js
function common2(paths) {
  return common(paths, SEPARATOR);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/_common/glob_to_reg_exp.js
var REG_EXP_ESCAPE_CHARS = [
  "!",
  "$",
  "(",
  ")",
  "*",
  "+",
  ".",
  "=",
  "?",
  "[",
  "\\",
  "^",
  "{",
  "|"
];
var RANGE_ESCAPE_CHARS = ["-", "\\", "]"];
function _globToRegExp(c, glob, {
  extended = true,
  globstar: globstarOption = true,
  caseInsensitive = false
} = {}) {
  if (glob === "") {
    return /(?!)/;
  }
  let newLength = glob.length;
  for (;newLength > 1 && c.seps.includes(glob[newLength - 1]); newLength--)
    ;
  glob = glob.slice(0, newLength);
  let regExpString = "";
  for (let j = 0;j < glob.length; ) {
    let segment = "";
    const groupStack = [];
    let inRange = false;
    let inEscape = false;
    let endsWithSep = false;
    let i = j;
    for (;i < glob.length && !c.seps.includes(glob[i]); i++) {
      if (inEscape) {
        inEscape = false;
        const escapeChars = inRange ? RANGE_ESCAPE_CHARS : REG_EXP_ESCAPE_CHARS;
        segment += escapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
        continue;
      }
      if (glob[i] === c.escapePrefix) {
        inEscape = true;
        continue;
      }
      if (glob[i] === "[") {
        if (!inRange) {
          inRange = true;
          segment += "[";
          if (glob[i + 1] === "!") {
            i++;
            segment += "^";
          } else if (glob[i + 1] === "^") {
            i++;
            segment += "\\^";
          }
          continue;
        } else if (glob[i + 1] === ":") {
          let k = i + 1;
          let value = "";
          while (glob[k + 1] !== undefined && glob[k + 1] !== ":") {
            value += glob[k + 1];
            k++;
          }
          if (glob[k + 1] === ":" && glob[k + 2] === "]") {
            i = k + 2;
            if (value === "alnum")
              segment += "\\dA-Za-z";
            else if (value === "alpha")
              segment += "A-Za-z";
            else if (value === "ascii")
              segment += "\x00-";
            else if (value === "blank")
              segment += "\t ";
            else if (value === "cntrl")
              segment += "\x00-\x1F";
            else if (value === "digit")
              segment += "\\d";
            else if (value === "graph")
              segment += "!-~";
            else if (value === "lower")
              segment += "a-z";
            else if (value === "print")
              segment += " -~";
            else if (value === "punct") {
              segment += `!"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_{|}~`;
            } else if (value === "space")
              segment += "\\s\v";
            else if (value === "upper")
              segment += "A-Z";
            else if (value === "word")
              segment += "\\w";
            else if (value === "xdigit")
              segment += "\\dA-Fa-f";
            continue;
          }
        }
      }
      if (glob[i] === "]" && inRange) {
        inRange = false;
        segment += "]";
        continue;
      }
      if (inRange) {
        segment += glob[i];
        continue;
      }
      if (glob[i] === ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] !== "BRACE") {
        segment += ")";
        const type = groupStack.pop();
        if (type === "!") {
          segment += c.wildcard;
        } else if (type !== "@") {
          segment += type;
        }
        continue;
      }
      if (glob[i] === "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] !== "BRACE") {
        segment += "|";
        continue;
      }
      if (glob[i] === "+" && extended && glob[i + 1] === "(") {
        i++;
        groupStack.push("+");
        segment += "(?:";
        continue;
      }
      if (glob[i] === "@" && extended && glob[i + 1] === "(") {
        i++;
        groupStack.push("@");
        segment += "(?:";
        continue;
      }
      if (glob[i] === "?") {
        if (extended && glob[i + 1] === "(") {
          i++;
          groupStack.push("?");
          segment += "(?:";
        } else {
          segment += ".";
        }
        continue;
      }
      if (glob[i] === "!" && extended && glob[i + 1] === "(") {
        i++;
        groupStack.push("!");
        segment += "(?!";
        continue;
      }
      if (glob[i] === "{") {
        groupStack.push("BRACE");
        segment += "(?:";
        continue;
      }
      if (glob[i] === "}" && groupStack[groupStack.length - 1] === "BRACE") {
        groupStack.pop();
        segment += ")";
        continue;
      }
      if (glob[i] === "," && groupStack[groupStack.length - 1] === "BRACE") {
        segment += "|";
        continue;
      }
      if (glob[i] === "*") {
        if (extended && glob[i + 1] === "(") {
          i++;
          groupStack.push("*");
          segment += "(?:";
        } else {
          const prevChar2 = glob[i - 1];
          let numStars = 1;
          while (glob[i + 1] === "*") {
            i++;
            numStars++;
          }
          const nextChar = glob[i + 1];
          if (globstarOption && numStars === 2 && [...c.seps, undefined].includes(prevChar2) && [...c.seps, undefined].includes(nextChar)) {
            segment += c.globstar;
            endsWithSep = true;
          } else {
            segment += c.wildcard;
          }
        }
        continue;
      }
      segment += REG_EXP_ESCAPE_CHARS.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
    }
    if (groupStack.length > 0 || inRange || inEscape) {
      segment = "";
      for (const c2 of glob.slice(j, i)) {
        segment += REG_EXP_ESCAPE_CHARS.includes(c2) ? `\\${c2}` : c2;
        endsWithSep = false;
      }
    }
    regExpString += segment;
    if (!endsWithSep) {
      regExpString += i < glob.length ? c.sep : c.sepMaybe;
      endsWithSep = true;
    }
    while (c.seps.includes(glob[i]))
      i++;
    j = i;
  }
  regExpString = `^${regExpString}$`;
  return new RegExp(regExpString, caseInsensitive ? "i" : "");
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/glob_to_regexp.js
var constants = {
  sep: "/+",
  sepMaybe: "/*",
  seps: ["/"],
  globstar: "(?:[^/]*(?:/|$)+)*",
  wildcard: "[^/]*",
  escapePrefix: "\\"
};
function globToRegExp(glob, options = {}) {
  return _globToRegExp(constants, glob, options);
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/glob_to_regexp.js
var constants2 = {
  sep: "(?:\\\\|/)+",
  sepMaybe: "(?:\\\\|/)*",
  seps: ["\\", "/"],
  globstar: "(?:[^\\\\/]*(?:\\\\|/|$)+)*",
  wildcard: "[^\\\\/]*",
  escapePrefix: "`"
};
function globToRegExp2(glob, options = {}) {
  return _globToRegExp(constants2, glob, options);
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/glob_to_regexp.js
function globToRegExp3(glob, options = {}) {
  return isWindows ? globToRegExp2(glob, options) : globToRegExp(glob, options);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/is_glob.js
function isGlob(str) {
  const chars = { "{": "}", "(": ")", "[": "]" };
  const regex = /\\(.)|(^!|\*|\?|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
  if (str === "") {
    return false;
  }
  let match;
  while (match = regex.exec(str)) {
    if (match[2])
      return true;
    let idx = match.index + match[0].length;
    const open = match[1];
    const close = open ? chars[open] : null;
    if (open && close) {
      const n = str.indexOf(close, idx);
      if (n !== -1) {
        idx = n + 1;
      }
    }
    str = str.slice(idx);
  }
  return false;
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/constants.js
var SEPARATOR2 = "/";
var SEPARATOR_PATTERN2 = /\/+/;

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/normalize_glob.js
function normalizeGlob(glob, options = {}) {
  const { globstar = false } = options;
  if (glob.match(/\0/g)) {
    throw new Error(`Glob contains invalid characters: "${glob}"`);
  }
  if (!globstar) {
    return normalize(glob);
  }
  const s = SEPARATOR_PATTERN2.source;
  const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
  return normalize(glob.replace(badParentPattern, "\x00")).replace(/\0/g, "..");
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/posix/join_globs.js
function joinGlobs(globs, options = {}) {
  const { globstar = false } = options;
  if (!globstar || globs.length === 0) {
    return join(...globs);
  }
  let joined;
  for (const glob of globs) {
    const path2 = glob;
    if (path2.length > 0) {
      if (!joined)
        joined = path2;
      else
        joined += `${SEPARATOR2}${path2}`;
    }
  }
  if (!joined)
    return ".";
  return normalizeGlob(joined, { globstar });
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/constants.js
var SEPARATOR3 = "\\";
var SEPARATOR_PATTERN3 = /[\\/]+/;

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/normalize_glob.js
function normalizeGlob2(glob, options = {}) {
  const { globstar = false } = options;
  if (glob.match(/\0/g)) {
    throw new Error(`Glob contains invalid characters: "${glob}"`);
  }
  if (!globstar) {
    return normalize2(glob);
  }
  const s = SEPARATOR_PATTERN3.source;
  const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
  return normalize2(glob.replace(badParentPattern, "\x00")).replace(/\0/g, "..");
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/windows/join_globs.js
function joinGlobs2(globs, options = {}) {
  const { globstar = false } = options;
  if (!globstar || globs.length === 0) {
    return join2(...globs);
  }
  let joined;
  for (const glob of globs) {
    const path2 = glob;
    if (path2.length > 0) {
      if (!joined)
        joined = path2;
      else
        joined += `${SEPARATOR3}${path2}`;
    }
  }
  if (!joined)
    return ".";
  return normalizeGlob2(joined, { globstar });
}

// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/join_globs.js
function joinGlobs3(globs, options = {}) {
  return isWindows ? joinGlobs2(globs, options) : joinGlobs(globs, options);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/path/1.0.8/normalize_glob.js
function normalizeGlob3(glob, options = {}) {
  return isWindows ? normalizeGlob2(glob, options) : normalizeGlob(glob, options);
}
// node_modules/ventojs/esm/deps/jsr.io/@std/html/1.0.3/mod.js
var exports_mod2 = {};
__export(exports_mod2, {
  unescape: () => unescape,
  escape: () => escape
});

// node_modules/ventojs/esm/deps/jsr.io/@std/html/1.0.3/entities.js
var rawToEntityEntries = [
  ["&", "&amp;"],
  ["<", "&lt;"],
  [">", "&gt;"],
  ['"', "&quot;"],
  ["'", "&#39;"]
];
var defaultEntityList = Object.fromEntries([
  ...rawToEntityEntries.map(([raw, entity]) => [entity, raw]),
  ["&apos;", "'"],
  ["&nbsp;", ""]
]);
var rawToEntity = new Map(rawToEntityEntries);
var rawRe = new RegExp(`[${[...rawToEntity.keys()].join("")}]`, "g");
function escape(str) {
  return str.replaceAll(rawRe, (m) => rawToEntity.get(m));
}
var defaultUnescapeOptions = {
  entityList: defaultEntityList
};
var MAX_CODE_POINT = 1114111;
var RX_DEC_ENTITY = /&#([0-9]+);/g;
var RX_HEX_ENTITY = /&#x(\p{AHex}+);/gu;
var entityListRegexCache = new WeakMap;
function unescape(str, options = {}) {
  const { entityList } = { ...defaultUnescapeOptions, ...options };
  let entityRe = entityListRegexCache.get(entityList);
  if (!entityRe) {
    entityRe = new RegExp(`(${Object.keys(entityList).sort((a, b) => b.length - a.length).join("|")})`, "g");
    entityListRegexCache.set(entityList, entityRe);
  }
  return str.replaceAll(entityRe, (m) => entityList[m]).replaceAll(RX_DEC_ENTITY, (_, dec) => codePointStrToChar(dec, 10)).replaceAll(RX_HEX_ENTITY, (_, hex) => codePointStrToChar(hex, 16));
}
function codePointStrToChar(codePointStr, radix) {
  const codePoint = parseInt(codePointStr, radix);
  return codePoint > MAX_CODE_POINT ? "" : String.fromCodePoint(codePoint);
}
// node_modules/ventojs/esm/deps/jsr.io/@davidbonnet/astring/1.8.6/src/astring.js
var exports_astring = {};
__export(exports_astring, {
  generate: () => generate,
  baseGenerator: () => baseGenerator,
  NEEDS_PARENTHESES: () => NEEDS_PARENTHESES,
  GENERATOR: () => GENERATOR,
  EXPRESSIONS_PRECEDENCE: () => EXPRESSIONS_PRECEDENCE
});
var { stringify } = JSON;
if (!String.prototype.repeat) {
  throw new Error("String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation");
}
if (!String.prototype.endsWith) {
  throw new Error("String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation");
}
var OPERATOR_PRECEDENCE = {
  "||": 2,
  "??": 3,
  "&&": 4,
  "|": 5,
  "^": 6,
  "&": 7,
  "==": 8,
  "!=": 8,
  "===": 8,
  "!==": 8,
  "<": 9,
  ">": 9,
  "<=": 9,
  ">=": 9,
  in: 9,
  instanceof: 9,
  "<<": 10,
  ">>": 10,
  ">>>": 10,
  "+": 11,
  "-": 11,
  "*": 12,
  "%": 12,
  "/": 12,
  "**": 13
};
var NEEDS_PARENTHESES = 17;
var EXPRESSIONS_PRECEDENCE = {
  ArrayExpression: 20,
  TaggedTemplateExpression: 20,
  ThisExpression: 20,
  Identifier: 20,
  PrivateIdentifier: 20,
  Literal: 18,
  TemplateLiteral: 20,
  Super: 20,
  SequenceExpression: 20,
  MemberExpression: 19,
  ChainExpression: 19,
  CallExpression: 19,
  NewExpression: 19,
  ArrowFunctionExpression: NEEDS_PARENTHESES,
  ClassExpression: NEEDS_PARENTHESES,
  FunctionExpression: NEEDS_PARENTHESES,
  ObjectExpression: NEEDS_PARENTHESES,
  UpdateExpression: 16,
  UnaryExpression: 15,
  AwaitExpression: 15,
  BinaryExpression: 14,
  LogicalExpression: 13,
  ConditionalExpression: 4,
  AssignmentExpression: 3,
  YieldExpression: 2,
  RestElement: 1
};
function formatSequence(state, nodes) {
  const { generator } = state;
  state.write("(");
  if (nodes != null && nodes.length > 0) {
    generator[nodes[0].type](nodes[0], state);
    const { length } = nodes;
    for (let i = 1;i < length; i++) {
      const param = nodes[i];
      state.write(", ");
      generator[param.type](param, state);
    }
  }
  state.write(")");
}
function expressionNeedsParenthesis(state, node, parentNode, isRightHand) {
  const nodePrecedence = state.expressionsPrecedence[node.type];
  if (nodePrecedence === NEEDS_PARENTHESES) {
    return true;
  }
  const parentNodePrecedence = state.expressionsPrecedence[parentNode.type];
  if (nodePrecedence !== parentNodePrecedence) {
    return !isRightHand && nodePrecedence === 15 && parentNodePrecedence === 14 && parentNode.operator === "**" || nodePrecedence < parentNodePrecedence;
  }
  if (nodePrecedence !== 13 && nodePrecedence !== 14) {
    return false;
  }
  if (node.operator === "**" && parentNode.operator === "**") {
    return !isRightHand;
  }
  if (nodePrecedence === 13 && parentNodePrecedence === 13 && (node.operator === "??" || parentNode.operator === "??")) {
    return true;
  }
  if (isRightHand) {
    return OPERATOR_PRECEDENCE[node.operator] <= OPERATOR_PRECEDENCE[parentNode.operator];
  }
  return OPERATOR_PRECEDENCE[node.operator] < OPERATOR_PRECEDENCE[parentNode.operator];
}
function formatExpression(state, node, parentNode, isRightHand) {
  const { generator } = state;
  if (expressionNeedsParenthesis(state, node, parentNode, isRightHand)) {
    state.write("(");
    generator[node.type](node, state);
    state.write(")");
  } else {
    generator[node.type](node, state);
  }
}
function reindent(state, text, indent, lineEnd) {
  const lines = text.split(`
`);
  const end = lines.length - 1;
  state.write(lines[0].trim());
  if (end > 0) {
    state.write(lineEnd);
    for (let i = 1;i < end; i++) {
      state.write(indent + lines[i].trim() + lineEnd);
    }
    state.write(indent + lines[end].trim());
  }
}
function formatComments(state, comments, indent, lineEnd) {
  const { length } = comments;
  for (let i = 0;i < length; i++) {
    const comment = comments[i];
    state.write(indent);
    if (comment.type[0] === "L") {
      state.write("// " + comment.value.trim() + `
`, comment);
    } else {
      state.write("/*");
      reindent(state, comment.value, indent, lineEnd);
      state.write("*/" + lineEnd);
    }
  }
}
function hasCallExpression(node) {
  let currentNode = node;
  while (currentNode != null) {
    const { type } = currentNode;
    if (type[0] === "C" && type[1] === "a") {
      return true;
    } else if (type[0] === "M" && type[1] === "e" && type[2] === "m") {
      currentNode = currentNode.object;
    } else {
      return false;
    }
  }
}
function formatVariableDeclaration(state, node) {
  const { generator } = state;
  const { declarations } = node;
  state.write(node.kind + " ");
  const { length } = declarations;
  if (length > 0) {
    generator.VariableDeclarator(declarations[0], state);
    for (let i = 1;i < length; i++) {
      state.write(", ");
      generator.VariableDeclarator(declarations[i], state);
    }
  }
}
var ForInStatement;
var FunctionDeclaration;
var RestElement;
var BinaryExpression;
var ArrayExpression;
var BlockStatement;
var GENERATOR = {
  Program(node, state) {
    const indent = state.indent.repeat(state.indentLevel);
    const { lineEnd, writeComments } = state;
    if (writeComments && node.comments != null) {
      formatComments(state, node.comments, indent, lineEnd);
    }
    const statements = node.body;
    const { length } = statements;
    for (let i = 0;i < length; i++) {
      const statement = statements[i];
      if (writeComments && statement.comments != null) {
        formatComments(state, statement.comments, indent, lineEnd);
      }
      state.write(indent);
      this[statement.type](statement, state);
      state.write(lineEnd);
    }
    if (writeComments && node.trailingComments != null) {
      formatComments(state, node.trailingComments, indent, lineEnd);
    }
  },
  BlockStatement: BlockStatement = function(node, state) {
    const indent = state.indent.repeat(state.indentLevel++);
    const { lineEnd, writeComments } = state;
    const statementIndent = indent + state.indent;
    state.write("{");
    const statements = node.body;
    if (statements != null && statements.length > 0) {
      state.write(lineEnd);
      if (writeComments && node.comments != null) {
        formatComments(state, node.comments, statementIndent, lineEnd);
      }
      const { length } = statements;
      for (let i = 0;i < length; i++) {
        const statement = statements[i];
        if (writeComments && statement.comments != null) {
          formatComments(state, statement.comments, statementIndent, lineEnd);
        }
        state.write(statementIndent);
        this[statement.type](statement, state);
        state.write(lineEnd);
      }
      state.write(indent);
    } else {
      if (writeComments && node.comments != null) {
        state.write(lineEnd);
        formatComments(state, node.comments, statementIndent, lineEnd);
        state.write(indent);
      }
    }
    if (writeComments && node.trailingComments != null) {
      formatComments(state, node.trailingComments, statementIndent, lineEnd);
    }
    state.write("}");
    state.indentLevel--;
  },
  ClassBody: BlockStatement,
  StaticBlock(node, state) {
    state.write("static ");
    this.BlockStatement(node, state);
  },
  EmptyStatement(node, state) {
    state.write(";");
  },
  ExpressionStatement(node, state) {
    const precedence = state.expressionsPrecedence[node.expression.type];
    if (precedence === NEEDS_PARENTHESES || precedence === 3 && node.expression.left.type[0] === "O") {
      state.write("(");
      this[node.expression.type](node.expression, state);
      state.write(")");
    } else {
      this[node.expression.type](node.expression, state);
    }
    state.write(";");
  },
  IfStatement(node, state) {
    state.write("if (");
    this[node.test.type](node.test, state);
    state.write(") ");
    this[node.consequent.type](node.consequent, state);
    if (node.alternate != null) {
      state.write(" else ");
      this[node.alternate.type](node.alternate, state);
    }
  },
  LabeledStatement(node, state) {
    this[node.label.type](node.label, state);
    state.write(": ");
    this[node.body.type](node.body, state);
  },
  BreakStatement(node, state) {
    state.write("break");
    if (node.label != null) {
      state.write(" ");
      this[node.label.type](node.label, state);
    }
    state.write(";");
  },
  ContinueStatement(node, state) {
    state.write("continue");
    if (node.label != null) {
      state.write(" ");
      this[node.label.type](node.label, state);
    }
    state.write(";");
  },
  WithStatement(node, state) {
    state.write("with (");
    this[node.object.type](node.object, state);
    state.write(") ");
    this[node.body.type](node.body, state);
  },
  SwitchStatement(node, state) {
    const indent = state.indent.repeat(state.indentLevel++);
    const { lineEnd, writeComments } = state;
    state.indentLevel++;
    const caseIndent = indent + state.indent;
    const statementIndent = caseIndent + state.indent;
    state.write("switch (");
    this[node.discriminant.type](node.discriminant, state);
    state.write(") {" + lineEnd);
    const { cases: occurences } = node;
    const { length: occurencesCount } = occurences;
    for (let i = 0;i < occurencesCount; i++) {
      const occurence = occurences[i];
      if (writeComments && occurence.comments != null) {
        formatComments(state, occurence.comments, caseIndent, lineEnd);
      }
      if (occurence.test) {
        state.write(caseIndent + "case ");
        this[occurence.test.type](occurence.test, state);
        state.write(":" + lineEnd);
      } else {
        state.write(caseIndent + "default:" + lineEnd);
      }
      const { consequent } = occurence;
      const { length: consequentCount } = consequent;
      for (let i2 = 0;i2 < consequentCount; i2++) {
        const statement = consequent[i2];
        if (writeComments && statement.comments != null) {
          formatComments(state, statement.comments, statementIndent, lineEnd);
        }
        state.write(statementIndent);
        this[statement.type](statement, state);
        state.write(lineEnd);
      }
    }
    state.indentLevel -= 2;
    state.write(indent + "}");
  },
  ReturnStatement(node, state) {
    state.write("return");
    if (node.argument) {
      state.write(" ");
      this[node.argument.type](node.argument, state);
    }
    state.write(";");
  },
  ThrowStatement(node, state) {
    state.write("throw ");
    this[node.argument.type](node.argument, state);
    state.write(";");
  },
  TryStatement(node, state) {
    state.write("try ");
    this[node.block.type](node.block, state);
    if (node.handler) {
      const { handler } = node;
      if (handler.param == null) {
        state.write(" catch ");
      } else {
        state.write(" catch (");
        this[handler.param.type](handler.param, state);
        state.write(") ");
      }
      this[handler.body.type](handler.body, state);
    }
    if (node.finalizer) {
      state.write(" finally ");
      this[node.finalizer.type](node.finalizer, state);
    }
  },
  WhileStatement(node, state) {
    state.write("while (");
    this[node.test.type](node.test, state);
    state.write(") ");
    this[node.body.type](node.body, state);
  },
  DoWhileStatement(node, state) {
    state.write("do ");
    this[node.body.type](node.body, state);
    state.write(" while (");
    this[node.test.type](node.test, state);
    state.write(");");
  },
  ForStatement(node, state) {
    state.write("for (");
    if (node.init != null) {
      const { init } = node;
      if (init.type[0] === "V") {
        formatVariableDeclaration(state, init);
      } else {
        this[init.type](init, state);
      }
    }
    state.write("; ");
    if (node.test) {
      this[node.test.type](node.test, state);
    }
    state.write("; ");
    if (node.update) {
      this[node.update.type](node.update, state);
    }
    state.write(") ");
    this[node.body.type](node.body, state);
  },
  ForInStatement: ForInStatement = function(node, state) {
    state.write(`for ${node.await ? "await " : ""}(`);
    const { left } = node;
    if (left.type[0] === "V") {
      formatVariableDeclaration(state, left);
    } else {
      this[left.type](left, state);
    }
    state.write(node.type[3] === "I" ? " in " : " of ");
    this[node.right.type](node.right, state);
    state.write(") ");
    this[node.body.type](node.body, state);
  },
  ForOfStatement: ForInStatement,
  DebuggerStatement(node, state) {
    state.write("debugger;", node);
  },
  FunctionDeclaration: FunctionDeclaration = function(node, state) {
    state.write((node.async ? "async " : "") + (node.generator ? "function* " : "function ") + (node.id ? node.id.name : ""), node);
    formatSequence(state, node.params);
    state.write(" ");
    this[node.body.type](node.body, state);
  },
  FunctionExpression: FunctionDeclaration,
  VariableDeclaration(node, state) {
    formatVariableDeclaration(state, node);
    state.write(";");
  },
  VariableDeclarator(node, state) {
    this[node.id.type](node.id, state);
    if (node.init != null) {
      state.write(" = ");
      this[node.init.type](node.init, state);
    }
  },
  ClassDeclaration(node, state) {
    state.write("class " + (node.id ? `${node.id.name} ` : ""), node);
    if (node.superClass) {
      state.write("extends ");
      const { superClass } = node;
      const { type } = superClass;
      const precedence = state.expressionsPrecedence[type];
      if ((type[0] !== "C" || type[1] !== "l" || type[5] !== "E") && (precedence === NEEDS_PARENTHESES || precedence < state.expressionsPrecedence.ClassExpression)) {
        state.write("(");
        this[node.superClass.type](superClass, state);
        state.write(")");
      } else {
        this[superClass.type](superClass, state);
      }
      state.write(" ");
    }
    this.ClassBody(node.body, state);
  },
  ImportDeclaration(node, state) {
    state.write("import ");
    const { specifiers } = node;
    const { length } = specifiers;
    let i = 0;
    if (length > 0) {
      for (;i < length; ) {
        if (i > 0) {
          state.write(", ");
        }
        const specifier = specifiers[i];
        const type = specifier.type[6];
        if (type === "D") {
          state.write(specifier.local.name, specifier);
          i++;
        } else if (type === "N") {
          state.write("* as " + specifier.local.name, specifier);
          i++;
        } else {
          break;
        }
      }
      if (i < length) {
        state.write("{");
        for (;; ) {
          const specifier = specifiers[i];
          const { name } = specifier.imported;
          state.write(name, specifier);
          if (name !== specifier.local.name) {
            state.write(" as " + specifier.local.name);
          }
          if (++i < length) {
            state.write(", ");
          } else {
            break;
          }
        }
        state.write("}");
      }
      state.write(" from ");
    }
    this.Literal(node.source, state);
    state.write(";");
  },
  ImportExpression(node, state) {
    state.write("import(");
    this[node.source.type](node.source, state);
    state.write(")");
  },
  ExportDefaultDeclaration(node, state) {
    state.write("export default ");
    this[node.declaration.type](node.declaration, state);
    if (state.expressionsPrecedence[node.declaration.type] != null && node.declaration.type[0] !== "F") {
      state.write(";");
    }
  },
  ExportNamedDeclaration(node, state) {
    state.write("export ");
    if (node.declaration) {
      this[node.declaration.type](node.declaration, state);
    } else {
      state.write("{");
      const { specifiers } = node, { length } = specifiers;
      if (length > 0) {
        for (let i = 0;; ) {
          const specifier = specifiers[i];
          const { name } = specifier.local;
          state.write(name, specifier);
          if (name !== specifier.exported.name) {
            state.write(" as " + specifier.exported.name);
          }
          if (++i < length) {
            state.write(", ");
          } else {
            break;
          }
        }
      }
      state.write("}");
      if (node.source) {
        state.write(" from ");
        this.Literal(node.source, state);
      }
      state.write(";");
    }
  },
  ExportAllDeclaration(node, state) {
    if (node.exported != null) {
      state.write("export * as " + node.exported.name + " from ");
    } else {
      state.write("export * from ");
    }
    this.Literal(node.source, state);
    state.write(";");
  },
  MethodDefinition(node, state) {
    if (node.static) {
      state.write("static ");
    }
    const kind = node.kind[0];
    if (kind === "g" || kind === "s") {
      state.write(node.kind + " ");
    }
    if (node.value.async) {
      state.write("async ");
    }
    if (node.value.generator) {
      state.write("*");
    }
    if (node.computed) {
      state.write("[");
      this[node.key.type](node.key, state);
      state.write("]");
    } else {
      this[node.key.type](node.key, state);
    }
    formatSequence(state, node.value.params);
    state.write(" ");
    this[node.value.body.type](node.value.body, state);
  },
  ClassExpression(node, state) {
    this.ClassDeclaration(node, state);
  },
  ArrowFunctionExpression(node, state) {
    state.write(node.async ? "async " : "", node);
    const { params } = node;
    if (params != null) {
      if (params.length === 1 && params[0].type[0] === "I") {
        state.write(params[0].name, params[0]);
      } else {
        formatSequence(state, node.params);
      }
    }
    state.write(" => ");
    if (node.body.type[0] === "O") {
      state.write("(");
      this.ObjectExpression(node.body, state);
      state.write(")");
    } else {
      this[node.body.type](node.body, state);
    }
  },
  ThisExpression(node, state) {
    state.write("this", node);
  },
  Super(node, state) {
    state.write("super", node);
  },
  RestElement: RestElement = function(node, state) {
    state.write("...");
    this[node.argument.type](node.argument, state);
  },
  SpreadElement: RestElement,
  YieldExpression(node, state) {
    state.write(node.delegate ? "yield*" : "yield");
    if (node.argument) {
      state.write(" ");
      this[node.argument.type](node.argument, state);
    }
  },
  AwaitExpression(node, state) {
    state.write("await ", node);
    formatExpression(state, node.argument, node);
  },
  TemplateLiteral(node, state) {
    const { quasis, expressions } = node;
    state.write("`");
    const { length } = expressions;
    for (let i = 0;i < length; i++) {
      const expression = expressions[i];
      const quasi2 = quasis[i];
      state.write(quasi2.value.raw, quasi2);
      state.write("${");
      this[expression.type](expression, state);
      state.write("}");
    }
    const quasi = quasis[quasis.length - 1];
    state.write(quasi.value.raw, quasi);
    state.write("`");
  },
  TemplateElement(node, state) {
    state.write(node.value.raw, node);
  },
  TaggedTemplateExpression(node, state) {
    formatExpression(state, node.tag, node);
    this[node.quasi.type](node.quasi, state);
  },
  ArrayExpression: ArrayExpression = function(node, state) {
    state.write("[");
    if (node.elements.length > 0) {
      const { elements } = node, { length } = elements;
      for (let i = 0;; ) {
        const element = elements[i];
        if (element != null) {
          this[element.type](element, state);
        }
        if (++i < length) {
          state.write(", ");
        } else {
          if (element == null) {
            state.write(", ");
          }
          break;
        }
      }
    }
    state.write("]");
  },
  ArrayPattern: ArrayExpression,
  ObjectExpression(node, state) {
    const indent = state.indent.repeat(state.indentLevel++);
    const { lineEnd, writeComments } = state;
    const propertyIndent = indent + state.indent;
    state.write("{");
    if (node.properties.length > 0) {
      state.write(lineEnd);
      if (writeComments && node.comments != null) {
        formatComments(state, node.comments, propertyIndent, lineEnd);
      }
      const comma = "," + lineEnd;
      const { properties } = node, { length } = properties;
      for (let i = 0;; ) {
        const property = properties[i];
        if (writeComments && property.comments != null) {
          formatComments(state, property.comments, propertyIndent, lineEnd);
        }
        state.write(propertyIndent);
        this[property.type](property, state);
        if (++i < length) {
          state.write(comma);
        } else {
          break;
        }
      }
      state.write(lineEnd);
      if (writeComments && node.trailingComments != null) {
        formatComments(state, node.trailingComments, propertyIndent, lineEnd);
      }
      state.write(indent + "}");
    } else if (writeComments) {
      if (node.comments != null) {
        state.write(lineEnd);
        formatComments(state, node.comments, propertyIndent, lineEnd);
        if (node.trailingComments != null) {
          formatComments(state, node.trailingComments, propertyIndent, lineEnd);
        }
        state.write(indent + "}");
      } else if (node.trailingComments != null) {
        state.write(lineEnd);
        formatComments(state, node.trailingComments, propertyIndent, lineEnd);
        state.write(indent + "}");
      } else {
        state.write("}");
      }
    } else {
      state.write("}");
    }
    state.indentLevel--;
  },
  Property(node, state) {
    if (node.method || node.kind[0] !== "i") {
      this.MethodDefinition(node, state);
    } else {
      if (!node.shorthand) {
        if (node.computed) {
          state.write("[");
          this[node.key.type](node.key, state);
          state.write("]");
        } else {
          this[node.key.type](node.key, state);
        }
        state.write(": ");
      }
      this[node.value.type](node.value, state);
    }
  },
  PropertyDefinition(node, state) {
    if (node.static) {
      state.write("static ");
    }
    if (node.computed) {
      state.write("[");
    }
    this[node.key.type](node.key, state);
    if (node.computed) {
      state.write("]");
    }
    if (node.value == null) {
      if (node.key.type[0] !== "F") {
        state.write(";");
      }
      return;
    }
    state.write(" = ");
    this[node.value.type](node.value, state);
    state.write(";");
  },
  ObjectPattern(node, state) {
    state.write("{");
    if (node.properties.length > 0) {
      const { properties } = node, { length } = properties;
      for (let i = 0;; ) {
        this[properties[i].type](properties[i], state);
        if (++i < length) {
          state.write(", ");
        } else {
          break;
        }
      }
    }
    state.write("}");
  },
  SequenceExpression(node, state) {
    formatSequence(state, node.expressions);
  },
  UnaryExpression(node, state) {
    if (node.prefix) {
      const { operator, argument, argument: { type } } = node;
      state.write(operator);
      const needsParentheses = expressionNeedsParenthesis(state, argument, node);
      if (!needsParentheses && (operator.length > 1 || type[0] === "U" && (type[1] === "n" || type[1] === "p") && argument.prefix && argument.operator[0] === operator && (operator === "+" || operator === "-"))) {
        state.write(" ");
      }
      if (needsParentheses) {
        state.write(operator.length > 1 ? " (" : "(");
        this[type](argument, state);
        state.write(")");
      } else {
        this[type](argument, state);
      }
    } else {
      this[node.argument.type](node.argument, state);
      state.write(node.operator);
    }
  },
  UpdateExpression(node, state) {
    if (node.prefix) {
      state.write(node.operator);
      this[node.argument.type](node.argument, state);
    } else {
      this[node.argument.type](node.argument, state);
      state.write(node.operator);
    }
  },
  AssignmentExpression(node, state) {
    this[node.left.type](node.left, state);
    state.write(" " + node.operator + " ");
    this[node.right.type](node.right, state);
  },
  AssignmentPattern(node, state) {
    this[node.left.type](node.left, state);
    state.write(" = ");
    this[node.right.type](node.right, state);
  },
  BinaryExpression: BinaryExpression = function(node, state) {
    const isIn = node.operator === "in";
    if (isIn) {
      state.write("(");
    }
    formatExpression(state, node.left, node, false);
    state.write(" " + node.operator + " ");
    formatExpression(state, node.right, node, true);
    if (isIn) {
      state.write(")");
    }
  },
  LogicalExpression: BinaryExpression,
  ConditionalExpression(node, state) {
    const { test } = node;
    const precedence = state.expressionsPrecedence[test.type];
    if (precedence === NEEDS_PARENTHESES || precedence <= state.expressionsPrecedence.ConditionalExpression) {
      state.write("(");
      this[test.type](test, state);
      state.write(")");
    } else {
      this[test.type](test, state);
    }
    state.write(" ? ");
    this[node.consequent.type](node.consequent, state);
    state.write(" : ");
    this[node.alternate.type](node.alternate, state);
  },
  NewExpression(node, state) {
    state.write("new ");
    const precedence = state.expressionsPrecedence[node.callee.type];
    if (precedence === NEEDS_PARENTHESES || precedence < state.expressionsPrecedence.CallExpression || hasCallExpression(node.callee)) {
      state.write("(");
      this[node.callee.type](node.callee, state);
      state.write(")");
    } else {
      this[node.callee.type](node.callee, state);
    }
    formatSequence(state, node["arguments"]);
  },
  CallExpression(node, state) {
    const precedence = state.expressionsPrecedence[node.callee.type];
    if (precedence === NEEDS_PARENTHESES || precedence < state.expressionsPrecedence.CallExpression) {
      state.write("(");
      this[node.callee.type](node.callee, state);
      state.write(")");
    } else {
      this[node.callee.type](node.callee, state);
    }
    if (node.optional) {
      state.write("?.");
    }
    formatSequence(state, node["arguments"]);
  },
  ChainExpression(node, state) {
    this[node.expression.type](node.expression, state);
  },
  MemberExpression(node, state) {
    const precedence = state.expressionsPrecedence[node.object.type];
    if (precedence === NEEDS_PARENTHESES || precedence < state.expressionsPrecedence.MemberExpression) {
      state.write("(");
      this[node.object.type](node.object, state);
      state.write(")");
    } else {
      this[node.object.type](node.object, state);
    }
    if (node.computed) {
      if (node.optional) {
        state.write("?.");
      }
      state.write("[");
      this[node.property.type](node.property, state);
      state.write("]");
    } else {
      if (node.optional) {
        state.write("?.");
      } else {
        state.write(".");
      }
      this[node.property.type](node.property, state);
    }
  },
  MetaProperty(node, state) {
    state.write(node.meta.name + "." + node.property.name, node);
  },
  Identifier(node, state) {
    state.write(node.name, node);
  },
  PrivateIdentifier(node, state) {
    state.write(`#${node.name}`, node);
  },
  Literal(node, state) {
    if (node.raw != null) {
      state.write(node.raw, node);
    } else if (node.regex != null) {
      this.RegExpLiteral(node, state);
    } else if (node.bigint != null) {
      state.write(node.bigint + "n", node);
    } else {
      state.write(stringify(node.value), node);
    }
  },
  RegExpLiteral(node, state) {
    const { regex } = node;
    state.write(`/${regex.pattern}/${regex.flags}`, node);
  }
};
var EMPTY_OBJECT = {};
var baseGenerator = GENERATOR;

class State {
  constructor(options) {
    const setup = options == null ? EMPTY_OBJECT : options;
    this.output = "";
    if (setup.output != null) {
      this.output = setup.output;
      this.write = this.writeToStream;
    } else {
      this.output = "";
    }
    this.generator = setup.generator != null ? setup.generator : GENERATOR;
    this.expressionsPrecedence = setup.expressionsPrecedence != null ? setup.expressionsPrecedence : EXPRESSIONS_PRECEDENCE;
    this.indent = setup.indent != null ? setup.indent : "  ";
    this.lineEnd = setup.lineEnd != null ? setup.lineEnd : `
`;
    this.indentLevel = setup.startingIndentLevel != null ? setup.startingIndentLevel : 0;
    this.writeComments = setup.comments ? setup.comments : false;
    if (setup.sourceMap != null) {
      this.write = setup.output == null ? this.writeAndMap : this.writeToStreamAndMap;
      this.sourceMap = setup.sourceMap;
      this.line = 1;
      this.column = 0;
      this.lineEndSize = this.lineEnd.split(`
`).length - 1;
      this.mapping = {
        original: null,
        generated: this,
        name: undefined,
        source: setup.sourceMap.file || setup.sourceMap._file
      };
    }
  }
  write(code) {
    this.output += code;
  }
  writeToStream(code) {
    this.output.write(code);
  }
  writeAndMap(code, node) {
    this.output += code;
    this.map(code, node);
  }
  writeToStreamAndMap(code, node) {
    this.output.write(code);
    this.map(code, node);
  }
  map(code, node) {
    if (node != null) {
      const { type } = node;
      if (type[0] === "L" && type[2] === "n") {
        this.column = 0;
        this.line++;
        return;
      }
      if (node.loc != null) {
        const { mapping } = this;
        mapping.original = node.loc.start;
        mapping.name = node.name;
        this.sourceMap.addMapping(mapping);
      }
      if (type[0] === "T" && type[8] === "E" || type[0] === "L" && type[1] === "i" && typeof node.value === "string") {
        const { length: length2 } = code;
        let { column, line } = this;
        for (let i = 0;i < length2; i++) {
          if (code[i] === `
`) {
            column = 0;
            line++;
          } else {
            column++;
          }
        }
        this.column = column;
        this.line = line;
        return;
      }
    }
    const { length } = code;
    const { lineEnd } = this;
    if (length > 0) {
      if (this.lineEndSize > 0 && (lineEnd.length === 1 ? code[length - 1] === lineEnd : code.endsWith(lineEnd))) {
        this.line += this.lineEndSize;
        this.column = 0;
      } else {
        this.column += length;
      }
    }
  }
  toString() {
    return this.output;
  }
}
function generate(node, options) {
  const state = new State(options);
  state.generator[node.type](node, state);
  return state.output;
}
// node_modules/meriyah/dist/meriyah.min.mjs
var exports_meriyah_min = {};
__export(exports_meriyah_min, {
  version: () => _n,
  parseScript: () => $n,
  parseModule: () => Yn,
  parse: () => Zn,
  ESTree: () => Xn
});
var e = { 0: "Unexpected token", 30: "Unexpected token: '%0'", 1: "Octal escape sequences are not allowed in strict mode", 2: "Octal escape sequences are not allowed in template strings", 3: "\\8 and \\9 are not allowed in template strings", 4: "Private identifier #%0 is not defined", 5: "Illegal Unicode escape sequence", 6: "Invalid code point %0", 7: "Invalid hexadecimal escape sequence", 9: "Octal literals are not allowed in strict mode", 8: "Decimal integer literals with a leading zero are forbidden in strict mode", 10: "Expected number in radix %0", 151: "Invalid left-hand side assignment to a destructible right-hand side", 11: "Non-number found after exponent indicator", 12: "Invalid BigIntLiteral", 13: "No identifiers allowed directly after numeric literal", 14: "Escapes \\8 or \\9 are not syntactically valid escapes", 15: "Escapes \\8 or \\9 are not allowed in strict mode", 16: "Unterminated string literal", 17: "Unterminated template literal", 18: "Multiline comment was not closed properly", 19: "The identifier contained dynamic unicode escape that was not closed", 20: "Illegal character '%0'", 21: "Missing hexadecimal digits", 22: "Invalid implicit octal", 23: "Invalid line break in string literal", 24: "Only unicode escapes are legal in identifier names", 25: "Expected '%0'", 26: "Invalid left-hand side in assignment", 27: "Invalid left-hand side in async arrow", 28: 'Calls to super must be in the "constructor" method of a class expression or class declaration that has a superclass', 29: "Member access on super must be in a method", 31: "Await expression not allowed in formal parameter", 32: "Yield expression not allowed in formal parameter", 95: "Unexpected token: 'escaped keyword'", 33: "Unary expressions as the left operand of an exponentiation expression must be disambiguated with parentheses", 123: "Async functions can only be declared at the top level or inside a block", 34: "Unterminated regular expression", 35: "Unexpected regular expression flag", 36: "Duplicate regular expression flag '%0'", 37: "%0 functions must have exactly %1 argument%2", 38: "Setter function argument must not be a rest parameter", 39: "%0 declaration must have a name in this context", 40: "Function name may not contain any reserved words or be eval or arguments in strict mode", 41: "The rest operator is missing an argument", 42: "A getter cannot be a generator", 43: "A setter cannot be a generator", 44: "A computed property name must be followed by a colon or paren", 134: "Object literal keys that are strings or numbers must be a method or have a colon", 46: "Found `* async x(){}` but this should be `async * x(){}`", 45: "Getters and setters can not be generators", 47: "'%0' can not be generator method", 48: "No line break is allowed after '=>'", 49: "The left-hand side of the arrow can only be destructed through assignment", 50: "The binding declaration is not destructible", 51: "Async arrow can not be followed by new expression", 52: "Classes may not have a static property named 'prototype'", 53: "Class constructor may not be a %0", 54: "Duplicate constructor method in class", 55: "Invalid increment/decrement operand", 56: "Invalid use of `new` keyword on an increment/decrement expression", 57: "`=>` is an invalid assignment target", 58: "Rest element may not have a trailing comma", 59: "Missing initializer in %0 declaration", 60: "'for-%0' loop head declarations can not have an initializer", 61: "Invalid left-hand side in for-%0 loop: Must have a single binding", 62: "Invalid shorthand property initializer", 63: "Property name __proto__ appears more than once in object literal", 64: "Let is disallowed as a lexically bound name", 65: "Invalid use of '%0' inside new expression", 66: "Illegal 'use strict' directive in function with non-simple parameter list", 67: 'Identifier "let" disallowed as left-hand side expression in strict mode', 68: "Illegal continue statement", 69: "Illegal break statement", 70: "Cannot have `let[...]` as a var name in strict mode", 71: "Invalid destructuring assignment target", 72: "Rest parameter may not have a default initializer", 73: "The rest argument must the be last parameter", 74: "Invalid rest argument", 76: "In strict mode code, functions can only be declared at top level or inside a block", 77: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement", 78: "Without web compatibility enabled functions can not be declared at top level, inside a block, or as the body of an if statement", 79: "Class declaration can't appear in single-statement context", 80: "Invalid left-hand side in for-%0", 81: "Invalid assignment in for-%0", 82: "for await (... of ...) is only valid in async functions and async generators", 83: "The first token after the template expression should be a continuation of the template", 85: "`let` declaration not allowed here and `let` cannot be a regular var name in strict mode", 84: "`let \n [` is a restricted production at the start of a statement", 86: "Catch clause requires exactly one parameter, not more (and no trailing comma)", 87: "Catch clause parameter does not support default values", 88: "Missing catch or finally after try", 89: "More than one default clause in switch statement", 90: "Illegal newline after throw", 91: "Strict mode code may not include a with statement", 92: "Illegal return statement", 93: "The left hand side of the for-header binding declaration is not destructible", 94: "new.target only allowed within functions or static blocks", 96: "'#' not followed by identifier", 102: "Invalid keyword", 101: "Can not use 'let' as a class name", 100: "'A lexical declaration can't define a 'let' binding", 99: "Can not use `let` as variable name in strict mode", 97: "'%0' may not be used as an identifier in this context", 98: "Await is only valid in async functions", 103: "The %0 keyword can only be used with the module goal", 104: "Unicode codepoint must not be greater than 0x10FFFF", 105: "%0 source must be string", 106: "Only a identifier or string can be used to indicate alias", 107: "Only '*' or '{...}' can be imported after default", 108: "Trailing decorator may be followed by method", 109: "Decorators can't be used with a constructor", 110: "Can not use `await` as identifier in module or async func", 111: "Can not use `await` as identifier in module", 112: "HTML comments are only allowed with web compatibility (Annex B)", 113: "The identifier 'let' must not be in expression position in strict mode", 114: "Cannot assign to `eval` and `arguments` in strict mode", 115: "The left-hand side of a for-of loop may not start with 'let'", 116: "Block body arrows can not be immediately invoked without a group", 117: "Block body arrows can not be immediately accessed without a group", 118: "Unexpected strict mode reserved word", 119: "Unexpected eval or arguments in strict mode", 120: "Decorators must not be followed by a semicolon", 121: "Calling delete on expression not allowed in strict mode", 122: "Pattern can not have a tail", 124: "Can not have a `yield` expression on the left side of a ternary", 125: "An arrow function can not have a postfix update operator", 126: "Invalid object literal key character after generator star", 127: "Private fields can not be deleted", 129: "Classes may not have a field called constructor", 128: "Classes may not have a private element named constructor", 130: "A class field initializer or static block may not contain arguments", 131: "Generators can only be declared at the top level or inside a block", 132: "Async methods are a restricted production and cannot have a newline following it", 133: "Unexpected character after object literal property name", 135: "Invalid key token", 136: "Label '%0' has already been declared", 137: "continue statement must be nested within an iteration statement", 138: "Undefined label '%0'", 139: "Trailing comma is disallowed inside import(...) arguments", 140: "Invalid binding in JSON import", 141: "import() requires exactly one argument", 142: "Cannot use new with import(...)", 143: "... is not allowed in import()", 144: "Expected '=>'", 145: "Duplicate binding '%0'", 146: "Duplicate private identifier #%0", 147: "Cannot export a duplicate name '%0'", 150: "Duplicate %0 for-binding", 148: "Exported binding '%0' needs to refer to a top-level declared variable", 149: "Unexpected private field", 153: "Numeric separators are not allowed at the end of numeric literals", 152: "Only one underscore is allowed as numeric separator", 154: "JSX value should be either an expression or a quoted JSX text", 155: "Expected corresponding JSX closing tag for %0", 156: "Adjacent JSX elements must be wrapped in an enclosing tag", 157: "JSX attributes must only be assigned a non-empty 'expression'", 158: "'%0' has already been declared", 159: "'%0' shadowed a catch clause binding", 160: "Dot property must be an identifier", 161: "Encountered invalid input after spread/rest argument", 162: "Catch without try", 163: "Finally without try", 164: "Expected corresponding closing tag for JSX fragment", 165: "Coalescing and logical operators used together in the same expression must be disambiguated with parentheses", 166: "Invalid tagged template on optional chain", 167: "Invalid optional chain from super property", 168: "Invalid optional chain from new expression", 169: 'Cannot use "import.meta" outside a module', 170: "Leading decorators must be attached to a class declaration", 171: "An export name cannot include a lone surrogate, found %0", 172: "A string literal cannot be used as an exported binding without `from`", 173: "Private fields can't be accessed on super", 174: "The only valid meta property for import is 'import.meta'", 175: "'import.meta' must not contain escaped characters", 176: 'cannot use "await" as identifier inside an async function', 177: 'cannot use "await" in static blocks' };

class n extends SyntaxError {
  constructor(n2, t, o, r, a, i, s, ...l) {
    const c = "[" + t + ":" + o + "-" + a + ":" + i + "]: " + e[s].replace(/%(\d+)/g, (e2, n3) => l[n3]);
    super(`${c}`), this.start = n2, this.end = r, this.range = [n2, r], this.loc = { start: { line: t, column: o }, end: { line: a, column: i } }, this.description = c;
  }
}
function t(e2, t2, ...o) {
  throw new n(e2.tokenIndex, e2.tokenLine, e2.tokenColumn, e2.index, e2.line, e2.column, t2, ...o);
}
function o(e2) {
  throw new n(e2.tokenIndex, e2.tokenLine, e2.tokenColumn, e2.index, e2.line, e2.column, e2.type, ...e2.params);
}
function r(e2, t2, o2, r2, a, i, s, ...l) {
  throw new n(e2, t2, o2, r2, a, i, s, ...l);
}
function a(e2, t2, o2, r2, a2, i, s) {
  throw new n(e2, t2, o2, r2, a2, i, s);
}
function i(e2) {
  return !!(1 & s[34816 + (e2 >>> 5)] >>> e2);
}
var s = ((e2, n2) => {
  const t2 = new Uint32Array(104448);
  let o2 = 0, r2 = 0;
  for (;o2 < 3822; ) {
    const a2 = e2[o2++];
    if (a2 < 0)
      r2 -= a2;
    else {
      let i2 = e2[o2++];
      2 & a2 && (i2 = n2[i2]), 1 & a2 ? t2.fill(i2, r2, r2 += e2[o2++]) : t2[r2++] = i2;
    }
  }
  return t2;
})([-1, 2, 26, 2, 27, 2, 5, -1, 0, 77595648, 3, 44, 2, 3, 0, 14, 2, 63, 2, 64, 3, 0, 3, 0, 3168796671, 0, 4294956992, 2, 1, 2, 0, 2, 41, 3, 0, 4, 0, 4294966523, 3, 0, 4, 2, 16, 2, 65, 2, 0, 0, 4294836735, 0, 3221225471, 0, 4294901942, 2, 66, 0, 134152192, 3, 0, 2, 0, 4294951935, 3, 0, 2, 0, 2683305983, 0, 2684354047, 2, 18, 2, 0, 0, 4294961151, 3, 0, 2, 2, 19, 2, 0, 0, 608174079, 2, 0, 2, 60, 2, 7, 2, 6, 0, 4286611199, 3, 0, 2, 2, 1, 3, 0, 3, 0, 4294901711, 2, 40, 0, 4089839103, 0, 2961209759, 0, 1342439375, 0, 4294543342, 0, 3547201023, 0, 1577204103, 0, 4194240, 0, 4294688750, 2, 2, 0, 80831, 0, 4261478351, 0, 4294549486, 2, 2, 0, 2967484831, 0, 196559, 0, 3594373100, 0, 3288319768, 0, 8469959, 2, 203, 2, 3, 0, 4093640191, 0, 660618719, 0, 65487, 0, 4294828015, 0, 4092591615, 0, 1616920031, 0, 982991, 2, 3, 2, 0, 0, 2163244511, 0, 4227923919, 0, 4236247022, 2, 71, 0, 4284449919, 0, 851904, 2, 4, 2, 12, 0, 67076095, -1, 2, 72, 0, 1073741743, 0, 4093607775, -1, 0, 50331649, 0, 3265266687, 2, 33, 0, 4294844415, 0, 4278190047, 2, 20, 2, 137, -1, 3, 0, 2, 2, 23, 2, 0, 2, 10, 2, 0, 2, 15, 2, 22, 3, 0, 10, 2, 74, 2, 0, 2, 75, 2, 76, 2, 77, 2, 0, 2, 78, 2, 0, 2, 11, 0, 261632, 2, 25, 3, 0, 2, 2, 13, 2, 4, 3, 0, 18, 2, 79, 2, 5, 3, 0, 2, 2, 80, 0, 2151677951, 2, 29, 2, 9, 0, 909311, 3, 0, 2, 0, 814743551, 2, 49, 0, 67090432, 3, 0, 2, 2, 42, 2, 0, 2, 6, 2, 0, 2, 30, 2, 8, 0, 268374015, 2, 110, 2, 51, 2, 0, 2, 81, 0, 134153215, -1, 2, 7, 2, 0, 2, 8, 0, 2684354559, 0, 67044351, 0, 3221160064, 2, 17, -1, 3, 0, 2, 2, 53, 0, 1046528, 3, 0, 3, 2, 9, 2, 0, 2, 54, 0, 4294960127, 2, 10, 2, 6, 2, 11, 0, 4294377472, 2, 12, 3, 0, 16, 2, 13, 2, 0, 2, 82, 2, 10, 2, 0, 2, 83, 2, 84, 2, 85, 2, 210, 2, 55, 0, 1048577, 2, 86, 2, 14, -1, 2, 14, 0, 131042, 2, 87, 2, 88, 2, 89, 2, 0, 2, 34, -83, 3, 0, 7, 0, 1046559, 2, 0, 2, 15, 2, 0, 0, 2147516671, 2, 21, 3, 90, 2, 2, 0, -16, 2, 91, 0, 524222462, 2, 4, 2, 0, 0, 4269801471, 2, 4, 3, 0, 2, 2, 28, 2, 16, 3, 0, 2, 2, 17, 2, 0, -1, 2, 18, -16, 3, 0, 206, -2, 3, 0, 692, 2, 73, -1, 2, 18, 2, 10, 3, 0, 8, 2, 93, 2, 133, 2, 0, 0, 3220242431, 3, 0, 3, 2, 19, 2, 94, 2, 95, 3, 0, 2, 2, 96, 2, 0, 2, 97, 2, 46, 2, 0, 0, 4351, 2, 0, 2, 9, 3, 0, 2, 0, 67043391, 0, 3909091327, 2, 0, 2, 24, 2, 9, 2, 20, 3, 0, 2, 0, 67076097, 2, 8, 2, 0, 2, 21, 0, 67059711, 0, 4236247039, 3, 0, 2, 0, 939524103, 0, 8191999, 2, 101, 2, 102, 2, 22, 2, 23, 3, 0, 3, 0, 67057663, 3, 0, 349, 2, 103, 2, 104, 2, 7, -264, 3, 0, 11, 2, 24, 3, 0, 2, 2, 32, -1, 0, 3774349439, 2, 105, 2, 106, 3, 0, 2, 2, 19, 2, 107, 3, 0, 10, 2, 10, 2, 18, 2, 0, 2, 47, 2, 0, 2, 31, 2, 108, 2, 25, 0, 1638399, 2, 183, 2, 109, 3, 0, 3, 2, 20, 2, 26, 2, 27, 2, 5, 2, 28, 2, 0, 2, 8, 2, 111, -1, 2, 112, 2, 113, 2, 114, -1, 3, 0, 3, 2, 12, -2, 2, 0, 2, 29, -3, 2, 163, -4, 2, 20, 2, 0, 2, 36, 0, 1, 2, 0, 2, 67, 2, 6, 2, 12, 2, 10, 2, 0, 2, 115, -1, 3, 0, 4, 2, 10, 2, 23, 2, 116, 2, 7, 2, 0, 2, 117, 2, 0, 2, 118, 2, 119, 2, 120, 2, 0, 2, 9, 3, 0, 9, 2, 21, 2, 30, 2, 31, 2, 121, 2, 122, -2, 2, 123, 2, 124, 2, 30, 2, 21, 2, 8, -2, 2, 125, 2, 30, 2, 32, -2, 2, 0, 2, 39, -2, 0, 4277137519, 0, 2269118463, -1, 3, 20, 2, -1, 2, 33, 2, 38, 2, 0, 3, 30, 2, 2, 35, 2, 19, -3, 3, 0, 2, 2, 34, -1, 2, 0, 2, 35, 2, 0, 2, 35, 2, 0, 2, 48, 2, 0, 0, 4294950463, 2, 37, -7, 2, 0, 0, 203775, 2, 57, 2, 167, 2, 20, 2, 43, 2, 36, 2, 18, 2, 37, 2, 18, 2, 126, 2, 21, 3, 0, 2, 2, 38, 0, 2151677888, 2, 0, 2, 12, 0, 4294901764, 2, 144, 2, 0, 2, 58, 2, 56, 0, 5242879, 3, 0, 2, 0, 402644511, -1, 2, 128, 2, 39, 0, 3, -1, 2, 129, 2, 130, 2, 0, 0, 67045375, 2, 40, 0, 4226678271, 0, 3766565279, 0, 2039759, 2, 132, 2, 41, 0, 1046437, 0, 6, 3, 0, 2, 0, 3288270847, 0, 3, 3, 0, 2, 0, 67043519, -5, 2, 0, 0, 4282384383, 0, 1056964609, -1, 3, 0, 2, 0, 67043345, -1, 2, 0, 2, 42, 2, 23, 2, 50, 2, 11, 2, 61, 2, 38, -5, 2, 0, 2, 12, -3, 3, 0, 2, 0, 2147484671, 2, 134, 0, 4190109695, 2, 52, -2, 2, 135, 0, 4244635647, 0, 27, 2, 0, 2, 8, 2, 43, 2, 0, 2, 68, 2, 18, 2, 0, 2, 42, -6, 2, 0, 2, 45, 2, 59, 2, 44, 2, 45, 2, 46, 2, 47, 0, 8388351, -2, 2, 136, 0, 3028287487, 2, 48, 2, 138, 0, 33259519, 2, 49, -9, 2, 21, 0, 4294836223, 0, 3355443199, 0, 134152199, -2, 2, 69, -2, 3, 0, 28, 2, 32, -3, 3, 0, 3, 2, 17, 3, 0, 6, 2, 50, -81, 2, 18, 3, 0, 2, 2, 36, 3, 0, 33, 2, 25, 2, 30, 3, 0, 124, 2, 12, 3, 0, 18, 2, 38, -213, 2, 0, 2, 32, -54, 3, 0, 17, 2, 42, 2, 8, 2, 23, 2, 0, 2, 8, 2, 23, 2, 51, 2, 0, 2, 21, 2, 52, 2, 139, 2, 25, -13, 2, 0, 2, 53, -6, 3, 0, 2, -4, 3, 0, 2, 0, 4294936575, 2, 0, 0, 4294934783, -2, 0, 196635, 3, 0, 191, 2, 54, 3, 0, 38, 2, 30, 2, 55, 2, 34, -278, 2, 140, 3, 0, 9, 2, 141, 2, 142, 2, 56, 3, 0, 11, 2, 7, -72, 3, 0, 3, 2, 143, 0, 1677656575, -130, 2, 26, -16, 2, 0, 2, 24, 2, 38, -16, 0, 4161266656, 0, 4071, 2, 205, -4, 2, 57, -13, 3, 0, 2, 2, 58, 2, 0, 2, 145, 2, 146, 2, 62, 2, 0, 2, 147, 2, 148, 2, 149, 3, 0, 10, 2, 150, 2, 151, 2, 22, 3, 58, 2, 3, 152, 2, 3, 59, 2, 0, 4294954999, 2, 0, -16, 2, 0, 2, 92, 2, 0, 0, 2105343, 0, 4160749584, 2, 177, -34, 2, 8, 2, 154, -6, 0, 4194303871, 0, 4294903771, 2, 0, 2, 60, 2, 100, -3, 2, 0, 0, 1073684479, 0, 17407, -9, 2, 18, 2, 17, 2, 0, 2, 32, -14, 2, 18, 2, 32, -6, 2, 18, 2, 12, -15, 2, 155, 3, 0, 6, 0, 8323103, -1, 3, 0, 2, 2, 61, -37, 2, 62, 2, 156, 2, 157, 2, 158, 2, 159, 2, 160, -105, 2, 26, -32, 3, 0, 1335, -1, 3, 0, 129, 2, 32, 3, 0, 6, 2, 10, 3, 0, 180, 2, 161, 3, 0, 233, 2, 162, 3, 0, 18, 2, 10, -77, 3, 0, 16, 2, 10, -47, 3, 0, 154, 2, 6, 3, 0, 130, 2, 25, -22250, 3, 0, 7, 2, 25, -6130, 3, 5, 2, -1, 0, 69207040, 3, 44, 2, 3, 0, 14, 2, 63, 2, 64, -3, 0, 3168731136, 0, 4294956864, 2, 1, 2, 0, 2, 41, 3, 0, 4, 0, 4294966275, 3, 0, 4, 2, 16, 2, 65, 2, 0, 2, 34, -1, 2, 18, 2, 66, -1, 2, 0, 0, 2047, 0, 4294885376, 3, 0, 2, 0, 3145727, 0, 2617294944, 0, 4294770688, 2, 25, 2, 67, 3, 0, 2, 0, 131135, 2, 98, 0, 70256639, 0, 71303167, 0, 272, 2, 42, 2, 6, 0, 32511, 2, 0, 2, 49, -1, 2, 99, 2, 68, 0, 4278255616, 0, 4294836227, 0, 4294549473, 0, 600178175, 0, 2952806400, 0, 268632067, 0, 4294543328, 0, 57540095, 0, 1577058304, 0, 1835008, 0, 4294688736, 2, 70, 2, 69, 0, 33554435, 2, 131, 2, 70, 2, 164, 0, 131075, 0, 3594373096, 0, 67094296, 2, 69, -1, 0, 4294828000, 0, 603979263, 0, 654311424, 0, 3, 0, 4294828001, 0, 602930687, 2, 171, 0, 393219, 0, 4294828016, 0, 671088639, 0, 2154840064, 0, 4227858435, 0, 4236247008, 2, 71, 2, 38, -1, 2, 4, 0, 917503, 2, 38, -1, 2, 72, 0, 537788335, 0, 4026531935, -1, 0, 1, -1, 2, 33, 2, 73, 0, 7936, -3, 2, 0, 0, 2147485695, 0, 1010761728, 0, 4292984930, 0, 16387, 2, 0, 2, 15, 2, 22, 3, 0, 10, 2, 74, 2, 0, 2, 75, 2, 76, 2, 77, 2, 0, 2, 78, 2, 0, 2, 12, -1, 2, 25, 3, 0, 2, 2, 13, 2, 4, 3, 0, 18, 2, 79, 2, 5, 3, 0, 2, 2, 80, 0, 2147745791, 3, 19, 2, 0, 122879, 2, 0, 2, 9, 0, 276824064, -2, 3, 0, 2, 2, 42, 2, 0, 0, 4294903295, 2, 0, 2, 30, 2, 8, -1, 2, 18, 2, 51, 2, 0, 2, 81, 2, 49, -1, 2, 21, 2, 0, 2, 29, -2, 0, 128, -2, 2, 28, 2, 9, 0, 8160, -1, 2, 127, 0, 4227907585, 2, 0, 2, 37, 2, 0, 2, 50, 2, 184, 2, 10, 2, 6, 2, 11, -1, 0, 74440192, 3, 0, 6, -2, 3, 0, 8, 2, 13, 2, 0, 2, 82, 2, 10, 2, 0, 2, 83, 2, 84, 2, 85, -3, 2, 86, 2, 14, -3, 2, 87, 2, 88, 2, 89, 2, 0, 2, 34, -83, 3, 0, 7, 0, 817183, 2, 0, 2, 15, 2, 0, 0, 33023, 2, 21, 3, 90, 2, -17, 2, 91, 0, 524157950, 2, 4, 2, 0, 2, 92, 2, 4, 2, 0, 2, 22, 2, 28, 2, 16, 3, 0, 2, 2, 17, 2, 0, -1, 2, 18, -16, 3, 0, 206, -2, 3, 0, 692, 2, 73, -1, 2, 18, 2, 10, 3, 0, 8, 2, 93, 0, 3072, 2, 0, 0, 2147516415, 2, 10, 3, 0, 2, 2, 25, 2, 94, 2, 95, 3, 0, 2, 2, 96, 2, 0, 2, 97, 2, 46, 0, 4294965179, 0, 7, 2, 0, 2, 9, 2, 95, 2, 9, -1, 0, 1761345536, 2, 98, 0, 4294901823, 2, 38, 2, 20, 2, 99, 2, 35, 2, 100, 0, 2080440287, 2, 0, 2, 34, 2, 153, 0, 3296722943, 2, 0, 0, 1046675455, 0, 939524101, 0, 1837055, 2, 101, 2, 102, 2, 22, 2, 23, 3, 0, 3, 0, 7, 3, 0, 349, 2, 103, 2, 104, 2, 7, -264, 3, 0, 11, 2, 24, 3, 0, 2, 2, 32, -1, 0, 2700607615, 2, 105, 2, 106, 3, 0, 2, 2, 19, 2, 107, 3, 0, 10, 2, 10, 2, 18, 2, 0, 2, 47, 2, 0, 2, 31, 2, 108, -3, 2, 109, 3, 0, 3, 2, 20, -1, 3, 5, 2, 2, 110, 2, 0, 2, 8, 2, 111, -1, 2, 112, 2, 113, 2, 114, -1, 3, 0, 3, 2, 12, -2, 2, 0, 2, 29, -8, 2, 20, 2, 0, 2, 36, -1, 2, 0, 2, 67, 2, 6, 2, 30, 2, 10, 2, 0, 2, 115, -1, 3, 0, 4, 2, 10, 2, 18, 2, 116, 2, 7, 2, 0, 2, 117, 2, 0, 2, 118, 2, 119, 2, 120, 2, 0, 2, 9, 3, 0, 9, 2, 21, 2, 30, 2, 31, 2, 121, 2, 122, -2, 2, 123, 2, 124, 2, 30, 2, 21, 2, 8, -2, 2, 125, 2, 30, 2, 32, -2, 2, 0, 2, 39, -2, 0, 4277075969, 2, 30, -1, 3, 20, 2, -1, 2, 33, 2, 126, 2, 0, 3, 30, 2, 2, 35, 2, 19, -3, 3, 0, 2, 2, 34, -1, 2, 0, 2, 35, 2, 0, 2, 35, 2, 0, 2, 50, 2, 98, 0, 4294934591, 2, 37, -7, 2, 0, 0, 197631, 2, 57, -1, 2, 20, 2, 43, 2, 37, 2, 18, 0, 3, 2, 18, 2, 126, 2, 21, 2, 127, 2, 54, -1, 0, 2490368, 2, 127, 2, 25, 2, 18, 2, 34, 2, 127, 2, 38, 0, 4294901904, 0, 4718591, 2, 127, 2, 35, 0, 335544350, -1, 2, 128, 0, 2147487743, 0, 1, -1, 2, 129, 2, 130, 2, 8, -1, 2, 131, 2, 70, 0, 3758161920, 0, 3, 2, 132, 0, 12582911, 0, 655360, -1, 2, 0, 2, 29, 0, 2147485568, 0, 3, 2, 0, 2, 25, 0, 176, -5, 2, 0, 2, 17, 2, 192, -1, 2, 0, 2, 25, 2, 209, -1, 2, 0, 0, 16779263, -2, 2, 12, -1, 2, 38, -5, 2, 0, 2, 133, -3, 3, 0, 2, 2, 55, 2, 134, 0, 2147549183, 0, 2, -2, 2, 135, 2, 36, 0, 10, 0, 4294965249, 0, 67633151, 0, 4026597376, 2, 0, 0, 536871935, 2, 18, 2, 0, 2, 42, -6, 2, 0, 0, 1, 2, 59, 2, 17, 0, 1, 2, 46, 2, 25, -3, 2, 136, 2, 36, 2, 137, 2, 138, 0, 16778239, -10, 2, 35, 0, 4294836212, 2, 9, -3, 2, 69, -2, 3, 0, 28, 2, 32, -3, 3, 0, 3, 2, 17, 3, 0, 6, 2, 50, -81, 2, 18, 3, 0, 2, 2, 36, 3, 0, 33, 2, 25, 0, 126, 3, 0, 124, 2, 12, 3, 0, 18, 2, 38, -213, 2, 10, -55, 3, 0, 17, 2, 42, 2, 8, 2, 18, 2, 0, 2, 8, 2, 18, 2, 60, 2, 0, 2, 25, 2, 50, 2, 139, 2, 25, -13, 2, 0, 2, 73, -6, 3, 0, 2, -4, 3, 0, 2, 0, 67583, -1, 2, 107, -2, 0, 11, 3, 0, 191, 2, 54, 3, 0, 38, 2, 30, 2, 55, 2, 34, -278, 2, 140, 3, 0, 9, 2, 141, 2, 142, 2, 56, 3, 0, 11, 2, 7, -72, 3, 0, 3, 2, 143, 2, 144, -187, 3, 0, 2, 2, 58, 2, 0, 2, 145, 2, 146, 2, 62, 2, 0, 2, 147, 2, 148, 2, 149, 3, 0, 10, 2, 150, 2, 151, 2, 22, 3, 58, 2, 3, 152, 2, 3, 59, 2, 2, 153, -57, 2, 8, 2, 154, -7, 2, 18, 2, 0, 2, 60, -4, 2, 0, 0, 1065361407, 0, 16384, -9, 2, 18, 2, 60, 2, 0, 2, 133, -14, 2, 18, 2, 133, -6, 2, 18, 0, 81919, -15, 2, 155, 3, 0, 6, 2, 126, -1, 3, 0, 2, 0, 2063, -37, 2, 62, 2, 156, 2, 157, 2, 158, 2, 159, 2, 160, -138, 3, 0, 1335, -1, 3, 0, 129, 2, 32, 3, 0, 6, 2, 10, 3, 0, 180, 2, 161, 3, 0, 233, 2, 162, 3, 0, 18, 2, 10, -77, 3, 0, 16, 2, 10, -47, 3, 0, 154, 2, 6, 3, 0, 130, 2, 25, -28386, 2, 0, 0, 1, -1, 2, 55, 2, 0, 0, 8193, -21, 2, 201, 0, 10255, 0, 4, -11, 2, 69, 2, 182, -1, 0, 71680, -1, 2, 174, 0, 4292900864, 0, 268435519, -5, 2, 163, -1, 2, 173, -1, 0, 6144, -2, 2, 46, -1, 2, 168, -1, 0, 2147532800, 2, 164, 2, 170, 0, 8355840, -2, 0, 4, -4, 2, 198, 0, 205128192, 0, 1333757536, 0, 2147483696, 0, 423953, 0, 747766272, 0, 2717763192, 0, 4286578751, 0, 278545, 2, 165, 0, 4294886464, 0, 33292336, 0, 417809, 2, 165, 0, 1327482464, 0, 4278190128, 0, 700594195, 0, 1006647527, 0, 4286497336, 0, 4160749631, 2, 166, 0, 201327104, 0, 3634348576, 0, 8323120, 2, 166, 0, 202375680, 0, 2678047264, 0, 4293984304, 2, 166, -1, 0, 983584, 0, 48, 0, 58720273, 0, 3489923072, 0, 10517376, 0, 4293066815, 0, 1, 2, 213, 2, 167, 2, 0, 0, 2089, 0, 3221225552, 0, 201359520, 2, 0, -2, 0, 256, 0, 122880, 0, 16777216, 2, 163, 0, 4160757760, 2, 0, -6, 2, 179, -11, 0, 3263218176, -1, 0, 49664, 0, 2160197632, 0, 8388802, -1, 0, 12713984, -1, 2, 168, 2, 186, 2, 187, -2, 2, 175, -20, 0, 3758096385, -2, 2, 169, 2, 195, 2, 94, 2, 180, 0, 4294057984, -2, 2, 176, 2, 172, 0, 4227874816, -2, 2, 169, -1, 2, 170, -1, 2, 181, 2, 55, 0, 4026593280, 0, 14, 0, 4292919296, -1, 2, 178, 0, 939588608, -1, 0, 805306368, -1, 2, 55, 2, 171, 2, 172, 2, 173, 2, 211, 2, 0, -2, 0, 8192, -4, 0, 267386880, -1, 0, 117440512, 0, 7168, -1, 2, 170, 2, 168, 2, 174, 2, 188, -16, 2, 175, -1, 0, 1426112704, 2, 176, -1, 2, 196, 0, 271581216, 0, 2149777408, 2, 25, 2, 174, 2, 55, 0, 851967, 2, 189, -1, 2, 177, 2, 190, -4, 2, 178, -20, 2, 98, 2, 208, -56, 0, 3145728, 2, 191, -10, 0, 32505856, -1, 2, 179, -1, 0, 2147385088, 2, 94, 1, 2155905152, 2, -3, 2, 176, 2, 0, 0, 67108864, -2, 2, 180, -6, 2, 181, 2, 25, 0, 1, -1, 0, 1, -1, 2, 182, -3, 2, 126, 2, 69, -2, 2, 100, -2, 0, 32704, 2, 55, -915, 2, 183, -1, 2, 207, -10, 2, 194, -5, 2, 185, -6, 0, 3759456256, 2, 19, -1, 2, 184, -1, 2, 185, -2, 0, 4227874752, -3, 0, 2146435072, 2, 186, -2, 0, 1006649344, 2, 55, -1, 2, 94, 0, 201375744, -3, 0, 134217720, 2, 94, 0, 4286677377, 0, 32896, -1, 2, 178, -3, 0, 4227907584, -349, 0, 65520, 0, 1920, 2, 167, 3, 0, 264, -11, 2, 173, -2, 2, 187, 2, 0, 0, 520617856, 0, 2692743168, 0, 36, -3, 0, 524280, -13, 2, 193, -1, 0, 4294934272, 2, 25, 2, 187, -1, 2, 215, 0, 2158720, -3, 2, 186, 0, 1, -4, 2, 55, 0, 3808625411, 0, 3489628288, 0, 4096, 0, 1207959680, 0, 3221274624, 2, 0, -3, 2, 188, 0, 120, 0, 7340032, -2, 2, 189, 2, 4, 2, 25, 2, 176, 3, 0, 4, 2, 186, -1, 2, 190, 2, 167, -1, 0, 8176, 2, 170, 2, 188, 0, 1073741824, -1, 0, 4290773232, 2, 0, -4, 2, 176, 2, 197, 0, 15728640, 2, 167, -1, 2, 174, -1, 0, 134250480, 0, 4720640, 0, 3825467396, -1, 2, 180, -9, 2, 94, 2, 181, 0, 4294967040, 2, 137, 0, 4160880640, 3, 0, 2, 0, 704, 0, 1849688064, 2, 191, -1, 2, 55, 0, 4294901887, 2, 0, 0, 130547712, 0, 1879048192, 2, 212, 3, 0, 2, -1, 2, 192, 2, 193, -1, 0, 17829776, 0, 2025848832, 0, 4261477888, -2, 2, 0, -1, 0, 4286580608, -1, 0, 29360128, 2, 200, 0, 16252928, 0, 3791388672, 2, 130, 3, 0, 2, -2, 2, 206, 2, 0, -1, 2, 107, -1, 0, 66584576, -1, 2, 199, -1, 0, 448, 0, 4294918080, 3, 0, 6, 2, 55, -1, 0, 4294755328, 0, 4294967267, 2, 7, -1, 2, 174, 2, 187, 2, 25, 2, 98, 2, 25, 2, 194, 2, 94, -2, 0, 245760, 2, 195, -1, 2, 163, 2, 202, 0, 4227923456, -1, 2, 196, 2, 174, 2, 94, -3, 0, 4292870145, 0, 262144, -1, 2, 95, 2, 0, 0, 1073758848, 2, 197, -1, 0, 4227921920, 2, 198, 0, 68289024, 0, 528402016, 0, 4292927536, 0, 46080, 2, 191, 0, 4265609306, 0, 4294967289, -2, 0, 268435456, 2, 95, -2, 2, 199, 3, 0, 5, -1, 2, 200, 2, 176, 2, 0, -2, 0, 4227923936, 2, 67, -1, 2, 187, 2, 197, 2, 99, 2, 168, 2, 178, 2, 204, 3, 0, 5, -1, 2, 167, 3, 0, 3, -2, 0, 2146959360, 0, 9440640, 0, 104857600, 0, 4227923840, 3, 0, 2, 0, 768, 2, 201, 2, 28, -2, 2, 174, -2, 2, 202, -1, 2, 169, 2, 98, 3, 0, 5, -1, 0, 4227923964, 0, 512, 0, 8388608, 2, 203, 2, 183, 2, 193, 0, 4286578944, 3, 0, 2, 0, 1152, 0, 1266679808, 2, 199, 0, 576, 0, 4261707776, 2, 98, 3, 0, 9, 2, 169, 0, 131072, 0, 939524096, 2, 188, 3, 0, 2, 2, 16, -1, 0, 2147221504, -28, 2, 187, 3, 0, 3, -3, 0, 4292902912, -6, 2, 99, 3, 0, 81, 2, 25, -2, 2, 107, -33, 2, 18, 2, 181, -124, 2, 188, -18, 2, 204, 3, 0, 213, -1, 2, 187, 3, 0, 54, -17, 2, 169, 2, 55, 2, 205, -1, 2, 55, 2, 197, 0, 4290822144, -2, 0, 67174336, 0, 520093700, 2, 18, 3, 0, 13, -1, 2, 187, 3, 0, 6, -2, 2, 188, 3, 0, 3, -2, 0, 30720, -1, 0, 32512, 3, 0, 2, 0, 4294770656, -191, 2, 185, -38, 2, 181, 2, 8, 2, 206, 3, 0, 278, 0, 2417033215, -9, 0, 4294705144, 0, 4292411391, 0, 65295, -11, 2, 167, 3, 0, 72, -3, 0, 3758159872, 0, 201391616, 3, 0, 123, -7, 2, 187, -13, 2, 180, 3, 0, 2, -1, 2, 173, 2, 207, -3, 2, 99, 2, 0, -7, 2, 181, -1, 0, 384, -1, 0, 133693440, -3, 2, 208, -2, 2, 110, 3, 0, 3, 3, 180, 2, -2, 2, 94, 2, 169, 3, 0, 4, -2, 2, 196, -1, 2, 163, 0, 335552923, 2, 209, -1, 0, 538974272, 0, 2214592512, 0, 132000, -10, 0, 192, -8, 2, 210, -21, 0, 134213632, 2, 162, 3, 0, 34, 2, 55, 0, 4294965279, 3, 0, 6, 0, 100663424, 0, 63524, -1, 2, 214, 2, 152, 3, 0, 3, -1, 0, 3221282816, 0, 4294917120, 3, 0, 9, 2, 25, 2, 211, -1, 2, 212, 3, 0, 14, 2, 25, 2, 187, 3, 0, 6, 2, 25, 2, 213, 3, 0, 15, 0, 2147520640, -6, 0, 4286578784, 2, 0, -2, 0, 1006694400, 3, 0, 24, 2, 36, -1, 0, 4292870144, 3, 0, 2, 0, 1, 2, 176, 3, 0, 6, 2, 209, 0, 4110942569, 0, 1432950139, 0, 2701658217, 0, 4026532864, 0, 4026532881, 2, 0, 2, 47, 3, 0, 8, -1, 2, 178, -2, 2, 180, 0, 98304, 0, 65537, 2, 181, -5, 2, 214, 2, 0, 2, 37, 2, 202, 2, 167, 0, 4294770176, 2, 110, 3, 0, 4, -30, 2, 192, 0, 3758153728, -3, 0, 125829120, -2, 2, 187, 0, 4294897664, 2, 178, -1, 2, 199, -1, 2, 174, 0, 4026580992, 2, 95, 2, 0, -10, 2, 180, 0, 3758145536, 0, 31744, -1, 0, 1610628992, 0, 4261477376, -4, 2, 215, -2, 2, 187, 3, 0, 32, -1335, 2, 0, -129, 2, 187, -6, 2, 176, -180, 0, 65532, -233, 2, 177, -18, 2, 176, 3, 0, 77, -16, 2, 176, 3, 0, 47, -154, 2, 170, -130, 2, 18, 3, 0, 22250, -7, 2, 18, 3, 0, 6128], [4294967295, 4294967291, 4092460543, 4294828031, 4294967294, 134217726, 4294903807, 268435455, 2147483647, 1048575, 1073741823, 3892314111, 134217727, 1061158911, 536805376, 4294910143, 4294901759, 32767, 4294901760, 262143, 536870911, 8388607, 4160749567, 4294902783, 4294918143, 65535, 67043328, 2281701374, 4294967264, 2097151, 4194303, 255, 67108863, 4294967039, 511, 524287, 131071, 63, 127, 3238002687, 4294549487, 4290772991, 33554431, 4294901888, 4286578687, 67043329, 4294705152, 4294770687, 67043583, 1023, 15, 2047999, 67043343, 67051519, 16777215, 2147483648, 4294902000, 28, 4292870143, 4294966783, 16383, 67047423, 4294967279, 262083, 20511, 41943039, 493567, 4294959104, 603979775, 65536, 602799615, 805044223, 4294965206, 8191, 1031749119, 4294917631, 2134769663, 4286578493, 4282253311, 4294942719, 33540095, 4294905855, 2868854591, 1608515583, 265232348, 534519807, 2147614720, 1060109444, 4093640016, 17376, 2139062143, 224, 4169138175, 4294909951, 4286578688, 4294967292, 4294965759, 535511039, 4294966272, 4294967280, 32768, 8289918, 4294934399, 4294901775, 4294965375, 1602223615, 4294967259, 4294443008, 268369920, 4292804608, 4294967232, 486341884, 4294963199, 3087007615, 1073692671, 4128527, 4279238655, 4294902015, 4160684047, 4290246655, 469499899, 4294967231, 134086655, 4294966591, 2445279231, 3670015, 31, 4294967288, 4294705151, 3221208447, 4294902271, 4294549472, 4294921215, 4095, 4285526655, 4294966527, 4294966143, 64, 4294966719, 3774873592, 1877934080, 262151, 2555904, 536807423, 67043839, 3758096383, 3959414372, 3755993023, 2080374783, 4294835295, 4294967103, 4160749565, 4294934527, 4087, 2016, 2147446655, 184024726, 2862017156, 1593309078, 268434431, 268434414, 4294901763, 4294901761, 536870912, 2952790016, 202506752, 139264, 4026531840, 402653184, 4261412864, 63488, 1610612736, 4227922944, 49152, 65280, 3233808384, 3221225472, 65534, 61440, 57152, 4293918720, 4290772992, 25165824, 57344, 4227915776, 4278190080, 3758096384, 4227858432, 4160749568, 3758129152, 4294836224, 4194304, 251658240, 196608, 4294963200, 2143289344, 2097152, 64512, 417808, 4227923712, 12582912, 50331648, 65528, 65472, 4294967168, 15360, 4294966784, 65408, 4294965248, 16, 12288, 4294934528, 2080374784, 2013265920, 4294950912, 524288]);
function l(e2) {
  return e2.column++, e2.currentChar = e2.source.charCodeAt(++e2.index);
}
function c(e2) {
  const n2 = e2.currentChar;
  if ((64512 & n2) != 55296)
    return 0;
  const t2 = e2.source.charCodeAt(e2.index + 1);
  return (64512 & t2) != 56320 ? 0 : 65536 + ((1023 & n2) << 10) + (1023 & t2);
}
function u(e2, n2) {
  e2.currentChar = e2.source.charCodeAt(++e2.index), e2.flags |= 1, 4 & n2 || (e2.column = 0, e2.line++);
}
function d(e2) {
  e2.flags |= 1, e2.currentChar = e2.source.charCodeAt(++e2.index), e2.column = 0, e2.line++;
}
function g(e2) {
  return e2 < 65 ? e2 - 48 : e2 - 65 + 10 & 15;
}
function k(e2) {
  switch (e2) {
    case 134283266:
      return "NumericLiteral";
    case 134283267:
      return "StringLiteral";
    case 86021:
    case 86022:
      return "BooleanLiteral";
    case 86023:
      return "NullLiteral";
    case 65540:
      return "RegularExpression";
    case 67174408:
    case 67174409:
    case 131:
      return "TemplateLiteral";
    default:
      return 143360 & ~e2 ? 4096 & ~e2 ? "Punctuator" : "Keyword" : "Identifier";
  }
}
var p = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1032, 0, 0, 2056, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8192, 0, 3, 0, 0, 8192, 0, 0, 0, 256, 0, 33024, 0, 0, 242, 242, 114, 114, 114, 114, 114, 114, 594, 594, 0, 0, 16384, 0, 0, 0, 0, 67, 67, 67, 67, 67, 67, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 1, 0, 0, 4099, 0, 71, 71, 71, 71, 71, 71, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 16384, 0, 0, 0, 0];
var f = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
var m = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
function b(e2) {
  return e2 <= 127 ? f[e2] > 0 : i(e2);
}
function h(e2) {
  return e2 <= 127 ? m[e2] > 0 : function(e3) {
    return !!(1 & s[0 + (e3 >>> 5)] >>> e3);
  }(e2) || e2 === 8204 || e2 === 8205;
}
var x = ["SingleLine", "MultiLine", "HTMLOpen", "HTMLClose", "HashbangComment"];
function T(e2, n2, o2, r2, a2, i2, s2, l2) {
  return 512 & r2 && t(e2, 0), y(e2, n2, o2, a2, i2, s2, l2);
}
function y(e2, n2, t2, o2, r2, a2, i2) {
  const { index: s2 } = e2;
  for (e2.tokenIndex = e2.index, e2.tokenLine = e2.line, e2.tokenColumn = e2.column;e2.index < e2.end; ) {
    if (8 & p[e2.currentChar]) {
      const t3 = e2.currentChar === 13;
      d(e2), t3 && e2.index < e2.end && e2.currentChar === 10 && (e2.currentChar = n2.charCodeAt(++e2.index));
      break;
    }
    if ((8232 ^ e2.currentChar) <= 1) {
      d(e2);
      break;
    }
    l(e2), e2.tokenIndex = e2.index, e2.tokenLine = e2.line, e2.tokenColumn = e2.column;
  }
  if (e2.onComment) {
    const t3 = { start: { line: a2, column: i2 }, end: { line: e2.tokenLine, column: e2.tokenColumn } };
    e2.onComment(x[255 & o2], n2.slice(s2, e2.tokenIndex), r2, e2.tokenIndex, t3);
  }
  return 1 | t2;
}
function C(e2, n2, o2) {
  const { index: r2 } = e2;
  for (;e2.index < e2.end; )
    if (e2.currentChar < 43) {
      let t2 = false;
      for (;e2.currentChar === 42; )
        if (t2 || (o2 &= -5, t2 = true), l(e2) === 47) {
          if (l(e2), e2.onComment) {
            const t3 = { start: { line: e2.tokenLine, column: e2.tokenColumn }, end: { line: e2.line, column: e2.column } };
            e2.onComment(x[1], n2.slice(r2, e2.index - 2), r2 - 2, e2.index, t3);
          }
          return e2.tokenIndex = e2.index, e2.tokenLine = e2.line, e2.tokenColumn = e2.column, o2;
        }
      if (t2)
        continue;
      8 & p[e2.currentChar] ? e2.currentChar === 13 ? (o2 |= 5, d(e2)) : (u(e2, o2), o2 = -5 & o2 | 1) : l(e2);
    } else
      (8232 ^ e2.currentChar) <= 1 ? (o2 = -5 & o2 | 1, d(e2)) : (o2 &= -5, l(e2));
  t(e2, 18);
}
var v;
var w;
function L(e2, n2) {
  const o2 = e2.index;
  let r2 = v.Empty;
  e:
    for (;; ) {
      const n3 = e2.currentChar;
      if (l(e2), r2 & v.Escape)
        r2 &= ~v.Escape;
      else
        switch (n3) {
          case 47:
            if (r2)
              break;
            break e;
          case 92:
            r2 |= v.Escape;
            break;
          case 91:
            r2 |= v.Class;
            break;
          case 93:
            r2 &= v.Escape;
        }
      if (n3 !== 13 && n3 !== 10 && n3 !== 8232 && n3 !== 8233 || t(e2, 34), e2.index >= e2.source.length)
        return t(e2, 34);
    }
  const a2 = e2.index - 1;
  let i2 = w.Empty, s2 = e2.currentChar;
  const { index: c2 } = e2;
  for (;h(s2); ) {
    switch (s2) {
      case 103:
        i2 & w.Global && t(e2, 36, "g"), i2 |= w.Global;
        break;
      case 105:
        i2 & w.IgnoreCase && t(e2, 36, "i"), i2 |= w.IgnoreCase;
        break;
      case 109:
        i2 & w.Multiline && t(e2, 36, "m"), i2 |= w.Multiline;
        break;
      case 117:
        i2 & w.Unicode && t(e2, 36, "u"), i2 & w.UnicodeSets && t(e2, 36, "vu"), i2 |= w.Unicode;
        break;
      case 118:
        i2 & w.Unicode && t(e2, 36, "uv"), i2 & w.UnicodeSets && t(e2, 36, "v"), i2 |= w.UnicodeSets;
        break;
      case 121:
        i2 & w.Sticky && t(e2, 36, "y"), i2 |= w.Sticky;
        break;
      case 115:
        i2 & w.DotAll && t(e2, 36, "s"), i2 |= w.DotAll;
        break;
      case 100:
        i2 & w.Indices && t(e2, 36, "d"), i2 |= w.Indices;
        break;
      default:
        t(e2, 35);
    }
    s2 = l(e2);
  }
  const u2 = e2.source.slice(c2, e2.index), d2 = e2.source.slice(o2, a2);
  return e2.tokenRegExp = { pattern: d2, flags: u2 }, 128 & n2 && (e2.tokenRaw = e2.source.slice(e2.tokenIndex, e2.index)), e2.tokenValue = function(e3, n3, o3) {
    try {
      return new RegExp(n3, o3);
    } catch {
      try {
        return new RegExp(n3, o3), null;
      } catch {
        t(e3, 34);
      }
    }
  }(e2, d2, u2), 65540;
}
function I(e2, n2, o2) {
  const { index: r2 } = e2;
  let a2 = "", i2 = l(e2), s2 = e2.index;
  for (;!(8 & p[i2]); ) {
    if (i2 === o2)
      return a2 += e2.source.slice(s2, e2.index), l(e2), 128 & n2 && (e2.tokenRaw = e2.source.slice(r2, e2.index)), e2.tokenValue = a2, 134283267;
    if (!(8 & ~i2) && i2 === 92) {
      if (a2 += e2.source.slice(s2, e2.index), i2 = l(e2), i2 < 127 || i2 === 8232 || i2 === 8233) {
        const t2 = q(e2, n2, i2);
        t2 >= 0 ? a2 += String.fromCodePoint(t2) : E(e2, t2, 0);
      } else
        a2 += String.fromCodePoint(i2);
      s2 = e2.index + 1;
    }
    e2.index >= e2.end && t(e2, 16), i2 = l(e2);
  }
  t(e2, 16);
}
function q(e2, n2, t2, o2 = 0) {
  switch (t2) {
    case 98:
      return 8;
    case 102:
      return 12;
    case 114:
      return 13;
    case 110:
      return 10;
    case 116:
      return 9;
    case 118:
      return 11;
    case 13:
      if (e2.index < e2.end) {
        const n3 = e2.source.charCodeAt(e2.index + 1);
        n3 === 10 && (e2.index = e2.index + 1, e2.currentChar = n3);
      }
    case 10:
    case 8232:
    case 8233:
      return e2.column = -1, e2.line++, -1;
    case 48:
    case 49:
    case 50:
    case 51: {
      let r2 = t2 - 48, a2 = e2.index + 1, i2 = e2.column + 1;
      if (a2 < e2.end) {
        const t3 = e2.source.charCodeAt(a2);
        if (32 & p[t3]) {
          if (256 & n2 || o2)
            return -2;
          if (e2.currentChar = t3, r2 = r2 << 3 | t3 - 48, a2++, i2++, a2 < e2.end) {
            const n3 = e2.source.charCodeAt(a2);
            32 & p[n3] && (e2.currentChar = n3, r2 = r2 << 3 | n3 - 48, a2++, i2++);
          }
          e2.flags |= 64;
        } else if (r2 !== 0 || 512 & p[t3]) {
          if (256 & n2 || o2)
            return -2;
          e2.flags |= 64;
        }
        e2.index = a2 - 1, e2.column = i2 - 1;
      }
      return r2;
    }
    case 52:
    case 53:
    case 54:
    case 55: {
      if (o2 || 256 & n2)
        return -2;
      let r2 = t2 - 48;
      const a2 = e2.index + 1, i2 = e2.column + 1;
      if (a2 < e2.end) {
        const n3 = e2.source.charCodeAt(a2);
        32 & p[n3] && (r2 = r2 << 3 | n3 - 48, e2.currentChar = n3, e2.index = a2, e2.column = i2);
      }
      return e2.flags |= 64, r2;
    }
    case 120: {
      const n3 = l(e2);
      if (!(64 & p[n3]))
        return -4;
      const t3 = g(n3), o3 = l(e2);
      if (!(64 & p[o3]))
        return -4;
      return t3 << 4 | g(o3);
    }
    case 117: {
      const n3 = l(e2);
      if (e2.currentChar === 123) {
        let n4 = 0;
        for (;64 & p[l(e2)]; )
          if (n4 = n4 << 4 | g(e2.currentChar), n4 > 1114111)
            return -5;
        return e2.currentChar < 1 || e2.currentChar !== 125 ? -4 : n4;
      }
      {
        if (!(64 & p[n3]))
          return -4;
        const t3 = e2.source.charCodeAt(e2.index + 1);
        if (!(64 & p[t3]))
          return -4;
        const o3 = e2.source.charCodeAt(e2.index + 2);
        if (!(64 & p[o3]))
          return -4;
        const r2 = e2.source.charCodeAt(e2.index + 3);
        return 64 & p[r2] ? (e2.index += 3, e2.column += 3, e2.currentChar = e2.source.charCodeAt(e2.index), g(n3) << 12 | g(t3) << 8 | g(o3) << 4 | g(r2)) : -4;
      }
    }
    case 56:
    case 57:
      if (o2 || !(64 & n2) || 256 & n2)
        return -3;
      e2.flags |= 4096;
    default:
      return t2;
  }
}
function E(e2, n2, o2) {
  switch (n2) {
    case -1:
      return;
    case -2:
      t(e2, o2 ? 2 : 1);
    case -3:
      t(e2, o2 ? 3 : 14);
    case -4:
      t(e2, 7);
    case -5:
      t(e2, 104);
  }
}
function S(e2, n2) {
  const { index: o2 } = e2;
  let r2 = 67174409, a2 = "", i2 = l(e2);
  for (;i2 !== 96; ) {
    if (i2 === 36 && e2.source.charCodeAt(e2.index + 1) === 123) {
      l(e2), r2 = 67174408;
      break;
    }
    if (i2 === 92)
      if (i2 = l(e2), i2 > 126)
        a2 += String.fromCodePoint(i2);
      else {
        const { index: t2, line: o3, column: s2 } = e2, l2 = q(e2, 256 | n2, i2, 1);
        if (l2 >= 0)
          a2 += String.fromCodePoint(l2);
        else {
          if (l2 !== -1 && 16384 & n2) {
            e2.index = t2, e2.line = o3, e2.column = s2, a2 = null, i2 = A(e2, i2), i2 < 0 && (r2 = 67174408);
            break;
          }
          E(e2, l2, 1);
        }
      }
    else
      e2.index < e2.end && (i2 === 13 && e2.source.charCodeAt(e2.index) === 10 && (a2 += String.fromCodePoint(i2), e2.currentChar = e2.source.charCodeAt(++e2.index)), ((83 & i2) < 3 && i2 === 10 || (8232 ^ i2) <= 1) && (e2.column = -1, e2.line++), a2 += String.fromCodePoint(i2));
    e2.index >= e2.end && t(e2, 17), i2 = l(e2);
  }
  return l(e2), e2.tokenValue = a2, e2.tokenRaw = e2.source.slice(o2 + 1, e2.index - (r2 === 67174409 ? 1 : 2)), r2;
}
function A(e2, n2) {
  for (;n2 !== 96; ) {
    switch (n2) {
      case 36: {
        const t2 = e2.index + 1;
        if (t2 < e2.end && e2.source.charCodeAt(t2) === 123)
          return e2.index = t2, e2.column++, -n2;
        break;
      }
      case 10:
      case 8232:
      case 8233:
        e2.column = -1, e2.line++;
    }
    e2.index >= e2.end && t(e2, 17), n2 = l(e2);
  }
  return n2;
}
function D(e2, n2) {
  return e2.index >= e2.end && t(e2, 0), e2.index--, e2.column--, S(e2, n2);
}
function V(e2, n2, o2) {
  let r2 = e2.currentChar, i2 = 0, s2 = 9, c2 = 64 & o2 ? 0 : 1, u2 = 0, d2 = 0;
  if (64 & o2)
    i2 = "." + R(e2, r2), r2 = e2.currentChar, r2 === 110 && t(e2, 12);
  else {
    if (r2 === 48)
      if (r2 = l(e2), (32 | r2) == 120) {
        for (o2 = 136, r2 = l(e2);4160 & p[r2]; )
          r2 !== 95 ? (d2 = 1, i2 = 16 * i2 + g(r2), u2++, r2 = l(e2)) : (d2 || t(e2, 152), d2 = 0, r2 = l(e2));
        u2 !== 0 && d2 || t(e2, u2 === 0 ? 21 : 153);
      } else if ((32 | r2) == 111) {
        for (o2 = 132, r2 = l(e2);4128 & p[r2]; )
          r2 !== 95 ? (d2 = 1, i2 = 8 * i2 + (r2 - 48), u2++, r2 = l(e2)) : (d2 || t(e2, 152), d2 = 0, r2 = l(e2));
        u2 !== 0 && d2 || t(e2, u2 === 0 ? 0 : 153);
      } else if ((32 | r2) == 98) {
        for (o2 = 130, r2 = l(e2);4224 & p[r2]; )
          r2 !== 95 ? (d2 = 1, i2 = 2 * i2 + (r2 - 48), u2++, r2 = l(e2)) : (d2 || t(e2, 152), d2 = 0, r2 = l(e2));
        u2 !== 0 && d2 || t(e2, u2 === 0 ? 0 : 153);
      } else if (32 & p[r2])
        for (256 & n2 && t(e2, 1), o2 = 1;16 & p[r2]; ) {
          if (512 & p[r2]) {
            o2 = 32, c2 = 0;
            break;
          }
          i2 = 8 * i2 + (r2 - 48), r2 = l(e2);
        }
      else
        512 & p[r2] ? (256 & n2 && t(e2, 1), e2.flags |= 64, o2 = 32) : r2 === 95 && t(e2, 0);
    if (48 & o2) {
      if (c2) {
        for (;s2 >= 0 && 4112 & p[r2]; )
          r2 !== 95 ? (d2 = 0, i2 = 10 * i2 + (r2 - 48), r2 = l(e2), --s2) : (r2 = l(e2), (r2 === 95 || 32 & o2) && a(e2.index, e2.line, e2.column, e2.index + 1, e2.line, e2.column, 152), d2 = 1);
        if (d2 && a(e2.index, e2.line, e2.column, e2.index + 1, e2.line, e2.column, 153), s2 >= 0 && !b(r2) && r2 !== 46)
          return e2.tokenValue = i2, 128 & n2 && (e2.tokenRaw = e2.source.slice(e2.tokenIndex, e2.index)), 134283266;
      }
      i2 += R(e2, r2), r2 = e2.currentChar, r2 === 46 && (l(e2) === 95 && t(e2, 0), o2 = 64, i2 += "." + R(e2, e2.currentChar), r2 = e2.currentChar);
    }
  }
  const k2 = e2.index;
  let f2 = 0;
  if (r2 === 110 && 128 & o2)
    f2 = 1, r2 = l(e2);
  else if ((32 | r2) == 101) {
    r2 = l(e2), 256 & p[r2] && (r2 = l(e2));
    const { index: n3 } = e2;
    16 & p[r2] || t(e2, 11), i2 += e2.source.substring(k2, n3) + R(e2, r2), r2 = e2.currentChar;
  }
  return (e2.index < e2.end && 16 & p[r2] || b(r2)) && t(e2, 13), f2 ? (e2.tokenRaw = e2.source.slice(e2.tokenIndex, e2.index), e2.tokenValue = BigInt(e2.tokenRaw.slice(0, -1).replaceAll("_", "")), 134283388) : (e2.tokenValue = 15 & o2 ? i2 : 32 & o2 ? parseFloat(e2.source.substring(e2.tokenIndex, e2.index)) : +i2, 128 & n2 && (e2.tokenRaw = e2.source.slice(e2.tokenIndex, e2.index)), 134283266);
}
function R(e2, n2) {
  let t2 = 0, o2 = e2.index, r2 = "";
  for (;4112 & p[n2]; )
    if (n2 !== 95)
      t2 = 0, n2 = l(e2);
    else {
      const { index: i2 } = e2;
      (n2 = l(e2)) === 95 && a(e2.index, e2.line, e2.column, e2.index + 1, e2.line, e2.column, 152), t2 = 1, r2 += e2.source.substring(o2, i2), o2 = e2.index;
    }
  return t2 && a(e2.index, e2.line, e2.column, e2.index + 1, e2.line, e2.column, 153), r2 + e2.source.substring(o2, e2.index);
}
(function(e2) {
  e2[e2.Empty = 0] = "Empty", e2[e2.Escape = 1] = "Escape", e2[e2.Class = 2] = "Class";
})(v || (v = {})), function(e2) {
  e2[e2.Empty = 0] = "Empty", e2[e2.IgnoreCase = 1] = "IgnoreCase", e2[e2.Global = 2] = "Global", e2[e2.Multiline = 4] = "Multiline", e2[e2.Unicode = 16] = "Unicode", e2[e2.Sticky = 8] = "Sticky", e2[e2.DotAll = 32] = "DotAll", e2[e2.Indices = 64] = "Indices", e2[e2.UnicodeSets = 128] = "UnicodeSets";
}(w || (w = {}));
var N = ["end of source", "identifier", "number", "string", "regular expression", "false", "true", "null", "template continuation", "template tail", "=>", "(", "{", ".", "...", "}", ")", ";", ",", "[", "]", ":", "?", "'", '"', "++", "--", "=", "<<=", ">>=", ">>>=", "**=", "+=", "-=", "*=", "/=", "%=", "^=", "|=", "&=", "||=", "&&=", "??=", "typeof", "delete", "void", "!", "~", "+", "-", "in", "instanceof", "*", "%", "/", "**", "&&", "||", "===", "!==", "==", "!=", "<=", ">=", "<", ">", "<<", ">>", ">>>", "&", "|", "^", "var", "let", "const", "break", "case", "catch", "class", "continue", "debugger", "default", "do", "else", "export", "extends", "finally", "for", "function", "if", "import", "new", "return", "super", "switch", "this", "throw", "try", "while", "with", "implements", "interface", "package", "private", "protected", "public", "static", "yield", "as", "async", "await", "constructor", "get", "set", "accessor", "from", "of", "enum", "eval", "arguments", "escaped keyword", "escaped future reserved keyword", "reserved if strict", "#", "BigIntLiteral", "??", "?.", "WhiteSpace", "Illegal", "LineTerminator", "PrivateField", "Template", "@", "target", "meta", "LineFeed", "Escaped", "JSXText"];
var U = Object.create(null, { this: { value: 86111 }, function: { value: 86104 }, if: { value: 20569 }, return: { value: 20572 }, var: { value: 86088 }, else: { value: 20563 }, for: { value: 20567 }, new: { value: 86107 }, in: { value: 8673330 }, typeof: { value: 16863275 }, while: { value: 20578 }, case: { value: 20556 }, break: { value: 20555 }, try: { value: 20577 }, catch: { value: 20557 }, delete: { value: 16863276 }, throw: { value: 86112 }, switch: { value: 86110 }, continue: { value: 20559 }, default: { value: 20561 }, instanceof: { value: 8411187 }, do: { value: 20562 }, void: { value: 16863277 }, finally: { value: 20566 }, async: { value: 209005 }, await: { value: 209006 }, class: { value: 86094 }, const: { value: 86090 }, constructor: { value: 12399 }, debugger: { value: 20560 }, export: { value: 20564 }, extends: { value: 20565 }, false: { value: 86021 }, from: { value: 12403 }, get: { value: 12400 }, implements: { value: 36964 }, import: { value: 86106 }, interface: { value: 36965 }, let: { value: 241737 }, null: { value: 86023 }, of: { value: 274548 }, package: { value: 36966 }, private: { value: 36967 }, protected: { value: 36968 }, public: { value: 36969 }, set: { value: 12401 }, static: { value: 36970 }, super: { value: 86109 }, true: { value: 86022 }, with: { value: 20579 }, yield: { value: 241771 }, enum: { value: 86133 }, eval: { value: 537079926 }, as: { value: 77932 }, arguments: { value: 537079927 }, target: { value: 209029 }, meta: { value: 209030 }, accessor: { value: 12402 } });
function P(e2, n2, t2) {
  for (;m[l(e2)]; )
    ;
  return e2.tokenValue = e2.source.slice(e2.tokenIndex, e2.index), e2.currentChar !== 92 && e2.currentChar <= 126 ? U[e2.tokenValue] || 208897 : O(e2, n2, 0, t2);
}
function B(e2, n2) {
  const o2 = F(e2);
  return b(o2) || t(e2, 5), e2.tokenValue = String.fromCodePoint(o2), O(e2, n2, 1, 4 & p[o2]);
}
function O(e2, n2, o2, r2) {
  let a2 = e2.index;
  for (;e2.index < e2.end; )
    if (e2.currentChar === 92) {
      e2.tokenValue += e2.source.slice(a2, e2.index), o2 = 1;
      const n3 = F(e2);
      h(n3) || t(e2, 5), r2 = r2 && 4 & p[n3], e2.tokenValue += String.fromCodePoint(n3), a2 = e2.index;
    } else {
      const n3 = c(e2);
      if (n3 > 0)
        h(n3) || t(e2, 20, String.fromCodePoint(n3)), e2.currentChar = n3, e2.index++, e2.column++;
      else if (!h(e2.currentChar))
        break;
      l(e2);
    }
  e2.index <= e2.end && (e2.tokenValue += e2.source.slice(a2, e2.index));
  const { length: i2 } = e2.tokenValue;
  if (r2 && i2 >= 2 && i2 <= 11) {
    const t2 = U[e2.tokenValue];
    return t2 === undefined ? 208897 | (o2 ? -2147483648 : 0) : o2 ? t2 === 209006 ? 524800 & n2 ? -2147483528 : -2147483648 | t2 : 256 & n2 ? t2 === 36970 ? -2147483527 : 36864 & ~t2 ? 20480 & ~t2 ? -2147274630 : 67108864 & n2 && !(2048 & n2) ? -2147483648 | t2 : -2147483528 : -2147483527 : !(67108864 & n2) || 2048 & n2 || 20480 & ~t2 ? t2 === 241771 ? 67108864 & n2 ? -2147274630 : 262144 & n2 ? -2147483528 : -2147483648 | t2 : t2 === 209005 ? -2147274630 : 36864 & ~t2 ? -2147483528 : 12288 | t2 | -2147483648 : -2147483648 | t2 : t2;
  }
  return 208897 | (o2 ? -2147483648 : 0);
}
function G(e2) {
  let n2 = l(e2);
  if (n2 === 92)
    return 130;
  const o2 = c(e2);
  return o2 && (n2 = o2), b(n2) || t(e2, 96), 130;
}
function F(e2) {
  return e2.source.charCodeAt(e2.index + 1) !== 117 && t(e2, 5), e2.currentChar = e2.source.charCodeAt(e2.index += 2), function(e3) {
    let n2 = 0;
    const o2 = e3.currentChar;
    if (o2 === 123) {
      const t2 = e3.index - 2;
      for (;64 & p[l(e3)]; )
        n2 = n2 << 4 | g(e3.currentChar), n2 > 1114111 && a(t2, e3.line, e3.column, e3.index, e3.line, e3.column, 104);
      return e3.currentChar !== 125 && a(t2, e3.line, e3.column, e3.index, e3.line, e3.column, 7), l(e3), n2;
    }
    64 & p[o2] || t(e3, 7);
    const r2 = e3.source.charCodeAt(e3.index + 1);
    64 & p[r2] || t(e3, 7);
    const i2 = e3.source.charCodeAt(e3.index + 2);
    64 & p[i2] || t(e3, 7);
    const s2 = e3.source.charCodeAt(e3.index + 3);
    64 & p[s2] || t(e3, 7);
    return n2 = g(o2) << 12 | g(r2) << 8 | g(i2) << 4 | g(s2), e3.currentChar = e3.source.charCodeAt(e3.index += 4), n2;
  }(e2);
}
var j = [128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 135, 127, 127, 129, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 16842798, 134283267, 130, 208897, 8391477, 8390213, 134283267, 67174411, 16, 8391476, 25233968, 18, 25233969, 67108877, 8457014, 134283266, 134283266, 134283266, 134283266, 134283266, 134283266, 134283266, 134283266, 134283266, 134283266, 21, 1074790417, 8456256, 1077936155, 8390721, 22, 132, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 208897, 69271571, 136, 20, 8389959, 208897, 131, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 208897, 4096, 208897, 208897, 4096, 208897, 4096, 208897, 4096, 208897, 4096, 4096, 4096, 208897, 4096, 4096, 208897, 4096, 4096, 2162700, 8389702, 1074790415, 16842799, 128];
function J(e2, n2) {
  e2.flags = 1 ^ (1 | e2.flags), e2.startIndex = e2.index, e2.startColumn = e2.column, e2.startLine = e2.line, e2.setToken(H(e2, n2, 0));
}
function H(e2, n2, o2) {
  const r2 = e2.index === 0, { source: a2 } = e2;
  let { index: s2, line: g2, column: k2 } = e2;
  for (;e2.index < e2.end; ) {
    e2.tokenIndex = e2.index, e2.tokenColumn = e2.column, e2.tokenLine = e2.line;
    let f2 = e2.currentChar;
    if (f2 <= 126) {
      const i2 = j[f2];
      switch (i2) {
        case 67174411:
        case 16:
        case 2162700:
        case 1074790415:
        case 69271571:
        case 20:
        case 21:
        case 1074790417:
        case 18:
        case 16842799:
        case 132:
        case 128:
          return l(e2), i2;
        case 208897:
          return P(e2, n2, 0);
        case 4096:
          return P(e2, n2, 1);
        case 134283266:
          return V(e2, n2, 144);
        case 134283267:
          return I(e2, n2, f2);
        case 131:
          return S(e2, n2);
        case 136:
          return B(e2, n2);
        case 130:
          return G(e2);
        case 127:
          l(e2);
          break;
        case 129:
          o2 |= 5, d(e2);
          break;
        case 135:
          u(e2, o2), o2 = -5 & o2 | 1;
          break;
        case 8456256: {
          const t2 = l(e2);
          if (e2.index < e2.end) {
            if (t2 === 60)
              return e2.index < e2.end && l(e2) === 61 ? (l(e2), 4194332) : 8390978;
            if (t2 === 61)
              return l(e2), 8390718;
            if (t2 === 33) {
              const t3 = e2.index + 1;
              if (t3 + 1 < e2.end && a2.charCodeAt(t3) === 45 && a2.charCodeAt(t3 + 1) == 45) {
                e2.column += 3, e2.currentChar = a2.charCodeAt(e2.index += 3), o2 = T(e2, a2, o2, n2, 2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn), s2 = e2.tokenIndex, g2 = e2.tokenLine, k2 = e2.tokenColumn;
                continue;
              }
              return 8456256;
            }
          }
          return 8456256;
        }
        case 1077936155: {
          l(e2);
          const n3 = e2.currentChar;
          return n3 === 61 ? l(e2) === 61 ? (l(e2), 8390458) : 8390460 : n3 === 62 ? (l(e2), 10) : 1077936155;
        }
        case 16842798:
          return l(e2) !== 61 ? 16842798 : l(e2) !== 61 ? 8390461 : (l(e2), 8390459);
        case 8391477:
          return l(e2) !== 61 ? 8391477 : (l(e2), 4194340);
        case 8391476: {
          if (l(e2), e2.index >= e2.end)
            return 8391476;
          const n3 = e2.currentChar;
          return n3 === 61 ? (l(e2), 4194338) : n3 !== 42 ? 8391476 : l(e2) !== 61 ? 8391735 : (l(e2), 4194335);
        }
        case 8389959:
          return l(e2) !== 61 ? 8389959 : (l(e2), 4194341);
        case 25233968: {
          l(e2);
          const n3 = e2.currentChar;
          return n3 === 43 ? (l(e2), 33619993) : n3 === 61 ? (l(e2), 4194336) : 25233968;
        }
        case 25233969: {
          l(e2);
          const i3 = e2.currentChar;
          if (i3 === 45) {
            if (l(e2), (1 & o2 || r2) && e2.currentChar === 62) {
              64 & n2 || t(e2, 112), l(e2), o2 = T(e2, a2, o2, n2, 3, s2, g2, k2), s2 = e2.tokenIndex, g2 = e2.tokenLine, k2 = e2.tokenColumn;
              continue;
            }
            return 33619994;
          }
          return i3 === 61 ? (l(e2), 4194337) : 25233969;
        }
        case 8457014:
          if (l(e2), e2.index < e2.end) {
            const t2 = e2.currentChar;
            if (t2 === 47) {
              l(e2), o2 = y(e2, a2, o2, 0, e2.tokenIndex, e2.tokenLine, e2.tokenColumn), s2 = e2.tokenIndex, g2 = e2.tokenLine, k2 = e2.tokenColumn;
              continue;
            }
            if (t2 === 42) {
              l(e2), o2 = C(e2, a2, o2), s2 = e2.tokenIndex, g2 = e2.tokenLine, k2 = e2.tokenColumn;
              continue;
            }
            if (8192 & n2)
              return L(e2, n2);
            if (t2 === 61)
              return l(e2), 4259875;
          }
          return 8457014;
        case 67108877: {
          const t2 = l(e2);
          if (t2 >= 48 && t2 <= 57)
            return V(e2, n2, 80);
          if (t2 === 46) {
            const n3 = e2.index + 1;
            if (n3 < e2.end && a2.charCodeAt(n3) === 46)
              return e2.column += 2, e2.currentChar = a2.charCodeAt(e2.index += 2), 14;
          }
          return 67108877;
        }
        case 8389702: {
          l(e2);
          const n3 = e2.currentChar;
          return n3 === 124 ? (l(e2), e2.currentChar === 61 ? (l(e2), 4194344) : 8913465) : n3 === 61 ? (l(e2), 4194342) : 8389702;
        }
        case 8390721: {
          l(e2);
          const n3 = e2.currentChar;
          if (n3 === 61)
            return l(e2), 8390719;
          if (n3 !== 62)
            return 8390721;
          if (l(e2), e2.index < e2.end) {
            const n4 = e2.currentChar;
            if (n4 === 62)
              return l(e2) === 61 ? (l(e2), 4194334) : 8390980;
            if (n4 === 61)
              return l(e2), 4194333;
          }
          return 8390979;
        }
        case 8390213: {
          l(e2);
          const n3 = e2.currentChar;
          return n3 === 38 ? (l(e2), e2.currentChar === 61 ? (l(e2), 4194345) : 8913720) : n3 === 61 ? (l(e2), 4194343) : 8390213;
        }
        case 22: {
          let n3 = l(e2);
          if (n3 === 63)
            return l(e2), e2.currentChar === 61 ? (l(e2), 4194346) : 276824445;
          if (n3 === 46) {
            const t2 = e2.index + 1;
            if (t2 < e2.end && (n3 = a2.charCodeAt(t2), !(n3 >= 48 && n3 <= 57)))
              return l(e2), 67108990;
          }
          return 22;
        }
      }
    } else {
      if ((8232 ^ f2) <= 1) {
        o2 = -5 & o2 | 1, d(e2);
        continue;
      }
      const r3 = c(e2);
      if (r3 > 0 && (f2 = r3), i(f2))
        return e2.tokenValue = "", O(e2, n2, 0, 0);
      if ((p2 = f2) === 160 || p2 === 65279 || p2 === 133 || p2 === 5760 || p2 >= 8192 && p2 <= 8203 || p2 === 8239 || p2 === 8287 || p2 === 12288 || p2 === 8201 || p2 === 65519) {
        l(e2);
        continue;
      }
      t(e2, 20, String.fromCodePoint(f2));
    }
  }
  var p2;
  return 1048576;
}
var M = { AElig: "", AMP: "&", Aacute: "", Abreve: "", Acirc: "", Acy: "", Afr: "\uD835\uDD04", Agrave: "", Alpha: "", Amacr: "", And: "", Aogon: "", Aopf: "\uD835\uDD38", ApplyFunction: "", Aring: "", Ascr: "\uD835\uDC9C", Assign: "", Atilde: "", Auml: "", Backslash: "", Barv: "", Barwed: "", Bcy: "", Because: "", Bernoullis: "", Beta: "", Bfr: "\uD835\uDD05", Bopf: "\uD835\uDD39", Breve: "", Bscr: "", Bumpeq: "", CHcy: "", COPY: "", Cacute: "", Cap: "", CapitalDifferentialD: "", Cayleys: "", Ccaron: "", Ccedil: "", Ccirc: "", Cconint: "", Cdot: "", Cedilla: "", CenterDot: "", Cfr: "", Chi: "", CircleDot: "", CircleMinus: "", CirclePlus: "", CircleTimes: "", ClockwiseContourIntegral: "", CloseCurlyDoubleQuote: "", CloseCurlyQuote: "", Colon: "", Colone: "", Congruent: "", Conint: "", ContourIntegral: "", Copf: "", Coproduct: "", CounterClockwiseContourIntegral: "", Cross: "", Cscr: "\uD835\uDC9E", Cup: "", CupCap: "", DD: "", DDotrahd: "", DJcy: "", DScy: "", DZcy: "", Dagger: "", Darr: "", Dashv: "", Dcaron: "", Dcy: "", Del: "", Delta: "", Dfr: "\uD835\uDD07", DiacriticalAcute: "", DiacriticalDot: "", DiacriticalDoubleAcute: "", DiacriticalGrave: "`", DiacriticalTilde: "", Diamond: "", DifferentialD: "", Dopf: "\uD835\uDD3B", Dot: "", DotDot: "", DotEqual: "", DoubleContourIntegral: "", DoubleDot: "", DoubleDownArrow: "", DoubleLeftArrow: "", DoubleLeftRightArrow: "", DoubleLeftTee: "", DoubleLongLeftArrow: "", DoubleLongLeftRightArrow: "", DoubleLongRightArrow: "", DoubleRightArrow: "", DoubleRightTee: "", DoubleUpArrow: "", DoubleUpDownArrow: "", DoubleVerticalBar: "", DownArrow: "", DownArrowBar: "", DownArrowUpArrow: "", DownBreve: "", DownLeftRightVector: "", DownLeftTeeVector: "", DownLeftVector: "", DownLeftVectorBar: "", DownRightTeeVector: "", DownRightVector: "", DownRightVectorBar: "", DownTee: "", DownTeeArrow: "", Downarrow: "", Dscr: "\uD835\uDC9F", Dstrok: "", ENG: "", ETH: "", Eacute: "", Ecaron: "", Ecirc: "", Ecy: "", Edot: "", Efr: "\uD835\uDD08", Egrave: "", Element: "", Emacr: "", EmptySmallSquare: "", EmptyVerySmallSquare: "", Eogon: "", Eopf: "\uD835\uDD3C", Epsilon: "", Equal: "", EqualTilde: "", Equilibrium: "", Escr: "", Esim: "", Eta: "", Euml: "", Exists: "", ExponentialE: "", Fcy: "", Ffr: "\uD835\uDD09", FilledSmallSquare: "", FilledVerySmallSquare: "", Fopf: "\uD835\uDD3D", ForAll: "", Fouriertrf: "", Fscr: "", GJcy: "", GT: ">", Gamma: "", Gammad: "", Gbreve: "", Gcedil: "", Gcirc: "", Gcy: "", Gdot: "", Gfr: "\uD835\uDD0A", Gg: "", Gopf: "\uD835\uDD3E", GreaterEqual: "", GreaterEqualLess: "", GreaterFullEqual: "", GreaterGreater: "", GreaterLess: "", GreaterSlantEqual: "", GreaterTilde: "", Gscr: "\uD835\uDCA2", Gt: "", HARDcy: "", Hacek: "", Hat: "^", Hcirc: "", Hfr: "", HilbertSpace: "", Hopf: "", HorizontalLine: "", Hscr: "", Hstrok: "", HumpDownHump: "", HumpEqual: "", IEcy: "", IJlig: "", IOcy: "", Iacute: "", Icirc: "", Icy: "", Idot: "", Ifr: "", Igrave: "", Im: "", Imacr: "", ImaginaryI: "", Implies: "", Int: "", Integral: "", Intersection: "", InvisibleComma: "", InvisibleTimes: "", Iogon: "", Iopf: "\uD835\uDD40", Iota: "", Iscr: "", Itilde: "", Iukcy: "", Iuml: "", Jcirc: "", Jcy: "", Jfr: "\uD835\uDD0D", Jopf: "\uD835\uDD41", Jscr: "\uD835\uDCA5", Jsercy: "", Jukcy: "", KHcy: "", KJcy: "", Kappa: "", Kcedil: "", Kcy: "", Kfr: "\uD835\uDD0E", Kopf: "\uD835\uDD42", Kscr: "\uD835\uDCA6", LJcy: "", LT: "<", Lacute: "", Lambda: "", Lang: "", Laplacetrf: "", Larr: "", Lcaron: "", Lcedil: "", Lcy: "", LeftAngleBracket: "", LeftArrow: "", LeftArrowBar: "", LeftArrowRightArrow: "", LeftCeiling: "", LeftDoubleBracket: "", LeftDownTeeVector: "", LeftDownVector: "", LeftDownVectorBar: "", LeftFloor: "", LeftRightArrow: "", LeftRightVector: "", LeftTee: "", LeftTeeArrow: "", LeftTeeVector: "", LeftTriangle: "", LeftTriangleBar: "", LeftTriangleEqual: "", LeftUpDownVector: "", LeftUpTeeVector: "", LeftUpVector: "", LeftUpVectorBar: "", LeftVector: "", LeftVectorBar: "", Leftarrow: "", Leftrightarrow: "", LessEqualGreater: "", LessFullEqual: "", LessGreater: "", LessLess: "", LessSlantEqual: "", LessTilde: "", Lfr: "\uD835\uDD0F", Ll: "", Lleftarrow: "", Lmidot: "", LongLeftArrow: "", LongLeftRightArrow: "", LongRightArrow: "", Longleftarrow: "", Longleftrightarrow: "", Longrightarrow: "", Lopf: "\uD835\uDD43", LowerLeftArrow: "", LowerRightArrow: "", Lscr: "", Lsh: "", Lstrok: "", Lt: "", Map: "", Mcy: "", MediumSpace: "", Mellintrf: "", Mfr: "\uD835\uDD10", MinusPlus: "", Mopf: "\uD835\uDD44", Mscr: "", Mu: "", NJcy: "", Nacute: "", Ncaron: "", Ncedil: "", Ncy: "", NegativeMediumSpace: "", NegativeThickSpace: "", NegativeThinSpace: "", NegativeVeryThinSpace: "", NestedGreaterGreater: "", NestedLessLess: "", NewLine: `
`, Nfr: "\uD835\uDD11", NoBreak: "", NonBreakingSpace: "", Nopf: "", Not: "", NotCongruent: "", NotCupCap: "", NotDoubleVerticalBar: "", NotElement: "", NotEqual: "", NotEqualTilde: "", NotExists: "", NotGreater: "", NotGreaterEqual: "", NotGreaterFullEqual: "", NotGreaterGreater: "", NotGreaterLess: "", NotGreaterSlantEqual: "", NotGreaterTilde: "", NotHumpDownHump: "", NotHumpEqual: "", NotLeftTriangle: "", NotLeftTriangleBar: "", NotLeftTriangleEqual: "", NotLess: "", NotLessEqual: "", NotLessGreater: "", NotLessLess: "", NotLessSlantEqual: "", NotLessTilde: "", NotNestedGreaterGreater: "", NotNestedLessLess: "", NotPrecedes: "", NotPrecedesEqual: "", NotPrecedesSlantEqual: "", NotReverseElement: "", NotRightTriangle: "", NotRightTriangleBar: "", NotRightTriangleEqual: "", NotSquareSubset: "", NotSquareSubsetEqual: "", NotSquareSuperset: "", NotSquareSupersetEqual: "", NotSubset: "", NotSubsetEqual: "", NotSucceeds: "", NotSucceedsEqual: "", NotSucceedsSlantEqual: "", NotSucceedsTilde: "", NotSuperset: "", NotSupersetEqual: "", NotTilde: "", NotTildeEqual: "", NotTildeFullEqual: "", NotTildeTilde: "", NotVerticalBar: "", Nscr: "\uD835\uDCA9", Ntilde: "", Nu: "", OElig: "", Oacute: "", Ocirc: "", Ocy: "", Odblac: "", Ofr: "\uD835\uDD12", Ograve: "", Omacr: "", Omega: "", Omicron: "", Oopf: "\uD835\uDD46", OpenCurlyDoubleQuote: "", OpenCurlyQuote: "", Or: "", Oscr: "\uD835\uDCAA", Oslash: "", Otilde: "", Otimes: "", Ouml: "", OverBar: "", OverBrace: "", OverBracket: "", OverParenthesis: "", PartialD: "", Pcy: "", Pfr: "\uD835\uDD13", Phi: "", Pi: "", PlusMinus: "", Poincareplane: "", Popf: "", Pr: "", Precedes: "", PrecedesEqual: "", PrecedesSlantEqual: "", PrecedesTilde: "", Prime: "", Product: "", Proportion: "", Proportional: "", Pscr: "\uD835\uDCAB", Psi: "", QUOT: '"', Qfr: "\uD835\uDD14", Qopf: "", Qscr: "\uD835\uDCAC", RBarr: "", REG: "", Racute: "", Rang: "", Rarr: "", Rarrtl: "", Rcaron: "", Rcedil: "", Rcy: "", Re: "", ReverseElement: "", ReverseEquilibrium: "", ReverseUpEquilibrium: "", Rfr: "", Rho: "", RightAngleBracket: "", RightArrow: "", RightArrowBar: "", RightArrowLeftArrow: "", RightCeiling: "", RightDoubleBracket: "", RightDownTeeVector: "", RightDownVector: "", RightDownVectorBar: "", RightFloor: "", RightTee: "", RightTeeArrow: "", RightTeeVector: "", RightTriangle: "", RightTriangleBar: "", RightTriangleEqual: "", RightUpDownVector: "", RightUpTeeVector: "", RightUpVector: "", RightUpVectorBar: "", RightVector: "", RightVectorBar: "", Rightarrow: "", Ropf: "", RoundImplies: "", Rrightarrow: "", Rscr: "", Rsh: "", RuleDelayed: "", SHCHcy: "", SHcy: "", SOFTcy: "", Sacute: "", Sc: "", Scaron: "", Scedil: "", Scirc: "", Scy: "", Sfr: "\uD835\uDD16", ShortDownArrow: "", ShortLeftArrow: "", ShortRightArrow: "", ShortUpArrow: "", Sigma: "", SmallCircle: "", Sopf: "\uD835\uDD4A", Sqrt: "", Square: "", SquareIntersection: "", SquareSubset: "", SquareSubsetEqual: "", SquareSuperset: "", SquareSupersetEqual: "", SquareUnion: "", Sscr: "\uD835\uDCAE", Star: "", Sub: "", Subset: "", SubsetEqual: "", Succeeds: "", SucceedsEqual: "", SucceedsSlantEqual: "", SucceedsTilde: "", SuchThat: "", Sum: "", Sup: "", Superset: "", SupersetEqual: "", Supset: "", THORN: "", TRADE: "", TSHcy: "", TScy: "", Tab: "\t", Tau: "", Tcaron: "", Tcedil: "", Tcy: "", Tfr: "\uD835\uDD17", Therefore: "", Theta: "", ThickSpace: "", ThinSpace: "", Tilde: "", TildeEqual: "", TildeFullEqual: "", TildeTilde: "", Topf: "\uD835\uDD4B", TripleDot: "", Tscr: "\uD835\uDCAF", Tstrok: "", Uacute: "", Uarr: "", Uarrocir: "", Ubrcy: "", Ubreve: "", Ucirc: "", Ucy: "", Udblac: "", Ufr: "\uD835\uDD18", Ugrave: "", Umacr: "", UnderBar: "_", UnderBrace: "", UnderBracket: "", UnderParenthesis: "", Union: "", UnionPlus: "", Uogon: "", Uopf: "\uD835\uDD4C", UpArrow: "", UpArrowBar: "", UpArrowDownArrow: "", UpDownArrow: "", UpEquilibrium: "", UpTee: "", UpTeeArrow: "", Uparrow: "", Updownarrow: "", UpperLeftArrow: "", UpperRightArrow: "", Upsi: "", Upsilon: "", Uring: "", Uscr: "\uD835\uDCB0", Utilde: "", Uuml: "", VDash: "", Vbar: "", Vcy: "", Vdash: "", Vdashl: "", Vee: "", Verbar: "", Vert: "", VerticalBar: "", VerticalLine: "|", VerticalSeparator: "", VerticalTilde: "", VeryThinSpace: "", Vfr: "\uD835\uDD19", Vopf: "\uD835\uDD4D", Vscr: "\uD835\uDCB1", Vvdash: "", Wcirc: "", Wedge: "", Wfr: "\uD835\uDD1A", Wopf: "\uD835\uDD4E", Wscr: "\uD835\uDCB2", Xfr: "\uD835\uDD1B", Xi: "", Xopf: "\uD835\uDD4F", Xscr: "\uD835\uDCB3", YAcy: "", YIcy: "", YUcy: "", Yacute: "", Ycirc: "", Ycy: "", Yfr: "\uD835\uDD1C", Yopf: "\uD835\uDD50", Yscr: "\uD835\uDCB4", Yuml: "", ZHcy: "", Zacute: "", Zcaron: "", Zcy: "", Zdot: "", ZeroWidthSpace: "", Zeta: "", Zfr: "", Zopf: "", Zscr: "\uD835\uDCB5", aacute: "", abreve: "", ac: "", acE: "", acd: "", acirc: "", acute: "", acy: "", aelig: "", af: "", afr: "\uD835\uDD1E", agrave: "", alefsym: "", aleph: "", alpha: "", amacr: "", amalg: "", amp: "&", and: "", andand: "", andd: "", andslope: "", andv: "", ang: "", ange: "", angle: "", angmsd: "", angmsdaa: "", angmsdab: "", angmsdac: "", angmsdad: "", angmsdae: "", angmsdaf: "", angmsdag: "", angmsdah: "", angrt: "", angrtvb: "", angrtvbd: "", angsph: "", angst: "", angzarr: "", aogon: "", aopf: "\uD835\uDD52", ap: "", apE: "", apacir: "", ape: "", apid: "", apos: "'", approx: "", approxeq: "", aring: "", ascr: "\uD835\uDCB6", ast: "*", asymp: "", asympeq: "", atilde: "", auml: "", awconint: "", awint: "", bNot: "", backcong: "", backepsilon: "", backprime: "", backsim: "", backsimeq: "", barvee: "", barwed: "", barwedge: "", bbrk: "", bbrktbrk: "", bcong: "", bcy: "", bdquo: "", becaus: "", because: "", bemptyv: "", bepsi: "", bernou: "", beta: "", beth: "", between: "", bfr: "\uD835\uDD1F", bigcap: "", bigcirc: "", bigcup: "", bigodot: "", bigoplus: "", bigotimes: "", bigsqcup: "", bigstar: "", bigtriangledown: "", bigtriangleup: "", biguplus: "", bigvee: "", bigwedge: "", bkarow: "", blacklozenge: "", blacksquare: "", blacktriangle: "", blacktriangledown: "", blacktriangleleft: "", blacktriangleright: "", blank: "", blk12: "", blk14: "", blk34: "", block: "", bne: "=", bnequiv: "", bnot: "", bopf: "\uD835\uDD53", bot: "", bottom: "", bowtie: "", boxDL: "", boxDR: "", boxDl: "", boxDr: "", boxH: "", boxHD: "", boxHU: "", boxHd: "", boxHu: "", boxUL: "", boxUR: "", boxUl: "", boxUr: "", boxV: "", boxVH: "", boxVL: "", boxVR: "", boxVh: "", boxVl: "", boxVr: "", boxbox: "", boxdL: "", boxdR: "", boxdl: "", boxdr: "", boxh: "", boxhD: "", boxhU: "", boxhd: "", boxhu: "", boxminus: "", boxplus: "", boxtimes: "", boxuL: "", boxuR: "", boxul: "", boxur: "", boxv: "", boxvH: "", boxvL: "", boxvR: "", boxvh: "", boxvl: "", boxvr: "", bprime: "", breve: "", brvbar: "", bscr: "\uD835\uDCB7", bsemi: "", bsim: "", bsime: "", bsol: "\\", bsolb: "", bsolhsub: "", bull: "", bullet: "", bump: "", bumpE: "", bumpe: "", bumpeq: "", cacute: "", cap: "", capand: "", capbrcup: "", capcap: "", capcup: "", capdot: "", caps: "", caret: "", caron: "", ccaps: "", ccaron: "", ccedil: "", ccirc: "", ccups: "", ccupssm: "", cdot: "", cedil: "", cemptyv: "", cent: "", centerdot: "", cfr: "\uD835\uDD20", chcy: "", check: "", checkmark: "", chi: "", cir: "", cirE: "", circ: "", circeq: "", circlearrowleft: "", circlearrowright: "", circledR: "", circledS: "", circledast: "", circledcirc: "", circleddash: "", cire: "", cirfnint: "", cirmid: "", cirscir: "", clubs: "", clubsuit: "", colon: ":", colone: "", coloneq: "", comma: ",", commat: "@", comp: "", compfn: "", complement: "", complexes: "", cong: "", congdot: "", conint: "", copf: "\uD835\uDD54", coprod: "", copy: "", copysr: "", crarr: "", cross: "", cscr: "\uD835\uDCB8", csub: "", csube: "", csup: "", csupe: "", ctdot: "", cudarrl: "", cudarrr: "", cuepr: "", cuesc: "", cularr: "", cularrp: "", cup: "", cupbrcap: "", cupcap: "", cupcup: "", cupdot: "", cupor: "", cups: "", curarr: "", curarrm: "", curlyeqprec: "", curlyeqsucc: "", curlyvee: "", curlywedge: "", curren: "", curvearrowleft: "", curvearrowright: "", cuvee: "", cuwed: "", cwconint: "", cwint: "", cylcty: "", dArr: "", dHar: "", dagger: "", daleth: "", darr: "", dash: "", dashv: "", dbkarow: "", dblac: "", dcaron: "", dcy: "", dd: "", ddagger: "", ddarr: "", ddotseq: "", deg: "", delta: "", demptyv: "", dfisht: "", dfr: "\uD835\uDD21", dharl: "", dharr: "", diam: "", diamond: "", diamondsuit: "", diams: "", die: "", digamma: "", disin: "", div: "", divide: "", divideontimes: "", divonx: "", djcy: "", dlcorn: "", dlcrop: "", dollar: "$", dopf: "\uD835\uDD55", dot: "", doteq: "", doteqdot: "", dotminus: "", dotplus: "", dotsquare: "", doublebarwedge: "", downarrow: "", downdownarrows: "", downharpoonleft: "", downharpoonright: "", drbkarow: "", drcorn: "", drcrop: "", dscr: "\uD835\uDCB9", dscy: "", dsol: "", dstrok: "", dtdot: "", dtri: "", dtrif: "", duarr: "", duhar: "", dwangle: "", dzcy: "", dzigrarr: "", eDDot: "", eDot: "", eacute: "", easter: "", ecaron: "", ecir: "", ecirc: "", ecolon: "", ecy: "", edot: "", ee: "", efDot: "", efr: "\uD835\uDD22", eg: "", egrave: "", egs: "", egsdot: "", el: "", elinters: "", ell: "", els: "", elsdot: "", emacr: "", empty: "", emptyset: "", emptyv: "", emsp13: "", emsp14: "", emsp: "", eng: "", ensp: "", eogon: "", eopf: "\uD835\uDD56", epar: "", eparsl: "", eplus: "", epsi: "", epsilon: "", epsiv: "", eqcirc: "", eqcolon: "", eqsim: "", eqslantgtr: "", eqslantless: "", equals: "=", equest: "", equiv: "", equivDD: "", eqvparsl: "", erDot: "", erarr: "", escr: "", esdot: "", esim: "", eta: "", eth: "", euml: "", euro: "", excl: "!", exist: "", expectation: "", exponentiale: "", fallingdotseq: "", fcy: "", female: "", ffilig: "", fflig: "", ffllig: "", ffr: "\uD835\uDD23", filig: "", fjlig: "fj", flat: "", fllig: "", fltns: "", fnof: "", fopf: "\uD835\uDD57", forall: "", fork: "", forkv: "", fpartint: "", frac12: "", frac13: "", frac14: "", frac15: "", frac16: "", frac18: "", frac23: "", frac25: "", frac34: "", frac35: "", frac38: "", frac45: "", frac56: "", frac58: "", frac78: "", frasl: "", frown: "", fscr: "\uD835\uDCBB", gE: "", gEl: "", gacute: "", gamma: "", gammad: "", gap: "", gbreve: "", gcirc: "", gcy: "", gdot: "", ge: "", gel: "", geq: "", geqq: "", geqslant: "", ges: "", gescc: "", gesdot: "", gesdoto: "", gesdotol: "", gesl: "", gesles: "", gfr: "\uD835\uDD24", gg: "", ggg: "", gimel: "", gjcy: "", gl: "", glE: "", gla: "", glj: "", gnE: "", gnap: "", gnapprox: "", gne: "", gneq: "", gneqq: "", gnsim: "", gopf: "\uD835\uDD58", grave: "`", gscr: "", gsim: "", gsime: "", gsiml: "", gt: ">", gtcc: "", gtcir: "", gtdot: "", gtlPar: "", gtquest: "", gtrapprox: "", gtrarr: "", gtrdot: "", gtreqless: "", gtreqqless: "", gtrless: "", gtrsim: "", gvertneqq: "", gvnE: "", hArr: "", hairsp: "", half: "", hamilt: "", hardcy: "", harr: "", harrcir: "", harrw: "", hbar: "", hcirc: "", hearts: "", heartsuit: "", hellip: "", hercon: "", hfr: "\uD835\uDD25", hksearow: "", hkswarow: "", hoarr: "", homtht: "", hookleftarrow: "", hookrightarrow: "", hopf: "\uD835\uDD59", horbar: "", hscr: "\uD835\uDCBD", hslash: "", hstrok: "", hybull: "", hyphen: "", iacute: "", ic: "", icirc: "", icy: "", iecy: "", iexcl: "", iff: "", ifr: "\uD835\uDD26", igrave: "", ii: "", iiiint: "", iiint: "", iinfin: "", iiota: "", ijlig: "", imacr: "", image: "", imagline: "", imagpart: "", imath: "", imof: "", imped: "", in: "", incare: "", infin: "", infintie: "", inodot: "", int: "", intcal: "", integers: "", intercal: "", intlarhk: "", intprod: "", iocy: "", iogon: "", iopf: "\uD835\uDD5A", iota: "", iprod: "", iquest: "", iscr: "\uD835\uDCBE", isin: "", isinE: "", isindot: "", isins: "", isinsv: "", isinv: "", it: "", itilde: "", iukcy: "", iuml: "", jcirc: "", jcy: "", jfr: "\uD835\uDD27", jmath: "", jopf: "\uD835\uDD5B", jscr: "\uD835\uDCBF", jsercy: "", jukcy: "", kappa: "", kappav: "", kcedil: "", kcy: "", kfr: "\uD835\uDD28", kgreen: "", khcy: "", kjcy: "", kopf: "\uD835\uDD5C", kscr: "\uD835\uDCC0", lAarr: "", lArr: "", lAtail: "", lBarr: "", lE: "", lEg: "", lHar: "", lacute: "", laemptyv: "", lagran: "", lambda: "", lang: "", langd: "", langle: "", lap: "", laquo: "", larr: "", larrb: "", larrbfs: "", larrfs: "", larrhk: "", larrlp: "", larrpl: "", larrsim: "", larrtl: "", lat: "", latail: "", late: "", lates: "", lbarr: "", lbbrk: "", lbrace: "{", lbrack: "[", lbrke: "", lbrksld: "", lbrkslu: "", lcaron: "", lcedil: "", lceil: "", lcub: "{", lcy: "", ldca: "", ldquo: "", ldquor: "", ldrdhar: "", ldrushar: "", ldsh: "", le: "", leftarrow: "", leftarrowtail: "", leftharpoondown: "", leftharpoonup: "", leftleftarrows: "", leftrightarrow: "", leftrightarrows: "", leftrightharpoons: "", leftrightsquigarrow: "", leftthreetimes: "", leg: "", leq: "", leqq: "", leqslant: "", les: "", lescc: "", lesdot: "", lesdoto: "", lesdotor: "", lesg: "", lesges: "", lessapprox: "", lessdot: "", lesseqgtr: "", lesseqqgtr: "", lessgtr: "", lesssim: "", lfisht: "", lfloor: "", lfr: "\uD835\uDD29", lg: "", lgE: "", lhard: "", lharu: "", lharul: "", lhblk: "", ljcy: "", ll: "", llarr: "", llcorner: "", llhard: "", lltri: "", lmidot: "", lmoust: "", lmoustache: "", lnE: "", lnap: "", lnapprox: "", lne: "", lneq: "", lneqq: "", lnsim: "", loang: "", loarr: "", lobrk: "", longleftarrow: "", longleftrightarrow: "", longmapsto: "", longrightarrow: "", looparrowleft: "", looparrowright: "", lopar: "", lopf: "\uD835\uDD5D", loplus: "", lotimes: "", lowast: "", lowbar: "_", loz: "", lozenge: "", lozf: "", lpar: "(", lparlt: "", lrarr: "", lrcorner: "", lrhar: "", lrhard: "", lrm: "", lrtri: "", lsaquo: "", lscr: "\uD835\uDCC1", lsh: "", lsim: "", lsime: "", lsimg: "", lsqb: "[", lsquo: "", lsquor: "", lstrok: "", lt: "<", ltcc: "", ltcir: "", ltdot: "", lthree: "", ltimes: "", ltlarr: "", ltquest: "", ltrPar: "", ltri: "", ltrie: "", ltrif: "", lurdshar: "", luruhar: "", lvertneqq: "", lvnE: "", mDDot: "", macr: "", male: "", malt: "", maltese: "", map: "", mapsto: "", mapstodown: "", mapstoleft: "", mapstoup: "", marker: "", mcomma: "", mcy: "", mdash: "", measuredangle: "", mfr: "\uD835\uDD2A", mho: "", micro: "", mid: "", midast: "*", midcir: "", middot: "", minus: "", minusb: "", minusd: "", minusdu: "", mlcp: "", mldr: "", mnplus: "", models: "", mopf: "\uD835\uDD5E", mp: "", mscr: "\uD835\uDCC2", mstpos: "", mu: "", multimap: "", mumap: "", nGg: "", nGt: "", nGtv: "", nLeftarrow: "", nLeftrightarrow: "", nLl: "", nLt: "", nLtv: "", nRightarrow: "", nVDash: "", nVdash: "", nabla: "", nacute: "", nang: "", nap: "", napE: "", napid: "", napos: "", napprox: "", natur: "", natural: "", naturals: "", nbsp: "", nbump: "", nbumpe: "", ncap: "", ncaron: "", ncedil: "", ncong: "", ncongdot: "", ncup: "", ncy: "", ndash: "", ne: "", neArr: "", nearhk: "", nearr: "", nearrow: "", nedot: "", nequiv: "", nesear: "", nesim: "", nexist: "", nexists: "", nfr: "\uD835\uDD2B", ngE: "", nge: "", ngeq: "", ngeqq: "", ngeqslant: "", nges: "", ngsim: "", ngt: "", ngtr: "", nhArr: "", nharr: "", nhpar: "", ni: "", nis: "", nisd: "", niv: "", njcy: "", nlArr: "", nlE: "", nlarr: "", nldr: "", nle: "", nleftarrow: "", nleftrightarrow: "", nleq: "", nleqq: "", nleqslant: "", nles: "", nless: "", nlsim: "", nlt: "", nltri: "", nltrie: "", nmid: "", nopf: "\uD835\uDD5F", not: "", notin: "", notinE: "", notindot: "", notinva: "", notinvb: "", notinvc: "", notni: "", notniva: "", notnivb: "", notnivc: "", npar: "", nparallel: "", nparsl: "", npart: "", npolint: "", npr: "", nprcue: "", npre: "", nprec: "", npreceq: "", nrArr: "", nrarr: "", nrarrc: "", nrarrw: "", nrightarrow: "", nrtri: "", nrtrie: "", nsc: "", nsccue: "", nsce: "", nscr: "\uD835\uDCC3", nshortmid: "", nshortparallel: "", nsim: "", nsime: "", nsimeq: "", nsmid: "", nspar: "", nsqsube: "", nsqsupe: "", nsub: "", nsubE: "", nsube: "", nsubset: "", nsubseteq: "", nsubseteqq: "", nsucc: "", nsucceq: "", nsup: "", nsupE: "", nsupe: "", nsupset: "", nsupseteq: "", nsupseteqq: "", ntgl: "", ntilde: "", ntlg: "", ntriangleleft: "", ntrianglelefteq: "", ntriangleright: "", ntrianglerighteq: "", nu: "", num: "#", numero: "", numsp: "", nvDash: "", nvHarr: "", nvap: "", nvdash: "", nvge: "", nvgt: ">", nvinfin: "", nvlArr: "", nvle: "", nvlt: "<", nvltrie: "", nvrArr: "", nvrtrie: "", nvsim: "", nwArr: "", nwarhk: "", nwarr: "", nwarrow: "", nwnear: "", oS: "", oacute: "", oast: "", ocir: "", ocirc: "", ocy: "", odash: "", odblac: "", odiv: "", odot: "", odsold: "", oelig: "", ofcir: "", ofr: "\uD835\uDD2C", ogon: "", ograve: "", ogt: "", ohbar: "", ohm: "", oint: "", olarr: "", olcir: "", olcross: "", oline: "", olt: "", omacr: "", omega: "", omicron: "", omid: "", ominus: "", oopf: "\uD835\uDD60", opar: "", operp: "", oplus: "", or: "", orarr: "", ord: "", order: "", orderof: "", ordf: "", ordm: "", origof: "", oror: "", orslope: "", orv: "", oscr: "", oslash: "", osol: "", otilde: "", otimes: "", otimesas: "", ouml: "", ovbar: "", par: "", para: "", parallel: "", parsim: "", parsl: "", part: "", pcy: "", percnt: "%", period: ".", permil: "", perp: "", pertenk: "", pfr: "\uD835\uDD2D", phi: "", phiv: "", phmmat: "", phone: "", pi: "", pitchfork: "", piv: "", planck: "", planckh: "", plankv: "", plus: "+", plusacir: "", plusb: "", pluscir: "", plusdo: "", plusdu: "", pluse: "", plusmn: "", plussim: "", plustwo: "", pm: "", pointint: "", popf: "\uD835\uDD61", pound: "", pr: "", prE: "", prap: "", prcue: "", pre: "", prec: "", precapprox: "", preccurlyeq: "", preceq: "", precnapprox: "", precneqq: "", precnsim: "", precsim: "", prime: "", primes: "", prnE: "", prnap: "", prnsim: "", prod: "", profalar: "", profline: "", profsurf: "", prop: "", propto: "", prsim: "", prurel: "", pscr: "\uD835\uDCC5", psi: "", puncsp: "", qfr: "\uD835\uDD2E", qint: "", qopf: "\uD835\uDD62", qprime: "", qscr: "\uD835\uDCC6", quaternions: "", quatint: "", quest: "?", questeq: "", quot: '"', rAarr: "", rArr: "", rAtail: "", rBarr: "", rHar: "", race: "", racute: "", radic: "", raemptyv: "", rang: "", rangd: "", range: "", rangle: "", raquo: "", rarr: "", rarrap: "", rarrb: "", rarrbfs: "", rarrc: "", rarrfs: "", rarrhk: "", rarrlp: "", rarrpl: "", rarrsim: "", rarrtl: "", rarrw: "", ratail: "", ratio: "", rationals: "", rbarr: "", rbbrk: "", rbrace: "}", rbrack: "]", rbrke: "", rbrksld: "", rbrkslu: "", rcaron: "", rcedil: "", rceil: "", rcub: "}", rcy: "", rdca: "", rdldhar: "", rdquo: "", rdquor: "", rdsh: "", real: "", realine: "", realpart: "", reals: "", rect: "", reg: "", rfisht: "", rfloor: "", rfr: "\uD835\uDD2F", rhard: "", rharu: "", rharul: "", rho: "", rhov: "", rightarrow: "", rightarrowtail: "", rightharpoondown: "", rightharpoonup: "", rightleftarrows: "", rightleftharpoons: "", rightrightarrows: "", rightsquigarrow: "", rightthreetimes: "", ring: "", risingdotseq: "", rlarr: "", rlhar: "", rlm: "", rmoust: "", rmoustache: "", rnmid: "", roang: "", roarr: "", robrk: "", ropar: "", ropf: "\uD835\uDD63", roplus: "", rotimes: "", rpar: ")", rpargt: "", rppolint: "", rrarr: "", rsaquo: "", rscr: "\uD835\uDCC7", rsh: "", rsqb: "]", rsquo: "", rsquor: "", rthree: "", rtimes: "", rtri: "", rtrie: "", rtrif: "", rtriltri: "", ruluhar: "", rx: "", sacute: "", sbquo: "", sc: "", scE: "", scap: "", scaron: "", sccue: "", sce: "", scedil: "", scirc: "", scnE: "", scnap: "", scnsim: "", scpolint: "", scsim: "", scy: "", sdot: "", sdotb: "", sdote: "", seArr: "", searhk: "", searr: "", searrow: "", sect: "", semi: ";", seswar: "", setminus: "", setmn: "", sext: "", sfr: "\uD835\uDD30", sfrown: "", sharp: "", shchcy: "", shcy: "", shortmid: "", shortparallel: "", shy: "", sigma: "", sigmaf: "", sigmav: "", sim: "", simdot: "", sime: "", simeq: "", simg: "", simgE: "", siml: "", simlE: "", simne: "", simplus: "", simrarr: "", slarr: "", smallsetminus: "", smashp: "", smeparsl: "", smid: "", smile: "", smt: "", smte: "", smtes: "", softcy: "", sol: "/", solb: "", solbar: "", sopf: "\uD835\uDD64", spades: "", spadesuit: "", spar: "", sqcap: "", sqcaps: "", sqcup: "", sqcups: "", sqsub: "", sqsube: "", sqsubset: "", sqsubseteq: "", sqsup: "", sqsupe: "", sqsupset: "", sqsupseteq: "", squ: "", square: "", squarf: "", squf: "", srarr: "", sscr: "\uD835\uDCC8", ssetmn: "", ssmile: "", sstarf: "", star: "", starf: "", straightepsilon: "", straightphi: "", strns: "", sub: "", subE: "", subdot: "", sube: "", subedot: "", submult: "", subnE: "", subne: "", subplus: "", subrarr: "", subset: "", subseteq: "", subseteqq: "", subsetneq: "", subsetneqq: "", subsim: "", subsub: "", subsup: "", succ: "", succapprox: "", succcurlyeq: "", succeq: "", succnapprox: "", succneqq: "", succnsim: "", succsim: "", sum: "", sung: "", sup1: "", sup2: "", sup3: "", sup: "", supE: "", supdot: "", supdsub: "", supe: "", supedot: "", suphsol: "", suphsub: "", suplarr: "", supmult: "", supnE: "", supne: "", supplus: "", supset: "", supseteq: "", supseteqq: "", supsetneq: "", supsetneqq: "", supsim: "", supsub: "", supsup: "", swArr: "", swarhk: "", swarr: "", swarrow: "", swnwar: "", szlig: "", target: "", tau: "", tbrk: "", tcaron: "", tcedil: "", tcy: "", tdot: "", telrec: "", tfr: "\uD835\uDD31", there4: "", therefore: "", theta: "", thetasym: "", thetav: "", thickapprox: "", thicksim: "", thinsp: "", thkap: "", thksim: "", thorn: "", tilde: "", times: "", timesb: "", timesbar: "", timesd: "", tint: "", toea: "", top: "", topbot: "", topcir: "", topf: "\uD835\uDD65", topfork: "", tosa: "", tprime: "", trade: "", triangle: "", triangledown: "", triangleleft: "", trianglelefteq: "", triangleq: "", triangleright: "", trianglerighteq: "", tridot: "", trie: "", triminus: "", triplus: "", trisb: "", tritime: "", trpezium: "", tscr: "\uD835\uDCC9", tscy: "", tshcy: "", tstrok: "", twixt: "", twoheadleftarrow: "", twoheadrightarrow: "", uArr: "", uHar: "", uacute: "", uarr: "", ubrcy: "", ubreve: "", ucirc: "", ucy: "", udarr: "", udblac: "", udhar: "", ufisht: "", ufr: "\uD835\uDD32", ugrave: "", uharl: "", uharr: "", uhblk: "", ulcorn: "", ulcorner: "", ulcrop: "", ultri: "", umacr: "", uml: "", uogon: "", uopf: "\uD835\uDD66", uparrow: "", updownarrow: "", upharpoonleft: "", upharpoonright: "", uplus: "", upsi: "", upsih: "", upsilon: "", upuparrows: "", urcorn: "", urcorner: "", urcrop: "", uring: "", urtri: "", uscr: "\uD835\uDCCA", utdot: "", utilde: "", utri: "", utrif: "", uuarr: "", uuml: "", uwangle: "", vArr: "", vBar: "", vBarv: "", vDash: "", vangrt: "", varepsilon: "", varkappa: "", varnothing: "", varphi: "", varpi: "", varpropto: "", varr: "", varrho: "", varsigma: "", varsubsetneq: "", varsubsetneqq: "", varsupsetneq: "", varsupsetneqq: "", vartheta: "", vartriangleleft: "", vartriangleright: "", vcy: "", vdash: "", vee: "", veebar: "", veeeq: "", vellip: "", verbar: "|", vert: "|", vfr: "\uD835\uDD33", vltri: "", vnsub: "", vnsup: "", vopf: "\uD835\uDD67", vprop: "", vrtri: "", vscr: "\uD835\uDCCB", vsubnE: "", vsubne: "", vsupnE: "", vsupne: "", vzigzag: "", wcirc: "", wedbar: "", wedge: "", wedgeq: "", weierp: "", wfr: "\uD835\uDD34", wopf: "\uD835\uDD68", wp: "", wr: "", wreath: "", wscr: "\uD835\uDCCC", xcap: "", xcirc: "", xcup: "", xdtri: "", xfr: "\uD835\uDD35", xhArr: "", xharr: "", xi: "", xlArr: "", xlarr: "", xmap: "", xnis: "", xodot: "", xopf: "\uD835\uDD69", xoplus: "", xotime: "", xrArr: "", xrarr: "", xscr: "\uD835\uDCCD", xsqcup: "", xuplus: "", xutri: "", xvee: "", xwedge: "", yacute: "", yacy: "", ycirc: "", ycy: "", yen: "", yfr: "\uD835\uDD36", yicy: "", yopf: "\uD835\uDD6A", yscr: "\uD835\uDCCE", yucy: "", yuml: "", zacute: "", zcaron: "", zcy: "", zdot: "", zeetrf: "", zeta: "", zfr: "\uD835\uDD37", zhcy: "", zigrarr: "", zopf: "\uD835\uDD6B", zscr: "\uD835\uDCCF", zwj: "", zwnj: "" };
var z = { 0: 65533, 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 };
function X(e2) {
  return e2.replace(/&(?:[a-zA-Z]+|#[xX][\da-fA-F]+|#\d+);/g, (e3) => {
    if (e3.charAt(1) === "#") {
      const n2 = e3.charAt(2);
      return function(e4) {
        if (e4 >= 55296 && e4 <= 57343 || e4 > 1114111)
          return "";
        e4 in z && (e4 = z[e4]);
        return String.fromCodePoint(e4);
      }(n2 === "X" || n2 === "x" ? parseInt(e3.slice(3), 16) : parseInt(e3.slice(2), 10));
    }
    return M[e3.slice(1, -1)] || e3;
  });
}
function _(e2, n2) {
  return e2.startIndex = e2.tokenIndex = e2.index, e2.startColumn = e2.tokenColumn = e2.column, e2.startLine = e2.tokenLine = e2.line, e2.setToken(8192 & p[e2.currentChar] ? function(e3, n3) {
    const o2 = e3.currentChar;
    let r2 = l(e3);
    const a2 = e3.index;
    for (;r2 !== o2; )
      e3.index >= e3.end && t(e3, 16), r2 = l(e3);
    r2 !== o2 && t(e3, 16);
    e3.tokenValue = e3.source.slice(a2, e3.index), l(e3), 128 & n3 && (e3.tokenRaw = e3.source.slice(e3.tokenIndex, e3.index));
    return 134283267;
  }(e2, n2) : H(e2, n2, 0)), e2.getToken();
}
function $(e2, n2) {
  if (e2.startIndex = e2.tokenIndex = e2.index, e2.startColumn = e2.tokenColumn = e2.column, e2.startLine = e2.tokenLine = e2.line, e2.index >= e2.end)
    return void e2.setToken(1048576);
  if (e2.currentChar === 60)
    return l(e2), void e2.setToken(8456256);
  if (e2.currentChar === 123)
    return l(e2), void e2.setToken(2162700);
  let o2 = 0;
  for (;e2.index < e2.end; ) {
    const n3 = p[e2.source.charCodeAt(e2.index)];
    if (1024 & n3 ? (o2 |= 5, d(e2)) : 2048 & n3 ? (u(e2, o2), o2 = -5 & o2 | 1) : l(e2), 16384 & p[e2.currentChar])
      break;
  }
  e2.tokenIndex === e2.index && t(e2, 0);
  const r2 = e2.source.slice(e2.tokenIndex, e2.index);
  128 & n2 && (e2.tokenRaw = r2), e2.tokenValue = X(r2), e2.setToken(137);
}
function Y(e2) {
  if (!(143360 & ~e2.getToken())) {
    const { index: n2 } = e2;
    let t2 = e2.currentChar;
    for (;32770 & p[t2]; )
      t2 = l(e2);
    e2.tokenValue += e2.source.slice(n2, e2.index), e2.setToken(208897, true);
  }
  return e2.getToken();
}
function Z(e2, n2) {
  !(1 & e2.flags) && 1048576 & ~e2.getToken() && t(e2, 30, N[255 & e2.getToken()]), Q(e2, n2, 1074790417) || e2.onInsertedSemicolon?.(e2.startIndex);
}
function W(e2, n2, t2, o2) {
  return n2 - t2 < 13 && o2 === "use strict" && (!(1048576 & ~e2.getToken()) || 1 & e2.flags) ? 1 : 0;
}
function K(e2, n2, t2) {
  return e2.getToken() !== t2 ? 0 : (J(e2, n2), 1);
}
function Q(e2, n2, t2) {
  return e2.getToken() === t2 && (J(e2, n2), true);
}
function ee(e2, n2, o2) {
  e2.getToken() !== o2 && t(e2, 25, N[255 & o2]), J(e2, n2);
}
function ne(e2, n2) {
  switch (n2.type) {
    case "ArrayExpression": {
      n2.type = "ArrayPattern";
      const { elements: t2 } = n2;
      for (let n3 = 0, o2 = t2.length;n3 < o2; ++n3) {
        const o3 = t2[n3];
        o3 && ne(e2, o3);
      }
      return;
    }
    case "ObjectExpression": {
      n2.type = "ObjectPattern";
      const { properties: t2 } = n2;
      for (let n3 = 0, o2 = t2.length;n3 < o2; ++n3)
        ne(e2, t2[n3]);
      return;
    }
    case "AssignmentExpression":
      return n2.type = "AssignmentPattern", n2.operator !== "=" && t(e2, 71), delete n2.operator, void ne(e2, n2.left);
    case "Property":
      return void ne(e2, n2.value);
    case "SpreadElement":
      n2.type = "RestElement", ne(e2, n2.argument);
  }
}
function te(e2, n2, o2, r2, a2) {
  256 & n2 && (36864 & ~r2 || t(e2, 118), a2 || 537079808 & ~r2 || t(e2, 119)), 20480 & ~r2 && r2 !== -2147483528 || t(e2, 102), 24 & o2 && (255 & r2) == 73 && t(e2, 100), 524800 & n2 && r2 === 209006 && t(e2, 110), 262400 & n2 && r2 === 241771 && t(e2, 97, "yield");
}
function oe(e2, n2, o2) {
  256 & n2 && (36864 & ~o2 || t(e2, 118), 537079808 & ~o2 || t(e2, 119), o2 === -2147483527 && t(e2, 95), o2 === -2147483528 && t(e2, 95)), 20480 & ~o2 || t(e2, 102), 524800 & n2 && o2 === 209006 && t(e2, 110), 262400 & n2 && o2 === 241771 && t(e2, 97, "yield");
}
function re(e2, n2, o2) {
  return o2 === 209006 && (524800 & n2 && t(e2, 110), e2.destructible |= 128), o2 === 241771 && 262144 & n2 && t(e2, 97, "yield"), !(20480 & ~o2 && 36864 & ~o2 && o2 != -2147483527);
}
function ae(e2, n2, o2, r2) {
  for (;n2; ) {
    if (n2["$" + o2])
      return r2 && t(e2, 137), 1;
    r2 && n2.loop && (r2 = 0), n2 = n2.$;
  }
  return 0;
}
function ie(e2, n2, t2, o2, r2, a2) {
  return 2 & n2 && (a2.start = t2, a2.end = e2.startIndex, a2.range = [t2, e2.startIndex]), 4 & n2 && (a2.loc = { start: { line: o2, column: r2 }, end: { line: e2.startLine, column: e2.startColumn } }, e2.sourceFile && (a2.loc.source = e2.sourceFile)), a2;
}
function se(e2) {
  switch (e2.type) {
    case "JSXIdentifier":
      return e2.name;
    case "JSXNamespacedName":
      return e2.namespace + ":" + e2.name;
    case "JSXMemberExpression":
      return se(e2.object) + "." + se(e2.property);
  }
}
function le(e2, n2, t2) {
  const o2 = ue({ parent: undefined, type: 2 }, 1024);
  return ge(e2, n2, o2, t2, 1, 0), o2;
}
function ce(e2, n2, ...t2) {
  const { index: o2, line: r2, column: a2, tokenIndex: i2, tokenLine: s2, tokenColumn: l2 } = e2;
  return { type: n2, params: t2, index: o2, line: r2, column: a2, tokenIndex: i2, tokenLine: s2, tokenColumn: l2 };
}
function ue(e2, n2) {
  return { parent: e2, type: n2, scopeError: undefined };
}
function de(e2, n2, t2, o2, r2, a2) {
  4 & r2 ? ke(e2, n2, t2, o2, r2) : ge(e2, n2, t2, o2, r2, a2), 64 & a2 && fe(e2, o2);
}
function ge(e2, n2, o2, r2, a2, i2) {
  const s2 = o2["#" + r2];
  !s2 || 2 & s2 || (1 & a2 ? o2.scopeError = ce(e2, 145, r2) : 64 & n2 && !(256 & n2) && 2 & i2 && s2 === 64 && a2 === 64 || t(e2, 145, r2)), 128 & o2.type && o2.parent["#" + r2] && !(2 & o2.parent["#" + r2]) && t(e2, 145, r2), 1024 & o2.type && s2 && !(2 & s2) && 1 & a2 && (o2.scopeError = ce(e2, 145, r2)), 64 & o2.type && 768 & o2.parent["#" + r2] && t(e2, 159, r2), o2["#" + r2] = a2;
}
function ke(e2, n2, o2, r2, a2) {
  let i2 = o2;
  for (;i2 && !(256 & i2.type); ) {
    const s2 = i2["#" + r2];
    248 & s2 && (64 & n2 && !(256 & n2) && (128 & a2 && 68 & s2 || 128 & s2 && 68 & a2) || t(e2, 145, r2)), i2 === o2 && 1 & s2 && 1 & a2 && (i2.scopeError = ce(e2, 145, r2)), (256 & s2 || 512 & s2 && !(64 & n2)) && t(e2, 145, r2), i2["#" + r2] = a2, i2 = i2.parent;
  }
}
function pe(e2, n2) {
  return n2["#" + e2] ? 1 : n2.parent ? pe(e2, n2.parent) : 0;
}
function fe(e2, n2) {
  e2.exportedNames !== undefined && n2 !== "" && (e2.exportedNames["#" + n2] && t(e2, 147, n2), e2.exportedNames["#" + n2] = 1);
}
function me(e2, n2) {
  return 262400 & e2 ? !(512 & e2 && n2 === 209006) && (!(262144 & e2 && n2 === 241771) && !(12288 & ~n2)) : !(12288 & ~n2 && 36864 & ~n2);
}
function be(e2, n2, o2) {
  537079808 & ~o2 || (256 & n2 && t(e2, 119), e2.flags |= 512), me(n2, o2) || t(e2, 0);
}
function he(e2, n2, o2) {
  let a2, i2, s2, c2 = "";
  n2 != null && (n2.module && (o2 |= 768), n2.next && (o2 |= 1), n2.loc && (o2 |= 4), n2.ranges && (o2 |= 2), n2.uniqueKeyInPattern && (o2 |= 134217728), n2.lexical && (o2 |= 16), n2.webcompat && (o2 |= 64), n2.globalReturn && (o2 |= 1048576), n2.raw && (o2 |= 128), n2.preserveParens && (o2 |= 32), n2.impliedStrict && (o2 |= 256), n2.jsx && (o2 |= 8), n2.source && (c2 = n2.source), n2.onComment != null && (a2 = Array.isArray(n2.onComment) ? function(e3, n3) {
    return function(t2, o3, r2, a3, i3) {
      const s3 = { type: t2, value: o3 };
      2 & e3 && (s3.start = r2, s3.end = a3, s3.range = [r2, a3]), 4 & e3 && (s3.loc = i3), n3.push(s3);
    };
  }(o2, n2.onComment) : n2.onComment), n2.onInsertedSemicolon != null && (i2 = n2.onInsertedSemicolon), n2.onToken != null && (s2 = Array.isArray(n2.onToken) ? function(e3, n3) {
    return function(t2, o3, r2, a3) {
      const i3 = { token: t2 };
      2 & e3 && (i3.start = o3, i3.end = r2, i3.range = [o3, r2]), 4 & e3 && (i3.loc = a3), n3.push(i3);
    };
  }(o2, n2.onToken) : n2.onToken));
  const u2 = function(e3, n3, t2, o3, r2) {
    let a3 = 1048576, i3 = null;
    return { source: e3, flags: 0, index: 0, line: 1, column: 0, startIndex: 0, end: e3.length, tokenIndex: 0, startColumn: 0, tokenColumn: 0, tokenLine: 1, startLine: 1, sourceFile: n3, tokenValue: "", getToken: () => a3, setToken(e4, n4 = false) {
      if (o3)
        if (e4 !== 1048576) {
          const t3 = { start: { line: this.tokenLine, column: this.tokenColumn }, end: { line: this.line, column: this.column } };
          !n4 && i3 && o3(...i3), i3 = [k(e4), this.tokenIndex, this.index, t3];
        } else
          i3 && (o3(...i3), i3 = null);
      return a3 = e4;
    }, tokenRaw: "", tokenRegExp: undefined, currentChar: e3.charCodeAt(0), exportedNames: [], exportedBindings: [], assignable: 1, destructible: 0, onComment: t2, onToken: o3, onInsertedSemicolon: r2, leadingDecorators: [] };
  }(e2, c2, a2, s2, i2);
  (function(e3) {
    const { source: n3 } = e3;
    e3.currentChar === 35 && n3.charCodeAt(e3.index + 1) === 33 && (l(e3), l(e3), y(e3, n3, 0, 4, e3.tokenIndex, e3.tokenLine, e3.tokenColumn));
  })(u2);
  const d2 = 16 & o2 ? { parent: undefined, type: 2 } : undefined;
  let g2 = [], p2 = "script";
  if (512 & o2) {
    if (p2 = "module", g2 = function(e3, n3, t2) {
      J(e3, 8192 | n3);
      const o3 = [];
      for (;e3.getToken() === 134283267; ) {
        const { tokenIndex: t3, tokenLine: r2, tokenColumn: a3 } = e3, i3 = e3.getToken();
        o3.push(Ie(e3, n3, un(e3, n3), i3, t3, r2, a3));
      }
      for (;e3.getToken() !== 1048576; )
        o3.push(xe(e3, n3, t2));
      return o3;
    }(u2, 2048 | o2, d2), d2)
      for (const e3 in u2.exportedBindings)
        e3[0] !== "#" || d2[e3] || t(u2, 148, e3.slice(1));
  } else
    g2 = function(e3, n3, t2) {
      J(e3, 67117056 | n3);
      const o3 = [];
      for (;e3.getToken() === 134283267; ) {
        const { index: t3, tokenIndex: a3, tokenValue: i3, tokenLine: s3, tokenColumn: l2 } = e3, c3 = e3.getToken(), u3 = un(e3, n3);
        W(e3, t3, a3, i3) && (n3 |= 256, 64 & e3.flags && r(e3.tokenIndex, e3.tokenLine, e3.tokenColumn, e3.index, e3.line, e3.column, 9), 4096 & e3.flags && r(e3.tokenIndex, e3.tokenLine, e3.tokenColumn, e3.index, e3.line, e3.column, 15)), o3.push(Ie(e3, n3, u3, c3, a3, s3, l2));
      }
      for (;e3.getToken() !== 1048576; )
        o3.push(Te(e3, n3, t2, undefined, 4, {}));
      return o3;
    }(u2, 2048 | o2, d2);
  const f2 = { type: "Program", sourceType: p2, body: g2 };
  return 2 & o2 && (f2.start = 0, f2.end = e2.length, f2.range = [0, e2.length]), 4 & o2 && (f2.loc = { start: { line: 1, column: 0 }, end: { line: u2.line, column: u2.column } }, u2.sourceFile && (f2.loc.source = c2)), f2;
}
function xe(e2, n2, o2) {
  let r2;
  switch (e2.leadingDecorators = En(e2, n2, undefined), e2.getToken()) {
    case 20564:
      r2 = function(e3, n3, o3) {
        const { tokenIndex: r3, tokenLine: a2, tokenColumn: i2 } = e3;
        J(e3, 8192 | n3);
        const s2 = [];
        let l2 = null, c2 = null, u2 = null;
        if (Q(e3, 8192 | n3, 20561)) {
          switch (e3.getToken()) {
            case 86104:
              l2 = dn(e3, n3, o3, undefined, 4, 1, 1, 0, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
              break;
            case 132:
            case 86094:
              l2 = qn(e3, n3, o3, undefined, 1, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
              break;
            case 209005: {
              const { tokenIndex: t2, tokenLine: r4, tokenColumn: a3 } = e3;
              l2 = cn(e3, n3);
              const { flags: i3 } = e3;
              1 & i3 || (e3.getToken() === 86104 ? l2 = dn(e3, n3, o3, undefined, 4, 1, 1, 1, t2, r4, a3) : e3.getToken() === 67174411 ? (l2 = In(e3, n3, undefined, l2, 1, 1, 0, i3, t2, r4, a3), l2 = _e(e3, n3, undefined, l2, 0, 0, t2, r4, a3), l2 = je(e3, n3, undefined, 0, 0, t2, r4, a3, l2)) : 143360 & e3.getToken() && (o3 && (o3 = le(e3, n3, e3.tokenValue)), l2 = cn(e3, n3), l2 = Cn(e3, n3, o3, undefined, [l2], 1, t2, r4, a3)));
              break;
            }
            default:
              l2 = Oe(e3, n3, undefined, 1, 0, e3.tokenIndex, e3.tokenLine, e3.tokenColumn), Z(e3, 8192 | n3);
          }
          return o3 && fe(e3, "default"), ie(e3, n3, r3, a2, i2, { type: "ExportDefaultDeclaration", declaration: l2 });
        }
        switch (e3.getToken()) {
          case 8391476: {
            J(e3, n3);
            let s3 = null;
            Q(e3, n3, 77932) && (o3 && fe(e3, e3.tokenValue), s3 = nn(e3, n3)), ee(e3, n3, 12403), e3.getToken() !== 134283267 && t(e3, 105, "Export"), c2 = un(e3, n3);
            const l3 = { type: "ExportAllDeclaration", source: c2, exported: s3 };
            return 1 & n3 && (l3.attributes = Ke(e3, n3)), Z(e3, 8192 | n3), ie(e3, n3, r3, a2, i2, l3);
          }
          case 2162700: {
            J(e3, n3);
            const r4 = [], a3 = [];
            let i3 = 0;
            for (;143360 & e3.getToken() || e3.getToken() === 134283267; ) {
              const { tokenIndex: l3, tokenValue: c3, tokenLine: u3, tokenColumn: d3 } = e3, g2 = nn(e3, n3);
              let k2;
              g2.type === "Literal" && (i3 = 1), e3.getToken() === 77932 ? (J(e3, n3), 143360 & e3.getToken() || e3.getToken() === 134283267 || t(e3, 106), o3 && (r4.push(e3.tokenValue), a3.push(c3)), k2 = nn(e3, n3)) : (o3 && (r4.push(e3.tokenValue), a3.push(e3.tokenValue)), k2 = g2), s2.push(ie(e3, n3, l3, u3, d3, { type: "ExportSpecifier", local: g2, exported: k2 })), e3.getToken() !== 1074790415 && ee(e3, n3, 18);
            }
            ee(e3, n3, 1074790415), Q(e3, n3, 12403) ? (e3.getToken() !== 134283267 && t(e3, 105, "Export"), c2 = un(e3, n3), 1 & n3 && (u2 = Ke(e3, n3, s2)), o3 && r4.forEach((n4) => fe(e3, n4))) : (i3 && t(e3, 172), o3 && (r4.forEach((n4) => fe(e3, n4)), a3.forEach((n4) => function(e4, n5) {
              e4.exportedBindings !== undefined && n5 !== "" && (e4.exportedBindings["#" + n5] = 1);
            }(e3, n4)))), Z(e3, 8192 | n3);
            break;
          }
          case 86094:
            l2 = qn(e3, n3, o3, undefined, 2, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
            break;
          case 86104:
            l2 = dn(e3, n3, o3, undefined, 4, 1, 2, 0, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
            break;
          case 241737:
            l2 = Se(e3, n3, o3, undefined, 8, 64, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
            break;
          case 86090:
            l2 = Se(e3, n3, o3, undefined, 16, 64, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
            break;
          case 86088:
            l2 = Ae(e3, n3, o3, undefined, 64, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
            break;
          case 209005: {
            const { tokenIndex: t2, tokenLine: r4, tokenColumn: a3 } = e3;
            if (J(e3, n3), !(1 & e3.flags) && e3.getToken() === 86104) {
              l2 = dn(e3, n3, o3, undefined, 4, 1, 2, 1, t2, r4, a3);
              break;
            }
          }
          default:
            t(e3, 30, N[255 & e3.getToken()]);
        }
        const d2 = { type: "ExportNamedDeclaration", declaration: l2, specifiers: s2, source: c2 };
        u2 && (d2.attributes = u2);
        return ie(e3, n3, r3, a2, i2, d2);
      }(e2, n2, o2);
      break;
    case 86106:
      r2 = function(e3, n3, o3) {
        const { tokenIndex: r3, tokenLine: a2, tokenColumn: i2 } = e3;
        J(e3, n3);
        let s2 = null;
        const { tokenIndex: l2, tokenLine: c2, tokenColumn: u2 } = e3;
        let d2 = [];
        if (e3.getToken() === 134283267)
          s2 = un(e3, n3);
        else {
          if (143360 & e3.getToken()) {
            if (d2 = [ie(e3, n3, l2, c2, u2, { type: "ImportDefaultSpecifier", local: Re(e3, n3, o3) })], Q(e3, n3, 18))
              switch (e3.getToken()) {
                case 8391476:
                  d2.push(Ne(e3, n3, o3));
                  break;
                case 2162700:
                  Ue(e3, n3, o3, d2);
                  break;
                default:
                  t(e3, 107);
              }
          } else
            switch (e3.getToken()) {
              case 8391476:
                d2 = [Ne(e3, n3, o3)];
                break;
              case 2162700:
                Ue(e3, n3, o3, d2);
                break;
              case 67174411:
                return Be(e3, n3, undefined, r3, a2, i2);
              case 67108877:
                return Pe(e3, n3, r3, a2, i2);
              default:
                t(e3, 30, N[255 & e3.getToken()]);
            }
          s2 = function(e4, n4) {
            ee(e4, n4, 12403), e4.getToken() !== 134283267 && t(e4, 105, "Import");
            return un(e4, n4);
          }(e3, n3);
        }
        const g2 = { type: "ImportDeclaration", specifiers: d2, source: s2 };
        1 & n3 && (g2.attributes = Ke(e3, n3, d2));
        return Z(e3, 8192 | n3), ie(e3, n3, r3, a2, i2, g2);
      }(e2, n2, o2);
      break;
    default:
      r2 = Te(e2, n2, o2, undefined, 4, {});
  }
  return e2.leadingDecorators.length && t(e2, 170), r2;
}
function Te(e2, n2, o2, r2, a2, i2) {
  const { tokenIndex: s2, tokenLine: l2, tokenColumn: c2 } = e2;
  switch (e2.getToken()) {
    case 86104:
      return dn(e2, n2, o2, r2, a2, 1, 0, 0, s2, l2, c2);
    case 132:
    case 86094:
      return qn(e2, n2, o2, r2, 0, s2, l2, c2);
    case 86090:
      return Se(e2, n2, o2, r2, 16, 0, s2, l2, c2);
    case 241737:
      return function(e3, n3, o3, r3, a3, i3, s3, l3) {
        const { tokenValue: c3 } = e3, u2 = e3.getToken();
        let d2 = cn(e3, n3);
        if (2240512 & e3.getToken()) {
          const t2 = De(e3, n3, o3, r3, 8, 0);
          return Z(e3, 8192 | n3), ie(e3, n3, i3, s3, l3, { type: "VariableDeclaration", kind: "let", declarations: t2 });
        }
        e3.assignable = 1, 256 & n3 && t(e3, 85);
        if (e3.getToken() === 21)
          return we(e3, n3, o3, r3, a3, {}, c3, d2, u2, 0, i3, s3, l3);
        if (e3.getToken() === 10) {
          let t2;
          16 & n3 && (t2 = le(e3, n3, c3)), e3.flags = 128 ^ (128 | e3.flags), d2 = Cn(e3, n3, t2, r3, [d2], 0, i3, s3, l3);
        } else
          d2 = _e(e3, n3, r3, d2, 0, 0, i3, s3, l3), d2 = je(e3, n3, r3, 0, 0, i3, s3, l3, d2);
        e3.getToken() === 18 && (d2 = Ge(e3, n3, r3, 0, i3, s3, l3, d2));
        return ve(e3, n3, d2, i3, s3, l3);
      }(e2, n2, o2, r2, a2, s2, l2, c2);
    case 20564:
      t(e2, 103, "export");
    case 86106:
      switch (J(e2, n2), e2.getToken()) {
        case 67174411:
          return Be(e2, n2, r2, s2, l2, c2);
        case 67108877:
          return Pe(e2, n2, s2, l2, c2);
        default:
          t(e2, 103, "import");
      }
    case 209005:
      return Le(e2, n2, o2, r2, a2, i2, 1, s2, l2, c2);
    default:
      return ye(e2, n2, o2, r2, a2, i2, 1, s2, l2, c2);
  }
}
function ye(e2, n2, o2, r2, a2, i2, s2, l2, c2, u2) {
  switch (e2.getToken()) {
    case 86088:
      return Ae(e2, n2, o2, r2, 0, l2, c2, u2);
    case 20572:
      return function(e3, n3, o3, r3, a3, i3) {
        1048576 & n3 || t(e3, 92);
        J(e3, 8192 | n3);
        const s3 = 1 & e3.flags || 1048576 & e3.getToken() ? null : Fe(e3, n3, o3, 0, 1, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
        return Z(e3, 8192 | n3), ie(e3, n3, r3, a3, i3, { type: "ReturnStatement", argument: s3 });
      }(e2, n2, r2, l2, c2, u2);
    case 20569:
      return function(e3, n3, t2, o3, r3, a3, i3, s3) {
        J(e3, n3), ee(e3, 8192 | n3, 67174411), e3.assignable = 1;
        const l3 = Fe(e3, n3, o3, 0, 1, e3.tokenIndex, e3.line, e3.tokenColumn);
        ee(e3, 8192 | n3, 16);
        const c3 = qe(e3, n3, t2, o3, r3, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
        let u3 = null;
        e3.getToken() === 20563 && (J(e3, 8192 | n3), u3 = qe(e3, n3, t2, o3, r3, e3.tokenIndex, e3.tokenLine, e3.tokenColumn));
        return ie(e3, n3, a3, i3, s3, { type: "IfStatement", test: l3, consequent: c3, alternate: u3 });
      }(e2, n2, o2, r2, i2, l2, c2, u2);
    case 20567:
      return function(e3, n3, o3, r3, a3, i3, s3, l3) {
        J(e3, n3);
        const c3 = ((524288 & n3) > 0 || (512 & n3) > 0 && (2048 & n3) > 0) && Q(e3, n3, 209006);
        ee(e3, 8192 | n3, 67174411), o3 && (o3 = ue(o3, 1));
        let u3, d2 = null, g2 = null, k2 = 0, p2 = null, f2 = e3.getToken() === 86088 || e3.getToken() === 241737 || e3.getToken() === 86090;
        const { tokenIndex: m2, tokenLine: b2, tokenColumn: h2 } = e3, x2 = e3.getToken();
        f2 ? x2 === 241737 ? (p2 = cn(e3, n3), 2240512 & e3.getToken() ? (e3.getToken() === 8673330 ? 256 & n3 && t(e3, 67) : p2 = ie(e3, n3, m2, b2, h2, { type: "VariableDeclaration", kind: "let", declarations: De(e3, 33554432 | n3, o3, r3, 8, 32) }), e3.assignable = 1) : 256 & n3 ? t(e3, 67) : (f2 = false, e3.assignable = 1, p2 = _e(e3, n3, r3, p2, 0, 0, m2, b2, h2), e3.getToken() === 274548 && t(e3, 115))) : (J(e3, n3), p2 = ie(e3, n3, m2, b2, h2, x2 === 86088 ? { type: "VariableDeclaration", kind: "var", declarations: De(e3, 33554432 | n3, o3, r3, 4, 32) } : { type: "VariableDeclaration", kind: "const", declarations: De(e3, 33554432 | n3, o3, r3, 16, 32) }), e3.assignable = 1) : x2 === 1074790417 ? c3 && t(e3, 82) : 2097152 & ~x2 ? p2 = Xe(e3, 33554432 | n3, r3, 1, 0, 1, m2, b2, h2) : (p2 = x2 === 2162700 ? bn(e3, n3, undefined, r3, 1, 0, 0, 2, 32, m2, b2, h2) : kn(e3, n3, undefined, r3, 1, 0, 0, 2, 32, m2, b2, h2), k2 = e3.destructible, 64 & k2 && t(e3, 63), e3.assignable = 16 & k2 ? 2 : 1, p2 = _e(e3, 33554432 | n3, r3, p2, 0, 0, e3.tokenIndex, e3.tokenLine, e3.tokenColumn));
        if (!(262144 & ~e3.getToken())) {
          if (e3.getToken() === 274548) {
            2 & e3.assignable && t(e3, 80, c3 ? "await" : "of"), ne(e3, p2), J(e3, 8192 | n3), u3 = Oe(e3, n3, r3, 1, 0, e3.tokenIndex, e3.tokenLine, e3.tokenColumn), ee(e3, 8192 | n3, 16);
            return ie(e3, n3, i3, s3, l3, { type: "ForOfStatement", left: p2, right: u3, body: Ee(e3, n3, o3, r3, a3), await: c3 });
          }
          2 & e3.assignable && t(e3, 80, "in"), ne(e3, p2), J(e3, 8192 | n3), c3 && t(e3, 82), u3 = Fe(e3, n3, r3, 0, 1, e3.tokenIndex, e3.tokenLine, e3.tokenColumn), ee(e3, 8192 | n3, 16);
          return ie(e3, n3, i3, s3, l3, { type: "ForInStatement", body: Ee(e3, n3, o3, r3, a3), left: p2, right: u3 });
        }
        c3 && t(e3, 82);
        f2 || (8 & k2 && e3.getToken() !== 1077936155 && t(e3, 80, "loop"), p2 = je(e3, 33554432 | n3, r3, 0, 0, m2, b2, h2, p2));
        e3.getToken() === 18 && (p2 = Ge(e3, n3, r3, 0, e3.tokenIndex, e3.tokenLine, e3.tokenColumn, p2));
        ee(e3, 8192 | n3, 1074790417), e3.getToken() !== 1074790417 && (d2 = Fe(e3, n3, r3, 0, 1, e3.tokenIndex, e3.tokenLine, e3.tokenColumn));
        ee(e3, 8192 | n3, 1074790417), e3.getToken() !== 16 && (g2 = Fe(e3, n3, r3, 0, 1, e3.tokenIndex, e3.tokenLine, e3.tokenColumn));
        ee(e3, 8192 | n3, 16);
        const T2 = Ee(e3, n3, o3, r3, a3);
        return ie(e3, n3, i3, s3, l3, { type: "ForStatement", init: p2, test: d2, update: g2, body: T2 });
      }(e2, n2, o2, r2, i2, l2, c2, u2);
    case 20562:
      return function(e3, n3, t2, o3, r3, a3, i3, s3) {
        J(e3, 8192 | n3);
        const l3 = Ee(e3, n3, t2, o3, r3);
        ee(e3, n3, 20578), ee(e3, 8192 | n3, 67174411);
        const c3 = Fe(e3, n3, o3, 0, 1, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
        return ee(e3, 8192 | n3, 16), Q(e3, 8192 | n3, 1074790417), ie(e3, n3, a3, i3, s3, { type: "DoWhileStatement", body: l3, test: c3 });
      }(e2, n2, o2, r2, i2, l2, c2, u2);
    case 20578:
      return function(e3, n3, t2, o3, r3, a3, i3, s3) {
        J(e3, n3), ee(e3, 8192 | n3, 67174411);
        const l3 = Fe(e3, n3, o3, 0, 1, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
        ee(e3, 8192 | n3, 16);
        const c3 = Ee(e3, n3, t2, o3, r3);
        return ie(e3, n3, a3, i3, s3, { type: "WhileStatement", test: l3, body: c3 });
      }(e2, n2, o2, r2, i2, l2, c2, u2);
    case 86110:
      return function(e3, n3, o3, r3, a3, i3, s3, l3) {
        J(e3, n3), ee(e3, 8192 | n3, 67174411);
        const c3 = Fe(e3, n3, r3, 0, 1, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
        ee(e3, n3, 16), ee(e3, n3, 2162700);
        const u3 = [];
        let d2 = 0;
        o3 && (o3 = ue(o3, 8));
        for (;e3.getToken() !== 1074790415; ) {
          const { tokenIndex: i4, tokenLine: s4, tokenColumn: l4 } = e3;
          let c4 = null;
          const g2 = [];
          for (Q(e3, 8192 | n3, 20556) ? c4 = Fe(e3, n3, r3, 0, 1, e3.tokenIndex, e3.tokenLine, e3.tokenColumn) : (ee(e3, 8192 | n3, 20561), d2 && t(e3, 89), d2 = 1), ee(e3, 8192 | n3, 21);e3.getToken() !== 20556 && e3.getToken() !== 1074790415 && e3.getToken() !== 20561; )
            g2.push(Te(e3, 1024 | n3, o3, r3, 2, { $: a3 }));
          u3.push(ie(e3, n3, i4, s4, l4, { type: "SwitchCase", test: c4, consequent: g2 }));
        }
        return ee(e3, 8192 | n3, 1074790415), ie(e3, n3, i3, s3, l3, { type: "SwitchStatement", discriminant: c3, cases: u3 });
      }(e2, n2, o2, r2, i2, l2, c2, u2);
    case 1074790417:
      return function(e3, n3, t2, o3, r3) {
        return J(e3, 8192 | n3), ie(e3, n3, t2, o3, r3, { type: "EmptyStatement" });
      }(e2, n2, l2, c2, u2);
    case 2162700:
      return Ce(e2, n2, o2 ? ue(o2, 2) : o2, r2, i2, l2, c2, u2);
    case 86112:
      return function(e3, n3, o3, r3, a3, i3) {
        J(e3, 8192 | n3), 1 & e3.flags && t(e3, 90);
        const s3 = Fe(e3, n3, o3, 0, 1, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
        return Z(e3, 8192 | n3), ie(e3, n3, r3, a3, i3, { type: "ThrowStatement", argument: s3 });
      }(e2, n2, r2, l2, c2, u2);
    case 20555:
      return function(e3, n3, o3, r3, a3, i3) {
        J(e3, 8192 | n3);
        let s3 = null;
        if (!(1 & e3.flags) && 143360 & e3.getToken()) {
          const { tokenValue: r4 } = e3;
          s3 = cn(e3, 8192 | n3), ae(e3, o3, r4, 0) || t(e3, 138, r4);
        } else
          33792 & n3 || t(e3, 69);
        return Z(e3, 8192 | n3), ie(e3, n3, r3, a3, i3, { type: "BreakStatement", label: s3 });
      }(e2, n2, i2, l2, c2, u2);
    case 20559:
      return function(e3, n3, o3, r3, a3, i3) {
        32768 & n3 || t(e3, 68);
        J(e3, n3);
        let s3 = null;
        if (!(1 & e3.flags) && 143360 & e3.getToken()) {
          const { tokenValue: r4 } = e3;
          s3 = cn(e3, 8192 | n3), ae(e3, o3, r4, 1) || t(e3, 138, r4);
        }
        return Z(e3, 8192 | n3), ie(e3, n3, r3, a3, i3, { type: "ContinueStatement", label: s3 });
      }(e2, n2, i2, l2, c2, u2);
    case 20577:
      return function(e3, n3, o3, r3, a3, i3, s3, l3) {
        J(e3, 8192 | n3);
        const c3 = o3 ? ue(o3, 32) : undefined, u3 = Ce(e3, n3, c3, r3, { $: a3 }, e3.tokenIndex, e3.tokenLine, e3.tokenColumn), { tokenIndex: d2, tokenLine: g2, tokenColumn: k2 } = e3, p2 = Q(e3, 8192 | n3, 20557) ? function(e4, n4, o4, r4, a4, i4, s4, l4) {
          let c4 = null, u4 = o4;
          Q(e4, n4, 67174411) && (o4 && (o4 = ue(o4, 4)), c4 = Nn(e4, n4, o4, r4, 2097152 & ~e4.getToken() ? 512 : 256, 0, e4.tokenIndex, e4.tokenLine, e4.tokenColumn), e4.getToken() === 18 ? t(e4, 86) : e4.getToken() === 1077936155 && t(e4, 87), ee(e4, 8192 | n4, 16));
          o4 && (u4 = ue(o4, 64));
          const d3 = Ce(e4, n4, u4, r4, { $: a4 }, e4.tokenIndex, e4.tokenLine, e4.tokenColumn);
          return ie(e4, n4, i4, s4, l4, { type: "CatchClause", param: c4, body: d3 });
        }(e3, n3, o3, r3, a3, d2, g2, k2) : null;
        let f2 = null;
        if (e3.getToken() === 20566) {
          J(e3, 8192 | n3);
          f2 = Ce(e3, n3, c3 ? ue(o3, 4) : undefined, r3, { $: a3 }, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
        }
        p2 || f2 || t(e3, 88);
        return ie(e3, n3, i3, s3, l3, { type: "TryStatement", block: u3, handler: p2, finalizer: f2 });
      }(e2, n2, o2, r2, i2, l2, c2, u2);
    case 20579:
      return function(e3, n3, o3, r3, a3, i3, s3, l3) {
        J(e3, n3), 256 & n3 && t(e3, 91);
        ee(e3, 8192 | n3, 67174411);
        const c3 = Fe(e3, n3, r3, 0, 1, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
        ee(e3, 8192 | n3, 16);
        const u3 = ye(e3, n3, o3, r3, 2, a3, 0, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
        return ie(e3, n3, i3, s3, l3, { type: "WithStatement", object: c3, body: u3 });
      }(e2, n2, o2, r2, i2, l2, c2, u2);
    case 20560:
      return function(e3, n3, t2, o3, r3) {
        return J(e3, 8192 | n3), Z(e3, 8192 | n3), ie(e3, n3, t2, o3, r3, { type: "DebuggerStatement" });
      }(e2, n2, l2, c2, u2);
    case 209005:
      return Le(e2, n2, o2, r2, a2, i2, 0, l2, c2, u2);
    case 20557:
      t(e2, 162);
    case 20566:
      t(e2, 163);
    case 86104:
      t(e2, 256 & n2 ? 76 : 64 & n2 ? 77 : 78);
    case 86094:
      t(e2, 79);
    default:
      return function(e3, n3, o3, r3, a3, i3, s3, l3, c3, u3) {
        const { tokenValue: d2 } = e3, g2 = e3.getToken();
        let k2;
        if (g2 === 241737)
          k2 = cn(e3, n3), 256 & n3 && t(e3, 85), e3.getToken() === 69271571 && t(e3, 84);
        else
          k2 = Ye(e3, n3, r3, 2, 0, 1, 0, 1, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
        if (143360 & g2 && e3.getToken() === 21)
          return we(e3, n3, o3, r3, a3, i3, d2, k2, g2, s3, l3, c3, u3);
        k2 = _e(e3, n3, r3, k2, 0, 0, l3, c3, u3), k2 = je(e3, n3, r3, 0, 0, l3, c3, u3, k2), e3.getToken() === 18 && (k2 = Ge(e3, n3, r3, 0, l3, c3, u3, k2));
        return ve(e3, n3, k2, l3, c3, u3);
      }(e2, n2, o2, r2, a2, i2, s2, l2, c2, u2);
  }
}
function Ce(e2, n2, t2, o2, r2, a2, i2, s2) {
  const l2 = [];
  for (ee(e2, 8192 | n2, 2162700);e2.getToken() !== 1074790415; )
    l2.push(Te(e2, n2, t2, o2, 2, { $: r2 }));
  return ee(e2, 8192 | n2, 1074790415), ie(e2, n2, a2, i2, s2, { type: "BlockStatement", body: l2 });
}
function ve(e2, n2, t2, o2, r2, a2) {
  return Z(e2, 8192 | n2), ie(e2, n2, o2, r2, a2, { type: "ExpressionStatement", expression: t2 });
}
function we(e2, n2, o2, r2, a2, i2, s2, l2, c2, u2, d2, g2, k2) {
  te(e2, n2, 0, c2, 1), function(e3, n3, o3) {
    let r3 = n3;
    for (;r3; )
      r3["$" + o3] && t(e3, 136, o3), r3 = r3.$;
    n3["$" + o3] = 1;
  }(e2, i2, s2), J(e2, 8192 | n2);
  const p2 = u2 && !(256 & n2) && 64 & n2 && e2.getToken() === 86104 ? dn(e2, n2, ue(o2, 2), r2, a2, 0, 0, 0, e2.tokenIndex, e2.tokenLine, e2.tokenColumn) : ye(e2, n2, o2, r2, a2, i2, u2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn);
  return ie(e2, n2, d2, g2, k2, { type: "LabeledStatement", label: l2, body: p2 });
}
function Le(e2, n2, o2, r2, a2, i2, s2, l2, c2, u2) {
  const { tokenValue: d2 } = e2, g2 = e2.getToken();
  let k2 = cn(e2, n2);
  if (e2.getToken() === 21)
    return we(e2, n2, o2, r2, a2, i2, d2, k2, g2, 1, l2, c2, u2);
  const p2 = 1 & e2.flags;
  if (!p2) {
    if (e2.getToken() === 86104)
      return s2 || t(e2, 123), dn(e2, n2, o2, r2, a2, 1, 0, 1, l2, c2, u2);
    if (me(n2, e2.getToken()))
      return k2 = Ln(e2, n2, r2, 1, l2, c2, u2), e2.getToken() === 18 && (k2 = Ge(e2, n2, r2, 0, l2, c2, u2, k2)), ve(e2, n2, k2, l2, c2, u2);
  }
  return e2.getToken() === 67174411 ? k2 = In(e2, n2, r2, k2, 1, 1, 0, p2, l2, c2, u2) : (e2.getToken() === 10 && (be(e2, n2, g2), 36864 & ~g2 || (e2.flags |= 256), k2 = Tn(e2, 524288 | n2, r2, e2.tokenValue, k2, 0, 1, 0, l2, c2, u2)), e2.assignable = 1), k2 = _e(e2, n2, r2, k2, 0, 0, l2, c2, u2), k2 = je(e2, n2, r2, 0, 0, l2, c2, u2, k2), e2.assignable = 1, e2.getToken() === 18 && (k2 = Ge(e2, n2, r2, 0, l2, c2, u2, k2)), ve(e2, n2, k2, l2, c2, u2);
}
function Ie(e2, n2, t2, o2, r2, a2, i2) {
  const s2 = e2.startIndex;
  return o2 !== 1074790417 && (e2.assignable = 2, t2 = _e(e2, n2, undefined, t2, 0, 0, r2, a2, i2), e2.getToken() !== 1074790417 && (t2 = je(e2, n2, undefined, 0, 0, r2, a2, i2, t2), e2.getToken() === 18 && (t2 = Ge(e2, n2, undefined, 0, r2, a2, i2, t2))), Z(e2, 8192 | n2)), t2.type === "Literal" && typeof t2.value == "string" ? ie(e2, n2, r2, a2, i2, { type: "ExpressionStatement", expression: t2, directive: e2.source.slice(r2 + 1, s2 - 1) }) : ie(e2, n2, r2, a2, i2, { type: "ExpressionStatement", expression: t2 });
}
function qe(e2, n2, t2, o2, r2, a2, i2, s2) {
  return 256 & n2 || !(64 & n2) || e2.getToken() !== 86104 ? ye(e2, n2, t2, o2, 0, { $: r2 }, 0, e2.tokenIndex, e2.tokenLine, e2.tokenColumn) : dn(e2, n2, ue(t2, 2), o2, 0, 0, 0, 0, a2, i2, s2);
}
function Ee(e2, n2, t2, o2, r2) {
  return ye(e2, 33554432 ^ (33554432 | n2) | 32768, t2, o2, 0, { loop: 1, $: r2 }, 0, e2.tokenIndex, e2.tokenLine, e2.tokenColumn);
}
function Se(e2, n2, t2, o2, r2, a2, i2, s2, l2) {
  J(e2, n2);
  const c2 = De(e2, n2, t2, o2, r2, a2);
  return Z(e2, 8192 | n2), ie(e2, n2, i2, s2, l2, { type: "VariableDeclaration", kind: 8 & r2 ? "let" : "const", declarations: c2 });
}
function Ae(e2, n2, t2, o2, r2, a2, i2, s2) {
  J(e2, n2);
  const l2 = De(e2, n2, t2, o2, 4, r2);
  return Z(e2, 8192 | n2), ie(e2, n2, a2, i2, s2, { type: "VariableDeclaration", kind: "var", declarations: l2 });
}
function De(e2, n2, o2, r2, a2, i2) {
  let s2 = 1;
  const l2 = [Ve(e2, n2, o2, r2, a2, i2)];
  for (;Q(e2, n2, 18); )
    s2++, l2.push(Ve(e2, n2, o2, r2, a2, i2));
  return s2 > 1 && 32 & i2 && 262144 & e2.getToken() && t(e2, 61, N[255 & e2.getToken()]), l2;
}
function Ve(e2, n2, o2, a2, i2, s2) {
  const { tokenIndex: l2, tokenLine: c2, tokenColumn: u2 } = e2, d2 = e2.getToken();
  let g2 = null;
  const k2 = Nn(e2, n2, o2, a2, i2, s2, l2, c2, u2);
  return e2.getToken() === 1077936155 ? (J(e2, 8192 | n2), g2 = Oe(e2, n2, a2, 1, 0, e2.tokenIndex, e2.tokenLine, e2.tokenColumn), !(32 & s2) && 2097152 & d2 || (e2.getToken() === 274548 || e2.getToken() === 8673330 && (2097152 & d2 || !(4 & i2) || 256 & n2)) && r(l2, c2, u2, e2.index, e2.line, e2.column, 60, e2.getToken() === 274548 ? "of" : "in")) : (16 & i2 || (2097152 & d2) > 0) && 262144 & ~e2.getToken() && t(e2, 59, 16 & i2 ? "const" : "destructuring"), ie(e2, n2, l2, c2, u2, { type: "VariableDeclarator", id: k2, init: g2 });
}
function Re(e2, n2, o2) {
  return me(n2, e2.getToken()) || t(e2, 118), 537079808 & ~e2.getToken() || t(e2, 119), o2 && ge(e2, n2, o2, e2.tokenValue, 8, 0), cn(e2, n2);
}
function Ne(e2, n2, t2) {
  const { tokenIndex: o2, tokenLine: a2, tokenColumn: i2 } = e2;
  return J(e2, n2), ee(e2, n2, 77932), 134217728 & ~e2.getToken() || r(o2, a2, i2, e2.index, e2.line, e2.column, 30, N[255 & e2.getToken()]), ie(e2, n2, o2, a2, i2, { type: "ImportNamespaceSpecifier", local: Re(e2, n2, t2) });
}
function Ue(e2, n2, o2, r2) {
  for (J(e2, n2);143360 & e2.getToken() || e2.getToken() === 134283267; ) {
    let { tokenValue: a2, tokenIndex: i2, tokenLine: s2, tokenColumn: l2 } = e2;
    const c2 = e2.getToken(), u2 = nn(e2, n2);
    let d2;
    Q(e2, n2, 77932) ? (134217728 & ~e2.getToken() && e2.getToken() !== 18 ? te(e2, n2, 16, e2.getToken(), 0) : t(e2, 106), a2 = e2.tokenValue, d2 = cn(e2, n2)) : u2.type === "Identifier" ? (te(e2, n2, 16, c2, 0), d2 = u2) : t(e2, 25, N[108]), o2 && ge(e2, n2, o2, a2, 8, 0), r2.push(ie(e2, n2, i2, s2, l2, { type: "ImportSpecifier", local: d2, imported: u2 })), e2.getToken() !== 1074790415 && ee(e2, n2, 18);
  }
  return ee(e2, n2, 1074790415), r2;
}
function Pe(e2, n2, t2, o2, r2) {
  let a2 = Ze(e2, n2, ie(e2, n2, t2, o2, r2, { type: "Identifier", name: "import" }), t2, o2, r2);
  return a2 = _e(e2, n2, undefined, a2, 0, 0, t2, o2, r2), a2 = je(e2, n2, undefined, 0, 0, t2, o2, r2, a2), e2.getToken() === 18 && (a2 = Ge(e2, n2, undefined, 0, t2, o2, r2, a2)), ve(e2, n2, a2, t2, o2, r2);
}
function Be(e2, n2, t2, o2, r2, a2) {
  let i2 = We(e2, n2, t2, 0, o2, r2, a2);
  return i2 = _e(e2, n2, t2, i2, 0, 0, o2, r2, a2), e2.getToken() === 18 && (i2 = Ge(e2, n2, t2, 0, o2, r2, a2, i2)), ve(e2, n2, i2, o2, r2, a2);
}
function Oe(e2, n2, t2, o2, r2, a2, i2, s2) {
  let l2 = Ye(e2, n2, t2, 2, 0, o2, r2, 1, a2, i2, s2);
  return l2 = _e(e2, n2, t2, l2, r2, 0, a2, i2, s2), je(e2, n2, t2, r2, 0, a2, i2, s2, l2);
}
function Ge(e2, n2, t2, o2, r2, a2, i2, s2) {
  const l2 = [s2];
  for (;Q(e2, 8192 | n2, 18); )
    l2.push(Oe(e2, n2, t2, 1, o2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn));
  return ie(e2, n2, r2, a2, i2, { type: "SequenceExpression", expressions: l2 });
}
function Fe(e2, n2, t2, o2, r2, a2, i2, s2) {
  const l2 = Oe(e2, n2, t2, r2, o2, a2, i2, s2);
  return e2.getToken() === 18 ? Ge(e2, n2, t2, o2, a2, i2, s2, l2) : l2;
}
function je(e2, n2, o2, r2, a2, i2, s2, l2, c2) {
  const u2 = e2.getToken();
  if (!(4194304 & ~u2)) {
    2 & e2.assignable && t(e2, 26), (!a2 && u2 === 1077936155 && c2.type === "ArrayExpression" || c2.type === "ObjectExpression") && ne(e2, c2), J(e2, 8192 | n2);
    const d2 = Oe(e2, n2, o2, 1, r2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn);
    return e2.assignable = 2, ie(e2, n2, i2, s2, l2, a2 ? { type: "AssignmentPattern", left: c2, right: d2 } : { type: "AssignmentExpression", left: c2, operator: N[255 & u2], right: d2 });
  }
  return 8388608 & ~u2 || (c2 = Me(e2, n2, o2, r2, i2, s2, l2, 4, u2, c2)), Q(e2, 8192 | n2, 22) && (c2 = He(e2, n2, o2, c2, i2, s2, l2)), c2;
}
function Je(e2, n2, t2, o2, r2, a2, i2, s2, l2) {
  const c2 = e2.getToken();
  J(e2, 8192 | n2);
  const u2 = Oe(e2, n2, t2, 1, o2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn);
  return l2 = ie(e2, n2, a2, i2, s2, r2 ? { type: "AssignmentPattern", left: l2, right: u2 } : { type: "AssignmentExpression", left: l2, operator: N[255 & c2], right: u2 }), e2.assignable = 2, l2;
}
function He(e2, n2, t2, o2, r2, a2, i2) {
  const s2 = Oe(e2, 33554432 ^ (33554432 | n2), t2, 1, 0, e2.tokenIndex, e2.tokenLine, e2.tokenColumn);
  ee(e2, 8192 | n2, 21), e2.assignable = 1;
  const l2 = Oe(e2, n2, t2, 1, 0, e2.tokenIndex, e2.tokenLine, e2.tokenColumn);
  return e2.assignable = 2, ie(e2, n2, r2, a2, i2, { type: "ConditionalExpression", test: o2, consequent: s2, alternate: l2 });
}
function Me(e2, n2, o2, r2, a2, i2, s2, l2, c2, u2) {
  const d2 = 8673330 & -((33554432 & n2) > 0);
  let g2, k2;
  for (e2.assignable = 2;8388608 & e2.getToken() && (g2 = e2.getToken(), k2 = 3840 & g2, (524288 & g2 && 268435456 & c2 || 524288 & c2 && 268435456 & g2) && t(e2, 165), !(k2 + ((g2 === 8391735) << 8) - ((d2 === g2) << 12) <= l2)); )
    J(e2, 8192 | n2), u2 = ie(e2, n2, a2, i2, s2, { type: 524288 & g2 || 268435456 & g2 ? "LogicalExpression" : "BinaryExpression", left: u2, right: Me(e2, n2, o2, r2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn, k2, g2, Xe(e2, n2, o2, 0, r2, 1, e2.tokenIndex, e2.tokenLine, e2.tokenColumn)), operator: N[255 & g2] });
  return e2.getToken() === 1077936155 && t(e2, 26), u2;
}
function ze(e2, n2, a2, i2, s2, l2, c2) {
  const { tokenIndex: u2, tokenLine: d2, tokenColumn: g2 } = e2;
  ee(e2, 8192 | n2, 2162700);
  const k2 = [];
  if (e2.getToken() !== 1074790415) {
    for (;e2.getToken() === 134283267; ) {
      const { index: t2, tokenIndex: a3, tokenValue: i3 } = e2, s3 = e2.getToken(), l3 = un(e2, n2);
      W(e2, t2, a3, i3) && (n2 |= 256, 128 & e2.flags && r(a3, d2, g2, e2.index, e2.line, e2.column, 66), 64 & e2.flags && r(a3, d2, g2, e2.index, e2.line, e2.column, 9), 4096 & e2.flags && r(a3, d2, g2, e2.index, e2.line, e2.column, 15), c2 && o(c2)), k2.push(Ie(e2, n2, l3, s3, a3, e2.tokenLine, e2.tokenColumn));
    }
    256 & n2 && (l2 && (537079808 & ~l2 || t(e2, 119), 36864 & ~l2 || t(e2, 40)), 512 & e2.flags && t(e2, 119), 256 & e2.flags && t(e2, 118));
  }
  for (e2.flags = 4928 ^ (4928 | e2.flags), e2.destructible = 256 ^ (256 | e2.destructible);e2.getToken() !== 1074790415; )
    k2.push(Te(e2, n2, a2, i2, 4, {}));
  return ee(e2, 24 & s2 ? 8192 | n2 : n2, 1074790415), e2.flags &= -4289, e2.getToken() === 1077936155 && t(e2, 26), ie(e2, n2, u2, d2, g2, { type: "BlockStatement", body: k2 });
}
function Xe(e2, n2, t2, o2, r2, a2, i2, s2, l2) {
  return _e(e2, n2, t2, Ye(e2, n2, t2, 2, 0, o2, r2, a2, i2, s2, l2), r2, 0, i2, s2, l2);
}
function _e(e2, n2, o2, r2, a2, i2, s2, l2, c2) {
  if (33619968 & ~e2.getToken() || 1 & e2.flags) {
    if (!(67108864 & ~e2.getToken())) {
      switch (n2 = 33554432 ^ (33554432 | n2), e2.getToken()) {
        case 67108877:
          J(e2, 2048 ^ (67110912 | n2)), 4096 & n2 && e2.getToken() === 130 && e2.tokenValue === "super" && t(e2, 173), e2.assignable = 1;
          r2 = ie(e2, n2, s2, l2, c2, { type: "MemberExpression", object: r2, computed: false, property: $e(e2, 16384 | n2, o2) });
          break;
        case 69271571: {
          let t2 = false;
          2048 & ~e2.flags || (t2 = true, e2.flags = 2048 ^ (2048 | e2.flags)), J(e2, 8192 | n2);
          const { tokenIndex: i3, tokenLine: u2, tokenColumn: d2 } = e2, g2 = Fe(e2, n2, o2, a2, 1, i3, u2, d2);
          ee(e2, n2, 20), e2.assignable = 1, r2 = ie(e2, n2, s2, l2, c2, { type: "MemberExpression", object: r2, computed: true, property: g2 }), t2 && (e2.flags |= 2048);
          break;
        }
        case 67174411: {
          if (!(1024 & ~e2.flags))
            return e2.flags = 1024 ^ (1024 | e2.flags), r2;
          let t2 = false;
          2048 & ~e2.flags || (t2 = true, e2.flags = 2048 ^ (2048 | e2.flags));
          const i3 = ln(e2, n2, o2, a2);
          e2.assignable = 2, r2 = ie(e2, n2, s2, l2, c2, { type: "CallExpression", callee: r2, arguments: i3 }), t2 && (e2.flags |= 2048);
          break;
        }
        case 67108990:
          J(e2, 2048 ^ (67110912 | n2)), e2.flags |= 2048, e2.assignable = 2, r2 = function(e3, n3, t2, o3, r3, a3, i3) {
            let s3, l3 = false;
            e3.getToken() !== 69271571 && e3.getToken() !== 67174411 || 2048 & ~e3.flags || (l3 = true, e3.flags = 2048 ^ (2048 | e3.flags));
            if (e3.getToken() === 69271571) {
              J(e3, 8192 | n3);
              const { tokenIndex: l4, tokenLine: c3, tokenColumn: u2 } = e3, d2 = Fe(e3, n3, t2, 0, 1, l4, c3, u2);
              ee(e3, n3, 20), e3.assignable = 2, s3 = ie(e3, n3, r3, a3, i3, { type: "MemberExpression", object: o3, computed: true, optional: true, property: d2 });
            } else if (e3.getToken() === 67174411) {
              const l4 = ln(e3, n3, t2, 0);
              e3.assignable = 2, s3 = ie(e3, n3, r3, a3, i3, { type: "CallExpression", callee: o3, arguments: l4, optional: true });
            } else {
              const l4 = $e(e3, n3, t2);
              e3.assignable = 2, s3 = ie(e3, n3, r3, a3, i3, { type: "MemberExpression", object: o3, computed: false, optional: true, property: l4 });
            }
            l3 && (e3.flags |= 2048);
            return s3;
          }(e2, n2, o2, r2, s2, l2, c2);
          break;
        default:
          2048 & ~e2.flags || t(e2, 166), e2.assignable = 2, r2 = ie(e2, n2, s2, l2, c2, { type: "TaggedTemplateExpression", tag: r2, quasi: e2.getToken() === 67174408 ? rn(e2, 16384 | n2, o2) : on(e2, n2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn) });
      }
      r2 = _e(e2, n2, o2, r2, 0, 1, s2, l2, c2);
    }
  } else
    r2 = function(e3, n3, o3, r3, a3, i3) {
      2 & e3.assignable && t(e3, 55);
      const s3 = e3.getToken();
      return J(e3, n3), e3.assignable = 2, ie(e3, n3, r3, a3, i3, { type: "UpdateExpression", argument: o3, operator: N[255 & s3], prefix: false });
    }(e2, n2, r2, s2, l2, c2);
  return i2 !== 0 || 2048 & ~e2.flags || (e2.flags = 2048 ^ (2048 | e2.flags), r2 = ie(e2, n2, s2, l2, c2, { type: "ChainExpression", expression: r2 })), r2;
}
function $e(e2, n2, o2) {
  return 143360 & e2.getToken() || e2.getToken() === -2147483528 || e2.getToken() === -2147483527 || e2.getToken() === 130 || t(e2, 160), e2.getToken() === 130 ? Vn(e2, n2, o2, 0, e2.tokenIndex, e2.tokenLine, e2.tokenColumn) : cn(e2, n2);
}
function Ye(e2, n2, o2, a2, i2, s2, l2, c2, u2, d2, g2) {
  if (!(143360 & ~e2.getToken())) {
    switch (e2.getToken()) {
      case 209006:
        return function(e3, n3, o3, a3, i3, s3, l3, c3) {
          i3 && (e3.destructible |= 128), 268435456 & n3 && t(e3, 177);
          const u3 = xn(e3, n3, o3, s3, l3, c3);
          if (u3.type === "ArrowFunctionExpression" || !(65536 & e3.getToken()))
            return 524288 & n3 && r(s3, l3, c3, e3.startIndex, e3.startLine, e3.startColumn, 176), 512 & n3 && r(s3, l3, c3, e3.startIndex, e3.startLine, e3.startColumn, 110), 2097152 & n3 && 524288 & n3 && r(s3, l3, c3, e3.startIndex, e3.startLine, e3.startColumn, 110), u3;
          if (2097152 & n3 && r(s3, l3, c3, e3.startIndex, e3.startLine, e3.startColumn, 31), 524288 & n3 || 512 & n3 && 2048 & n3) {
            a3 && r(s3, l3, c3, e3.startIndex, e3.startLine, e3.startColumn, 0);
            const i4 = Xe(e3, n3, o3, 0, 0, 1, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
            return e3.getToken() === 8391735 && t(e3, 33), e3.assignable = 2, ie(e3, n3, s3, l3, c3, { type: "AwaitExpression", argument: i4 });
          }
          return 512 & n3 && r(s3, l3, c3, e3.startIndex, e3.startLine, e3.startColumn, 98), u3;
        }(e2, n2, o2, i2, l2, u2, d2, g2);
      case 241771:
        return function(e3, n3, o3, r2, a3, i3, s3, l3) {
          if (r2 && (e3.destructible |= 256), 262144 & n3) {
            J(e3, 8192 | n3), 2097152 & n3 && t(e3, 32), a3 || t(e3, 26), e3.getToken() === 22 && t(e3, 124);
            let r3 = null, c3 = false;
            return 1 & e3.flags ? e3.getToken() === 8391476 && t(e3, 30, N[255 & e3.getToken()]) : (c3 = Q(e3, 8192 | n3, 8391476), (77824 & e3.getToken() || c3) && (r3 = Oe(e3, n3, o3, 1, 0, e3.tokenIndex, e3.tokenLine, e3.tokenColumn))), e3.assignable = 2, ie(e3, n3, i3, s3, l3, { type: "YieldExpression", argument: r3, delegate: c3 });
          }
          return 256 & n3 && t(e3, 97, "yield"), xn(e3, n3, o3, i3, s3, l3);
        }(e2, n2, o2, l2, s2, u2, d2, g2);
      case 209005:
        return function(e3, n3, o3, r2, a3, i3, s3, l3, c3, u3) {
          const d3 = e3.getToken(), g3 = cn(e3, n3), { flags: k3 } = e3;
          if (!(1 & k3)) {
            if (e3.getToken() === 86104)
              return gn(e3, n3, o3, 1, r2, l3, c3, u3);
            if (me(n3, e3.getToken()))
              return a3 || t(e3, 0), 36864 & ~e3.getToken() || (e3.flags |= 256), Ln(e3, n3, o3, i3, l3, c3, u3);
          }
          return s3 || e3.getToken() !== 67174411 ? e3.getToken() === 10 ? (be(e3, n3, d3), s3 && t(e3, 51), 36864 & ~d3 || (e3.flags |= 256), Tn(e3, n3, o3, e3.tokenValue, g3, s3, i3, 0, l3, c3, u3)) : (e3.assignable = 1, g3) : In(e3, n3, o3, g3, i3, 1, 0, k3, l3, c3, u3);
        }(e2, n2, o2, l2, c2, s2, i2, u2, d2, g2);
    }
    const { tokenValue: k2 } = e2, p2 = e2.getToken(), f2 = cn(e2, 16384 | n2);
    return e2.getToken() === 10 ? (c2 || t(e2, 0), be(e2, n2, p2), 36864 & ~p2 || (e2.flags |= 256), Tn(e2, n2, o2, k2, f2, i2, s2, 0, u2, d2, g2)) : (!(4096 & n2) || 8388608 & n2 || 2097152 & n2 || e2.tokenValue !== "arguments" || t(e2, 130), (255 & p2) == 73 && (256 & n2 && t(e2, 113), 24 & a2 && t(e2, 100)), e2.assignable = 256 & n2 && !(537079808 & ~p2) ? 2 : 1, f2);
  }
  if (!(134217728 & ~e2.getToken()))
    return un(e2, n2);
  switch (e2.getToken()) {
    case 33619993:
    case 33619994:
      return function(e3, n3, o3, r2, a3, i3, s3, l3) {
        r2 && t(e3, 56), a3 || t(e3, 0);
        const c3 = e3.getToken();
        J(e3, 8192 | n3);
        const u3 = Xe(e3, n3, o3, 0, 0, 1, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
        return 2 & e3.assignable && t(e3, 55), e3.assignable = 2, ie(e3, n3, i3, s3, l3, { type: "UpdateExpression", argument: u3, operator: N[255 & c3], prefix: true });
      }(e2, n2, o2, i2, c2, u2, d2, g2);
    case 16863276:
    case 16842798:
    case 16842799:
    case 25233968:
    case 25233969:
    case 16863275:
    case 16863277:
      return function(e3, n3, o3, r2, a3, i3, s3, l3) {
        r2 || t(e3, 0);
        const c3 = e3.getToken();
        J(e3, 8192 | n3);
        const u3 = Xe(e3, n3, o3, 0, l3, 1, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
        var d3;
        return e3.getToken() === 8391735 && t(e3, 33), 256 & n3 && c3 === 16863276 && (u3.type === "Identifier" ? t(e3, 121) : (d3 = u3).property && d3.property.type === "PrivateIdentifier" && t(e3, 127)), e3.assignable = 2, ie(e3, n3, a3, i3, s3, { type: "UnaryExpression", operator: N[255 & c3], argument: u3, prefix: true });
      }(e2, n2, o2, c2, u2, d2, g2, l2);
    case 86104:
      return gn(e2, n2, o2, 0, l2, u2, d2, g2);
    case 2162700:
      return function(e3, n3, o3, r2, a3, i3, s3, l3) {
        const c3 = bn(e3, n3, undefined, o3, r2, a3, 0, 2, 0, i3, s3, l3);
        64 & e3.destructible && t(e3, 63);
        8 & e3.destructible && t(e3, 62);
        return c3;
      }(e2, n2, o2, s2 ? 0 : 1, l2, u2, d2, g2);
    case 69271571:
      return function(e3, n3, o3, r2, a3, i3, s3, l3) {
        const c3 = kn(e3, n3, undefined, o3, r2, a3, 0, 2, 0, i3, s3, l3);
        64 & e3.destructible && t(e3, 63);
        8 & e3.destructible && t(e3, 62);
        return c3;
      }(e2, n2, o2, s2 ? 0 : 1, l2, u2, d2, g2);
    case 67174411:
      return function(e3, n3, o3, r2, a3, i3, s3, l3, c3) {
        e3.flags = 128 ^ (128 | e3.flags);
        const { tokenIndex: u3, tokenLine: d3, tokenColumn: g3 } = e3;
        J(e3, 67117056 | n3);
        const k2 = 16 & n3 ? ue({ parent: undefined, type: 2 }, 1024) : undefined;
        if (n3 = 33554432 ^ (33554432 | n3), Q(e3, n3, 16))
          return yn(e3, n3, k2, o3, [], r2, 0, s3, l3, c3);
        let p2, f2 = 0;
        e3.destructible &= -385;
        let m2 = [], b2 = 0, h2 = 0, x2 = 0;
        const { tokenIndex: T2, tokenLine: y2, tokenColumn: C2 } = e3;
        e3.assignable = 1;
        for (;e3.getToken() !== 16; ) {
          const { tokenIndex: r3, tokenLine: s4, tokenColumn: l4 } = e3, c4 = e3.getToken();
          if (143360 & c4)
            k2 && ge(e3, n3, k2, e3.tokenValue, 1, 0), 537079808 & ~c4 ? 36864 & ~c4 || (x2 = 1) : h2 = 1, p2 = Ye(e3, n3, o3, a3, 0, 1, 1, 1, r3, s4, l4), e3.getToken() === 16 || e3.getToken() === 18 ? 2 & e3.assignable && (f2 |= 16, h2 = 1) : (e3.getToken() === 1077936155 ? h2 = 1 : f2 |= 16, p2 = _e(e3, n3, o3, p2, 1, 0, r3, s4, l4), e3.getToken() !== 16 && e3.getToken() !== 18 && (p2 = je(e3, n3, o3, 1, 0, r3, s4, l4, p2)));
          else {
            if (2097152 & ~c4) {
              if (c4 === 14) {
                p2 = fn(e3, n3, k2, o3, 16, a3, i3, 0, 1, 0, r3, s4, l4), 16 & e3.destructible && t(e3, 74), h2 = 1, !b2 || e3.getToken() !== 16 && e3.getToken() !== 18 || m2.push(p2), f2 |= 8;
                break;
              }
              if (f2 |= 16, p2 = Oe(e3, n3, o3, 1, 1, r3, s4, l4), !b2 || e3.getToken() !== 16 && e3.getToken() !== 18 || m2.push(p2), e3.getToken() === 18 && (b2 || (b2 = 1, m2 = [p2])), b2) {
                for (;Q(e3, 8192 | n3, 18); )
                  m2.push(Oe(e3, n3, o3, 1, 1, e3.tokenIndex, e3.tokenLine, e3.tokenColumn));
                e3.assignable = 2, p2 = ie(e3, n3, T2, y2, C2, { type: "SequenceExpression", expressions: m2 });
              }
              return ee(e3, n3, 16), e3.destructible = f2, p2;
            }
            p2 = c4 === 2162700 ? bn(e3, 67108864 | n3, k2, o3, 0, 1, 0, a3, i3, r3, s4, l4) : kn(e3, 67108864 | n3, k2, o3, 0, 1, 0, a3, i3, r3, s4, l4), f2 |= e3.destructible, h2 = 1, e3.assignable = 2, e3.getToken() !== 16 && e3.getToken() !== 18 && (8 & f2 && t(e3, 122), p2 = _e(e3, n3, o3, p2, 0, 0, r3, s4, l4), f2 |= 16, e3.getToken() !== 16 && e3.getToken() !== 18 && (p2 = je(e3, n3, o3, 0, 0, r3, s4, l4, p2)));
          }
          if (!b2 || e3.getToken() !== 16 && e3.getToken() !== 18 || m2.push(p2), !Q(e3, 8192 | n3, 18))
            break;
          if (b2 || (b2 = 1, m2 = [p2]), e3.getToken() === 16) {
            f2 |= 8;
            break;
          }
        }
        b2 && (e3.assignable = 2, p2 = ie(e3, n3, T2, y2, C2, { type: "SequenceExpression", expressions: m2 }));
        ee(e3, n3, 16), 16 & f2 && 8 & f2 && t(e3, 151);
        if (f2 |= 256 & e3.destructible ? 256 : 128 & e3.destructible ? 128 : 0, e3.getToken() === 10)
          return 48 & f2 && t(e3, 49), 524800 & n3 && 128 & f2 && t(e3, 31), 262400 & n3 && 256 & f2 && t(e3, 32), h2 && (e3.flags |= 128), x2 && (e3.flags |= 256), yn(e3, n3, k2, o3, b2 ? m2 : [p2], r2, 0, s3, l3, c3);
        64 & f2 && t(e3, 63);
        8 & f2 && t(e3, 144);
        return e3.destructible = 256 ^ (256 | e3.destructible) | f2, 32 & n3 ? ie(e3, n3, u3, d3, g3, { type: "ParenthesizedExpression", expression: p2 }) : p2;
      }(e2, 16384 | n2, o2, s2, 1, 0, u2, d2, g2);
    case 86021:
    case 86022:
    case 86023:
      return function(e3, n3, t2, o3, r2) {
        const a3 = N[255 & e3.getToken()], i3 = e3.getToken() === 86023 ? null : a3 === "true";
        return J(e3, n3), e3.assignable = 2, ie(e3, n3, t2, o3, r2, 128 & n3 ? { type: "Literal", value: i3, raw: a3 } : { type: "Literal", value: i3 });
      }(e2, n2, u2, d2, g2);
    case 86111:
      return function(e3, n3) {
        const { tokenIndex: t2, tokenLine: o3, tokenColumn: r2 } = e3;
        return J(e3, n3), e3.assignable = 2, ie(e3, n3, t2, o3, r2, { type: "ThisExpression" });
      }(e2, n2);
    case 65540:
      return function(e3, n3, t2, o3, r2) {
        const { tokenRaw: a3, tokenRegExp: i3, tokenValue: s3 } = e3;
        return J(e3, n3), e3.assignable = 2, ie(e3, n3, t2, o3, r2, 128 & n3 ? { type: "Literal", value: s3, regex: i3, raw: a3 } : { type: "Literal", value: s3, regex: i3 });
      }(e2, n2, u2, d2, g2);
    case 132:
    case 86094:
      return function(e3, n3, o3, r2, a3, i3, s3) {
        let l3 = null, c3 = null;
        const u3 = En(e3, n3, o3);
        u3.length && (a3 = e3.tokenIndex, i3 = e3.tokenLine, s3 = e3.tokenColumn);
        n3 = 4194304 ^ (4194560 | n3), J(e3, n3), 4096 & e3.getToken() && e3.getToken() !== 20565 && (re(e3, n3, e3.getToken()) && t(e3, 118), 537079808 & ~e3.getToken() || t(e3, 119), l3 = cn(e3, n3));
        let d3 = n3;
        Q(e3, 8192 | n3, 20565) ? (c3 = Xe(e3, n3, o3, 0, r2, 0, e3.tokenIndex, e3.tokenLine, e3.tokenColumn), d3 |= 131072) : d3 = 131072 ^ (131072 | d3);
        const g3 = An(e3, d3, n3, undefined, o3, 2, 0, r2);
        return e3.assignable = 2, ie(e3, n3, a3, i3, s3, { type: "ClassExpression", id: l3, superClass: c3, body: g3, ...1 & n3 ? { decorators: u3 } : null });
      }(e2, n2, o2, l2, u2, d2, g2);
    case 86109:
      return function(e3, n3, o3, r2, a3) {
        switch (J(e3, n3), e3.getToken()) {
          case 67108990:
            t(e3, 167);
          case 67174411:
            131072 & n3 || t(e3, 28), e3.assignable = 2;
            break;
          case 69271571:
          case 67108877:
            65536 & n3 || t(e3, 29), e3.assignable = 1;
            break;
          default:
            t(e3, 30, "super");
        }
        return ie(e3, n3, o3, r2, a3, { type: "Super" });
      }(e2, n2, u2, d2, g2);
    case 67174409:
      return on(e2, n2, u2, d2, g2);
    case 67174408:
      return rn(e2, n2, o2);
    case 86107:
      return function(e3, n3, o3, r2, a3, i3, s3) {
        const l3 = cn(e3, 8192 | n3), { tokenIndex: c3, tokenLine: u3, tokenColumn: d3 } = e3;
        if (Q(e3, n3, 67108877)) {
          if (16777216 & n3 && e3.getToken() === 209029)
            return e3.assignable = 2, function(e4, n4, t2, o4, r3, a4) {
              const i4 = cn(e4, n4);
              return ie(e4, n4, o4, r3, a4, { type: "MetaProperty", meta: t2, property: i4 });
            }(e3, n3, l3, a3, i3, s3);
          t(e3, 94);
        }
        e3.assignable = 2, 16842752 & ~e3.getToken() || t(e3, 65, N[255 & e3.getToken()]);
        const g3 = Ye(e3, n3, o3, 2, 1, 0, r2, 1, c3, u3, d3);
        n3 = 33554432 ^ (33554432 | n3), e3.getToken() === 67108990 && t(e3, 168);
        const k2 = wn(e3, n3, o3, g3, r2, c3, u3, d3);
        return e3.assignable = 2, ie(e3, n3, a3, i3, s3, { type: "NewExpression", callee: k2, arguments: e3.getToken() === 67174411 ? ln(e3, n3, o3, r2) : [] });
      }(e2, n2, o2, l2, u2, d2, g2);
    case 134283388:
      return tn(e2, n2, u2, d2, g2);
    case 130:
      return Vn(e2, n2, o2, 0, u2, d2, g2);
    case 86106:
      return function(e3, n3, o3, r2, a3, i3, s3, l3) {
        let c3 = cn(e3, n3);
        if (e3.getToken() === 67108877)
          return Ze(e3, n3, c3, i3, s3, l3);
        r2 && t(e3, 142);
        return c3 = We(e3, n3, o3, a3, i3, s3, l3), e3.assignable = 2, _e(e3, n3, o3, c3, a3, 0, i3, s3, l3);
      }(e2, n2, o2, i2, l2, u2, d2, g2);
    case 8456256:
      if (8 & n2)
        return Pn(e2, n2, o2, 0, u2, d2, g2);
    default:
      if (me(n2, e2.getToken()))
        return xn(e2, n2, o2, u2, d2, g2);
      t(e2, 30, N[255 & e2.getToken()]);
  }
}
function Ze(e2, n2, o2, r2, a2, i2) {
  512 & n2 || t(e2, 169), J(e2, n2);
  const s2 = e2.getToken();
  return s2 !== 209030 && e2.tokenValue !== "meta" ? t(e2, 174) : -2147483648 & s2 && t(e2, 175), e2.assignable = 2, ie(e2, n2, r2, a2, i2, { type: "MetaProperty", meta: o2, property: cn(e2, n2) });
}
function We(e2, n2, o2, r2, a2, i2, s2) {
  ee(e2, 8192 | n2, 67174411), e2.getToken() === 14 && t(e2, 143);
  const l2 = { type: "ImportExpression", source: Oe(e2, n2, o2, 1, r2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn) };
  if (1 & n2) {
    let t2 = null;
    if (e2.getToken() === 18 && (ee(e2, n2, 18), e2.getToken() !== 16)) {
      t2 = Oe(e2, 33554432 ^ (33554432 | n2), o2, 1, r2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn);
    }
    l2.options = t2, Q(e2, n2, 18);
  }
  return ee(e2, n2, 16), ie(e2, n2, a2, i2, s2, l2);
}
function Ke(e2, n2, o2 = null) {
  if (!Q(e2, n2, 20579))
    return [];
  ee(e2, n2, 2162700);
  const r2 = [], a2 = new Set;
  for (;e2.getToken() !== 1074790415; ) {
    const { tokenIndex: i2, tokenLine: s2, tokenColumn: l2 } = e2, c2 = en(e2, n2);
    ee(e2, n2, 21);
    const u2 = Qe(e2, n2), d2 = c2.type === "Literal" ? c2.value : c2.name;
    if (d2 === "type" && u2.value === "json") {
      o2 === null || o2.length === 1 && (o2[0].type === "ImportDefaultSpecifier" || o2[0].type === "ImportNamespaceSpecifier" || o2[0].type === "ImportSpecifier" && o2[0].imported.type === "Identifier" && o2[0].imported.name === "default" || o2[0].type === "ExportSpecifier" && o2[0].local.type === "Identifier" && o2[0].local.name === "default") || t(e2, 140);
    }
    a2.has(d2) && t(e2, 145, `${d2}`), a2.add(d2), r2.push(ie(e2, n2, i2, s2, l2, { type: "ImportAttribute", key: c2, value: u2 })), e2.getToken() !== 1074790415 && ee(e2, n2, 18);
  }
  return ee(e2, n2, 1074790415), r2;
}
function Qe(e2, n2) {
  if (e2.getToken() === 134283267)
    return un(e2, n2);
  t(e2, 30, N[255 & e2.getToken()]);
}
function en(e2, n2) {
  return e2.getToken() === 134283267 ? un(e2, n2) : 143360 & e2.getToken() ? cn(e2, n2) : void t(e2, 30, N[255 & e2.getToken()]);
}
function nn(e2, n2) {
  return e2.getToken() === 134283267 ? (function(e3, n3) {
    const o2 = n3.length;
    for (let r2 = 0;r2 < o2; r2++) {
      const a2 = n3.charCodeAt(r2);
      (64512 & a2) == 55296 && (a2 > 56319 || ++r2 >= o2 || (64512 & n3.charCodeAt(r2)) != 56320) && t(e3, 171, JSON.stringify(n3.charAt(r2--)));
    }
  }(e2, e2.tokenValue), un(e2, n2)) : 143360 & e2.getToken() ? cn(e2, n2) : void t(e2, 30, N[255 & e2.getToken()]);
}
function tn(e2, n2, t2, o2, r2) {
  const { tokenRaw: a2, tokenValue: i2 } = e2;
  return J(e2, n2), e2.assignable = 2, ie(e2, n2, t2, o2, r2, 128 & n2 ? { type: "Literal", value: i2, bigint: a2.slice(0, -1), raw: a2 } : { type: "Literal", value: i2, bigint: a2.slice(0, -1) });
}
function on(e2, n2, t2, o2, r2) {
  e2.assignable = 2;
  const { tokenValue: a2, tokenRaw: i2, tokenIndex: s2, tokenLine: l2, tokenColumn: c2 } = e2;
  ee(e2, n2, 67174409);
  return ie(e2, n2, t2, o2, r2, { type: "TemplateLiteral", expressions: [], quasis: [an(e2, n2, a2, i2, s2, l2, c2, true)] });
}
function rn(e2, n2, o2) {
  n2 = 33554432 ^ (33554432 | n2);
  const { tokenValue: r2, tokenRaw: a2, tokenIndex: i2, tokenLine: s2, tokenColumn: l2 } = e2;
  ee(e2, -16385 & n2 | 8192, 67174408);
  const c2 = [an(e2, n2, r2, a2, i2, s2, l2, false)], u2 = [Fe(e2, -16385 & n2, o2, 0, 1, e2.tokenIndex, e2.tokenLine, e2.tokenColumn)];
  for (e2.getToken() !== 1074790415 && t(e2, 83);e2.setToken(D(e2, n2), true) !== 67174409; ) {
    const { tokenValue: r3, tokenRaw: a3, tokenIndex: i3, tokenLine: s3, tokenColumn: l3 } = e2;
    ee(e2, -16385 & n2 | 8192, 67174408), c2.push(an(e2, n2, r3, a3, i3, s3, l3, false)), u2.push(Fe(e2, n2, o2, 0, 1, e2.tokenIndex, e2.tokenLine, e2.tokenColumn)), e2.getToken() !== 1074790415 && t(e2, 83);
  }
  {
    const { tokenValue: t2, tokenRaw: o3, tokenIndex: r3, tokenLine: a3, tokenColumn: i3 } = e2;
    ee(e2, n2, 67174409), c2.push(an(e2, n2, t2, o3, r3, a3, i3, true));
  }
  return ie(e2, n2, i2, s2, l2, { type: "TemplateLiteral", expressions: u2, quasis: c2 });
}
function an(e2, n2, t2, o2, r2, a2, i2, s2) {
  const l2 = ie(e2, n2, r2, a2, i2, { type: "TemplateElement", value: { cooked: t2, raw: o2 }, tail: s2 }), c2 = s2 ? 1 : 2;
  return 2 & n2 && (l2.start += 1, l2.range[0] += 1, l2.end -= c2, l2.range[1] -= c2), 4 & n2 && (l2.loc.start.column += 1, l2.loc.end.column -= c2), l2;
}
function sn(e2, n2, t2, o2, r2, a2) {
  ee(e2, 8192 | (n2 = 33554432 ^ (33554432 | n2)), 14);
  const i2 = Oe(e2, n2, t2, 1, 0, e2.tokenIndex, e2.tokenLine, e2.tokenColumn);
  return e2.assignable = 1, ie(e2, n2, o2, r2, a2, { type: "SpreadElement", argument: i2 });
}
function ln(e2, n2, t2, o2) {
  J(e2, 8192 | n2);
  const r2 = [];
  if (e2.getToken() === 16)
    return J(e2, 16384 | n2), r2;
  for (;e2.getToken() !== 16 && (e2.getToken() === 14 ? r2.push(sn(e2, n2, t2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn)) : r2.push(Oe(e2, n2, t2, 1, o2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn)), e2.getToken() === 18) && (J(e2, 8192 | n2), e2.getToken() !== 16); )
    ;
  return ee(e2, 16384 | n2, 16), r2;
}
function cn(e2, n2) {
  const { tokenValue: t2, tokenIndex: o2, tokenLine: r2, tokenColumn: a2 } = e2, i2 = t2 === "await" && !(-2147483648 & e2.getToken());
  return J(e2, n2 | (i2 ? 8192 : 0)), ie(e2, n2, o2, r2, a2, { type: "Identifier", name: t2 });
}
function un(e2, n2) {
  const { tokenValue: t2, tokenRaw: o2, tokenIndex: r2, tokenLine: a2, tokenColumn: i2 } = e2;
  return e2.getToken() === 134283388 ? tn(e2, n2, r2, a2, i2) : (J(e2, n2), e2.assignable = 2, ie(e2, n2, r2, a2, i2, 128 & n2 ? { type: "Literal", value: t2, raw: o2 } : { type: "Literal", value: t2 }));
}
function dn(e2, n2, o2, r2, a2, i2, s2, l2, c2, u2, d2) {
  J(e2, 8192 | n2);
  const g2 = i2 ? K(e2, n2, 8391476) : 0;
  let k2, p2 = null, f2 = o2 ? { parent: undefined, type: 2 } : undefined;
  if (e2.getToken() === 67174411)
    1 & s2 || t(e2, 39, "Function");
  else {
    const r3 = !(4 & a2) || 2048 & n2 && 512 & n2 ? 64 | (l2 ? 1024 : 0) | (g2 ? 1024 : 0) : 4;
    oe(e2, n2, e2.getToken()), o2 && (4 & r3 ? ke(e2, n2, o2, e2.tokenValue, r3) : ge(e2, n2, o2, e2.tokenValue, r3, a2), f2 = ue(f2, 256), s2 && 2 & s2 && fe(e2, e2.tokenValue)), k2 = e2.getToken(), 143360 & e2.getToken() ? p2 = cn(e2, n2) : t(e2, 30, N[255 & e2.getToken()]);
  }
  const m2 = 7274496;
  n2 = (n2 | m2) ^ m2 | 16777216 | (l2 ? 524288 : 0) | (g2 ? 262144 : 0) | (g2 ? 0 : 67108864), o2 && (f2 = ue(f2, 512));
  const b2 = 268471296;
  return ie(e2, n2, c2, u2, d2, { type: "FunctionDeclaration", id: p2, params: vn(e2, -268435457 & n2 | 2097152, f2, r2, 0, 1), body: ze(e2, 9437184 | (n2 | b2) ^ b2, o2 ? ue(f2, 128) : f2, r2, 8, k2, f2?.scopeError), async: l2 === 1, generator: g2 === 1 });
}
function gn(e2, n2, t2, o2, r2, a2, i2, s2) {
  J(e2, 8192 | n2);
  const l2 = K(e2, n2, 8391476), c2 = (o2 ? 524288 : 0) | (l2 ? 262144 : 0);
  let u2, d2 = null, g2 = 16 & n2 ? { parent: undefined, type: 2 } : undefined;
  const k2 = 275709952;
  143360 & e2.getToken() && (oe(e2, (n2 | k2) ^ k2 | c2, e2.getToken()), g2 && (g2 = ue(g2, 256)), u2 = e2.getToken(), d2 = cn(e2, n2)), n2 = (n2 | k2) ^ k2 | 16777216 | c2 | (l2 ? 0 : 67108864), g2 && (g2 = ue(g2, 512));
  const p2 = vn(e2, -268435457 & n2 | 2097152, g2, t2, r2, 1), f2 = ze(e2, 9437184 | -33594369 & n2, g2 ? ue(g2, 128) : g2, t2, 0, u2, g2?.scopeError);
  return e2.assignable = 2, ie(e2, n2, a2, i2, s2, { type: "FunctionExpression", id: d2, params: p2, body: f2, async: o2 === 1, generator: l2 === 1 });
}
function kn(e2, n2, o2, r2, a2, i2, s2, l2, c2, u2, d2, g2) {
  J(e2, 8192 | n2);
  const k2 = [];
  let p2 = 0;
  for (n2 = 33554432 ^ (33554432 | n2);e2.getToken() !== 20; )
    if (Q(e2, 8192 | n2, 18))
      k2.push(null);
    else {
      let a3;
      const { tokenIndex: u3, tokenLine: d3, tokenColumn: g3, tokenValue: f3 } = e2, m2 = e2.getToken();
      if (143360 & m2)
        if (a3 = Ye(e2, n2, r2, l2, 0, 1, i2, 1, u3, d3, g3), e2.getToken() === 1077936155) {
          2 & e2.assignable && t(e2, 26), J(e2, 8192 | n2), o2 && de(e2, n2, o2, f3, l2, c2);
          const k3 = Oe(e2, n2, r2, 1, i2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn);
          a3 = ie(e2, n2, u3, d3, g3, s2 ? { type: "AssignmentPattern", left: a3, right: k3 } : { type: "AssignmentExpression", operator: "=", left: a3, right: k3 }), p2 |= 256 & e2.destructible ? 256 : 128 & e2.destructible ? 128 : 0;
        } else
          e2.getToken() === 18 || e2.getToken() === 20 ? (2 & e2.assignable ? p2 |= 16 : o2 && de(e2, n2, o2, f3, l2, c2), p2 |= 256 & e2.destructible ? 256 : 128 & e2.destructible ? 128 : 0) : (p2 |= 1 & l2 ? 32 : 2 & l2 ? 0 : 16, a3 = _e(e2, n2, r2, a3, i2, 0, u3, d3, g3), e2.getToken() !== 18 && e2.getToken() !== 20 ? (e2.getToken() !== 1077936155 && (p2 |= 16), a3 = je(e2, n2, r2, i2, s2, u3, d3, g3, a3)) : e2.getToken() !== 1077936155 && (p2 |= 2 & e2.assignable ? 16 : 32));
      else
        2097152 & m2 ? (a3 = e2.getToken() === 2162700 ? bn(e2, n2, o2, r2, 0, i2, s2, l2, c2, u3, d3, g3) : kn(e2, n2, o2, r2, 0, i2, s2, l2, c2, u3, d3, g3), p2 |= e2.destructible, e2.assignable = 16 & e2.destructible ? 2 : 1, e2.getToken() === 18 || e2.getToken() === 20 ? 2 & e2.assignable && (p2 |= 16) : 8 & e2.destructible ? t(e2, 71) : (a3 = _e(e2, n2, r2, a3, i2, 0, u3, d3, g3), p2 = 2 & e2.assignable ? 16 : 0, e2.getToken() !== 18 && e2.getToken() !== 20 ? a3 = je(e2, n2, r2, i2, s2, u3, d3, g3, a3) : e2.getToken() !== 1077936155 && (p2 |= 2 & e2.assignable ? 16 : 32))) : m2 === 14 ? (a3 = fn(e2, n2, o2, r2, 20, l2, c2, 0, i2, s2, u3, d3, g3), p2 |= e2.destructible, e2.getToken() !== 18 && e2.getToken() !== 20 && t(e2, 30, N[255 & e2.getToken()])) : (a3 = Xe(e2, n2, r2, 1, 0, 1, u3, d3, g3), e2.getToken() !== 18 && e2.getToken() !== 20 ? (a3 = je(e2, n2, r2, i2, s2, u3, d3, g3, a3), 3 & l2 || m2 !== 67174411 || (p2 |= 16)) : 2 & e2.assignable ? p2 |= 16 : m2 === 67174411 && (p2 |= 1 & e2.assignable && 3 & l2 ? 32 : 16));
      if (k2.push(a3), !Q(e2, 8192 | n2, 18))
        break;
      if (e2.getToken() === 20)
        break;
    }
  ee(e2, n2, 20);
  const f2 = ie(e2, n2, u2, d2, g2, { type: s2 ? "ArrayPattern" : "ArrayExpression", elements: k2 });
  return !a2 && 4194304 & e2.getToken() ? pn(e2, n2, r2, p2, i2, s2, u2, d2, g2, f2) : (e2.destructible = p2, f2);
}
function pn(e2, n2, o2, r2, a2, i2, s2, l2, c2, u2) {
  e2.getToken() !== 1077936155 && t(e2, 26), J(e2, 8192 | n2), 16 & r2 && t(e2, 26), i2 || ne(e2, u2);
  const { tokenIndex: d2, tokenLine: g2, tokenColumn: k2 } = e2, p2 = Oe(e2, n2, o2, 1, a2, d2, g2, k2);
  return e2.destructible = 72 ^ (72 | r2) | (128 & e2.destructible ? 128 : 0) | (256 & e2.destructible ? 256 : 0), ie(e2, n2, s2, l2, c2, i2 ? { type: "AssignmentPattern", left: u2, right: p2 } : { type: "AssignmentExpression", left: u2, operator: "=", right: p2 });
}
function fn(e2, n2, o2, r2, a2, i2, s2, l2, c2, u2, d2, g2, k2) {
  J(e2, 8192 | n2);
  let p2 = null, f2 = 0;
  const { tokenValue: m2, tokenIndex: b2, tokenLine: h2, tokenColumn: x2 } = e2;
  let T2 = e2.getToken();
  if (143360 & T2)
    e2.assignable = 1, p2 = Ye(e2, n2, r2, i2, 0, 1, c2, 1, b2, h2, x2), T2 = e2.getToken(), p2 = _e(e2, n2, r2, p2, c2, 0, b2, h2, x2), e2.getToken() !== 18 && e2.getToken() !== a2 && (2 & e2.assignable && e2.getToken() === 1077936155 && t(e2, 71), f2 |= 16, p2 = je(e2, n2, r2, c2, u2, b2, h2, x2, p2)), 2 & e2.assignable ? f2 |= 16 : T2 === a2 || T2 === 18 ? o2 && de(e2, n2, o2, m2, i2, s2) : f2 |= 32, f2 |= 128 & e2.destructible ? 128 : 0;
  else if (T2 === a2)
    t(e2, 41);
  else {
    if (!(2097152 & T2)) {
      f2 |= 32, p2 = Xe(e2, n2, r2, 1, c2, 1, e2.tokenIndex, e2.tokenLine, e2.tokenColumn);
      const { tokenIndex: o3, tokenLine: i3, tokenColumn: s3 } = e2, l3 = e2.getToken();
      return l3 === 1077936155 ? (2 & e2.assignable && t(e2, 26), p2 = je(e2, n2, r2, c2, u2, o3, i3, s3, p2), f2 |= 16) : (l3 === 18 ? f2 |= 16 : l3 !== a2 && (p2 = je(e2, n2, r2, c2, u2, o3, i3, s3, p2)), f2 |= 1 & e2.assignable ? 32 : 16), e2.destructible = f2, e2.getToken() !== a2 && e2.getToken() !== 18 && t(e2, 161), ie(e2, n2, d2, g2, k2, { type: u2 ? "RestElement" : "SpreadElement", argument: p2 });
    }
    p2 = e2.getToken() === 2162700 ? bn(e2, n2, o2, r2, 1, c2, u2, i2, s2, b2, h2, x2) : kn(e2, n2, o2, r2, 1, c2, u2, i2, s2, b2, h2, x2), T2 = e2.getToken(), T2 !== 1077936155 && T2 !== a2 && T2 !== 18 ? (8 & e2.destructible && t(e2, 71), p2 = _e(e2, n2, r2, p2, c2, 0, b2, h2, x2), f2 |= 2 & e2.assignable ? 16 : 0, 4194304 & ~e2.getToken() ? (8388608 & ~e2.getToken() || (p2 = Me(e2, n2, r2, 1, b2, h2, x2, 4, T2, p2)), Q(e2, 8192 | n2, 22) && (p2 = He(e2, n2, r2, p2, b2, h2, x2)), f2 |= 2 & e2.assignable ? 16 : 32) : (e2.getToken() !== 1077936155 && (f2 |= 16), p2 = je(e2, n2, r2, c2, u2, b2, h2, x2, p2))) : f2 |= a2 === 1074790415 && T2 !== 1077936155 ? 16 : e2.destructible;
  }
  if (e2.getToken() !== a2)
    if (1 & i2 && (f2 |= l2 ? 16 : 32), Q(e2, 8192 | n2, 1077936155)) {
      16 & f2 && t(e2, 26), ne(e2, p2);
      const o3 = Oe(e2, n2, r2, 1, c2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn);
      p2 = ie(e2, n2, b2, h2, x2, u2 ? { type: "AssignmentPattern", left: p2, right: o3 } : { type: "AssignmentExpression", left: p2, operator: "=", right: o3 }), f2 = 16;
    } else
      f2 |= 16;
  return e2.destructible = f2, ie(e2, n2, d2, g2, k2, { type: u2 ? "RestElement" : "SpreadElement", argument: p2 });
}
function mn(e2, n2, r2, a2, i2, s2, l2, c2) {
  const u2 = 2883584 | (64 & a2 ? 0 : 4325376);
  let d2 = 16 & (n2 = 25231360 | ((n2 | u2) ^ u2 | (8 & a2 ? 262144 : 0) | (16 & a2 ? 524288 : 0) | (64 & a2 ? 4194304 : 0))) ? ue({ parent: undefined, type: 2 }, 512) : undefined;
  const g2 = function(e3, n3, r3, a3, i3, s3, l3) {
    ee(e3, n3, 67174411);
    const c3 = [];
    if (e3.flags = 128 ^ (128 | e3.flags), e3.getToken() === 16)
      return 512 & i3 && t(e3, 37, "Setter", "one", ""), J(e3, n3), c3;
    256 & i3 && t(e3, 37, "Getter", "no", "s");
    512 & i3 && e3.getToken() === 14 && t(e3, 38);
    n3 = 33554432 ^ (33554432 | n3);
    let u3 = 0, d3 = 0;
    for (;e3.getToken() !== 18; ) {
      let o2 = null;
      const { tokenIndex: g3, tokenLine: k2, tokenColumn: p2 } = e3;
      if (143360 & e3.getToken() ? (256 & n3 || (36864 & ~e3.getToken() || (e3.flags |= 256), 537079808 & ~e3.getToken() || (e3.flags |= 512)), o2 = Un(e3, n3, r3, 1 | i3, 0, g3, k2, p2)) : (e3.getToken() === 2162700 ? o2 = bn(e3, n3, r3, a3, 1, l3, 1, s3, 0, g3, k2, p2) : e3.getToken() === 69271571 ? o2 = kn(e3, n3, r3, a3, 1, l3, 1, s3, 0, g3, k2, p2) : e3.getToken() === 14 && (o2 = fn(e3, n3, r3, a3, 16, s3, 0, 0, l3, 1, g3, k2, p2)), d3 = 1, 48 & e3.destructible && t(e3, 50)), e3.getToken() === 1077936155) {
        J(e3, 8192 | n3), d3 = 1;
        o2 = ie(e3, n3, g3, k2, p2, { type: "AssignmentPattern", left: o2, right: Oe(e3, n3, a3, 1, 0, e3.tokenIndex, e3.tokenLine, e3.tokenColumn) });
      }
      if (u3++, c3.push(o2), !Q(e3, n3, 18))
        break;
      if (e3.getToken() === 16)
        break;
    }
    512 & i3 && u3 !== 1 && t(e3, 37, "Setter", "one", "");
    r3 && r3.scopeError && o(r3.scopeError);
    d3 && (e3.flags |= 128);
    return ee(e3, n3, 16), c3;
  }(e2, -268435457 & n2 | 2097152, d2, r2, a2, 1, i2);
  d2 && (d2 = ue(d2, 128));
  return ie(e2, n2, s2, l2, c2, { type: "FunctionExpression", params: g2, body: ze(e2, 9437184 | -301992961 & n2, d2, r2, 0, undefined, d2?.parent?.scopeError), async: (16 & a2) > 0, generator: (8 & a2) > 0, id: null });
}
function bn(e2, n2, o2, a2, i2, s2, l2, c2, u2, d2, g2, k2) {
  J(e2, n2);
  const p2 = [];
  let f2 = 0, m2 = 0;
  for (n2 = 33554432 ^ (33554432 | n2);e2.getToken() !== 1074790415; ) {
    const { tokenValue: i3, tokenLine: d3, tokenColumn: g3, tokenIndex: k3 } = e2, b3 = e2.getToken();
    if (b3 === 14)
      p2.push(fn(e2, n2, o2, a2, 1074790415, c2, u2, 0, s2, l2, k3, d3, g3));
    else {
      let h2, x2 = 0, T2 = null;
      if (143360 & e2.getToken() || e2.getToken() === -2147483528 || e2.getToken() === -2147483527)
        if (e2.getToken() === -2147483527 && (f2 |= 16), T2 = cn(e2, n2), e2.getToken() === 18 || e2.getToken() === 1074790415 || e2.getToken() === 1077936155)
          if (x2 |= 4, 256 & n2 && !(537079808 & ~b3) ? f2 |= 16 : te(e2, n2, c2, b3, 0), o2 && de(e2, n2, o2, i3, c2, u2), Q(e2, 8192 | n2, 1077936155)) {
            f2 |= 8;
            const t2 = Oe(e2, n2, a2, 1, s2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn);
            f2 |= 256 & e2.destructible ? 256 : 128 & e2.destructible ? 128 : 0, h2 = ie(e2, n2, k3, d3, g3, { type: "AssignmentPattern", left: 134217728 & n2 ? Object.assign({}, T2) : T2, right: t2 });
          } else
            f2 |= (b3 === 209006 ? 128 : 0) | (b3 === -2147483528 ? 16 : 0), h2 = 134217728 & n2 ? Object.assign({}, T2) : T2;
        else if (Q(e2, 8192 | n2, 21)) {
          const { tokenIndex: r2, tokenLine: d4, tokenColumn: g4 } = e2;
          if (i3 === "__proto__" && m2++, 143360 & e2.getToken()) {
            const t2 = e2.getToken(), i4 = e2.tokenValue;
            h2 = Ye(e2, n2, a2, c2, 0, 1, s2, 1, r2, d4, g4);
            const k4 = e2.getToken();
            h2 = _e(e2, n2, a2, h2, s2, 0, r2, d4, g4), e2.getToken() === 18 || e2.getToken() === 1074790415 ? k4 === 1077936155 || k4 === 1074790415 || k4 === 18 ? (f2 |= 128 & e2.destructible ? 128 : 0, 2 & e2.assignable ? f2 |= 16 : !o2 || 143360 & ~t2 || de(e2, n2, o2, i4, c2, u2)) : f2 |= 1 & e2.assignable ? 32 : 16 : 4194304 & ~e2.getToken() ? (f2 |= 16, 8388608 & ~e2.getToken() || (h2 = Me(e2, n2, a2, 1, r2, d4, g4, 4, k4, h2)), Q(e2, 8192 | n2, 22) && (h2 = He(e2, n2, a2, h2, r2, d4, g4))) : (2 & e2.assignable ? f2 |= 16 : k4 !== 1077936155 ? f2 |= 32 : o2 && de(e2, n2, o2, i4, c2, u2), h2 = je(e2, n2, a2, s2, l2, r2, d4, g4, h2));
          } else
            2097152 & ~e2.getToken() ? (h2 = Xe(e2, n2, a2, 1, s2, 1, r2, d4, g4), f2 |= 1 & e2.assignable ? 32 : 16, e2.getToken() === 18 || e2.getToken() === 1074790415 ? 2 & e2.assignable && (f2 |= 16) : (h2 = _e(e2, n2, a2, h2, s2, 0, r2, d4, g4), f2 = 2 & e2.assignable ? 16 : 0, e2.getToken() !== 18 && b3 !== 1074790415 && (e2.getToken() !== 1077936155 && (f2 |= 16), h2 = je(e2, n2, a2, s2, l2, r2, d4, g4, h2)))) : (h2 = e2.getToken() === 69271571 ? kn(e2, n2, o2, a2, 0, s2, l2, c2, u2, r2, d4, g4) : bn(e2, n2, o2, a2, 0, s2, l2, c2, u2, r2, d4, g4), f2 = e2.destructible, e2.assignable = 16 & f2 ? 2 : 1, e2.getToken() === 18 || e2.getToken() === 1074790415 ? 2 & e2.assignable && (f2 |= 16) : 8 & e2.destructible ? t(e2, 71) : (h2 = _e(e2, n2, a2, h2, s2, 0, r2, d4, g4), f2 = 2 & e2.assignable ? 16 : 0, 4194304 & ~e2.getToken() ? (8388608 & ~e2.getToken() || (h2 = Me(e2, n2, a2, 1, r2, d4, g4, 4, b3, h2)), Q(e2, 8192 | n2, 22) && (h2 = He(e2, n2, a2, h2, r2, d4, g4)), f2 |= 2 & e2.assignable ? 16 : 32) : h2 = Je(e2, n2, a2, s2, l2, r2, d4, g4, h2)));
        } else
          e2.getToken() === 69271571 ? (f2 |= 16, b3 === 209005 && (x2 |= 16), x2 |= 2 | (b3 === 12400 ? 256 : b3 === 12401 ? 512 : 1), T2 = hn(e2, n2, a2, s2), f2 |= e2.assignable, h2 = mn(e2, n2, a2, x2, s2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn)) : 143360 & e2.getToken() ? (f2 |= 16, b3 === -2147483528 && t(e2, 95), b3 === 209005 ? (1 & e2.flags && t(e2, 132), x2 |= 17) : b3 === 12400 ? x2 |= 256 : b3 === 12401 ? x2 |= 512 : t(e2, 0), T2 = cn(e2, n2), h2 = mn(e2, n2, a2, x2, s2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn)) : e2.getToken() === 67174411 ? (f2 |= 16, x2 |= 1, h2 = mn(e2, n2, a2, x2, s2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn)) : e2.getToken() === 8391476 ? (f2 |= 16, b3 === 12400 ? t(e2, 42) : b3 === 12401 ? t(e2, 43) : b3 !== 209005 && t(e2, 30, N[52]), J(e2, n2), x2 |= 9 | (b3 === 209005 ? 16 : 0), 143360 & e2.getToken() ? T2 = cn(e2, n2) : 134217728 & ~e2.getToken() ? e2.getToken() === 69271571 ? (x2 |= 2, T2 = hn(e2, n2, a2, s2), f2 |= e2.assignable) : t(e2, 30, N[255 & e2.getToken()]) : T2 = un(e2, n2), h2 = mn(e2, n2, a2, x2, s2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn)) : 134217728 & ~e2.getToken() ? t(e2, 133) : (b3 === 209005 && (x2 |= 16), x2 |= b3 === 12400 ? 256 : b3 === 12401 ? 512 : 1, f2 |= 16, T2 = un(e2, n2), h2 = mn(e2, n2, a2, x2, s2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn));
      else if (134217728 & ~e2.getToken())
        if (e2.getToken() === 69271571)
          if (T2 = hn(e2, n2, a2, s2), f2 |= 256 & e2.destructible ? 256 : 0, x2 |= 2, e2.getToken() === 21) {
            J(e2, 8192 | n2);
            const { tokenIndex: r2, tokenLine: i4, tokenColumn: d4, tokenValue: g4 } = e2, k4 = e2.getToken();
            if (143360 & e2.getToken()) {
              h2 = Ye(e2, n2, a2, c2, 0, 1, s2, 1, r2, i4, d4);
              const t2 = e2.getToken();
              h2 = _e(e2, n2, a2, h2, s2, 0, r2, i4, d4), 4194304 & ~e2.getToken() ? e2.getToken() === 18 || e2.getToken() === 1074790415 ? t2 === 1077936155 || t2 === 1074790415 || t2 === 18 ? 2 & e2.assignable ? f2 |= 16 : !o2 || 143360 & ~k4 || de(e2, n2, o2, g4, c2, u2) : f2 |= 1 & e2.assignable ? 32 : 16 : (f2 |= 16, h2 = je(e2, n2, a2, s2, l2, r2, i4, d4, h2)) : (f2 |= 2 & e2.assignable ? 16 : t2 === 1077936155 ? 0 : 32, h2 = Je(e2, n2, a2, s2, l2, r2, i4, d4, h2));
            } else
              2097152 & ~e2.getToken() ? (h2 = Xe(e2, n2, a2, 1, 0, 1, r2, i4, d4), f2 |= 1 & e2.assignable ? 32 : 16, e2.getToken() === 18 || e2.getToken() === 1074790415 ? 2 & e2.assignable && (f2 |= 16) : (h2 = _e(e2, n2, a2, h2, s2, 0, r2, i4, d4), f2 = 1 & e2.assignable ? 0 : 16, e2.getToken() !== 18 && e2.getToken() !== 1074790415 && (e2.getToken() !== 1077936155 && (f2 |= 16), h2 = je(e2, n2, a2, s2, l2, r2, i4, d4, h2)))) : (h2 = e2.getToken() === 69271571 ? kn(e2, n2, o2, a2, 0, s2, l2, c2, u2, r2, i4, d4) : bn(e2, n2, o2, a2, 0, s2, l2, c2, u2, r2, i4, d4), f2 = e2.destructible, e2.assignable = 16 & f2 ? 2 : 1, e2.getToken() === 18 || e2.getToken() === 1074790415 ? 2 & e2.assignable && (f2 |= 16) : 8 & f2 ? t(e2, 62) : (h2 = _e(e2, n2, a2, h2, s2, 0, r2, i4, d4), f2 = 2 & e2.assignable ? 16 | f2 : 0, 4194304 & ~e2.getToken() ? (8388608 & ~e2.getToken() || (h2 = Me(e2, n2, a2, 1, r2, i4, d4, 4, b3, h2)), Q(e2, 8192 | n2, 22) && (h2 = He(e2, n2, a2, h2, r2, i4, d4)), f2 |= 2 & e2.assignable ? 16 : 32) : (e2.getToken() !== 1077936155 && (f2 |= 16), h2 = Je(e2, n2, a2, s2, l2, r2, i4, d4, h2))));
          } else
            e2.getToken() === 67174411 ? (x2 |= 1, h2 = mn(e2, n2, a2, x2, s2, e2.tokenIndex, d3, g3), f2 = 16) : t(e2, 44);
        else if (b3 === 8391476)
          if (ee(e2, 8192 | n2, 8391476), x2 |= 8, 143360 & e2.getToken()) {
            const t2 = e2.getToken();
            T2 = cn(e2, n2), x2 |= 1, e2.getToken() === 67174411 ? (f2 |= 16, h2 = mn(e2, n2, a2, x2, s2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn)) : r(e2.tokenIndex, e2.tokenLine, e2.tokenColumn, e2.index, e2.line, e2.column, t2 === 209005 ? 46 : t2 === 12400 || e2.getToken() === 12401 ? 45 : 47, N[255 & t2]);
          } else
            134217728 & ~e2.getToken() ? e2.getToken() === 69271571 ? (f2 |= 16, x2 |= 3, T2 = hn(e2, n2, a2, s2), h2 = mn(e2, n2, a2, x2, s2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn)) : t(e2, 126) : (f2 |= 16, T2 = un(e2, n2), x2 |= 1, h2 = mn(e2, n2, a2, x2, s2, k3, d3, g3));
        else
          t(e2, 30, N[255 & b3]);
      else if (T2 = un(e2, n2), e2.getToken() === 21) {
        ee(e2, 8192 | n2, 21);
        const { tokenIndex: t2, tokenLine: r2, tokenColumn: d4 } = e2;
        if (i3 === "__proto__" && m2++, 143360 & e2.getToken()) {
          h2 = Ye(e2, n2, a2, c2, 0, 1, s2, 1, t2, r2, d4);
          const { tokenValue: i4 } = e2, g4 = e2.getToken();
          h2 = _e(e2, n2, a2, h2, s2, 0, t2, r2, d4), e2.getToken() === 18 || e2.getToken() === 1074790415 ? g4 === 1077936155 || g4 === 1074790415 || g4 === 18 ? 2 & e2.assignable ? f2 |= 16 : o2 && de(e2, n2, o2, i4, c2, u2) : f2 |= 1 & e2.assignable ? 32 : 16 : e2.getToken() === 1077936155 ? (2 & e2.assignable && (f2 |= 16), h2 = je(e2, n2, a2, s2, l2, t2, r2, d4, h2)) : (f2 |= 16, h2 = je(e2, n2, a2, s2, l2, t2, r2, d4, h2));
        } else
          2097152 & ~e2.getToken() ? (h2 = Xe(e2, n2, a2, 1, 0, 1, t2, r2, d4), f2 |= 1 & e2.assignable ? 32 : 16, e2.getToken() === 18 || e2.getToken() === 1074790415 ? 2 & e2.assignable && (f2 |= 16) : (h2 = _e(e2, n2, a2, h2, s2, 0, t2, r2, d4), f2 = 1 & e2.assignable ? 0 : 16, e2.getToken() !== 18 && e2.getToken() !== 1074790415 && (e2.getToken() !== 1077936155 && (f2 |= 16), h2 = je(e2, n2, a2, s2, l2, t2, r2, d4, h2)))) : (h2 = e2.getToken() === 69271571 ? kn(e2, n2, o2, a2, 0, s2, l2, c2, u2, t2, r2, d4) : bn(e2, n2, o2, a2, 0, s2, l2, c2, u2, t2, r2, d4), f2 = e2.destructible, e2.assignable = 16 & f2 ? 2 : 1, e2.getToken() === 18 || e2.getToken() === 1074790415 ? 2 & e2.assignable && (f2 |= 16) : 8 & ~e2.destructible && (h2 = _e(e2, n2, a2, h2, s2, 0, t2, r2, d4), f2 = 2 & e2.assignable ? 16 : 0, 4194304 & ~e2.getToken() ? (8388608 & ~e2.getToken() || (h2 = Me(e2, n2, a2, 1, t2, r2, d4, 4, b3, h2)), Q(e2, 8192 | n2, 22) && (h2 = He(e2, n2, a2, h2, t2, r2, d4)), f2 |= 2 & e2.assignable ? 16 : 32) : h2 = Je(e2, n2, a2, s2, l2, t2, r2, d4, h2)));
      } else
        e2.getToken() === 67174411 ? (x2 |= 1, h2 = mn(e2, n2, a2, x2, s2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn), f2 = 16 | e2.assignable) : t(e2, 134);
      f2 |= 128 & e2.destructible ? 128 : 0, e2.destructible = f2, p2.push(ie(e2, n2, k3, d3, g3, { type: "Property", key: T2, value: h2, kind: 768 & x2 ? 512 & x2 ? "set" : "get" : "init", computed: (2 & x2) > 0, method: (1 & x2) > 0, shorthand: (4 & x2) > 0 }));
    }
    if (f2 |= e2.destructible, e2.getToken() !== 18)
      break;
    J(e2, n2);
  }
  ee(e2, n2, 1074790415), m2 > 1 && (f2 |= 64);
  const b2 = ie(e2, n2, d2, g2, k2, { type: l2 ? "ObjectPattern" : "ObjectExpression", properties: p2 });
  return !i2 && 4194304 & e2.getToken() ? pn(e2, n2, a2, f2, s2, l2, d2, g2, k2, b2) : (e2.destructible = f2, b2);
}
function hn(e2, n2, t2, o2) {
  J(e2, 8192 | n2);
  const r2 = Oe(e2, 33554432 ^ (33554432 | n2), t2, 1, o2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn);
  return ee(e2, n2, 20), r2;
}
function xn(e2, n2, t2, o2, r2, a2) {
  const { tokenValue: i2 } = e2;
  let s2 = 0, l2 = 0;
  537079808 & ~e2.getToken() ? 36864 & ~e2.getToken() || (l2 = 1) : s2 = 1;
  const c2 = cn(e2, n2);
  if (e2.assignable = 1, e2.getToken() === 10) {
    let u2;
    return 16 & n2 && (u2 = le(e2, n2, i2)), s2 && (e2.flags |= 128), l2 && (e2.flags |= 256), Cn(e2, n2, u2, t2, [c2], 0, o2, r2, a2);
  }
  return c2;
}
function Tn(e2, n2, o2, r2, a2, i2, s2, l2, c2, u2, d2) {
  s2 || t(e2, 57), i2 && t(e2, 51), e2.flags &= -129;
  return Cn(e2, n2, 16 & n2 ? le(e2, n2, r2) : undefined, o2, [a2], l2, c2, u2, d2);
}
function yn(e2, n2, o2, r2, a2, i2, s2, l2, c2, u2) {
  i2 || t(e2, 57);
  for (let n3 = 0;n3 < a2.length; ++n3)
    ne(e2, a2[n3]);
  return Cn(e2, n2, o2, r2, a2, s2, l2, c2, u2);
}
function Cn(e2, n2, r2, a2, i2, s2, l2, c2, u2) {
  1 & e2.flags && t(e2, 48), ee(e2, 8192 | n2, 10);
  const d2 = 271319040;
  n2 = (n2 | d2) ^ d2 | (s2 ? 524288 : 0);
  const g2 = e2.getToken() !== 2162700;
  let k2;
  if (r2 && r2.scopeError && o(r2.scopeError), g2)
    e2.flags = 4928 ^ (4928 | e2.flags), k2 = Oe(e2, n2, a2, 1, 0, e2.tokenIndex, e2.tokenLine, e2.tokenColumn);
  else {
    r2 && (r2 = ue(r2, 128));
    const o2 = 33557504;
    switch (k2 = ze(e2, (n2 | o2) ^ o2 | 1048576, r2, a2, 16, undefined, undefined), e2.getToken()) {
      case 69271571:
        1 & e2.flags || t(e2, 116);
        break;
      case 67108877:
      case 67174409:
      case 22:
        t(e2, 117);
      case 67174411:
        1 & e2.flags || t(e2, 116), e2.flags |= 1024;
    }
    8388608 & ~e2.getToken() || 1 & e2.flags || t(e2, 30, N[255 & e2.getToken()]), 33619968 & ~e2.getToken() || t(e2, 125);
  }
  return e2.assignable = 2, ie(e2, n2, l2, c2, u2, { type: "ArrowFunctionExpression", params: i2, body: k2, async: s2 === 1, expression: g2 });
}
function vn(e2, n2, r2, a2, i2, s2) {
  ee(e2, n2, 67174411), e2.flags = 128 ^ (128 | e2.flags);
  const l2 = [];
  if (Q(e2, n2, 16))
    return l2;
  n2 = 33554432 ^ (33554432 | n2);
  let c2 = 0;
  for (;e2.getToken() !== 18; ) {
    let o2;
    const { tokenIndex: u2, tokenLine: d2, tokenColumn: g2 } = e2, k2 = e2.getToken();
    if (143360 & k2 ? (256 & n2 || (36864 & ~k2 || (e2.flags |= 256), 537079808 & ~k2 || (e2.flags |= 512)), o2 = Un(e2, n2, r2, 1 | s2, 0, u2, d2, g2)) : (k2 === 2162700 ? o2 = bn(e2, n2, r2, a2, 1, i2, 1, s2, 0, u2, d2, g2) : k2 === 69271571 ? o2 = kn(e2, n2, r2, a2, 1, i2, 1, s2, 0, u2, d2, g2) : k2 === 14 ? o2 = fn(e2, n2, r2, a2, 16, s2, 0, 0, i2, 1, u2, d2, g2) : t(e2, 30, N[255 & k2]), c2 = 1, 48 & e2.destructible && t(e2, 50)), e2.getToken() === 1077936155) {
      J(e2, 8192 | n2), c2 = 1;
      o2 = ie(e2, n2, u2, d2, g2, { type: "AssignmentPattern", left: o2, right: Oe(e2, n2, a2, 1, i2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn) });
    }
    if (l2.push(o2), !Q(e2, n2, 18))
      break;
    if (e2.getToken() === 16)
      break;
  }
  return c2 && (e2.flags |= 128), r2 && (c2 || 256 & n2) && r2.scopeError && o(r2.scopeError), ee(e2, n2, 16), l2;
}
function wn(e2, n2, t2, o2, r2, a2, i2, s2) {
  const l2 = e2.getToken();
  if (67108864 & l2) {
    if (l2 === 67108877) {
      J(e2, 67108864 | n2), e2.assignable = 1;
      return wn(e2, n2, t2, ie(e2, n2, a2, i2, s2, { type: "MemberExpression", object: o2, computed: false, property: $e(e2, n2, t2) }), 0, a2, i2, s2);
    }
    if (l2 === 69271571) {
      J(e2, 8192 | n2);
      const { tokenIndex: l3, tokenLine: c2, tokenColumn: u2 } = e2, d2 = Fe(e2, n2, t2, r2, 1, l3, c2, u2);
      return ee(e2, n2, 20), e2.assignable = 1, wn(e2, n2, t2, ie(e2, n2, a2, i2, s2, { type: "MemberExpression", object: o2, computed: true, property: d2 }), 0, a2, i2, s2);
    }
    if (l2 === 67174408 || l2 === 67174409)
      return e2.assignable = 2, wn(e2, n2, t2, ie(e2, n2, a2, i2, s2, { type: "TaggedTemplateExpression", tag: o2, quasi: e2.getToken() === 67174408 ? rn(e2, 16384 | n2, t2) : on(e2, 16384 | n2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn) }), 0, a2, i2, s2);
  }
  return o2;
}
function Ln(e2, n2, o2, r2, a2, i2, s2) {
  return e2.getToken() === 209006 && t(e2, 31), 262400 & n2 && e2.getToken() === 241771 && t(e2, 32), be(e2, n2, e2.getToken()), 36864 & ~e2.getToken() || (e2.flags |= 256), Tn(e2, -268435457 & n2 | 524288, o2, e2.tokenValue, cn(e2, n2), 0, r2, 1, a2, i2, s2);
}
function In(e2, n2, o2, r2, a2, i2, s2, l2, c2, u2, d2) {
  J(e2, 8192 | n2);
  const g2 = 16 & n2 ? ue({ parent: undefined, type: 2 }, 1024) : undefined;
  if (Q(e2, n2 = 33554432 ^ (33554432 | n2), 16))
    return e2.getToken() === 10 ? (1 & l2 && t(e2, 48), yn(e2, n2, g2, o2, [], a2, 1, c2, u2, d2)) : ie(e2, n2, c2, u2, d2, { type: "CallExpression", callee: r2, arguments: [] });
  let k2 = 0, p2 = null, f2 = 0;
  e2.destructible = 384 ^ (384 | e2.destructible);
  const m2 = [];
  for (;e2.getToken() !== 16; ) {
    const { tokenIndex: a3, tokenLine: l3, tokenColumn: b2 } = e2, h2 = e2.getToken();
    if (143360 & h2)
      g2 && ge(e2, n2, g2, e2.tokenValue, i2, 0), 537079808 & ~h2 ? 36864 & ~h2 || (e2.flags |= 256) : e2.flags |= 512, p2 = Ye(e2, n2, o2, i2, 0, 1, 1, 1, a3, l3, b2), e2.getToken() === 16 || e2.getToken() === 18 ? 2 & e2.assignable && (k2 |= 16, f2 = 1) : (e2.getToken() === 1077936155 ? f2 = 1 : k2 |= 16, p2 = _e(e2, n2, o2, p2, 1, 0, a3, l3, b2), e2.getToken() !== 16 && e2.getToken() !== 18 && (p2 = je(e2, n2, o2, 1, 0, a3, l3, b2, p2)));
    else if (2097152 & h2)
      p2 = h2 === 2162700 ? bn(e2, n2, g2, o2, 0, 1, 0, i2, s2, a3, l3, b2) : kn(e2, n2, g2, o2, 0, 1, 0, i2, s2, a3, l3, b2), k2 |= e2.destructible, f2 = 1, e2.getToken() !== 16 && e2.getToken() !== 18 && (8 & k2 && t(e2, 122), p2 = _e(e2, n2, o2, p2, 0, 0, a3, l3, b2), k2 |= 16, 8388608 & ~e2.getToken() || (p2 = Me(e2, n2, o2, 1, c2, u2, d2, 4, h2, p2)), Q(e2, 8192 | n2, 22) && (p2 = He(e2, n2, o2, p2, c2, u2, d2)));
    else {
      if (h2 !== 14) {
        for (p2 = Oe(e2, n2, o2, 1, 0, a3, l3, b2), k2 = e2.assignable, m2.push(p2);Q(e2, 8192 | n2, 18); )
          m2.push(Oe(e2, n2, o2, 1, 0, a3, l3, b2));
        return k2 |= e2.assignable, ee(e2, n2, 16), e2.destructible = 16 | k2, e2.assignable = 2, ie(e2, n2, c2, u2, d2, { type: "CallExpression", callee: r2, arguments: m2 });
      }
      p2 = fn(e2, n2, g2, o2, 16, i2, s2, 1, 1, 0, a3, l3, b2), k2 |= (e2.getToken() === 16 ? 0 : 16) | e2.destructible, f2 = 1;
    }
    if (m2.push(p2), !Q(e2, 8192 | n2, 18))
      break;
  }
  return ee(e2, n2, 16), k2 |= 256 & e2.destructible ? 256 : 128 & e2.destructible ? 128 : 0, e2.getToken() === 10 ? (48 & k2 && t(e2, 27), (1 & e2.flags || 1 & l2) && t(e2, 48), 128 & k2 && t(e2, 31), 262400 & n2 && 256 & k2 && t(e2, 32), f2 && (e2.flags |= 128), yn(e2, 524288 | n2, g2, o2, m2, a2, 1, c2, u2, d2)) : (64 & k2 && t(e2, 63), 8 & k2 && t(e2, 62), e2.assignable = 2, ie(e2, n2, c2, u2, d2, { type: "CallExpression", callee: r2, arguments: m2 }));
}
function qn(e2, n2, o2, r2, a2, i2, s2, l2) {
  let c2 = En(e2, n2, r2);
  c2.length && (i2 = e2.tokenIndex, s2 = e2.tokenLine, l2 = e2.tokenColumn), e2.leadingDecorators.length && (e2.leadingDecorators.push(...c2), c2 = e2.leadingDecorators, e2.leadingDecorators = []), J(e2, n2 = 4194304 ^ (4194560 | n2));
  let u2 = null, d2 = null;
  const { tokenValue: g2 } = e2;
  4096 & e2.getToken() && e2.getToken() !== 20565 ? (re(e2, n2, e2.getToken()) && t(e2, 118), 537079808 & ~e2.getToken() || t(e2, 119), o2 && (ge(e2, n2, o2, g2, 32, 0), a2 && 2 & a2 && fe(e2, g2)), u2 = cn(e2, n2)) : 1 & a2 || t(e2, 39, "Class");
  let k2 = n2;
  Q(e2, 8192 | n2, 20565) ? (d2 = Xe(e2, n2, r2, 0, 0, 0, e2.tokenIndex, e2.tokenLine, e2.tokenColumn), k2 |= 131072) : k2 = 131072 ^ (131072 | k2);
  return ie(e2, n2, i2, s2, l2, { type: "ClassDeclaration", id: u2, superClass: d2, body: An(e2, k2, n2, o2, r2, 2, 8, 0), ...1 & n2 ? { decorators: c2 } : null });
}
function En(e2, n2, t2) {
  const o2 = [];
  if (1 & n2)
    for (;e2.getToken() === 132; )
      o2.push(Sn(e2, n2, t2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn));
  return o2;
}
function Sn(e2, n2, t2, o2, r2, a2) {
  J(e2, 8192 | n2);
  let i2 = Ye(e2, n2, t2, 2, 0, 1, 0, 1, o2, r2, a2);
  return i2 = _e(e2, n2, t2, i2, 0, 0, o2, r2, a2), ie(e2, n2, o2, r2, a2, { type: "Decorator", expression: i2 });
}
function An(e2, o2, r2, a2, i2, s2, l2, c2) {
  const { tokenIndex: u2, tokenLine: d2, tokenColumn: g2 } = e2, k2 = 16 & o2 ? { parent: i2, refs: Object.create(null) } : undefined;
  ee(e2, 8192 | o2, 2162700);
  const p2 = 301989888;
  o2 = (o2 | p2) ^ p2;
  const f2 = 32 & e2.flags;
  e2.flags = 32 ^ (32 | e2.flags);
  const m2 = [];
  let b2;
  for (;e2.getToken() !== 1074790415; ) {
    let n2 = 0;
    b2 = En(e2, o2, k2), n2 = b2.length, n2 > 0 && e2.tokenValue === "constructor" && t(e2, 109), e2.getToken() === 1074790415 && t(e2, 108), Q(e2, o2, 1074790417) ? n2 > 0 && t(e2, 120) : m2.push(Dn(e2, o2, a2, k2, r2, s2, b2, 0, c2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn));
  }
  return ee(e2, 8 & l2 ? 8192 | o2 : o2, 1074790415), k2 && function(e3) {
    for (const t2 in e3.refs)
      if (!pe(t2, e3)) {
        const { index: o3, line: r3, column: a3 } = e3.refs[t2][0];
        throw new n(o3, r3, a3, o3 + t2.length, r3, a3 + t2.length, 4, t2);
      }
  }(k2), e2.flags = -33 & e2.flags | f2, ie(e2, o2, u2, d2, g2, { type: "ClassBody", body: m2 });
}
function Dn(e2, n2, o2, r2, a2, i2, s2, l2, c2, u2, d2, g2) {
  let k2 = l2 ? 32 : 0, p2 = null;
  const { tokenIndex: f2, tokenLine: m2, tokenColumn: b2 } = e2, h2 = e2.getToken();
  if (176128 & h2 || h2 === -2147483528)
    switch (p2 = cn(e2, n2), h2) {
      case 36970:
        if (!l2 && e2.getToken() !== 67174411 && 1048576 & ~e2.getToken() && e2.getToken() !== 1077936155)
          return Dn(e2, n2, o2, r2, a2, i2, s2, 1, c2, u2, d2, g2);
        break;
      case 209005:
        if (e2.getToken() !== 67174411 && !(1 & e2.flags)) {
          if (!(1073741824 & ~e2.getToken()))
            return Rn(e2, n2, r2, p2, k2, s2, f2, m2, b2);
          k2 |= 16 | (K(e2, n2, 8391476) ? 8 : 0);
        }
        break;
      case 12400:
        if (e2.getToken() !== 67174411) {
          if (!(1073741824 & ~e2.getToken()))
            return Rn(e2, n2, r2, p2, k2, s2, f2, m2, b2);
          k2 |= 256;
        }
        break;
      case 12401:
        if (e2.getToken() !== 67174411) {
          if (!(1073741824 & ~e2.getToken()))
            return Rn(e2, n2, r2, p2, k2, s2, f2, m2, b2);
          k2 |= 512;
        }
        break;
      case 12402:
        if (e2.getToken() !== 67174411 && !(1 & e2.flags)) {
          if (!(1073741824 & ~e2.getToken()))
            return Rn(e2, n2, r2, p2, k2, s2, f2, m2, b2);
          1 & n2 && (k2 |= 1024);
        }
    }
  else if (h2 === 69271571)
    k2 |= 2, p2 = hn(e2, a2, r2, c2);
  else if (134217728 & ~h2)
    if (h2 === 8391476)
      k2 |= 8, J(e2, n2);
    else if (e2.getToken() === 130)
      k2 |= 8192, p2 = Vn(e2, 4096 | n2, r2, 768, f2, m2, b2);
    else if (1073741824 & ~e2.getToken()) {
      if (l2 && h2 === 2162700)
        return function(e3, n3, t2, o3, r3, a3, i3) {
          t2 && (t2 = ue(t2, 2));
          const s3 = 1475584;
          n3 = 285802496 | (n3 | s3) ^ s3;
          const { body: l3 } = Ce(e3, n3, t2, o3, {}, r3, a3, i3);
          return ie(e3, n3, r3, a3, i3, { type: "StaticBlock", body: l3 });
        }(e2, 4096 | n2, o2, r2, f2, m2, b2);
      h2 === -2147483527 ? (p2 = cn(e2, n2), e2.getToken() !== 67174411 && t(e2, 30, N[255 & e2.getToken()])) : t(e2, 30, N[255 & e2.getToken()]);
    } else
      k2 |= 128;
  else
    p2 = un(e2, n2);
  if (1816 & k2 && (143360 & e2.getToken() || e2.getToken() === -2147483528 || e2.getToken() === -2147483527 ? p2 = cn(e2, n2) : 134217728 & ~e2.getToken() ? e2.getToken() === 69271571 ? (k2 |= 2, p2 = hn(e2, n2, r2, 0)) : e2.getToken() === 130 ? (k2 |= 8192, p2 = Vn(e2, n2, r2, k2, f2, m2, b2)) : t(e2, 135) : p2 = un(e2, n2)), 2 & k2 || (e2.tokenValue === "constructor" ? (1073741824 & ~e2.getToken() ? 32 & k2 || e2.getToken() !== 67174411 || (920 & k2 ? t(e2, 53, "accessor") : 131072 & n2 || (32 & e2.flags ? t(e2, 54) : e2.flags |= 32)) : t(e2, 129), k2 |= 64) : !(8192 & k2) && 32 & k2 && e2.tokenValue === "prototype" && t(e2, 52)), 1024 & k2 || e2.getToken() !== 67174411 && !(768 & k2))
    return Rn(e2, n2, r2, p2, k2, s2, f2, m2, b2);
  return ie(e2, n2, u2, d2, g2, { type: "MethodDefinition", kind: !(32 & k2) && 64 & k2 ? "constructor" : 256 & k2 ? "get" : 512 & k2 ? "set" : "method", static: (32 & k2) > 0, computed: (2 & k2) > 0, key: p2, value: mn(e2, 4096 | n2, r2, k2, c2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn), ...1 & n2 ? { decorators: s2 } : null });
}
function Vn(e2, n2, o2, r2, a2, i2, s2) {
  J(e2, n2);
  const { tokenValue: l2 } = e2;
  return l2 === "constructor" && t(e2, 128), 16 & n2 && (o2 || t(e2, 4, l2), r2 ? function(e3, n3, o3, r3) {
    let a3 = 800 & r3;
    768 & a3 || (a3 |= 768);
    const i3 = n3["#" + o3];
    i3 !== undefined && ((32 & i3) != (32 & a3) || i3 & a3 & 768) && t(e3, 146, o3), n3["#" + o3] = i3 ? i3 | a3 : a3;
  }(e2, o2, l2, r2) : function(e3, n3, t2) {
    n3.refs[t2] ??= [], n3.refs[t2].push({ index: e3.tokenIndex, line: e3.tokenLine, column: e3.tokenColumn });
  }(e2, o2, l2)), J(e2, n2), ie(e2, n2, a2, i2, s2, { type: "PrivateIdentifier", name: l2 });
}
function Rn(e2, n2, o2, r2, a2, i2, s2, l2, c2) {
  let u2 = null;
  if (8 & a2 && t(e2, 0), e2.getToken() === 1077936155) {
    J(e2, 8192 | n2);
    const { tokenIndex: r3, tokenLine: i3, tokenColumn: s3 } = e2;
    e2.getToken() === 537079927 && t(e2, 119);
    const l3 = 2883584 | (64 & a2 ? 0 : 4325376);
    u2 = Ye(e2, 4096 | (n2 = 16842752 | ((n2 | l3) ^ l3 | (8 & a2 ? 262144 : 0) | (16 & a2 ? 524288 : 0) | (64 & a2 ? 4194304 : 0))), o2, 2, 0, 1, 0, 1, r3, i3, s3), !(1073741824 & ~e2.getToken()) && 4194304 & ~e2.getToken() || (u2 = _e(e2, 4096 | n2, o2, u2, 0, 0, r3, i3, s3), u2 = je(e2, 4096 | n2, o2, 0, 0, r3, i3, s3, u2));
  }
  return Z(e2, n2), ie(e2, n2, s2, l2, c2, { type: 1024 & a2 ? "AccessorProperty" : "PropertyDefinition", key: r2, value: u2, static: (32 & a2) > 0, computed: (2 & a2) > 0, ...1 & n2 ? { decorators: i2 } : null });
}
function Nn(e2, n2, o2, r2, a2, i2, s2, l2, c2) {
  if (143360 & e2.getToken() || !(256 & n2) && e2.getToken() === -2147483527)
    return Un(e2, n2, o2, a2, i2, s2, l2, c2);
  2097152 & ~e2.getToken() && t(e2, 30, N[255 & e2.getToken()]);
  const u2 = e2.getToken() === 69271571 ? kn(e2, n2, o2, r2, 1, 0, 1, a2, i2, s2, l2, c2) : bn(e2, n2, o2, r2, 1, 0, 1, a2, i2, s2, l2, c2);
  return 16 & e2.destructible && t(e2, 50), 32 & e2.destructible && t(e2, 50), u2;
}
function Un(e2, n2, o2, r2, a2, i2, s2, l2) {
  const { tokenValue: c2 } = e2, u2 = e2.getToken();
  return 256 & n2 && (537079808 & ~u2 ? 36864 & ~u2 && u2 !== -2147483527 || t(e2, 118) : t(e2, 119)), 20480 & ~u2 || t(e2, 102), u2 === 241771 && (262144 & n2 && t(e2, 32), 512 & n2 && t(e2, 111)), (255 & u2) == 73 && 24 & r2 && t(e2, 100), u2 === 209006 && (524288 & n2 && t(e2, 176), 512 & n2 && t(e2, 110)), J(e2, n2), o2 && de(e2, n2, o2, c2, r2, a2), ie(e2, n2, i2, s2, l2, { type: "Identifier", name: c2 });
}
function Pn(e2, n2, o2, r2, a2, i2, s2) {
  if (r2 || ee(e2, n2, 8456256), e2.getToken() === 8390721) {
    const t2 = function(e3, n3, t3, o3, r3) {
      return $(e3, n3), ie(e3, n3, t3, o3, r3, { type: "JSXOpeningFragment" });
    }(e2, n2, a2, i2, s2), [l3, c3] = function(e3, n3, t3, o3) {
      const r3 = [];
      for (;; ) {
        const a3 = On(e3, n3, t3, o3, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
        if (a3.type === "JSXClosingFragment")
          return [r3, a3];
        r3.push(a3);
      }
    }(e2, n2, o2, r2);
    return ie(e2, n2, a2, i2, s2, { type: "JSXFragment", openingFragment: t2, children: l3, closingFragment: c3 });
  }
  e2.getToken() === 8457014 && t(e2, 30, N[255 & e2.getToken()]);
  let l2 = null, c2 = [];
  const u2 = function(e3, n3, o3, r3, a3, i3, s3) {
    143360 & ~e3.getToken() && 4096 & ~e3.getToken() && t(e3, 0);
    const l3 = Fn(e3, n3, e3.tokenIndex, e3.tokenLine, e3.tokenColumn), c3 = function(e4, n4, t2) {
      const o4 = [];
      for (;e4.getToken() !== 8457014 && e4.getToken() !== 8390721 && e4.getToken() !== 1048576; )
        o4.push(Jn(e4, n4, t2, e4.tokenIndex, e4.tokenLine, e4.tokenColumn));
      return o4;
    }(e3, n3, o3), u3 = e3.getToken() === 8457014;
    u3 && ee(e3, n3, 8457014);
    e3.getToken() !== 8390721 && t(e3, 25, N[65]);
    r3 || !u3 ? $(e3, n3) : J(e3, n3);
    return ie(e3, n3, a3, i3, s3, { type: "JSXOpeningElement", name: l3, attributes: c3, selfClosing: u3 });
  }(e2, n2, o2, r2, a2, i2, s2);
  if (!u2.selfClosing) {
    [c2, l2] = function(e3, n3, t2, o3) {
      const r3 = [];
      for (;; ) {
        const a4 = Bn(e3, n3, t2, o3, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
        if (a4.type === "JSXClosingElement")
          return [r3, a4];
        r3.push(a4);
      }
    }(e2, n2, o2, r2);
    const a3 = se(l2.name);
    se(u2.name) !== a3 && t(e2, 155, a3);
  }
  return ie(e2, n2, a2, i2, s2, { type: "JSXElement", children: c2, openingElement: u2, closingElement: l2 });
}
function Bn(e2, n2, o2, r2, a2, i2, s2) {
  return e2.getToken() === 137 ? Gn(e2, n2, a2, i2, s2) : e2.getToken() === 2162700 ? Mn(e2, n2, o2, 1, 0, a2, i2, s2) : e2.getToken() === 8456256 ? (J(e2, n2), e2.getToken() === 8457014 ? function(e3, n3, o3, r3, a3, i3) {
    ee(e3, n3, 8457014);
    const s3 = Fn(e3, n3, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
    return e3.getToken() !== 8390721 && t(e3, 25, N[65]), o3 ? $(e3, n3) : J(e3, n3), ie(e3, n3, r3, a3, i3, { type: "JSXClosingElement", name: s3 });
  }(e2, n2, r2, a2, i2, s2) : Pn(e2, n2, o2, 1, a2, i2, s2)) : void t(e2, 0);
}
function On(e2, n2, o2, r2, a2, i2, s2) {
  return e2.getToken() === 137 ? Gn(e2, n2, a2, i2, s2) : e2.getToken() === 2162700 ? Mn(e2, n2, o2, 1, 0, a2, i2, s2) : e2.getToken() === 8456256 ? (J(e2, n2), e2.getToken() === 8457014 ? function(e3, n3, o3, r3, a3, i3) {
    return ee(e3, n3, 8457014), e3.getToken() !== 8390721 && t(e3, 25, N[65]), o3 ? $(e3, n3) : J(e3, n3), ie(e3, n3, r3, a3, i3, { type: "JSXClosingFragment" });
  }(e2, n2, r2, a2, i2, s2) : Pn(e2, n2, o2, 1, a2, i2, s2)) : void t(e2, 0);
}
function Gn(e2, n2, t2, o2, r2) {
  J(e2, n2);
  const a2 = { type: "JSXText", value: e2.tokenValue };
  return 128 & n2 && (a2.raw = e2.tokenRaw), ie(e2, n2, t2, o2, r2, a2);
}
function Fn(e2, n2, t2, o2, r2) {
  Y(e2);
  let a2 = zn(e2, n2, t2, o2, r2);
  if (e2.getToken() === 21)
    return Hn(e2, n2, a2, t2, o2, r2);
  for (;Q(e2, n2, 67108877); )
    Y(e2), a2 = jn(e2, n2, a2, t2, o2, r2);
  return a2;
}
function jn(e2, n2, t2, o2, r2, a2) {
  return ie(e2, n2, o2, r2, a2, { type: "JSXMemberExpression", object: t2, property: zn(e2, n2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn) });
}
function Jn(e2, n2, o2, r2, a2, i2) {
  if (e2.getToken() === 2162700)
    return function(e3, n3, t2, o3, r3, a3) {
      J(e3, n3), ee(e3, n3, 14);
      const i3 = Oe(e3, n3, t2, 1, 0, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
      return ee(e3, n3, 1074790415), ie(e3, n3, o3, r3, a3, { type: "JSXSpreadAttribute", argument: i3 });
    }(e2, n2, o2, r2, a2, i2);
  Y(e2);
  let s2 = null, l2 = zn(e2, n2, r2, a2, i2);
  if (e2.getToken() === 21 && (l2 = Hn(e2, n2, l2, r2, a2, i2)), e2.getToken() === 1077936155) {
    const r3 = _(e2, n2), { tokenIndex: a3, tokenLine: i3, tokenColumn: l3 } = e2;
    switch (r3) {
      case 134283267:
        s2 = un(e2, n2);
        break;
      case 8456256:
        s2 = Pn(e2, n2, o2, 0, a3, i3, l3);
        break;
      case 2162700:
        s2 = Mn(e2, n2, o2, 0, 1, a3, i3, l3);
        break;
      default:
        t(e2, 154);
    }
  }
  return ie(e2, n2, r2, a2, i2, { type: "JSXAttribute", value: s2, name: l2 });
}
function Hn(e2, n2, t2, o2, r2, a2) {
  ee(e2, n2, 21);
  return ie(e2, n2, o2, r2, a2, { type: "JSXNamespacedName", namespace: t2, name: zn(e2, n2, e2.tokenIndex, e2.tokenLine, e2.tokenColumn) });
}
function Mn(e2, n2, o2, r2, a2, i2, s2, l2) {
  J(e2, 8192 | n2);
  const { tokenIndex: c2, tokenLine: u2, tokenColumn: d2 } = e2;
  if (e2.getToken() === 14)
    return function(e3, n3, t2, o3, r3, a3) {
      ee(e3, n3, 14);
      const i3 = Oe(e3, n3, t2, 1, 0, e3.tokenIndex, e3.tokenLine, e3.tokenColumn);
      return ee(e3, n3, 1074790415), ie(e3, n3, o3, r3, a3, { type: "JSXSpreadChild", expression: i3 });
    }(e2, n2, o2, i2, s2, l2);
  let g2 = null;
  return e2.getToken() === 1074790415 ? (a2 && t(e2, 157), g2 = function(e3, n3, t2, o3, r3) {
    return e3.startIndex = e3.tokenIndex, e3.startLine = e3.tokenLine, e3.startColumn = e3.tokenColumn, ie(e3, n3, t2, o3, r3, { type: "JSXEmptyExpression" });
  }(e2, n2, e2.startIndex, e2.startLine, e2.startColumn)) : g2 = Oe(e2, n2, o2, 1, 0, c2, u2, d2), e2.getToken() !== 1074790415 && t(e2, 25, N[15]), r2 ? $(e2, n2) : J(e2, n2), ie(e2, n2, i2, s2, l2, { type: "JSXExpressionContainer", expression: g2 });
}
function zn(e2, n2, o2, r2, a2) {
  143360 & e2.getToken() || t(e2, 30, N[255 & e2.getToken()]);
  const { tokenValue: i2 } = e2;
  return J(e2, n2), ie(e2, n2, o2, r2, a2, { type: "JSXIdentifier", name: i2 });
}
var Xn = Object.freeze({ __proto__: null });
var _n = "6.0.5";
function $n(e2, n2) {
  return he(e2, n2, 0);
}
function Yn(e2, n2) {
  return he(e2, n2, 768);
}
function Zn(e2, n2) {
  return he(e2, n2, 0);
}
// node_modules/estree-walker/src/index.js
var exports_src = {};
__export(exports_src, {
  walk: () => walk,
  asyncWalk: () => asyncWalk
});

// node_modules/estree-walker/src/walker.js
class WalkerBase {
  constructor() {
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node) => this.replacement = node
    };
  }
  replace(parent, prop, index, node) {
    if (parent && prop) {
      if (index != null) {
        parent[prop][index] = node;
      } else {
        parent[prop] = node;
      }
    }
  }
  remove(parent, prop, index) {
    if (parent && prop) {
      if (index !== null && index !== undefined) {
        parent[prop].splice(index, 1);
      } else {
        delete parent[prop];
      }
    }
  }
}

// node_modules/estree-walker/src/sync.js
class SyncWalker extends WalkerBase {
  constructor(enter, leave) {
    super();
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node) => this.replacement = node
    };
    this.enter = enter;
    this.leave = leave;
  }
  visit(node, parent, prop, index) {
    if (node) {
      if (this.enter) {
        const _should_skip = this.should_skip;
        const _should_remove = this.should_remove;
        const _replacement = this.replacement;
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        this.enter.call(this.context, node, parent, prop, index);
        if (this.replacement) {
          node = this.replacement;
          this.replace(parent, prop, index, node);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index);
        }
        const skipped = this.should_skip;
        const removed = this.should_remove;
        this.should_skip = _should_skip;
        this.should_remove = _should_remove;
        this.replacement = _replacement;
        if (skipped)
          return node;
        if (removed)
          return null;
      }
      let key;
      for (key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          if (Array.isArray(value)) {
            const nodes = value;
            for (let i2 = 0;i2 < nodes.length; i2 += 1) {
              const item = nodes[i2];
              if (isNode(item)) {
                if (!this.visit(item, node, key, i2)) {
                  i2--;
                }
              }
            }
          } else if (isNode(value)) {
            this.visit(value, node, key, null);
          }
        }
      }
      if (this.leave) {
        const _replacement = this.replacement;
        const _should_remove = this.should_remove;
        this.replacement = null;
        this.should_remove = false;
        this.leave.call(this.context, node, parent, prop, index);
        if (this.replacement) {
          node = this.replacement;
          this.replace(parent, prop, index, node);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index);
        }
        const removed = this.should_remove;
        this.replacement = _replacement;
        this.should_remove = _should_remove;
        if (removed)
          return null;
      }
    }
    return node;
  }
}
function isNode(value) {
  return value !== null && typeof value === "object" && "type" in value && typeof value.type === "string";
}

// node_modules/estree-walker/src/async.js
class AsyncWalker extends WalkerBase {
  constructor(enter, leave) {
    super();
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node) => this.replacement = node
    };
    this.enter = enter;
    this.leave = leave;
  }
  async visit(node, parent, prop, index) {
    if (node) {
      if (this.enter) {
        const _should_skip = this.should_skip;
        const _should_remove = this.should_remove;
        const _replacement = this.replacement;
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        await this.enter.call(this.context, node, parent, prop, index);
        if (this.replacement) {
          node = this.replacement;
          this.replace(parent, prop, index, node);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index);
        }
        const skipped = this.should_skip;
        const removed = this.should_remove;
        this.should_skip = _should_skip;
        this.should_remove = _should_remove;
        this.replacement = _replacement;
        if (skipped)
          return node;
        if (removed)
          return null;
      }
      let key;
      for (key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          if (Array.isArray(value)) {
            const nodes = value;
            for (let i2 = 0;i2 < nodes.length; i2 += 1) {
              const item = nodes[i2];
              if (isNode2(item)) {
                if (!await this.visit(item, node, key, i2)) {
                  i2--;
                }
              }
            }
          } else if (isNode2(value)) {
            await this.visit(value, node, key, null);
          }
        }
      }
      if (this.leave) {
        const _replacement = this.replacement;
        const _should_remove = this.should_remove;
        this.replacement = null;
        this.should_remove = false;
        await this.leave.call(this.context, node, parent, prop, index);
        if (this.replacement) {
          node = this.replacement;
          this.replace(parent, prop, index, node);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index);
        }
        const removed = this.should_remove;
        this.replacement = _replacement;
        this.should_remove = _should_remove;
        if (removed)
          return null;
      }
    }
    return node;
  }
}
function isNode2(value) {
  return value !== null && typeof value === "object" && "type" in value && typeof value.type === "string";
}

// node_modules/estree-walker/src/index.js
function walk(ast, { enter, leave }) {
  const instance = new SyncWalker(enter, leave);
  return instance.visit(ast, null);
}
async function asyncWalk(ast, { enter, leave }) {
  const instance = new AsyncWalker(enter, leave);
  return await instance.visit(ast, null);
}
// node_modules/ventojs/esm/src/errors.js
class VentoBaseError extends Error {
  name = this.constructor.name;
}

class TemplateError extends VentoBaseError {
  path;
  source;
  position;
  constructor(path2 = "<unknown>", source = "<empty file>", position = 0, cause) {
    const { line, column, code } = errorLine(source, position);
    super(`Error in template ${path2}:${line}:${column}

${code.trim()}

`, { cause });
    this.path = path2;
    this.source = source;
    this.position = position;
  }
}

class TransformError extends VentoBaseError {
  position;
  constructor(message, position = 0, cause) {
    super(message, { cause });
    this.position = position;
  }
}
function errorLine(source, position) {
  let line = 1;
  let column = 1;
  for (let index = 0;index < position; index++) {
    if (source[index] === `
` || source[index] === "\r" && source[index + 1] === `
`) {
      line++;
      column = 1;
      if (source[index] === "\r") {
        index++;
      }
    } else {
      column++;
    }
  }
  return { line, column, code: source.split(`
`)[line - 1] };
}

// node_modules/ventojs/esm/src/transformer.js
var INCLUDE_GLOBAL = [
  "name"
];
var DEFAULT_EXCLUDES = [
  "globalThis",
  "self",
  "this",
  "undefined",
  "null"
];

class ScopeTracker {
  scopes = [{ globalScope: 0, stack: [] }];
  globalScope = 0;
  includes(val) {
    for (let i2 = this.scopes.length - 1;i2 >= 0; i2--) {
      if (this.scopes[i2].stack.includes(val)) {
        return true;
      }
    }
    return false;
  }
  pushScope(global2) {
    if (global2) {
      this.globalScope = this.scopes.length;
    }
    const newScope = {
      globalScope: this.globalScope,
      stack: []
    };
    this.scopes.push(newScope);
  }
  popScope() {
    this.scopes.pop();
    this.globalScope = this.scopes[this.scopes.length - 1].globalScope;
  }
  pushBinding(val, global2) {
    if (this.scopes.length === 0) {
      this.scopes.push({ globalScope: this.globalScope, stack: [] });
    }
    if (global2) {
      this.scopes[this.globalScope].stack.push(val);
    } else {
      this.scopes[this.scopes.length - 1].stack.push(val);
    }
  }
  pushPatternBinding(pattern, global2) {
    switch (pattern.type) {
      case "Identifier":
        this.pushBinding(pattern.name, global2);
        break;
      case "RestElement":
        this.pushPatternBinding(pattern.argument, global2);
        break;
      case "ArrayPattern":
        for (const element of pattern.elements) {
          if (element) {
            this.pushPatternBinding(element, global2);
          }
        }
        break;
      case "ObjectPattern":
        for (const prop of pattern.properties) {
          if (prop.type === "RestElement") {
            this.pushPatternBinding(prop.argument, global2);
          } else {
            this.pushPatternBinding(prop.value, global2);
          }
        }
        break;
      case "AssignmentPattern":
        this.pushPatternBinding(pattern.left, global2);
        break;
    }
  }
  pushPatternBindings(patterns, global2) {
    for (const pattern of patterns) {
      this.pushPatternBinding(pattern, global2);
    }
  }
}
function transformTemplateCode(code, templateState) {
  if (!code.trim()) {
    return code;
  }
  let parsed;
  try {
    parsed = exports_meriyah_min.parseScript(code, { module: true });
  } catch (error) {
    const { message, start, loc } = error;
    const annotation = `\x1B[2m${loc.start.line}\x1B[0m ` + code.split(`
`)[loc.start.line - 1] + `
${" ".repeat(loc.start.column)}\x1B[31m^\x1B[39m`;
    const matches = [...code.slice(0, start).matchAll(/__pos = (\d+);/g)];
    const position = Number(matches.at(-1)?.[1]);
    throw new TransformError(`[meriyah] ${message} while parsing compiled template function:

${annotation}`, position);
  }
  const tracker = new ScopeTracker;
  const exclude = [
    templateState,
    ...DEFAULT_EXCLUDES
  ];
  if (parsed.type !== "Program") {
    throw new TransformError("[meriyah] Expected a program");
  }
  if (parsed.body.length === 0) {
    throw new TransformError("[meriyah] Empty program");
  }
  function transformIdentifier(id) {
    if (!INCLUDE_GLOBAL.includes(id.name) && dntGlobalThis[id.name] !== undefined || exclude.includes(id.name) || tracker.includes(id.name) || id.name.startsWith("__")) {
      return id;
    }
    return {
      type: "MemberExpression",
      object: {
        type: "Identifier",
        name: templateState
      },
      optional: false,
      computed: false,
      property: id
    };
  }
  exports_src.walk(parsed, {
    enter(node) {
      switch (node.type) {
        case "VariableDeclaration":
          tracker.pushPatternBindings(node.declarations.map((d2) => d2.id), node.kind === "var");
          break;
        case "FunctionDeclaration":
        case "FunctionExpression":
          if (node.id) {
            tracker.pushBinding(node.id.name);
          }
          tracker.pushScope(true);
          tracker.pushPatternBindings(node.params);
          break;
        case "ArrowFunctionExpression":
          tracker.pushScope();
          tracker.pushPatternBindings(node.params);
          break;
        case "Property":
          if (node.shorthand && node.value.type === "Identifier") {
            this.replace({
              type: "Property",
              key: node.key,
              value: transformIdentifier(node.value),
              kind: "init",
              computed: false,
              method: false,
              shorthand: false
            });
          }
          break;
      }
    },
    leave(node, parent) {
      switch (node.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ArrowFunctionExpression":
          tracker.popScope();
          break;
        case "Identifier":
          if (parent?.type === "MemberExpression" && parent.property === node && parent.computed === false) {
            return;
          }
          if (parent?.type === "Property" && parent.key === node) {
            return;
          }
          this.replace(transformIdentifier(node));
          break;
      }
    }
  });
  const generated = exports_astring.generate(parsed);
  return generated;
}

// node_modules/ventojs/esm/src/environment.js
class Environment {
  cache = new Map;
  options;
  tags = [];
  tokenPreprocessors = [];
  filters = {};
  utils = {};
  constructor(options) {
    this.options = options;
  }
  use(plugin) {
    plugin(this);
  }
  async run(file, data, from) {
    const template = await this.load(file, from);
    return await template(data);
  }
  async runString(source, data, file) {
    if (file) {
      const cached = this.cache.get(file);
      if (cached) {
        return await cached(data);
      }
      const template2 = this.compile(source, file);
      this.cache.set(file, template2);
      return await template2(data);
    }
    const template = this.compile(source, file);
    return await template(data);
  }
  runStringSync(source, data) {
    const template = this.compile(source, "", {}, true);
    return template(data);
  }
  compile(source, path2, defaults, sync = false) {
    if (typeof source !== "string") {
      throw new Error(`The source code of "${path2}" must be a string. Got ${typeof source}`);
    }
    const tokens = this.tokenize(source, path2);
    let code = this.compileTokens(tokens).join(`
`);
    const { dataVarname, autoDataVarname } = this.options;
    if (autoDataVarname) {
      try {
        code = transformTemplateCode(code, dataVarname);
      } catch (cause) {
        if (cause instanceof TransformError) {
          throw new TemplateError(path2, source, cause.position, cause);
        }
        throw new Error(`Unknown error while transforming ${path2}`, { cause });
      }
    }
    const constructor = new Function("__file", "__env", "__defaults", "__err", `return${sync ? "" : " async"} function (${dataVarname}) {
        let __pos = 0;
        try {
          ${dataVarname} = Object.assign({}, __defaults, ${dataVarname});
          const __exports = { content: "" };
          ${code}
          return __exports;
        } catch (cause) {
          const template = __env.cache.get(__file);
          throw new __err(__file, template?.source, __pos, cause);
        }
      }
      `);
    const template = constructor(path2, this, defaults, TemplateError);
    template.file = path2;
    template.code = code;
    template.source = source;
    return template;
  }
  tokenize(source, path2) {
    const result = tokenize(source);
    let { tokens } = result;
    const { position, error } = result;
    if (error) {
      throw new TemplateError(path2, source, position, error);
    }
    for (const tokenPreprocessor of this.tokenPreprocessors) {
      const result2 = tokenPreprocessor(this, tokens, path2);
      if (result2 !== undefined) {
        tokens = result2;
      }
    }
    return tokens;
  }
  async load(file, from) {
    const path2 = this.options.loader.resolve(from || "", file);
    if (!this.cache.has(path2)) {
      const cleanPath = path2.split("?")[0].split("#")[0];
      const { source, data } = await this.options.loader.load(cleanPath);
      const template = this.compile(source, path2, data);
      this.cache.set(path2, template);
    }
    return this.cache.get(path2);
  }
  compileTokens(tokens, outputVar = "__exports.content", stopAt) {
    const compiled = [];
    tokens:
      while (tokens.length > 0) {
        if (stopAt && tokens[0][0] === "tag" && stopAt.includes(tokens[0][1])) {
          break;
        }
        const [type, code, pos] = tokens.shift();
        if (type === "comment") {
          continue;
        }
        if (type === "string") {
          if (code !== "") {
            compiled.push(`${outputVar} += ${JSON.stringify(code)};`);
          }
          continue;
        }
        if (type === "tag") {
          compiled.push(`__pos = ${pos};`);
          for (const tag of this.tags) {
            const compiledTag = tag(this, code, outputVar, tokens);
            if (typeof compiledTag === "string") {
              compiled.push(compiledTag);
              continue tokens;
            }
          }
          const expression = this.compileFilters(tokens, code, this.options.autoescape);
          compiled.push(`${outputVar} += (${expression}) ?? "";`);
          continue;
        }
        throw new Error(`Unknown token type "${type}"`);
      }
    return compiled;
  }
  compileFilters(tokens, output, autoescape = false) {
    let unescaped = false;
    while (tokens.length > 0 && tokens[0][0] === "filter") {
      const [, code] = tokens.shift();
      const match = code.match(/^(await\s+)?([\w.]+)(?:\((.*)\))?$/);
      if (!match) {
        throw new Error(`Invalid filter: ${code}`);
      }
      const [_2, isAsync, name, args] = match;
      if (!this.filters[name]) {
        if (name === "safe") {
          unescaped = true;
        } else if (isGlobal(name)) {
          output = `${isAsync ? "await " : ""}${name}(${output}${args ? `, ${args}` : ""})`;
        } else {
          output = `${isAsync ? "await " : ""}(${output})?.${name}?.(${args ? args : ""})`;
        }
      } else {
        const { dataVarname } = this.options;
        output = `${isAsync || checkAsync(this.filters[name]) ? "await " : ""}__env.filters.${name}.call({data:${dataVarname},env:__env}, ${output}${args ? `, ${args}` : ""})`;
      }
    }
    if (autoescape && !unescaped) {
      output = `__env.filters.escape(${output})`;
    }
    return output;
  }
}
function isGlobal(name) {
  if (dntGlobalThis[name]) {
    return true;
  }
  if (name.includes(".")) {
    const [obj, prop] = name.split(".");
    return typeof dntGlobalThis[obj]?.[prop] === "function";
  }
}
function checkAsync(fn2) {
  return fn2.constructor?.name === "AsyncFunction";
}

// node_modules/ventojs/esm/src/loader.js
class FileLoader {
  #root;
  constructor(root) {
    this.#root = root;
  }
  async load(file) {
    return {
      source: await import_shim_deno2.Deno.readTextFile(file)
    };
  }
  resolve(from, file) {
    if (file.startsWith(".")) {
      return exports_mod.join(exports_mod.dirname(from), file);
    }
    if (file.startsWith(this.#root)) {
      return file;
    }
    return exports_mod.join(this.#root, file);
  }
}

// node_modules/ventojs/esm/bare.js
function bare_default(options = {}) {
  const loader = typeof options.includes === "object" ? options.includes : new FileLoader(options.includes || import_shim_deno2.Deno.cwd());
  const env = new Environment({
    loader,
    dataVarname: options.dataVarname || "it",
    autoescape: options.autoescape ?? false,
    autoDataVarname: options.autoDataVarname ?? true
  });
  return env;
}

// node_modules/ventojs/esm/plugins/if.js
function if_default() {
  return (env) => {
    env.tags.push(ifTag);
    env.tags.push(elseTag);
  };
}
function ifTag(env, code, output, tokens) {
  if (!code.startsWith("if ")) {
    return;
  }
  const condition = code.replace(/^if\s+/, "").trim();
  const compiled = [];
  compiled.push(`if (${condition}) {`);
  compiled.push(...env.compileTokens(tokens, output, ["/if"]));
  tokens.shift();
  compiled.push("}");
  return compiled.join(`
`);
}
function elseTag(_env, code) {
  if (!code.startsWith("else ") && code !== "else") {
    return;
  }
  const match = code.match(/^else(\s+if\s+(.*))?$/);
  if (!match) {
    throw new Error(`Invalid else: ${code}`);
  }
  const [_2, ifTag2, condition] = match;
  if (ifTag2) {
    return `} else if (${condition}) {`;
  }
  return "} else {";
}

// node_modules/ventojs/esm/plugins/for.js
function for_default() {
  return (env) => {
    env.tags.push(forTag);
    env.utils.toIterator = toIterator;
  };
}
function forTag(env, code, output, tokens) {
  if (!code.startsWith("for ")) {
    return;
  }
  const compiled = [];
  const match = code.match(/^for\s+(await\s+)?(\w+)(?:,\s*(\w+))?\s+of\s+([\s|\S]+)$/);
  if (!match) {
    throw new Error(`Invalid for loop: ${code}`);
  }
  const [_2, aw, var1, var2, collection] = match;
  if (var2) {
    compiled.push(`for ${aw || ""}(let [${var1}, ${var2}] of __env.utils.toIterator(${env.compileFilters(tokens, collection)}, true)) {`);
  } else {
    compiled.push(`for ${aw || ""}(let ${var1} of __env.utils.toIterator(${env.compileFilters(tokens, collection)})) {`);
  }
  compiled.push(...env.compileTokens(tokens, output, ["/for"]));
  tokens.shift();
  compiled.push("}");
  return compiled.join(`
`);
}
function toIterator(item, withKeys = false) {
  if (item === undefined || item === null) {
    return [];
  }
  if (Array.isArray(item)) {
    return withKeys ? item.map((value, i2) => [i2, value]) : item;
  }
  if (typeof item === "function") {
    return toIterator(item(), withKeys);
  }
  if (typeof item === "object" && item !== null) {
    if (typeof item[Symbol.iterator] === "function") {
      if (withKeys) {
        return iterableToEntries(item);
      }
      return item;
    }
    if (typeof item[Symbol.asyncIterator] === "function") {
      if (withKeys) {
        return asyncIterableToEntries(item);
      }
      return item;
    }
    return withKeys ? Object.entries(item) : Object.values(item);
  }
  if (typeof item === "string") {
    return toIterator(item.split(""), withKeys);
  }
  if (typeof item === "number") {
    return toIterator(new Array(item).fill(0).map((_2, i2) => i2 + 1), withKeys);
  }
  return toIterator([item], withKeys);
}
function* iterableToEntries(iterator) {
  let i2 = 0;
  for (const value of iterator) {
    yield [i2++, value];
  }
}
async function* asyncIterableToEntries(iterator) {
  let i2 = 0;
  for await (const value of iterator) {
    yield [i2++, value];
  }
}

// node_modules/ventojs/esm/plugins/include.js
function include_default() {
  return (env) => {
    env.tags.push(includeTag);
  };
}
function includeTag(env, code, output, tokens) {
  if (!code.startsWith("include ")) {
    return;
  }
  const tagCode = code.substring(7).trim();
  let index = undefined;
  analyze(tagCode, (type, i2) => {
    if (type === "open-bracket") {
      index = i2 - 1;
      return false;
    }
  });
  const file = index === undefined ? tagCode.trim() : tagCode.slice(0, index).trim();
  const data = index === undefined ? "" : tagCode.slice(index).trim();
  const { dataVarname } = env.options;
  return `{
    const __tmp = await __env.run(${file},
      {...${dataVarname}${data ? `, ...${data}` : ""}},
      __file
    );
    ${output} += ${env.compileFilters(tokens, "__tmp.content")};
  }`;
}

// node_modules/ventojs/esm/plugins/set.js
function set_default() {
  return (env) => {
    env.tags.push(setTag);
  };
}
function setTag(env, code, _output, tokens) {
  if (!code.startsWith("set ")) {
    return;
  }
  const expression = code.replace(/^set\s+/, "");
  const { dataVarname } = env.options;
  if (expression.includes("=")) {
    const match = code.match(/^set\s+([\w]+)\s*=\s*([\s\S]+)$/);
    if (!match) {
      throw new Error(`Invalid set tag: ${code}`);
    }
    const [, variable, value] = match;
    const val = env.compileFilters(tokens, value);
    return `
    var ${variable} = ${val};
    ${dataVarname}["${variable}"] = ${variable};
    `;
  }
  const compiled = [];
  const compiledFilters = env.compileFilters(tokens, expression);
  compiled.push(`var ${expression} = "";`);
  compiled.push(...env.compileTokens(tokens, expression, ["/set"]));
  compiled.push(`${dataVarname}["${expression}"] = ${expression};`);
  if (tokens.length && (tokens[0][0] !== "tag" || tokens[0][1] !== "/set")) {
    throw new Error(`Missing closing tag for set tag: ${code}`);
  }
  tokens.shift();
  compiled.push(`${expression} = ${compiledFilters};`);
  compiled.push(`${dataVarname}["${expression.trim()}"] = ${expression};`);
  return compiled.join(`
`);
}

// node_modules/ventojs/esm/plugins/js.js
function js_default() {
  return (env) => {
    env.tags.push(jsTag);
  };
}
function jsTag(_env, code) {
  if (!code.startsWith(">")) {
    return;
  }
  return code.replace(/^>\s+/, "");
}

// node_modules/ventojs/esm/plugins/layout.js
function layout_default() {
  return (env) => {
    env.tags.push(layoutTag);
  };
}
function layoutTag(env, code, output, tokens) {
  if (!code.startsWith("layout ")) {
    return;
  }
  const match = code?.match(/^layout\s+([^{]+|`[^`]+`)+(?:\{([\s|\S]*)\})?$/);
  if (!match) {
    throw new Error(`Invalid wrap: ${code}`);
  }
  const [_2, file, data] = match;
  const varname = output.startsWith("__layout") ? output + "_layout" : "__layout";
  const compiled = [];
  const compiledFilters = env.compileFilters(tokens, varname);
  compiled.push("{");
  compiled.push(`let ${varname} = "";`);
  compiled.push(...env.compileTokens(tokens, varname, ["/layout"]));
  if (tokens.length && (tokens[0][0] !== "tag" || tokens[0][1] !== "/layout")) {
    throw new Error(`Missing closing tag for layout tag: ${code}`);
  }
  tokens.shift();
  compiled.push(`${varname} = ${compiledFilters};`);
  const { dataVarname } = env.options;
  compiled.push(`const __tmp = await __env.run(${file},
      {...${dataVarname}${data ? `, ${data}` : ""}, content: ${env.compileFilters(tokens, varname)}},
      __file
    );
    ${output} += __tmp.content;`);
  compiled.push("}");
  return compiled.join(`
`);
}

// node_modules/ventojs/esm/plugins/function.js
function function_default() {
  return (env) => {
    env.tags.push(functionTag);
  };
}
function functionTag(env, code, _output, tokens) {
  if (!code.match(/(export\s+)?(async\s+)?function\s/)) {
    return;
  }
  const match = code.match(/^(export\s+)?(async\s+)?function\s+(\w+)\s*(\([^)]+\))?$/);
  if (!match) {
    throw new Error(`Invalid function: ${code}`);
  }
  const [_2, exp, as, name, args] = match;
  const compiled = [];
  compiled.push(`${as || ""} function ${name} ${args || "()"} {`);
  compiled.push(`let __output = "";`);
  if (exp) {
    compiled.push(...env.compileTokens(tokens, "__output", ["/export"]));
    if (tokens.length && (tokens[0][0] !== "tag" || tokens[0][1] !== "/export")) {
      throw new Error(`Missing closing tag for export function tag: ${code}`);
    }
  } else {
    compiled.push(...env.compileTokens(tokens, "__output", ["/function"]));
    if (tokens.length && (tokens[0][0] !== "tag" || tokens[0][1] !== "/function")) {
      throw new Error(`Missing closing tag for function tag: ${code}`);
    }
  }
  tokens.shift();
  compiled.push(`return __output;`);
  compiled.push(`}`);
  if (exp) {
    compiled.push(`__exports["${name}"] = ${name}`);
  }
  return compiled.join(`
`);
}

// node_modules/ventojs/esm/plugins/import.js
function import_default() {
  return (env) => {
    env.tags.push(importTag);
  };
}
function importTag(env, code) {
  if (!code.startsWith("import ")) {
    return;
  }
  const match = code?.match(/^import\s+(\{[\s|\S]*\}|\w+)\s+from\s+(.+)$/);
  if (!match) {
    throw new Error(`Invalid import: ${code}`);
  }
  const [, vars, file] = match;
  const { dataVarname } = env.options;
  return `let ${vars} = await __env.run(${file}, {...${dataVarname}}, __file);`;
}

// node_modules/ventojs/esm/plugins/export.js
function export_default() {
  return (env) => {
    env.tags.push(exportTag);
  };
}
function exportTag(env, code, _output, tokens) {
  if (!code.startsWith("export ")) {
    return;
  }
  const expression = code.replace(/^export\s+/, "");
  const { dataVarname } = env.options;
  if (expression.includes("=")) {
    const match = code.match(/^export\s+([\w]+)\s*=\s*([\s\S]+)$/);
    if (!match) {
      throw new Error(`Invalid export tag: ${code}`);
    }
    const [, variable, value] = match;
    const val = env.compileFilters(tokens, value);
    return `if (${dataVarname}.hasOwnProperty("${variable}")) {
      ${variable} = ${val};
    } else {
      var ${variable} = ${val};
    }
    ${dataVarname}["${variable}"] = ${variable};
    __exports["${variable}"] = ${variable};
    `;
  }
  const compiled = [];
  const compiledFilters = env.compileFilters(tokens, expression);
  compiled.push(`if (${dataVarname}.hasOwnProperty("${expression}")) {
    ${expression} = "";
  } else {
    var ${expression} = "";
  }
  `);
  compiled.push(...env.compileTokens(tokens, expression, ["/export"]));
  if (tokens.length && (tokens[0][0] !== "tag" || tokens[0][1] !== "/export")) {
    throw new Error(`Missing closing tag for export tag: ${code}`);
  }
  tokens.shift();
  compiled.push(`${expression} = ${compiledFilters};`);
  compiled.push(`${dataVarname}["${expression.trim()}"] = ${expression};`);
  compiled.push(`__exports["${expression.trim()}"] = ${expression};`);
  return compiled.join(`
`);
}

// node_modules/ventojs/esm/plugins/echo.js
function echo_default() {
  return (env) => {
    env.tags.push(echoTag);
  };
}
function echoTag(env, code, output, tokens) {
  if (!code.startsWith("echo ")) {
    return;
  }
  const value = code.replace(/^echo\s+/, "");
  const val = env.compileFilters(tokens, value, env.options.autoescape);
  return `${output} += ${val};`;
}

// node_modules/ventojs/esm/plugins/escape.js
function escape_default() {
  return (env) => {
    env.filters.escape = (value) => value ? exports_mod2.escape(value.toString()) : "";
  };
}

// node_modules/ventojs/esm/plugins/unescape.js
function unescape_default() {
  return (env) => {
    env.filters.unescape = (value) => value ? exports_mod2.unescape(value.toString()) : "";
  };
}

// node_modules/ventojs/esm/plugins/trim.js
function trim_default() {
  return (env) => {
    env.tokenPreprocessors.push(trim);
  };
}
function trim(_2, tokens) {
  for (let i2 = 0;i2 < tokens.length; i2++) {
    const previous = tokens[i2 - 1];
    const token = tokens[i2];
    const next = tokens[i2 + 1];
    let [type, code] = token;
    if (["tag", "comment"].includes(type) && code.startsWith("-")) {
      previous[1] = previous[1].trimEnd();
      code = code.slice(1);
    }
    if (["tag", "filter", "comment"].includes(type) && code.endsWith("-")) {
      next[1] = next[1].trimStart();
      code = code.slice(0, -1);
    }
    switch (type) {
      case "tag":
      case "filter":
        token[1] = code.trim();
        break;
    }
  }
}

// node_modules/ventojs/esm/mod.js
function mod_default(options = {}) {
  const env = bare_default({
    ...options,
    autoDataVarname: options.autoDataVarname ?? options.useWith ?? true
  });
  env.use(if_default());
  env.use(for_default());
  env.use(js_default());
  env.use(include_default());
  env.use(set_default());
  env.use(layout_default());
  env.use(function_default());
  env.use(import_default());
  env.use(export_default());
  env.use(echo_default());
  env.use(escape_default());
  env.use(unescape_default());
  env.use(trim_default());
  return env;
}

// src/4_template/filters.ts
var exports_filters = {};
__export(exports_filters, {
  toSnakeCase: () => toSnakeCase,
  title: () => title,
  summarizeToSentence: () => summarizeToSentence,
  summarize: () => summarize,
  stripHtml: () => stripHtml,
  stripHeaders: () => stripHeaders,
  stripFormatting: () => stripFormatting,
  accessible: () => accessible
});

// node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values: __values2,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension
} = import_tslib.default;

// node_modules/@typespec/ts-http-runtime/dist/esm/abort-controller/AbortError.js
class AbortError extends Error {
  constructor(message) {
    super(message);
    this.name = "AbortError";
  }
}

// node_modules/@typespec/ts-http-runtime/dist/esm/logger/log.js
import { EOL } from "node:os";
import util from "node:util";
import * as process2 from "node:process";
function log(message, ...args) {
  process2.stderr.write(`${util.format(message, ...args)}${EOL}`);
}

// node_modules/@typespec/ts-http-runtime/dist/esm/logger/debug.js
var debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || undefined;
var enabledString;
var enabledNamespaces = [];
var skippedNamespaces = [];
var debuggers = [];
if (debugEnvVariable) {
  enable(debugEnvVariable);
}
var debugObj = Object.assign((namespace) => {
  return createDebugger(namespace);
}, {
  enable,
  enabled,
  disable,
  log
});
function enable(namespaces) {
  enabledString = namespaces;
  enabledNamespaces = [];
  skippedNamespaces = [];
  const wildcard = /\*/g;
  const namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
  for (const ns of namespaceList) {
    if (ns.startsWith("-")) {
      skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
    } else {
      enabledNamespaces.push(new RegExp(`^${ns}$`));
    }
  }
  for (const instance of debuggers) {
    instance.enabled = enabled(instance.namespace);
  }
}
function enabled(namespace) {
  if (namespace.endsWith("*")) {
    return true;
  }
  for (const skipped of skippedNamespaces) {
    if (skipped.test(namespace)) {
      return false;
    }
  }
  for (const enabledNamespace of enabledNamespaces) {
    if (enabledNamespace.test(namespace)) {
      return true;
    }
  }
  return false;
}
function disable() {
  const result = enabledString || "";
  enable("");
  return result;
}
function createDebugger(namespace) {
  const newDebugger = Object.assign(debug, {
    enabled: enabled(namespace),
    destroy,
    log: debugObj.log,
    namespace,
    extend
  });
  function debug(...args) {
    if (!newDebugger.enabled) {
      return;
    }
    if (args.length > 0) {
      args[0] = `${namespace} ${args[0]}`;
    }
    newDebugger.log(...args);
  }
  debuggers.push(newDebugger);
  return newDebugger;
}
function destroy() {
  const index = debuggers.indexOf(this);
  if (index >= 0) {
    debuggers.splice(index, 1);
    return true;
  }
  return false;
}
function extend(namespace) {
  const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
  newDebugger.log = this.log;
  return newDebugger;
}
var debug_default = debugObj;

// node_modules/@typespec/ts-http-runtime/dist/esm/logger/logger.js
var TYPESPEC_RUNTIME_LOG_LEVELS = ["verbose", "info", "warning", "error"];
var levelMap = {
  verbose: 400,
  info: 300,
  warning: 200,
  error: 100
};
function patchLogMethod(parent, child) {
  child.log = (...args) => {
    parent.log(...args);
  };
}
function isTypeSpecRuntimeLogLevel(level) {
  return TYPESPEC_RUNTIME_LOG_LEVELS.includes(level);
}
function createLoggerContext(options) {
  const registeredLoggers = new Set;
  const logLevelFromEnv = typeof process !== "undefined" && process.env && process.env[options.logLevelEnvVarName] || undefined;
  let logLevel;
  const clientLogger = debug_default(options.namespace);
  clientLogger.log = (...args) => {
    debug_default.log(...args);
  };
  if (logLevelFromEnv) {
    if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) {
      setLogLevel(logLevelFromEnv);
    } else {
      console.error(`${options.logLevelEnvVarName} set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(", ")}.`);
    }
  }
  function shouldEnable(logger) {
    return Boolean(logLevel && levelMap[logger.level] <= levelMap[logLevel]);
  }
  function createLogger(parent, level) {
    const logger = Object.assign(parent.extend(level), {
      level
    });
    patchLogMethod(parent, logger);
    if (shouldEnable(logger)) {
      const enabledNamespaces2 = debug_default.disable();
      debug_default.enable(enabledNamespaces2 + "," + logger.namespace);
    }
    registeredLoggers.add(logger);
    return logger;
  }
  return {
    setLogLevel(level) {
      if (level && !isTypeSpecRuntimeLogLevel(level)) {
        throw new Error(`Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(",")}`);
      }
      logLevel = level;
      const enabledNamespaces2 = [];
      for (const logger of registeredLoggers) {
        if (shouldEnable(logger)) {
          enabledNamespaces2.push(logger.namespace);
        }
      }
      debug_default.enable(enabledNamespaces2.join(","));
    },
    getLogLevel() {
      return logLevel;
    },
    createClientLogger(namespace) {
      const clientRootLogger = clientLogger.extend(namespace);
      patchLogMethod(clientLogger, clientRootLogger);
      return {
        error: createLogger(clientRootLogger, "error"),
        warning: createLogger(clientRootLogger, "warning"),
        info: createLogger(clientRootLogger, "info"),
        verbose: createLogger(clientRootLogger, "verbose")
      };
    },
    logger: clientLogger
  };
}
var context2 = createLoggerContext({
  logLevelEnvVarName: "TYPESPEC_RUNTIME_LOG_LEVEL",
  namespace: "typeSpecRuntime"
});
var TypeSpecRuntimeLogger = context2.logger;
function setLogLevel(logLevel) {
  context2.setLogLevel(logLevel);
}
function createClientLogger(namespace) {
  return context2.createClientLogger(namespace);
}

// node_modules/@typespec/ts-http-runtime/dist/esm/httpHeaders.js
function normalizeName(name) {
  return name.toLowerCase();
}
function* headerIterator(map) {
  for (const entry of map.values()) {
    yield [entry.name, entry.value];
  }
}

class HttpHeadersImpl {
  constructor(rawHeaders) {
    this._headersMap = new Map;
    if (rawHeaders) {
      for (const headerName of Object.keys(rawHeaders)) {
        this.set(headerName, rawHeaders[headerName]);
      }
    }
  }
  set(name, value) {
    this._headersMap.set(normalizeName(name), { name, value: String(value).trim() });
  }
  get(name) {
    var _a;
    return (_a = this._headersMap.get(normalizeName(name))) === null || _a === undefined ? undefined : _a.value;
  }
  has(name) {
    return this._headersMap.has(normalizeName(name));
  }
  delete(name) {
    this._headersMap.delete(normalizeName(name));
  }
  toJSON(options = {}) {
    const result = {};
    if (options.preserveCase) {
      for (const entry of this._headersMap.values()) {
        result[entry.name] = entry.value;
      }
    } else {
      for (const [normalizedName, entry] of this._headersMap) {
        result[normalizedName] = entry.value;
      }
    }
    return result;
  }
  toString() {
    return JSON.stringify(this.toJSON({ preserveCase: true }));
  }
  [Symbol.iterator]() {
    return headerIterator(this._headersMap);
  }
}
function createHttpHeaders(rawHeaders) {
  return new HttpHeadersImpl(rawHeaders);
}
// node_modules/@typespec/ts-http-runtime/dist/esm/util/uuidUtils.js
import { randomUUID as v4RandomUUID } from "node:crypto";
var _a;
var uuidFunction = typeof ((_a = globalThis === null || globalThis === undefined ? undefined : globalThis.crypto) === null || _a === undefined ? undefined : _a.randomUUID) === "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : v4RandomUUID;
function randomUUID() {
  return uuidFunction();
}

// node_modules/@typespec/ts-http-runtime/dist/esm/pipelineRequest.js
class PipelineRequestImpl {
  constructor(options) {
    var _a2, _b, _c, _d, _e2, _f, _g;
    this.url = options.url;
    this.body = options.body;
    this.headers = (_a2 = options.headers) !== null && _a2 !== undefined ? _a2 : createHttpHeaders();
    this.method = (_b = options.method) !== null && _b !== undefined ? _b : "GET";
    this.timeout = (_c = options.timeout) !== null && _c !== undefined ? _c : 0;
    this.multipartBody = options.multipartBody;
    this.formData = options.formData;
    this.disableKeepAlive = (_d = options.disableKeepAlive) !== null && _d !== undefined ? _d : false;
    this.proxySettings = options.proxySettings;
    this.streamResponseStatusCodes = options.streamResponseStatusCodes;
    this.withCredentials = (_e2 = options.withCredentials) !== null && _e2 !== undefined ? _e2 : false;
    this.abortSignal = options.abortSignal;
    this.onUploadProgress = options.onUploadProgress;
    this.onDownloadProgress = options.onDownloadProgress;
    this.requestId = options.requestId || randomUUID();
    this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== undefined ? _f : false;
    this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== undefined ? _g : false;
    this.requestOverrides = options.requestOverrides;
  }
}
function createPipelineRequest(options) {
  return new PipelineRequestImpl(options);
}

// node_modules/@typespec/ts-http-runtime/dist/esm/pipeline.js
var ValidPhaseNames = new Set(["Deserialize", "Serialize", "Retry", "Sign"]);

class HttpPipeline {
  constructor(policies) {
    var _a2;
    this._policies = [];
    this._policies = (_a2 = policies === null || policies === undefined ? undefined : policies.slice(0)) !== null && _a2 !== undefined ? _a2 : [];
    this._orderedPolicies = undefined;
  }
  addPolicy(policy, options = {}) {
    if (options.phase && options.afterPhase) {
      throw new Error("Policies inside a phase cannot specify afterPhase.");
    }
    if (options.phase && !ValidPhaseNames.has(options.phase)) {
      throw new Error(`Invalid phase name: ${options.phase}`);
    }
    if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
      throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
    }
    this._policies.push({
      policy,
      options
    });
    this._orderedPolicies = undefined;
  }
  removePolicy(options) {
    const removedPolicies = [];
    this._policies = this._policies.filter((policyDescriptor) => {
      if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
        removedPolicies.push(policyDescriptor.policy);
        return false;
      } else {
        return true;
      }
    });
    this._orderedPolicies = undefined;
    return removedPolicies;
  }
  sendRequest(httpClient, request) {
    const policies = this.getOrderedPolicies();
    const pipeline = policies.reduceRight((next, policy) => {
      return (req) => {
        return policy.sendRequest(req, next);
      };
    }, (req) => httpClient.sendRequest(req));
    return pipeline(request);
  }
  getOrderedPolicies() {
    if (!this._orderedPolicies) {
      this._orderedPolicies = this.orderPolicies();
    }
    return this._orderedPolicies;
  }
  clone() {
    return new HttpPipeline(this._policies);
  }
  static create() {
    return new HttpPipeline;
  }
  orderPolicies() {
    const result = [];
    const policyMap = new Map;
    function createPhase(name) {
      return {
        name,
        policies: new Set,
        hasRun: false,
        hasAfterPolicies: false
      };
    }
    const serializePhase = createPhase("Serialize");
    const noPhase = createPhase("None");
    const deserializePhase = createPhase("Deserialize");
    const retryPhase = createPhase("Retry");
    const signPhase = createPhase("Sign");
    const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
    function getPhase(phase) {
      if (phase === "Retry") {
        return retryPhase;
      } else if (phase === "Serialize") {
        return serializePhase;
      } else if (phase === "Deserialize") {
        return deserializePhase;
      } else if (phase === "Sign") {
        return signPhase;
      } else {
        return noPhase;
      }
    }
    for (const descriptor of this._policies) {
      const policy = descriptor.policy;
      const options = descriptor.options;
      const policyName = policy.name;
      if (policyMap.has(policyName)) {
        throw new Error("Duplicate policy names not allowed in pipeline");
      }
      const node = {
        policy,
        dependsOn: new Set,
        dependants: new Set
      };
      if (options.afterPhase) {
        node.afterPhase = getPhase(options.afterPhase);
        node.afterPhase.hasAfterPolicies = true;
      }
      policyMap.set(policyName, node);
      const phase = getPhase(options.phase);
      phase.policies.add(node);
    }
    for (const descriptor of this._policies) {
      const { policy, options } = descriptor;
      const policyName = policy.name;
      const node = policyMap.get(policyName);
      if (!node) {
        throw new Error(`Missing node for policy ${policyName}`);
      }
      if (options.afterPolicies) {
        for (const afterPolicyName of options.afterPolicies) {
          const afterNode = policyMap.get(afterPolicyName);
          if (afterNode) {
            node.dependsOn.add(afterNode);
            afterNode.dependants.add(node);
          }
        }
      }
      if (options.beforePolicies) {
        for (const beforePolicyName of options.beforePolicies) {
          const beforeNode = policyMap.get(beforePolicyName);
          if (beforeNode) {
            beforeNode.dependsOn.add(node);
            node.dependants.add(beforeNode);
          }
        }
      }
    }
    function walkPhase(phase) {
      phase.hasRun = true;
      for (const node of phase.policies) {
        if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
          continue;
        }
        if (node.dependsOn.size === 0) {
          result.push(node.policy);
          for (const dependant of node.dependants) {
            dependant.dependsOn.delete(node);
          }
          policyMap.delete(node.policy.name);
          phase.policies.delete(node);
        }
      }
    }
    function walkPhases() {
      for (const phase of orderedPhases) {
        walkPhase(phase);
        if (phase.policies.size > 0 && phase !== noPhase) {
          if (!noPhase.hasRun) {
            walkPhase(noPhase);
          }
          return;
        }
        if (phase.hasAfterPolicies) {
          walkPhase(noPhase);
        }
      }
    }
    let iteration = 0;
    while (policyMap.size > 0) {
      iteration++;
      const initialResultLength = result.length;
      walkPhases();
      if (result.length <= initialResultLength && iteration > 1) {
        throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
      }
    }
    return result;
  }
}
function createEmptyPipeline() {
  return HttpPipeline.create();
}
// node_modules/@typespec/ts-http-runtime/dist/esm/util/object.js
function isObject(input) {
  return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
}

// node_modules/@typespec/ts-http-runtime/dist/esm/util/error.js
function isError(e2) {
  if (isObject(e2)) {
    const hasName = typeof e2.name === "string";
    const hasMessage = typeof e2.message === "string";
    return hasName && hasMessage;
  }
  return false;
}

// node_modules/@typespec/ts-http-runtime/dist/esm/util/inspect.js
import { inspect } from "node:util";
var custom = inspect.custom;

// node_modules/@typespec/ts-http-runtime/dist/esm/util/sanitizer.js
var RedactedString = "REDACTED";
var defaultAllowedHeaderNames = [
  "x-ms-client-request-id",
  "x-ms-return-client-request-id",
  "x-ms-useragent",
  "x-ms-correlation-request-id",
  "x-ms-request-id",
  "client-request-id",
  "ms-cv",
  "return-client-request-id",
  "traceparent",
  "Access-Control-Allow-Credentials",
  "Access-Control-Allow-Headers",
  "Access-Control-Allow-Methods",
  "Access-Control-Allow-Origin",
  "Access-Control-Expose-Headers",
  "Access-Control-Max-Age",
  "Access-Control-Request-Headers",
  "Access-Control-Request-Method",
  "Origin",
  "Accept",
  "Accept-Encoding",
  "Cache-Control",
  "Connection",
  "Content-Length",
  "Content-Type",
  "Date",
  "ETag",
  "Expires",
  "If-Match",
  "If-Modified-Since",
  "If-None-Match",
  "If-Unmodified-Since",
  "Last-Modified",
  "Pragma",
  "Request-Id",
  "Retry-After",
  "Server",
  "Transfer-Encoding",
  "User-Agent",
  "WWW-Authenticate"
];
var defaultAllowedQueryParameters = ["api-version"];

class Sanitizer {
  constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
    allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
    allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
    this.allowedHeaderNames = new Set(allowedHeaderNames.map((n2) => n2.toLowerCase()));
    this.allowedQueryParameters = new Set(allowedQueryParameters.map((p2) => p2.toLowerCase()));
  }
  sanitize(obj) {
    const seen = new Set;
    return JSON.stringify(obj, (key, value) => {
      if (value instanceof Error) {
        return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
      }
      if (key === "headers") {
        return this.sanitizeHeaders(value);
      } else if (key === "url") {
        return this.sanitizeUrl(value);
      } else if (key === "query") {
        return this.sanitizeQuery(value);
      } else if (key === "body") {
        return;
      } else if (key === "response") {
        return;
      } else if (key === "operationSpec") {
        return;
      } else if (Array.isArray(value) || isObject(value)) {
        if (seen.has(value)) {
          return "[Circular]";
        }
        seen.add(value);
      }
      return value;
    }, 2);
  }
  sanitizeUrl(value) {
    if (typeof value !== "string" || value === null || value === "") {
      return value;
    }
    const url = new URL(value);
    if (!url.search) {
      return value;
    }
    for (const [key] of url.searchParams) {
      if (!this.allowedQueryParameters.has(key.toLowerCase())) {
        url.searchParams.set(key, RedactedString);
      }
    }
    return url.toString();
  }
  sanitizeHeaders(obj) {
    const sanitized = {};
    for (const key of Object.keys(obj)) {
      if (this.allowedHeaderNames.has(key.toLowerCase())) {
        sanitized[key] = obj[key];
      } else {
        sanitized[key] = RedactedString;
      }
    }
    return sanitized;
  }
  sanitizeQuery(value) {
    if (typeof value !== "object" || value === null) {
      return value;
    }
    const sanitized = {};
    for (const k2 of Object.keys(value)) {
      if (this.allowedQueryParameters.has(k2.toLowerCase())) {
        sanitized[k2] = value[k2];
      } else {
        sanitized[k2] = RedactedString;
      }
    }
    return sanitized;
  }
}

// node_modules/@typespec/ts-http-runtime/dist/esm/restError.js
var errorSanitizer = new Sanitizer;

class RestError extends Error {
  constructor(message, options = {}) {
    super(message);
    this.name = "RestError";
    this.code = options.code;
    this.statusCode = options.statusCode;
    Object.defineProperty(this, "request", { value: options.request, enumerable: false });
    Object.defineProperty(this, "response", { value: options.response, enumerable: false });
    Object.defineProperty(this, custom, {
      value: () => {
        return `RestError: ${this.message} 
 ${errorSanitizer.sanitize(Object.assign(Object.assign({}, this), { request: this.request, response: this.response }))}`;
      },
      enumerable: false
    });
    Object.setPrototypeOf(this, RestError.prototype);
  }
}
RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
RestError.PARSE_ERROR = "PARSE_ERROR";
function isRestError(e2) {
  if (e2 instanceof RestError) {
    return true;
  }
  return isError(e2) && e2.name === "RestError";
}
// node_modules/@typespec/ts-http-runtime/dist/esm/util/bytesEncoding.js
function uint8ArrayToString(bytes, format5) {
  return Buffer.from(bytes).toString(format5);
}
function stringToUint8Array(value, format5) {
  return Buffer.from(value, format5);
}

// node_modules/@typespec/ts-http-runtime/dist/esm/nodeHttpClient.js
import * as http from "node:http";
import * as https from "node:https";
import * as zlib from "node:zlib";
import { Transform } from "node:stream";

// node_modules/@typespec/ts-http-runtime/dist/esm/log.js
var logger = createClientLogger("ts-http-runtime");

// node_modules/@typespec/ts-http-runtime/dist/esm/nodeHttpClient.js
var DEFAULT_TLS_SETTINGS = {};
function isReadableStream(body) {
  return body && typeof body.pipe === "function";
}
function isStreamComplete(stream) {
  if (stream.readable === false) {
    return Promise.resolve();
  }
  return new Promise((resolve5) => {
    const handler = () => {
      resolve5();
      stream.removeListener("close", handler);
      stream.removeListener("end", handler);
      stream.removeListener("error", handler);
    };
    stream.on("close", handler);
    stream.on("end", handler);
    stream.on("error", handler);
  });
}
function isArrayBuffer(body) {
  return body && typeof body.byteLength === "number";
}

class ReportTransform extends Transform {
  _transform(chunk, _encoding, callback) {
    this.push(chunk);
    this.loadedBytes += chunk.length;
    try {
      this.progressCallback({ loadedBytes: this.loadedBytes });
      callback();
    } catch (e2) {
      callback(e2);
    }
  }
  constructor(progressCallback) {
    super();
    this.loadedBytes = 0;
    this.progressCallback = progressCallback;
  }
}

class NodeHttpClient {
  constructor() {
    this.cachedHttpsAgents = new WeakMap;
  }
  async sendRequest(request3) {
    var _a2, _b, _c;
    const abortController = new AbortController;
    let abortListener;
    if (request3.abortSignal) {
      if (request3.abortSignal.aborted) {
        throw new AbortError("The operation was aborted. Request has already been canceled.");
      }
      abortListener = (event) => {
        if (event.type === "abort") {
          abortController.abort();
        }
      };
      request3.abortSignal.addEventListener("abort", abortListener);
    }
    let timeoutId;
    if (request3.timeout > 0) {
      timeoutId = setTimeout(() => {
        const sanitizer = new Sanitizer;
        logger.info(`request to '${sanitizer.sanitizeUrl(request3.url)}' timed out. canceling...`);
        abortController.abort();
      }, request3.timeout);
    }
    const acceptEncoding = request3.headers.get("Accept-Encoding");
    const shouldDecompress = (acceptEncoding === null || acceptEncoding === undefined ? undefined : acceptEncoding.includes("gzip")) || (acceptEncoding === null || acceptEncoding === undefined ? undefined : acceptEncoding.includes("deflate"));
    let body = typeof request3.body === "function" ? request3.body() : request3.body;
    if (body && !request3.headers.has("Content-Length")) {
      const bodyLength = getBodyLength(body);
      if (bodyLength !== null) {
        request3.headers.set("Content-Length", bodyLength);
      }
    }
    let responseStream;
    try {
      if (body && request3.onUploadProgress) {
        const onUploadProgress = request3.onUploadProgress;
        const uploadReportStream = new ReportTransform(onUploadProgress);
        uploadReportStream.on("error", (e2) => {
          logger.error("Error in upload progress", e2);
        });
        if (isReadableStream(body)) {
          body.pipe(uploadReportStream);
        } else {
          uploadReportStream.end(body);
        }
        body = uploadReportStream;
      }
      const res = await this.makeRequest(request3, abortController, body);
      if (timeoutId !== undefined) {
        clearTimeout(timeoutId);
      }
      const headers = getResponseHeaders(res);
      const status = (_a2 = res.statusCode) !== null && _a2 !== undefined ? _a2 : 0;
      const response = {
        status,
        headers,
        request: request3
      };
      if (request3.method === "HEAD") {
        res.resume();
        return response;
      }
      responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
      const onDownloadProgress = request3.onDownloadProgress;
      if (onDownloadProgress) {
        const downloadReportStream = new ReportTransform(onDownloadProgress);
        downloadReportStream.on("error", (e2) => {
          logger.error("Error in download progress", e2);
        });
        responseStream.pipe(downloadReportStream);
        responseStream = downloadReportStream;
      }
      if (((_b = request3.streamResponseStatusCodes) === null || _b === undefined ? undefined : _b.has(Number.POSITIVE_INFINITY)) || ((_c = request3.streamResponseStatusCodes) === null || _c === undefined ? undefined : _c.has(response.status))) {
        response.readableStreamBody = responseStream;
      } else {
        response.bodyAsText = await streamToText(responseStream);
      }
      return response;
    } finally {
      if (request3.abortSignal && abortListener) {
        let uploadStreamDone = Promise.resolve();
        if (isReadableStream(body)) {
          uploadStreamDone = isStreamComplete(body);
        }
        let downloadStreamDone = Promise.resolve();
        if (isReadableStream(responseStream)) {
          downloadStreamDone = isStreamComplete(responseStream);
        }
        Promise.all([uploadStreamDone, downloadStreamDone]).then(() => {
          var _a3;
          if (abortListener) {
            (_a3 = request3.abortSignal) === null || _a3 === undefined || _a3.removeEventListener("abort", abortListener);
          }
        }).catch((e2) => {
          logger.warning("Error when cleaning up abortListener on httpRequest", e2);
        });
      }
    }
  }
  makeRequest(request3, abortController, body) {
    var _a2;
    const url = new URL(request3.url);
    const isInsecure = url.protocol !== "https:";
    if (isInsecure && !request3.allowInsecureConnection) {
      throw new Error(`Cannot connect to ${request3.url} while allowInsecureConnection is false.`);
    }
    const agent = (_a2 = request3.agent) !== null && _a2 !== undefined ? _a2 : this.getOrCreateAgent(request3, isInsecure);
    const options = Object.assign({ agent, hostname: url.hostname, path: `${url.pathname}${url.search}`, port: url.port, method: request3.method, headers: request3.headers.toJSON({ preserveCase: true }) }, request3.requestOverrides);
    return new Promise((resolve5, reject) => {
      const req = isInsecure ? http.request(options, resolve5) : https.request(options, resolve5);
      req.once("error", (err) => {
        var _a3;
        reject(new RestError(err.message, { code: (_a3 = err.code) !== null && _a3 !== undefined ? _a3 : RestError.REQUEST_SEND_ERROR, request: request3 }));
      });
      abortController.signal.addEventListener("abort", () => {
        const abortError = new AbortError("The operation was aborted. Rejecting from abort signal callback while making request.");
        req.destroy(abortError);
        reject(abortError);
      });
      if (body && isReadableStream(body)) {
        body.pipe(req);
      } else if (body) {
        if (typeof body === "string" || Buffer.isBuffer(body)) {
          req.end(body);
        } else if (isArrayBuffer(body)) {
          req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
        } else {
          logger.error("Unrecognized body type", body);
          reject(new RestError("Unrecognized body type"));
        }
      } else {
        req.end();
      }
    });
  }
  getOrCreateAgent(request3, isInsecure) {
    var _a2;
    const disableKeepAlive = request3.disableKeepAlive;
    if (isInsecure) {
      if (disableKeepAlive) {
        return http.globalAgent;
      }
      if (!this.cachedHttpAgent) {
        this.cachedHttpAgent = new http.Agent({ keepAlive: true });
      }
      return this.cachedHttpAgent;
    } else {
      if (disableKeepAlive && !request3.tlsSettings) {
        return https.globalAgent;
      }
      const tlsSettings = (_a2 = request3.tlsSettings) !== null && _a2 !== undefined ? _a2 : DEFAULT_TLS_SETTINGS;
      let agent = this.cachedHttpsAgents.get(tlsSettings);
      if (agent && agent.options.keepAlive === !disableKeepAlive) {
        return agent;
      }
      logger.info("No cached TLS Agent exist, creating a new Agent");
      agent = new https.Agent(Object.assign({
        keepAlive: !disableKeepAlive
      }, tlsSettings));
      this.cachedHttpsAgents.set(tlsSettings, agent);
      return agent;
    }
  }
}
function getResponseHeaders(res) {
  const headers = createHttpHeaders();
  for (const header of Object.keys(res.headers)) {
    const value = res.headers[header];
    if (Array.isArray(value)) {
      if (value.length > 0) {
        headers.set(header, value[0]);
      }
    } else if (value) {
      headers.set(header, value);
    }
  }
  return headers;
}
function getDecodedResponseStream(stream, headers) {
  const contentEncoding = headers.get("Content-Encoding");
  if (contentEncoding === "gzip") {
    const unzip = zlib.createGunzip();
    stream.pipe(unzip);
    return unzip;
  } else if (contentEncoding === "deflate") {
    const inflate = zlib.createInflate();
    stream.pipe(inflate);
    return inflate;
  }
  return stream;
}
function streamToText(stream) {
  return new Promise((resolve5, reject) => {
    const buffer = [];
    stream.on("data", (chunk) => {
      if (Buffer.isBuffer(chunk)) {
        buffer.push(chunk);
      } else {
        buffer.push(Buffer.from(chunk));
      }
    });
    stream.on("end", () => {
      resolve5(Buffer.concat(buffer).toString("utf8"));
    });
    stream.on("error", (e2) => {
      if (e2 && (e2 === null || e2 === undefined ? undefined : e2.name) === "AbortError") {
        reject(e2);
      } else {
        reject(new RestError(`Error reading response as text: ${e2.message}`, {
          code: RestError.PARSE_ERROR
        }));
      }
    });
  });
}
function getBodyLength(body) {
  if (!body) {
    return 0;
  } else if (Buffer.isBuffer(body)) {
    return body.length;
  } else if (isReadableStream(body)) {
    return null;
  } else if (isArrayBuffer(body)) {
    return body.byteLength;
  } else if (typeof body === "string") {
    return Buffer.from(body).length;
  } else {
    return null;
  }
}
function createNodeHttpClient() {
  return new NodeHttpClient;
}

// node_modules/@typespec/ts-http-runtime/dist/esm/defaultHttpClient.js
function createDefaultHttpClient() {
  return createNodeHttpClient();
}

// node_modules/@typespec/ts-http-runtime/dist/esm/policies/logPolicy.js
var logPolicyName = "logPolicy";
function logPolicy(options = {}) {
  var _a2;
  const logger2 = (_a2 = options.logger) !== null && _a2 !== undefined ? _a2 : logger.info;
  const sanitizer = new Sanitizer({
    additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
  });
  return {
    name: logPolicyName,
    async sendRequest(request3, next) {
      if (!logger2.enabled) {
        return next(request3);
      }
      logger2(`Request: ${sanitizer.sanitize(request3)}`);
      const response = await next(request3);
      logger2(`Response status code: ${response.status}`);
      logger2(`Headers: ${sanitizer.sanitize(response.headers)}`);
      return response;
    }
  };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/policies/redirectPolicy.js
var redirectPolicyName = "redirectPolicy";
var allowedRedirect = ["GET", "HEAD"];
function redirectPolicy(options = {}) {
  const { maxRetries = 20 } = options;
  return {
    name: redirectPolicyName,
    async sendRequest(request3, next) {
      const response = await next(request3);
      return handleRedirect(next, response, maxRetries);
    }
  };
}
async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
  const { request: request3, status, headers } = response;
  const locationHeader = headers.get("location");
  if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request3.method) || status === 302 && allowedRedirect.includes(request3.method) || status === 303 && request3.method === "POST" || status === 307) && currentRetries < maxRetries) {
    const url = new URL(locationHeader, request3.url);
    request3.url = url.toString();
    if (status === 303) {
      request3.method = "GET";
      request3.headers.delete("Content-Length");
      delete request3.body;
    }
    request3.headers.delete("Authorization");
    const res = await next(request3);
    return handleRedirect(next, res, maxRetries, currentRetries + 1);
  }
  return response;
}

// node_modules/@typespec/ts-http-runtime/dist/esm/util/userAgentPlatform.js
import * as os from "node:os";
import * as process3 from "node:process";
function getHeaderName() {
  return "User-Agent";
}
async function setPlatformSpecificData(map) {
  if (process3 && process3.versions) {
    const versions2 = process3.versions;
    if (versions2.bun) {
      map.set("Bun", versions2.bun);
    } else if (versions2.deno) {
      map.set("Deno", versions2.deno);
    } else if (versions2.node) {
      map.set("Node", versions2.node);
    }
  }
  map.set("OS", `(${os.arch()}-${os.type()}-${os.release()})`);
}

// node_modules/@typespec/ts-http-runtime/dist/esm/constants.js
var SDK_VERSION = "0.2.2";
var DEFAULT_RETRY_POLICY_COUNT = 3;

// node_modules/@typespec/ts-http-runtime/dist/esm/util/userAgent.js
function getUserAgentString(telemetryInfo) {
  const parts = [];
  for (const [key, value] of telemetryInfo) {
    const token = value ? `${key}/${value}` : key;
    parts.push(token);
  }
  return parts.join(" ");
}
function getUserAgentHeaderName() {
  return getHeaderName();
}
async function getUserAgentValue(prefix) {
  const runtimeInfo = new Map;
  runtimeInfo.set("ts-http-runtime", SDK_VERSION);
  await setPlatformSpecificData(runtimeInfo);
  const defaultAgent = getUserAgentString(runtimeInfo);
  const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
  return userAgentValue;
}

// node_modules/@typespec/ts-http-runtime/dist/esm/policies/userAgentPolicy.js
var UserAgentHeaderName = getUserAgentHeaderName();
var userAgentPolicyName = "userAgentPolicy";
function userAgentPolicy(options = {}) {
  const userAgentValue = getUserAgentValue(options.userAgentPrefix);
  return {
    name: userAgentPolicyName,
    async sendRequest(request3, next) {
      if (!request3.headers.has(UserAgentHeaderName)) {
        request3.headers.set(UserAgentHeaderName, await userAgentValue);
      }
      return next(request3);
    }
  };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/policies/decompressResponsePolicy.js
var decompressResponsePolicyName = "decompressResponsePolicy";
function decompressResponsePolicy() {
  return {
    name: decompressResponsePolicyName,
    async sendRequest(request3, next) {
      if (request3.method !== "HEAD") {
        request3.headers.set("Accept-Encoding", "gzip,deflate");
      }
      return next(request3);
    }
  };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/util/random.js
function getRandomIntegerInclusive(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  const offset = Math.floor(Math.random() * (max - min + 1));
  return offset + min;
}

// node_modules/@typespec/ts-http-runtime/dist/esm/util/delay.js
function calculateRetryDelay(retryAttempt, config) {
  const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
  const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
  const retryAfterInMs = clampedDelay / 2 + getRandomIntegerInclusive(0, clampedDelay / 2);
  return { retryAfterInMs };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/util/helpers.js
var StandardAbortMessage = "The operation was aborted.";
function delay(delayInMs, value, options) {
  return new Promise((resolve5, reject) => {
    let timer = undefined;
    let onAborted = undefined;
    const rejectOnAbort = () => {
      return reject(new AbortError((options === null || options === undefined ? undefined : options.abortErrorMsg) ? options === null || options === undefined ? undefined : options.abortErrorMsg : StandardAbortMessage));
    };
    const removeListeners = () => {
      if ((options === null || options === undefined ? undefined : options.abortSignal) && onAborted) {
        options.abortSignal.removeEventListener("abort", onAborted);
      }
    };
    onAborted = () => {
      if (timer) {
        clearTimeout(timer);
      }
      removeListeners();
      return rejectOnAbort();
    };
    if ((options === null || options === undefined ? undefined : options.abortSignal) && options.abortSignal.aborted) {
      return rejectOnAbort();
    }
    timer = setTimeout(() => {
      removeListeners();
      resolve5(value);
    }, delayInMs);
    if (options === null || options === undefined ? undefined : options.abortSignal) {
      options.abortSignal.addEventListener("abort", onAborted);
    }
  });
}
function parseHeaderValueAsNumber(response, headerName) {
  const value = response.headers.get(headerName);
  if (!value)
    return;
  const valueAsNum = Number(value);
  if (Number.isNaN(valueAsNum))
    return;
  return valueAsNum;
}

// node_modules/@typespec/ts-http-runtime/dist/esm/retryStrategies/throttlingRetryStrategy.js
var RetryAfterHeader = "Retry-After";
var AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
function getRetryAfterInMs(response) {
  if (!(response && [429, 503].includes(response.status)))
    return;
  try {
    for (const header of AllRetryAfterHeaders) {
      const retryAfterValue = parseHeaderValueAsNumber(response, header);
      if (retryAfterValue === 0 || retryAfterValue) {
        const multiplyingFactor = header === RetryAfterHeader ? 1000 : 1;
        return retryAfterValue * multiplyingFactor;
      }
    }
    const retryAfterHeader = response.headers.get(RetryAfterHeader);
    if (!retryAfterHeader)
      return;
    const date = Date.parse(retryAfterHeader);
    const diff = date - Date.now();
    return Number.isFinite(diff) ? Math.max(0, diff) : undefined;
  } catch (_a2) {
    return;
  }
}
function isThrottlingRetryResponse(response) {
  return Number.isFinite(getRetryAfterInMs(response));
}
function throttlingRetryStrategy() {
  return {
    name: "throttlingRetryStrategy",
    retry({ response }) {
      const retryAfterInMs = getRetryAfterInMs(response);
      if (!Number.isFinite(retryAfterInMs)) {
        return { skipStrategy: true };
      }
      return {
        retryAfterInMs
      };
    }
  };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/retryStrategies/exponentialRetryStrategy.js
var DEFAULT_CLIENT_RETRY_INTERVAL = 1000;
var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;
function exponentialRetryStrategy(options = {}) {
  var _a2, _b;
  const retryInterval = (_a2 = options.retryDelayInMs) !== null && _a2 !== undefined ? _a2 : DEFAULT_CLIENT_RETRY_INTERVAL;
  const maxRetryInterval = (_b = options.maxRetryDelayInMs) !== null && _b !== undefined ? _b : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
  return {
    name: "exponentialRetryStrategy",
    retry({ retryCount, response, responseError }) {
      const matchedSystemError = isSystemError(responseError);
      const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
      const isExponential = isExponentialRetryResponse(response);
      const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
      const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);
      if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
        return { skipStrategy: true };
      }
      if (responseError && !matchedSystemError && !isExponential) {
        return { errorToThrow: responseError };
      }
      return calculateRetryDelay(retryCount, {
        retryDelayInMs: retryInterval,
        maxRetryDelayInMs: maxRetryInterval
      });
    }
  };
}
function isExponentialRetryResponse(response) {
  return Boolean(response && response.status !== undefined && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
}
function isSystemError(err) {
  if (!err) {
    return false;
  }
  return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" || err.code === "ENOTFOUND";
}

// node_modules/@typespec/ts-http-runtime/dist/esm/policies/retryPolicy.js
var retryPolicyLogger = createClientLogger("ts-http-runtime retryPolicy");
var retryPolicyName = "retryPolicy";
function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {
  const logger2 = options.logger || retryPolicyLogger;
  return {
    name: retryPolicyName,
    async sendRequest(request3, next) {
      var _a2, _b;
      let response;
      let responseError;
      let retryCount = -1;
      retryRequest:
        while (true) {
          retryCount += 1;
          response = undefined;
          responseError = undefined;
          try {
            logger2.info(`Retry ${retryCount}: Attempting to send request`, request3.requestId);
            response = await next(request3);
            logger2.info(`Retry ${retryCount}: Received a response from request`, request3.requestId);
          } catch (e2) {
            logger2.error(`Retry ${retryCount}: Received an error from request`, request3.requestId);
            responseError = e2;
            if (!e2 || responseError.name !== "RestError") {
              throw e2;
            }
            response = responseError.response;
          }
          if ((_a2 = request3.abortSignal) === null || _a2 === undefined ? undefined : _a2.aborted) {
            logger2.error(`Retry ${retryCount}: Request aborted.`);
            const abortError = new AbortError;
            throw abortError;
          }
          if (retryCount >= ((_b = options.maxRetries) !== null && _b !== undefined ? _b : DEFAULT_RETRY_POLICY_COUNT)) {
            logger2.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
            if (responseError) {
              throw responseError;
            } else if (response) {
              return response;
            } else {
              throw new Error("Maximum retries reached with no response or error to throw");
            }
          }
          logger2.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
          strategiesLoop:
            for (const strategy of strategies) {
              const strategyLogger = strategy.logger || logger2;
              strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
              const modifiers = strategy.retry({
                retryCount,
                response,
                responseError
              });
              if (modifiers.skipStrategy) {
                strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                continue strategiesLoop;
              }
              const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
              if (errorToThrow) {
                strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                throw errorToThrow;
              }
              if (retryAfterInMs || retryAfterInMs === 0) {
                strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                await delay(retryAfterInMs, undefined, { abortSignal: request3.abortSignal });
                continue retryRequest;
              }
              if (redirectTo) {
                strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                request3.url = redirectTo;
                continue retryRequest;
              }
            }
          if (responseError) {
            logger2.info(`None of the retry strategies could work with the received error. Throwing it.`);
            throw responseError;
          }
          if (response) {
            logger2.info(`None of the retry strategies could work with the received response. Returning it.`);
            return response;
          }
        }
    }
  };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/policies/defaultRetryPolicy.js
var defaultRetryPolicyName = "defaultRetryPolicy";
function defaultRetryPolicy(options = {}) {
  var _a2;
  return {
    name: defaultRetryPolicyName,
    sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {
      maxRetries: (_a2 = options.maxRetries) !== null && _a2 !== undefined ? _a2 : DEFAULT_RETRY_POLICY_COUNT
    }).sendRequest
  };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/util/checkEnvironment.js
var _a2;
var _b;
var _c;
var _d;
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var isWebWorker = typeof self === "object" && typeof (self === null || self === undefined ? undefined : self.importScripts) === "function" && (((_a2 = self.constructor) === null || _a2 === undefined ? undefined : _a2.name) === "DedicatedWorkerGlobalScope" || ((_b = self.constructor) === null || _b === undefined ? undefined : _b.name) === "ServiceWorkerGlobalScope" || ((_c = self.constructor) === null || _c === undefined ? undefined : _c.name) === "SharedWorkerGlobalScope");
var isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
var isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
var isNodeLike = typeof globalThis.process !== "undefined" && Boolean(globalThis.process.version) && Boolean((_d = globalThis.process.versions) === null || _d === undefined ? undefined : _d.node);
var isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === undefined ? undefined : navigator.product) === "ReactNative";

// node_modules/@typespec/ts-http-runtime/dist/esm/policies/formDataPolicy.js
var formDataPolicyName = "formDataPolicy";
function formDataToFormDataMap(formData) {
  var _a3;
  const formDataMap = {};
  for (const [key, value] of formData.entries()) {
    (_a3 = formDataMap[key]) !== null && _a3 !== undefined || (formDataMap[key] = []);
    formDataMap[key].push(value);
  }
  return formDataMap;
}
function formDataPolicy() {
  return {
    name: formDataPolicyName,
    async sendRequest(request3, next) {
      if (isNodeLike && typeof FormData !== "undefined" && request3.body instanceof FormData) {
        request3.formData = formDataToFormDataMap(request3.body);
        request3.body = undefined;
      }
      if (request3.formData) {
        const contentType = request3.headers.get("Content-Type");
        if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
          request3.body = wwwFormUrlEncode(request3.formData);
        } else {
          await prepareFormData(request3.formData, request3);
        }
        request3.formData = undefined;
      }
      return next(request3);
    }
  };
}
function wwwFormUrlEncode(formData) {
  const urlSearchParams = new URLSearchParams;
  for (const [key, value] of Object.entries(formData)) {
    if (Array.isArray(value)) {
      for (const subValue of value) {
        urlSearchParams.append(key, subValue.toString());
      }
    } else {
      urlSearchParams.append(key, value.toString());
    }
  }
  return urlSearchParams.toString();
}
async function prepareFormData(formData, request3) {
  const contentType = request3.headers.get("Content-Type");
  if (contentType && !contentType.startsWith("multipart/form-data")) {
    return;
  }
  request3.headers.set("Content-Type", contentType !== null && contentType !== undefined ? contentType : "multipart/form-data");
  const parts = [];
  for (const [fieldName, values] of Object.entries(formData)) {
    for (const value of Array.isArray(values) ? values : [values]) {
      if (typeof value === "string") {
        parts.push({
          headers: createHttpHeaders({
            "Content-Disposition": `form-data; name="${fieldName}"`
          }),
          body: stringToUint8Array(value, "utf-8")
        });
      } else if (value === undefined || value === null || typeof value !== "object") {
        throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);
      } else {
        const fileName = value.name || "blob";
        const headers = createHttpHeaders();
        headers.set("Content-Disposition", `form-data; name="${fieldName}"; filename="${fileName}"`);
        headers.set("Content-Type", value.type || "application/octet-stream");
        parts.push({
          headers,
          body: value
        });
      }
    }
  }
  request3.multipartBody = { parts };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/policies/proxyPolicy.js
var import_https_proxy_agent = __toESM(require_dist5(), 1);
var import_http_proxy_agent = __toESM(require_dist6(), 1);
var HTTPS_PROXY = "HTTPS_PROXY";
var HTTP_PROXY = "HTTP_PROXY";
var ALL_PROXY = "ALL_PROXY";
var NO_PROXY = "NO_PROXY";
var proxyPolicyName = "proxyPolicy";
var globalNoProxyList = [];
var noProxyListLoaded = false;
var globalBypassedMap = new Map;
function getEnvironmentValue(name) {
  if (process.env[name]) {
    return process.env[name];
  } else if (process.env[name.toLowerCase()]) {
    return process.env[name.toLowerCase()];
  }
  return;
}
function loadEnvironmentProxyValue() {
  if (!process) {
    return;
  }
  const httpsProxy = getEnvironmentValue(HTTPS_PROXY);
  const allProxy = getEnvironmentValue(ALL_PROXY);
  const httpProxy = getEnvironmentValue(HTTP_PROXY);
  return httpsProxy || allProxy || httpProxy;
}
function isBypassed(uri, noProxyList, bypassedMap) {
  if (noProxyList.length === 0) {
    return false;
  }
  const host = new URL(uri).hostname;
  if (bypassedMap === null || bypassedMap === undefined ? undefined : bypassedMap.has(host)) {
    return bypassedMap.get(host);
  }
  let isBypassedFlag = false;
  for (const pattern of noProxyList) {
    if (pattern[0] === ".") {
      if (host.endsWith(pattern)) {
        isBypassedFlag = true;
      } else {
        if (host.length === pattern.length - 1 && host === pattern.slice(1)) {
          isBypassedFlag = true;
        }
      }
    } else {
      if (host === pattern) {
        isBypassedFlag = true;
      }
    }
  }
  bypassedMap === null || bypassedMap === undefined || bypassedMap.set(host, isBypassedFlag);
  return isBypassedFlag;
}
function loadNoProxy() {
  const noProxy = getEnvironmentValue(NO_PROXY);
  noProxyListLoaded = true;
  if (noProxy) {
    return noProxy.split(",").map((item) => item.trim()).filter((item) => item.length);
  }
  return [];
}
function getDefaultProxySettingsInternal() {
  const envProxy = loadEnvironmentProxyValue();
  return envProxy ? new URL(envProxy) : undefined;
}
function getUrlFromProxySettings(settings) {
  let parsedProxyUrl;
  try {
    parsedProxyUrl = new URL(settings.host);
  } catch (_a3) {
    throw new Error(`Expecting a valid host string in proxy settings, but found "${settings.host}".`);
  }
  parsedProxyUrl.port = String(settings.port);
  if (settings.username) {
    parsedProxyUrl.username = settings.username;
  }
  if (settings.password) {
    parsedProxyUrl.password = settings.password;
  }
  return parsedProxyUrl;
}
function setProxyAgentOnRequest(request3, cachedAgents, proxyUrl) {
  if (request3.agent) {
    return;
  }
  const url = new URL(request3.url);
  const isInsecure = url.protocol !== "https:";
  if (request3.tlsSettings) {
    logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
  }
  const headers = request3.headers.toJSON();
  if (isInsecure) {
    if (!cachedAgents.httpProxyAgent) {
      cachedAgents.httpProxyAgent = new import_http_proxy_agent.HttpProxyAgent(proxyUrl, { headers });
    }
    request3.agent = cachedAgents.httpProxyAgent;
  } else {
    if (!cachedAgents.httpsProxyAgent) {
      cachedAgents.httpsProxyAgent = new import_https_proxy_agent.HttpsProxyAgent(proxyUrl, { headers });
    }
    request3.agent = cachedAgents.httpsProxyAgent;
  }
}
function proxyPolicy(proxySettings, options) {
  if (!noProxyListLoaded) {
    globalNoProxyList.push(...loadNoProxy());
  }
  const defaultProxy = proxySettings ? getUrlFromProxySettings(proxySettings) : getDefaultProxySettingsInternal();
  const cachedAgents = {};
  return {
    name: proxyPolicyName,
    async sendRequest(request3, next) {
      var _a3;
      if (!request3.proxySettings && defaultProxy && !isBypassed(request3.url, (_a3 = options === null || options === undefined ? undefined : options.customNoProxyList) !== null && _a3 !== undefined ? _a3 : globalNoProxyList, (options === null || options === undefined ? undefined : options.customNoProxyList) ? undefined : globalBypassedMap)) {
        setProxyAgentOnRequest(request3, cachedAgents, defaultProxy);
      } else if (request3.proxySettings) {
        setProxyAgentOnRequest(request3, cachedAgents, getUrlFromProxySettings(request3.proxySettings));
      }
      return next(request3);
    }
  };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/policies/agentPolicy.js
var agentPolicyName = "agentPolicy";
function agentPolicy(agent) {
  return {
    name: agentPolicyName,
    sendRequest: async (req, next) => {
      if (!req.agent) {
        req.agent = agent;
      }
      return next(req);
    }
  };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/policies/tlsPolicy.js
var tlsPolicyName = "tlsPolicy";
function tlsPolicy(tlsSettings) {
  return {
    name: tlsPolicyName,
    sendRequest: async (req, next) => {
      if (!req.tlsSettings) {
        req.tlsSettings = tlsSettings;
      }
      return next(req);
    }
  };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/util/typeGuards.js
function isNodeReadableStream(x2) {
  return Boolean(x2 && typeof x2["pipe"] === "function");
}
function isWebReadableStream(x2) {
  return Boolean(x2 && typeof x2.getReader === "function" && typeof x2.tee === "function");
}
function isBinaryBody(body) {
  return body !== undefined && (body instanceof Uint8Array || isReadableStream2(body) || typeof body === "function" || body instanceof Blob);
}
function isReadableStream2(x2) {
  return isNodeReadableStream(x2) || isWebReadableStream(x2);
}
function isBlob(x2) {
  return typeof x2.stream === "function";
}

// node_modules/@typespec/ts-http-runtime/dist/esm/util/concat.js
import { Readable } from "stream";
function streamAsyncIterator() {
  return __asyncGenerator(this, arguments, function* streamAsyncIterator_1() {
    const reader = this.getReader();
    try {
      while (true) {
        const { done, value } = yield __await(reader.read());
        if (done) {
          return yield __await(undefined);
        }
        yield yield __await(value);
      }
    } finally {
      reader.releaseLock();
    }
  });
}
function makeAsyncIterable(webStream) {
  if (!webStream[Symbol.asyncIterator]) {
    webStream[Symbol.asyncIterator] = streamAsyncIterator.bind(webStream);
  }
  if (!webStream.values) {
    webStream.values = streamAsyncIterator.bind(webStream);
  }
}
function ensureNodeStream(stream) {
  if (stream instanceof ReadableStream) {
    makeAsyncIterable(stream);
    return Readable.fromWeb(stream);
  } else {
    return stream;
  }
}
function toStream(source) {
  if (source instanceof Uint8Array) {
    return Readable.from(Buffer.from(source));
  } else if (isBlob(source)) {
    return ensureNodeStream(source.stream());
  } else {
    return ensureNodeStream(source);
  }
}
async function concat(sources) {
  return function() {
    const streams = sources.map((x2) => typeof x2 === "function" ? x2() : x2).map(toStream);
    return Readable.from(function() {
      return __asyncGenerator(this, arguments, function* () {
        var _a3, e_1, _b2, _c2;
        for (const stream of streams) {
          try {
            for (var _d2 = true, stream_1 = (e_1 = undefined, __asyncValues(stream)), stream_1_1;stream_1_1 = yield __await(stream_1.next()), _a3 = stream_1_1.done, !_a3; _d2 = true) {
              _c2 = stream_1_1.value;
              _d2 = false;
              const chunk = _c2;
              yield yield __await(chunk);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d2 && !_a3 && (_b2 = stream_1.return))
                yield __await(_b2.call(stream_1));
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    }());
  };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/policies/multipartPolicy.js
function generateBoundary() {
  return `----AzSDKFormBoundary${randomUUID()}`;
}
function encodeHeaders(headers) {
  let result = "";
  for (const [key, value] of headers) {
    result += `${key}: ${value}\r
`;
  }
  return result;
}
function getLength(source) {
  if (source instanceof Uint8Array) {
    return source.byteLength;
  } else if (isBlob(source)) {
    return source.size === -1 ? undefined : source.size;
  } else {
    return;
  }
}
function getTotalLength(sources) {
  let total = 0;
  for (const source of sources) {
    const partLength = getLength(source);
    if (partLength === undefined) {
      return;
    } else {
      total += partLength;
    }
  }
  return total;
}
async function buildRequestBody(request3, parts, boundary) {
  const sources = [
    stringToUint8Array(`--${boundary}`, "utf-8"),
    ...parts.flatMap((part) => [
      stringToUint8Array(`\r
`, "utf-8"),
      stringToUint8Array(encodeHeaders(part.headers), "utf-8"),
      stringToUint8Array(`\r
`, "utf-8"),
      part.body,
      stringToUint8Array(`\r
--${boundary}`, "utf-8")
    ]),
    stringToUint8Array(`--\r
\r
`, "utf-8")
  ];
  const contentLength = getTotalLength(sources);
  if (contentLength) {
    request3.headers.set("Content-Length", contentLength);
  }
  request3.body = await concat(sources);
}
var multipartPolicyName = "multipartPolicy";
var maxBoundaryLength = 70;
var validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);
function assertValidBoundary(boundary) {
  if (boundary.length > maxBoundaryLength) {
    throw new Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
  }
  if (Array.from(boundary).some((x2) => !validBoundaryCharacters.has(x2))) {
    throw new Error(`Multipart boundary "${boundary}" contains invalid characters`);
  }
}
function multipartPolicy() {
  return {
    name: multipartPolicyName,
    async sendRequest(request3, next) {
      var _a3;
      if (!request3.multipartBody) {
        return next(request3);
      }
      if (request3.body) {
        throw new Error("multipartBody and regular body cannot be set at the same time");
      }
      let boundary = request3.multipartBody.boundary;
      const contentTypeHeader = (_a3 = request3.headers.get("Content-Type")) !== null && _a3 !== undefined ? _a3 : "multipart/mixed";
      const parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
      if (!parsedHeader) {
        throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);
      }
      const [, contentType, parsedBoundary] = parsedHeader;
      if (parsedBoundary && boundary && parsedBoundary !== boundary) {
        throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);
      }
      boundary !== null && boundary !== undefined || (boundary = parsedBoundary);
      if (boundary) {
        assertValidBoundary(boundary);
      } else {
        boundary = generateBoundary();
      }
      request3.headers.set("Content-Type", `${contentType}; boundary=${boundary}`);
      await buildRequestBody(request3, request3.multipartBody.parts, boundary);
      request3.multipartBody = undefined;
      return next(request3);
    }
  };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/createPipelineFromOptions.js
function createPipelineFromOptions(options) {
  const pipeline = createEmptyPipeline();
  if (isNodeLike) {
    if (options.agent) {
      pipeline.addPolicy(agentPolicy(options.agent));
    }
    if (options.tlsOptions) {
      pipeline.addPolicy(tlsPolicy(options.tlsOptions));
    }
    pipeline.addPolicy(proxyPolicy(options.proxyOptions));
    pipeline.addPolicy(decompressResponsePolicy());
  }
  pipeline.addPolicy(formDataPolicy(), { beforePolicies: [multipartPolicyName] });
  pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));
  pipeline.addPolicy(multipartPolicy(), { afterPhase: "Deserialize" });
  pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: "Retry" });
  if (isNodeLike) {
    pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: "Retry" });
  }
  pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: "Sign" });
  return pipeline;
}

// node_modules/@typespec/ts-http-runtime/dist/esm/client/apiVersionPolicy.js
var apiVersionPolicyName = "ApiVersionPolicy";
function apiVersionPolicy(options) {
  return {
    name: apiVersionPolicyName,
    sendRequest: (req, next) => {
      const url = new URL(req.url);
      if (!url.searchParams.get("api-version") && options.apiVersion) {
        req.url = `${req.url}${Array.from(url.searchParams.keys()).length > 0 ? "&" : "?"}api-version=${options.apiVersion}`;
      }
      return next(req);
    }
  };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/auth/credentials.js
function isOAuth2TokenCredential(credential) {
  return "getOAuth2Token" in credential;
}
function isBearerTokenCredential(credential) {
  return "getBearerToken" in credential;
}
function isBasicCredential(credential) {
  return "username" in credential && "password" in credential;
}
function isApiKeyCredential(credential) {
  return "key" in credential;
}

// node_modules/@typespec/ts-http-runtime/dist/esm/policies/auth/checkInsecureConnection.js
var insecureConnectionWarningEmmitted = false;
function allowInsecureConnection(request3, options) {
  if (options.allowInsecureConnection && request3.allowInsecureConnection) {
    const url = new URL(request3.url);
    if (url.hostname === "localhost" || url.hostname === "127.0.0.1") {
      return true;
    }
  }
  return false;
}
function emitInsecureConnectionWarning() {
  const warning = "Sending token over insecure transport. Assume any token issued is compromised.";
  logger.warning(warning);
  if (typeof (process === null || process === undefined ? undefined : process.emitWarning) === "function" && !insecureConnectionWarningEmmitted) {
    insecureConnectionWarningEmmitted = true;
    process.emitWarning(warning);
  }
}
function ensureSecureConnection(request3, options) {
  if (!request3.url.toLowerCase().startsWith("https://")) {
    if (allowInsecureConnection(request3, options)) {
      emitInsecureConnectionWarning();
    } else {
      throw new Error("Authentication is not permitted for non-TLS protected (non-https) URLs when allowInsecureConnection is false.");
    }
  }
}

// node_modules/@typespec/ts-http-runtime/dist/esm/policies/auth/apiKeyAuthenticationPolicy.js
var apiKeyAuthenticationPolicyName = "apiKeyAuthenticationPolicy";
function apiKeyAuthenticationPolicy(options) {
  return {
    name: apiKeyAuthenticationPolicyName,
    async sendRequest(request3, next) {
      var _a3, _b2;
      ensureSecureConnection(request3, options);
      const scheme = (_b2 = (_a3 = request3.authSchemes) !== null && _a3 !== undefined ? _a3 : options.authSchemes) === null || _b2 === undefined ? undefined : _b2.find((x2) => x2.kind === "apiKey");
      if (!scheme) {
        return next(request3);
      }
      if (scheme.apiKeyLocation !== "header") {
        throw new Error(`Unsupported API key location: ${scheme.apiKeyLocation}`);
      }
      request3.headers.set(scheme.name, options.credential.key);
      return next(request3);
    }
  };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/policies/auth/basicAuthenticationPolicy.js
var basicAuthenticationPolicyName = "bearerAuthenticationPolicy";
function basicAuthenticationPolicy(options) {
  return {
    name: basicAuthenticationPolicyName,
    async sendRequest(request3, next) {
      var _a3, _b2;
      ensureSecureConnection(request3, options);
      const scheme = (_b2 = (_a3 = request3.authSchemes) !== null && _a3 !== undefined ? _a3 : options.authSchemes) === null || _b2 === undefined ? undefined : _b2.find((x2) => x2.kind === "http" && x2.scheme === "basic");
      if (!scheme) {
        return next(request3);
      }
      const { username, password } = options.credential;
      const headerValue = uint8ArrayToString(stringToUint8Array(`${username}:${password}`, "utf-8"), "base64");
      request3.headers.set("Authorization", `Basic ${headerValue}`);
      return next(request3);
    }
  };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/policies/auth/bearerAuthenticationPolicy.js
var bearerAuthenticationPolicyName = "bearerAuthenticationPolicy";
function bearerAuthenticationPolicy(options) {
  return {
    name: bearerAuthenticationPolicyName,
    async sendRequest(request3, next) {
      var _a3, _b2;
      ensureSecureConnection(request3, options);
      const scheme = (_b2 = (_a3 = request3.authSchemes) !== null && _a3 !== undefined ? _a3 : options.authSchemes) === null || _b2 === undefined ? undefined : _b2.find((x2) => x2.kind === "http" && x2.scheme === "bearer");
      if (!scheme) {
        return next(request3);
      }
      const token = await options.credential.getBearerToken({
        abortSignal: request3.abortSignal
      });
      request3.headers.set("Authorization", `Bearer ${token}`);
      return next(request3);
    }
  };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/policies/auth/oauth2AuthenticationPolicy.js
var oauth2AuthenticationPolicyName = "oauth2AuthenticationPolicy";
function oauth2AuthenticationPolicy(options) {
  return {
    name: oauth2AuthenticationPolicyName,
    async sendRequest(request3, next) {
      var _a3, _b2;
      ensureSecureConnection(request3, options);
      const scheme = (_b2 = (_a3 = request3.authSchemes) !== null && _a3 !== undefined ? _a3 : options.authSchemes) === null || _b2 === undefined ? undefined : _b2.find((x2) => x2.kind === "oauth2");
      if (!scheme) {
        return next(request3);
      }
      const token = await options.credential.getOAuth2Token(scheme.flows, {
        abortSignal: request3.abortSignal
      });
      request3.headers.set("Authorization", `Bearer ${token}`);
      return next(request3);
    }
  };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/client/clientHelpers.js
var cachedHttpClient;
function createDefaultPipeline(options = {}) {
  const pipeline = createPipelineFromOptions(options);
  pipeline.addPolicy(apiVersionPolicy(options));
  const { credential, authSchemes, allowInsecureConnection: allowInsecureConnection2 } = options;
  if (credential) {
    if (isApiKeyCredential(credential)) {
      pipeline.addPolicy(apiKeyAuthenticationPolicy({ authSchemes, credential, allowInsecureConnection: allowInsecureConnection2 }));
    } else if (isBasicCredential(credential)) {
      pipeline.addPolicy(basicAuthenticationPolicy({ authSchemes, credential, allowInsecureConnection: allowInsecureConnection2 }));
    } else if (isBearerTokenCredential(credential)) {
      pipeline.addPolicy(bearerAuthenticationPolicy({ authSchemes, credential, allowInsecureConnection: allowInsecureConnection2 }));
    } else if (isOAuth2TokenCredential(credential)) {
      pipeline.addPolicy(oauth2AuthenticationPolicy({ authSchemes, credential, allowInsecureConnection: allowInsecureConnection2 }));
    }
  }
  return pipeline;
}
function getCachedDefaultHttpsClient() {
  if (!cachedHttpClient) {
    cachedHttpClient = createDefaultHttpClient();
  }
  return cachedHttpClient;
}

// node_modules/@typespec/ts-http-runtime/dist/esm/client/multipart.js
function getHeaderValue(descriptor, headerName) {
  if (descriptor.headers) {
    const actualHeaderName = Object.keys(descriptor.headers).find((x2) => x2.toLowerCase() === headerName.toLowerCase());
    if (actualHeaderName) {
      return descriptor.headers[actualHeaderName];
    }
  }
  return;
}
function getPartContentType(descriptor) {
  const contentTypeHeader = getHeaderValue(descriptor, "content-type");
  if (contentTypeHeader) {
    return contentTypeHeader;
  }
  if (descriptor.contentType === null) {
    return;
  }
  if (descriptor.contentType) {
    return descriptor.contentType;
  }
  const { body } = descriptor;
  if (body === null || body === undefined) {
    return;
  }
  if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") {
    return "text/plain; charset=UTF-8";
  }
  if (body instanceof Blob) {
    return body.type || "application/octet-stream";
  }
  if (isBinaryBody(body)) {
    return "application/octet-stream";
  }
  return "application/json";
}
function escapeDispositionField(value) {
  return JSON.stringify(value);
}
function getContentDisposition(descriptor) {
  var _a3;
  const contentDispositionHeader = getHeaderValue(descriptor, "content-disposition");
  if (contentDispositionHeader) {
    return contentDispositionHeader;
  }
  if (descriptor.dispositionType === undefined && descriptor.name === undefined && descriptor.filename === undefined) {
    return;
  }
  const dispositionType = (_a3 = descriptor.dispositionType) !== null && _a3 !== undefined ? _a3 : "form-data";
  let disposition = dispositionType;
  if (descriptor.name) {
    disposition += `; name=${escapeDispositionField(descriptor.name)}`;
  }
  let filename = undefined;
  if (descriptor.filename) {
    filename = descriptor.filename;
  } else if (typeof File !== "undefined" && descriptor.body instanceof File) {
    const filenameFromFile = descriptor.body.name;
    if (filenameFromFile !== "") {
      filename = filenameFromFile;
    }
  }
  if (filename) {
    disposition += `; filename=${escapeDispositionField(filename)}`;
  }
  return disposition;
}
function normalizeBody(body, contentType) {
  if (body === undefined) {
    return new Uint8Array([]);
  }
  if (isBinaryBody(body)) {
    return body;
  }
  if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") {
    return stringToUint8Array(String(body), "utf-8");
  }
  if (contentType && /application\/(.+\+)?json(;.+)?/i.test(String(contentType))) {
    return stringToUint8Array(JSON.stringify(body), "utf-8");
  }
  throw new RestError(`Unsupported body/content-type combination: ${body}, ${contentType}`);
}
function buildBodyPart(descriptor) {
  var _a3;
  const contentType = getPartContentType(descriptor);
  const contentDisposition = getContentDisposition(descriptor);
  const headers = createHttpHeaders((_a3 = descriptor.headers) !== null && _a3 !== undefined ? _a3 : {});
  if (contentType) {
    headers.set("content-type", contentType);
  }
  if (contentDisposition) {
    headers.set("content-disposition", contentDisposition);
  }
  const body = normalizeBody(descriptor.body, contentType);
  return {
    headers,
    body
  };
}
function buildMultipartBody(parts) {
  return { parts: parts.map(buildBodyPart) };
}

// node_modules/@typespec/ts-http-runtime/dist/esm/client/sendRequest.js
async function sendRequest(method, url, pipeline, options = {}, customHttpClient) {
  var _a3;
  const httpClient = customHttpClient !== null && customHttpClient !== undefined ? customHttpClient : getCachedDefaultHttpsClient();
  const request3 = buildPipelineRequest(method, url, options);
  try {
    const response = await pipeline.sendRequest(httpClient, request3);
    const headers = response.headers.toJSON();
    const stream = (_a3 = response.readableStreamBody) !== null && _a3 !== undefined ? _a3 : response.browserStreamBody;
    const parsedBody = options.responseAsStream || stream !== undefined ? undefined : getResponseBody(response);
    const body = stream !== null && stream !== undefined ? stream : parsedBody;
    if (options === null || options === undefined ? undefined : options.onResponse) {
      options.onResponse(Object.assign(Object.assign({}, response), { request: request3, rawHeaders: headers, parsedBody }));
    }
    return {
      request: request3,
      headers,
      status: `${response.status}`,
      body
    };
  } catch (e2) {
    if (isRestError(e2) && e2.response && options.onResponse) {
      const { response } = e2;
      const rawHeaders = response.headers.toJSON();
      options === null || options === undefined || options.onResponse(Object.assign(Object.assign({}, response), { request: request3, rawHeaders }), e2);
    }
    throw e2;
  }
}
function getRequestContentType(options = {}) {
  var _a3, _b2, _c2;
  return (_c2 = (_a3 = options.contentType) !== null && _a3 !== undefined ? _a3 : (_b2 = options.headers) === null || _b2 === undefined ? undefined : _b2["content-type"]) !== null && _c2 !== undefined ? _c2 : getContentType(options.body);
}
function getContentType(body) {
  if (ArrayBuffer.isView(body)) {
    return "application/octet-stream";
  }
  if (typeof body === "string") {
    try {
      JSON.parse(body);
      return "application/json";
    } catch (error) {
      return;
    }
  }
  return "application/json";
}
function buildPipelineRequest(method, url, options = {}) {
  var _a3, _b2, _c2;
  const requestContentType = getRequestContentType(options);
  const { body, multipartBody } = getRequestBody(options.body, requestContentType);
  const hasContent = body !== undefined || multipartBody !== undefined;
  const headers = createHttpHeaders(Object.assign(Object.assign(Object.assign({}, options.headers ? options.headers : {}), { accept: (_c2 = (_a3 = options.accept) !== null && _a3 !== undefined ? _a3 : (_b2 = options.headers) === null || _b2 === undefined ? undefined : _b2.accept) !== null && _c2 !== undefined ? _c2 : "application/json" }), hasContent && requestContentType && {
    "content-type": requestContentType
  }));
  return createPipelineRequest({
    url,
    method,
    body,
    multipartBody,
    headers,
    allowInsecureConnection: options.allowInsecureConnection,
    abortSignal: options.abortSignal,
    onUploadProgress: options.onUploadProgress,
    onDownloadProgress: options.onDownloadProgress,
    timeout: options.timeout,
    enableBrowserStreams: true,
    streamResponseStatusCodes: options.responseAsStream ? new Set([Number.POSITIVE_INFINITY]) : undefined
  });
}
function getRequestBody(body, contentType = "") {
  if (body === undefined) {
    return { body: undefined };
  }
  if (typeof FormData !== "undefined" && body instanceof FormData) {
    return { body };
  }
  if (isReadableStream2(body)) {
    return { body };
  }
  if (ArrayBuffer.isView(body)) {
    return { body: body instanceof Uint8Array ? body : JSON.stringify(body) };
  }
  const firstType = contentType.split(";")[0];
  switch (firstType) {
    case "application/json":
      return { body: JSON.stringify(body) };
    case "multipart/form-data":
      if (Array.isArray(body)) {
        return { multipartBody: buildMultipartBody(body) };
      }
      return { body: JSON.stringify(body) };
    case "text/plain":
      return { body: String(body) };
    default:
      if (typeof body === "string") {
        return { body };
      }
      return { body: JSON.stringify(body) };
  }
}
function getResponseBody(response) {
  var _a3, _b2;
  const contentType = (_a3 = response.headers.get("content-type")) !== null && _a3 !== undefined ? _a3 : "";
  const firstType = contentType.split(";")[0];
  const bodyToParse = (_b2 = response.bodyAsText) !== null && _b2 !== undefined ? _b2 : "";
  if (firstType === "text/plain") {
    return String(bodyToParse);
  }
  try {
    return bodyToParse ? JSON.parse(bodyToParse) : undefined;
  } catch (error) {
    if (firstType === "application/json") {
      throw createParseError(response, error);
    }
    return String(bodyToParse);
  }
}
function createParseError(response, err) {
  var _a3;
  const msg = `Error "${err}" occurred while parsing the response body - ${response.bodyAsText}.`;
  const errCode = (_a3 = err.code) !== null && _a3 !== undefined ? _a3 : RestError.PARSE_ERROR;
  return new RestError(msg, {
    code: errCode,
    statusCode: response.status,
    request: response.request,
    response
  });
}

// node_modules/@typespec/ts-http-runtime/dist/esm/client/urlHelpers.js
function isQueryParameterWithOptions(x2) {
  const value = x2.value;
  return value !== undefined && value.toString !== undefined && typeof value.toString === "function";
}
function buildRequestUrl(endpoint, routePath, pathParameters, options = {}) {
  if (routePath.startsWith("https://") || routePath.startsWith("http://")) {
    return routePath;
  }
  endpoint = buildBaseUrl(endpoint, options);
  routePath = buildRoutePath(routePath, pathParameters, options);
  const requestUrl = appendQueryParams(`${endpoint}/${routePath}`, options);
  const url = new URL(requestUrl);
  return url.toString().replace(/([^:]\/)\/+/g, "$1");
}
function getQueryParamValue(key, allowReserved, style, param) {
  let separator;
  if (style === "pipeDelimited") {
    separator = "|";
  } else if (style === "spaceDelimited") {
    separator = "%20";
  } else {
    separator = ",";
  }
  let paramValues;
  if (Array.isArray(param)) {
    paramValues = param;
  } else if (typeof param === "object" && param.toString === Object.prototype.toString) {
    paramValues = Object.entries(param).flat();
  } else {
    paramValues = [param];
  }
  const value = paramValues.map((p2) => {
    if (p2 === null || p2 === undefined) {
      return "";
    }
    if (!p2.toString || typeof p2.toString !== "function") {
      throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);
    }
    const rawValue = p2.toISOString !== undefined ? p2.toISOString() : p2.toString();
    return allowReserved ? rawValue : encodeURIComponent(rawValue);
  }).join(separator);
  return `${allowReserved ? key : encodeURIComponent(key)}=${value}`;
}
function appendQueryParams(url, options = {}) {
  var _a3, _b2, _c2, _d2;
  if (!options.queryParameters) {
    return url;
  }
  const parsedUrl = new URL(url);
  const queryParams = options.queryParameters;
  const paramStrings = [];
  for (const key of Object.keys(queryParams)) {
    const param = queryParams[key];
    if (param === undefined || param === null) {
      continue;
    }
    const hasMetadata = isQueryParameterWithOptions(param);
    const rawValue = hasMetadata ? param.value : param;
    const explode = hasMetadata ? (_a3 = param.explode) !== null && _a3 !== undefined ? _a3 : false : false;
    const style = hasMetadata && param.style ? param.style : "form";
    if (explode) {
      if (Array.isArray(rawValue)) {
        for (const item of rawValue) {
          paramStrings.push(getQueryParamValue(key, (_b2 = options.skipUrlEncoding) !== null && _b2 !== undefined ? _b2 : false, style, item));
        }
      } else if (typeof rawValue === "object") {
        for (const [actualKey, value] of Object.entries(rawValue)) {
          paramStrings.push(getQueryParamValue(actualKey, (_c2 = options.skipUrlEncoding) !== null && _c2 !== undefined ? _c2 : false, style, value));
        }
      } else {
        throw new Error("explode can only be set to true for objects and arrays");
      }
    } else {
      paramStrings.push(getQueryParamValue(key, (_d2 = options.skipUrlEncoding) !== null && _d2 !== undefined ? _d2 : false, style, rawValue));
    }
  }
  if (parsedUrl.search !== "") {
    parsedUrl.search += "&";
  }
  parsedUrl.search += paramStrings.join("&");
  return parsedUrl.toString();
}
function buildBaseUrl(endpoint, options) {
  var _a3;
  if (!options.pathParameters) {
    return endpoint;
  }
  const pathParams = options.pathParameters;
  for (const [key, param] of Object.entries(pathParams)) {
    if (param === undefined || param === null) {
      throw new Error(`Path parameters ${key} must not be undefined or null`);
    }
    if (!param.toString || typeof param.toString !== "function") {
      throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);
    }
    let value = param.toISOString !== undefined ? param.toISOString() : String(param);
    if (!options.skipUrlEncoding) {
      value = encodeURIComponent(param);
    }
    endpoint = (_a3 = replaceAll(endpoint, `{${key}}`, value)) !== null && _a3 !== undefined ? _a3 : "";
  }
  return endpoint;
}
function buildRoutePath(routePath, pathParameters, options = {}) {
  var _a3;
  for (const pathParam of pathParameters) {
    const allowReserved = typeof pathParam === "object" && ((_a3 = pathParam.allowReserved) !== null && _a3 !== undefined ? _a3 : false);
    let value = typeof pathParam === "object" ? pathParam.value : pathParam;
    if (!options.skipUrlEncoding && !allowReserved) {
      value = encodeURIComponent(value);
    }
    routePath = routePath.replace(/\{[\w-]+\}/, String(value));
  }
  return routePath;
}
function replaceAll(value, searchValue, replaceValue) {
  return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
}

// node_modules/@typespec/ts-http-runtime/dist/esm/client/getClient.js
function getClient(endpoint, clientOptions = {}) {
  var _a3, _b2, _c2;
  const pipeline = (_a3 = clientOptions.pipeline) !== null && _a3 !== undefined ? _a3 : createDefaultPipeline(clientOptions);
  if ((_b2 = clientOptions.additionalPolicies) === null || _b2 === undefined ? undefined : _b2.length) {
    for (const { policy, position } of clientOptions.additionalPolicies) {
      const afterPhase = position === "perRetry" ? "Sign" : undefined;
      pipeline.addPolicy(policy, {
        afterPhase
      });
    }
  }
  const { allowInsecureConnection: allowInsecureConnection2, httpClient } = clientOptions;
  const endpointUrl = (_c2 = clientOptions.endpoint) !== null && _c2 !== undefined ? _c2 : endpoint;
  const client = (path2, ...args) => {
    const getUrl = (requestOptions) => buildRequestUrl(endpointUrl, path2, args, Object.assign({ allowInsecureConnection: allowInsecureConnection2 }, requestOptions));
    return {
      get: (requestOptions = {}) => {
        return buildOperation("GET", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection2, httpClient);
      },
      post: (requestOptions = {}) => {
        return buildOperation("POST", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection2, httpClient);
      },
      put: (requestOptions = {}) => {
        return buildOperation("PUT", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection2, httpClient);
      },
      patch: (requestOptions = {}) => {
        return buildOperation("PATCH", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection2, httpClient);
      },
      delete: (requestOptions = {}) => {
        return buildOperation("DELETE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection2, httpClient);
      },
      head: (requestOptions = {}) => {
        return buildOperation("HEAD", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection2, httpClient);
      },
      options: (requestOptions = {}) => {
        return buildOperation("OPTIONS", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection2, httpClient);
      },
      trace: (requestOptions = {}) => {
        return buildOperation("TRACE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection2, httpClient);
      }
    };
  };
  return {
    path: client,
    pathUnchecked: client,
    pipeline
  };
}
function buildOperation(method, url, pipeline, options, allowInsecureConnection2, httpClient) {
  var _a3;
  allowInsecureConnection2 = (_a3 = options.allowInsecureConnection) !== null && _a3 !== undefined ? _a3 : allowInsecureConnection2;
  return {
    then: function(onFulfilled, onrejected) {
      return sendRequest(method, url, pipeline, Object.assign(Object.assign({}, options), { allowInsecureConnection: allowInsecureConnection2 }), httpClient).then(onFulfilled, onrejected);
    },
    async asBrowserStream() {
      if (isNodeLike) {
        throw new Error("`asBrowserStream` is supported only in the browser environment. Use `asNodeStream` instead to obtain the response body stream. If you require a Web stream of the response in Node, consider using `Readable.toWeb` on the result of `asNodeStream`.");
      } else {
        return sendRequest(method, url, pipeline, Object.assign(Object.assign({}, options), { allowInsecureConnection: allowInsecureConnection2, responseAsStream: true }), httpClient);
      }
    },
    async asNodeStream() {
      if (isNodeLike) {
        return sendRequest(method, url, pipeline, Object.assign(Object.assign({}, options), { allowInsecureConnection: allowInsecureConnection2, responseAsStream: true }), httpClient);
      } else {
        throw new Error("`isNodeStream` is not supported in the browser environment. Use `asBrowserStream` to obtain the response body stream.");
      }
    }
  };
}
// node_modules/@azure/core-rest-pipeline/dist/esm/pipeline.js
function createEmptyPipeline2() {
  return createEmptyPipeline();
}
// node_modules/@azure/logger/dist/esm/index.js
var context3 = createLoggerContext({
  logLevelEnvVarName: "AZURE_LOG_LEVEL",
  namespace: "azure"
});
var AzureLogger = context3.logger;
function createClientLogger2(namespace) {
  return context3.createClientLogger(namespace);
}

// node_modules/@azure/core-rest-pipeline/dist/esm/log.js
var logger2 = createClientLogger2("core-rest-pipeline");
// node_modules/@azure/core-rest-pipeline/dist/esm/policies/logPolicy.js
function logPolicy2(options = {}) {
  return logPolicy(Object.assign({ logger: logger2.info }, options));
}

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/redirectPolicy.js
function redirectPolicy2(options = {}) {
  return redirectPolicy(options);
}

// node_modules/@azure/core-rest-pipeline/dist/esm/util/userAgentPlatform.js
import * as os2 from "node:os";
import * as process4 from "node:process";
function getHeaderName2() {
  return "User-Agent";
}
async function setPlatformSpecificData2(map) {
  if (process4 && process4.versions) {
    const versions3 = process4.versions;
    if (versions3.bun) {
      map.set("Bun", versions3.bun);
    } else if (versions3.deno) {
      map.set("Deno", versions3.deno);
    } else if (versions3.node) {
      map.set("Node", versions3.node);
    }
  }
  map.set("OS", `(${os2.arch()}-${os2.type()}-${os2.release()})`);
}

// node_modules/@azure/core-rest-pipeline/dist/esm/constants.js
var SDK_VERSION2 = "1.20.0";

// node_modules/@azure/core-rest-pipeline/dist/esm/util/userAgent.js
function getUserAgentString2(telemetryInfo) {
  const parts = [];
  for (const [key, value] of telemetryInfo) {
    const token = value ? `${key}/${value}` : key;
    parts.push(token);
  }
  return parts.join(" ");
}
function getUserAgentHeaderName2() {
  return getHeaderName2();
}
async function getUserAgentValue2(prefix) {
  const runtimeInfo = new Map;
  runtimeInfo.set("core-rest-pipeline", SDK_VERSION2);
  await setPlatformSpecificData2(runtimeInfo);
  const defaultAgent = getUserAgentString2(runtimeInfo);
  const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
  return userAgentValue;
}

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/userAgentPolicy.js
var UserAgentHeaderName2 = getUserAgentHeaderName2();
var userAgentPolicyName2 = "userAgentPolicy";
function userAgentPolicy2(options = {}) {
  const userAgentValue = getUserAgentValue2(options.userAgentPrefix);
  return {
    name: userAgentPolicyName2,
    async sendRequest(request3, next) {
      if (!request3.headers.has(UserAgentHeaderName2)) {
        request3.headers.set(UserAgentHeaderName2, await userAgentValue);
      }
      return next(request3);
    }
  };
}
// node_modules/@azure/core-util/node_modules/@azure/abort-controller/dist/esm/AbortError.js
class AbortError2 extends Error {
  constructor(message) {
    super(message);
    this.name = "AbortError";
  }
}
// node_modules/@azure/core-util/dist/esm/createAbortablePromise.js
function createAbortablePromise(buildPromise, options) {
  const { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options !== null && options !== undefined ? options : {};
  return new Promise((resolve5, reject) => {
    function rejectOnAbort() {
      reject(new AbortError2(abortErrorMsg !== null && abortErrorMsg !== undefined ? abortErrorMsg : "The operation was aborted."));
    }
    function removeListeners() {
      abortSignal === null || abortSignal === undefined || abortSignal.removeEventListener("abort", onAbort);
    }
    function onAbort() {
      cleanupBeforeAbort === null || cleanupBeforeAbort === undefined || cleanupBeforeAbort();
      removeListeners();
      rejectOnAbort();
    }
    if (abortSignal === null || abortSignal === undefined ? undefined : abortSignal.aborted) {
      return rejectOnAbort();
    }
    try {
      buildPromise((x2) => {
        removeListeners();
        resolve5(x2);
      }, (x2) => {
        removeListeners();
        reject(x2);
      });
    } catch (err) {
      reject(err);
    }
    abortSignal === null || abortSignal === undefined || abortSignal.addEventListener("abort", onAbort);
  });
}

// node_modules/@azure/core-util/dist/esm/delay.js
var StandardAbortMessage2 = "The delay was aborted.";
function delay2(timeInMs, options) {
  let token;
  const { abortSignal, abortErrorMsg } = options !== null && options !== undefined ? options : {};
  return createAbortablePromise((resolve5) => {
    token = setTimeout(resolve5, timeInMs);
  }, {
    cleanupBeforeAbort: () => clearTimeout(token),
    abortSignal,
    abortErrorMsg: abortErrorMsg !== null && abortErrorMsg !== undefined ? abortErrorMsg : StandardAbortMessage2
  });
}
// node_modules/@azure/core-util/dist/esm/error.js
function getErrorMessage(e2) {
  if (isError(e2)) {
    return e2.message;
  } else {
    let stringified;
    try {
      if (typeof e2 === "object" && e2) {
        stringified = JSON.stringify(e2);
      } else {
        stringified = String(e2);
      }
    } catch (err) {
      stringified = "[unable to stringify input]";
    }
    return `Unknown error ${stringified}`;
  }
}
// node_modules/@azure/core-util/dist/esm/typeGuards.js
function isDefined(thing) {
  return typeof thing !== "undefined" && thing !== null;
}
function isObjectWithProperties(thing, properties) {
  if (!isDefined(thing) || typeof thing !== "object") {
    return false;
  }
  for (const property of properties) {
    if (!objectHasProperty(thing, property)) {
      return false;
    }
  }
  return true;
}
function objectHasProperty(thing, property) {
  return isDefined(thing) && typeof thing === "object" && property in thing;
}
// node_modules/@azure/core-util/dist/esm/index.js
function isError2(e2) {
  return isError(e2);
}
var isNodeLike2 = isNodeLike;

// node_modules/@azure/core-rest-pipeline/dist/esm/util/file.js
var rawContent = Symbol("rawContent");
function hasRawContent(x2) {
  return typeof x2[rawContent] === "function";
}
function getRawContent(blob) {
  if (hasRawContent(blob)) {
    return blob[rawContent]();
  } else {
    return blob;
  }
}

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/multipartPolicy.js
var multipartPolicyName2 = multipartPolicyName;
function multipartPolicy2() {
  const tspPolicy = multipartPolicy();
  return {
    name: multipartPolicyName2,
    sendRequest: async (request3, next) => {
      if (request3.multipartBody) {
        for (const part of request3.multipartBody.parts) {
          if (hasRawContent(part.body)) {
            part.body = getRawContent(part.body);
          }
        }
      }
      return tspPolicy.sendRequest(request3, next);
    }
  };
}

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/decompressResponsePolicy.js
function decompressResponsePolicy2() {
  return decompressResponsePolicy();
}

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/defaultRetryPolicy.js
function defaultRetryPolicy2(options = {}) {
  return defaultRetryPolicy(options);
}

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/formDataPolicy.js
function formDataPolicy2() {
  return formDataPolicy();
}

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/proxyPolicy.js
function proxyPolicy2(proxySettings, options) {
  return proxyPolicy(proxySettings, options);
}

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/setClientRequestIdPolicy.js
var setClientRequestIdPolicyName = "setClientRequestIdPolicy";
function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
  return {
    name: setClientRequestIdPolicyName,
    async sendRequest(request3, next) {
      if (!request3.headers.has(requestIdHeaderName)) {
        request3.headers.set(requestIdHeaderName, request3.requestId);
      }
      return next(request3);
    }
  };
}

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/agentPolicy.js
function agentPolicy2(agent) {
  return agentPolicy(agent);
}

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/tlsPolicy.js
function tlsPolicy2(tlsSettings) {
  return tlsPolicy(tlsSettings);
}

// node_modules/@azure/core-tracing/dist/esm/tracingContext.js
var knownContextKeys = {
  span: Symbol.for("@azure/core-tracing span"),
  namespace: Symbol.for("@azure/core-tracing namespace")
};
function createTracingContext(options = {}) {
  let context4 = new TracingContextImpl(options.parentContext);
  if (options.span) {
    context4 = context4.setValue(knownContextKeys.span, options.span);
  }
  if (options.namespace) {
    context4 = context4.setValue(knownContextKeys.namespace, options.namespace);
  }
  return context4;
}

class TracingContextImpl {
  constructor(initialContext) {
    this._contextMap = initialContext instanceof TracingContextImpl ? new Map(initialContext._contextMap) : new Map;
  }
  setValue(key, value) {
    const newContext = new TracingContextImpl(this);
    newContext._contextMap.set(key, value);
    return newContext;
  }
  getValue(key) {
    return this._contextMap.get(key);
  }
  deleteValue(key) {
    const newContext = new TracingContextImpl(this);
    newContext._contextMap.delete(key);
    return newContext;
  }
}

// node_modules/@azure/core-tracing/dist/esm/state.js
var import_state = __toESM(require_state(), 1);
var state = import_state.state;

// node_modules/@azure/core-tracing/dist/esm/instrumenter.js
function createDefaultTracingSpan() {
  return {
    end: () => {
    },
    isRecording: () => false,
    recordException: () => {
    },
    setAttribute: () => {
    },
    setStatus: () => {
    },
    addEvent: () => {
    }
  };
}
function createDefaultInstrumenter() {
  return {
    createRequestHeaders: () => {
      return {};
    },
    parseTraceparentHeader: () => {
      return;
    },
    startSpan: (_name, spanOptions) => {
      return {
        span: createDefaultTracingSpan(),
        tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext })
      };
    },
    withContext(_context, callback, ...callbackArgs) {
      return callback(...callbackArgs);
    }
  };
}
function getInstrumenter() {
  if (!state.instrumenterImplementation) {
    state.instrumenterImplementation = createDefaultInstrumenter();
  }
  return state.instrumenterImplementation;
}

// node_modules/@azure/core-tracing/dist/esm/tracingClient.js
function createTracingClient(options) {
  const { namespace, packageName, packageVersion } = options;
  function startSpan(name, operationOptions, spanOptions) {
    var _a3;
    const startSpanResult = getInstrumenter().startSpan(name, Object.assign(Object.assign({}, spanOptions), { packageName, packageVersion, tracingContext: (_a3 = operationOptions === null || operationOptions === undefined ? undefined : operationOptions.tracingOptions) === null || _a3 === undefined ? undefined : _a3.tracingContext }));
    let tracingContext = startSpanResult.tracingContext;
    const span = startSpanResult.span;
    if (!tracingContext.getValue(knownContextKeys.namespace)) {
      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);
    }
    span.setAttribute("az.namespace", tracingContext.getValue(knownContextKeys.namespace));
    const updatedOptions = Object.assign({}, operationOptions, {
      tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === undefined ? undefined : operationOptions.tracingOptions), { tracingContext })
    });
    return {
      span,
      updatedOptions
    };
  }
  async function withSpan(name, operationOptions, callback, spanOptions) {
    const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
    try {
      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
      span.setStatus({ status: "success" });
      return result;
    } catch (err) {
      span.setStatus({ status: "error", error: err });
      throw err;
    } finally {
      span.end();
    }
  }
  function withContext(context4, callback, ...callbackArgs) {
    return getInstrumenter().withContext(context4, callback, ...callbackArgs);
  }
  function parseTraceparentHeader(traceparentHeader) {
    return getInstrumenter().parseTraceparentHeader(traceparentHeader);
  }
  function createRequestHeaders(tracingContext) {
    return getInstrumenter().createRequestHeaders(tracingContext);
  }
  return {
    startSpan,
    withSpan,
    withContext,
    parseTraceparentHeader,
    createRequestHeaders
  };
}
// node_modules/@azure/core-rest-pipeline/dist/esm/restError.js
class RestError2 extends Error {
  constructor(message, options = {}) {
    super(message);
    return new RestError(message, options);
  }
}
RestError2.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
RestError2.PARSE_ERROR = "PARSE_ERROR";
function isRestError2(e2) {
  return isRestError(e2);
}

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/tracingPolicy.js
var tracingPolicyName = "tracingPolicy";
function tracingPolicy(options = {}) {
  const userAgentPromise = getUserAgentValue2(options.userAgentPrefix);
  const sanitizer = new Sanitizer({
    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
  });
  const tracingClient = tryCreateTracingClient();
  return {
    name: tracingPolicyName,
    async sendRequest(request3, next) {
      var _a3;
      if (!tracingClient) {
        return next(request3);
      }
      const userAgent = await userAgentPromise;
      const spanAttributes = {
        "http.url": sanitizer.sanitizeUrl(request3.url),
        "http.method": request3.method,
        "http.user_agent": userAgent,
        requestId: request3.requestId
      };
      if (userAgent) {
        spanAttributes["http.user_agent"] = userAgent;
      }
      const { span, tracingContext } = (_a3 = tryCreateSpan(tracingClient, request3, spanAttributes)) !== null && _a3 !== undefined ? _a3 : {};
      if (!span || !tracingContext) {
        return next(request3);
      }
      try {
        const response = await tracingClient.withContext(tracingContext, next, request3);
        tryProcessResponse(span, response);
        return response;
      } catch (err) {
        tryProcessError(span, err);
        throw err;
      }
    }
  };
}
function tryCreateTracingClient() {
  try {
    return createTracingClient({
      namespace: "",
      packageName: "@azure/core-rest-pipeline",
      packageVersion: SDK_VERSION2
    });
  } catch (e2) {
    logger2.warning(`Error when creating the TracingClient: ${getErrorMessage(e2)}`);
    return;
  }
}
function tryCreateSpan(tracingClient, request3, spanAttributes) {
  try {
    const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request3.method}`, { tracingOptions: request3.tracingOptions }, {
      spanKind: "client",
      spanAttributes
    });
    if (!span.isRecording()) {
      span.end();
      return;
    }
    const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
    for (const [key, value] of Object.entries(headers)) {
      request3.headers.set(key, value);
    }
    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
  } catch (e2) {
    logger2.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e2)}`);
    return;
  }
}
function tryProcessError(span, error) {
  try {
    span.setStatus({
      status: "error",
      error: isError2(error) ? error : undefined
    });
    if (isRestError2(error) && error.statusCode) {
      span.setAttribute("http.status_code", error.statusCode);
    }
    span.end();
  } catch (e2) {
    logger2.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e2)}`);
  }
}
function tryProcessResponse(span, response) {
  try {
    span.setAttribute("http.status_code", response.status);
    const serviceRequestId = response.headers.get("x-ms-request-id");
    if (serviceRequestId) {
      span.setAttribute("serviceRequestId", serviceRequestId);
    }
    if (response.status >= 400) {
      span.setStatus({
        status: "error"
      });
    }
    span.end();
  } catch (e2) {
    logger2.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e2)}`);
  }
}

// node_modules/@azure/core-rest-pipeline/dist/esm/util/wrapAbortSignal.js
function wrapAbortSignalLike(abortSignalLike) {
  if (abortSignalLike instanceof AbortSignal) {
    return { abortSignal: abortSignalLike };
  }
  if (abortSignalLike.aborted) {
    return { abortSignal: AbortSignal.abort(abortSignalLike.reason) };
  }
  const controller = new AbortController;
  let needsCleanup = true;
  function cleanup() {
    if (needsCleanup) {
      abortSignalLike.removeEventListener("abort", listener);
      needsCleanup = false;
    }
  }
  function listener() {
    controller.abort(abortSignalLike.reason);
    cleanup();
  }
  abortSignalLike.addEventListener("abort", listener);
  return { abortSignal: controller.signal, cleanup };
}

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/wrapAbortSignalLikePolicy.js
var wrapAbortSignalLikePolicyName = "wrapAbortSignalLikePolicy";
function wrapAbortSignalLikePolicy() {
  return {
    name: wrapAbortSignalLikePolicyName,
    sendRequest: async (request3, next) => {
      if (!request3.abortSignal) {
        return next(request3);
      }
      const { abortSignal, cleanup } = wrapAbortSignalLike(request3.abortSignal);
      request3.abortSignal = abortSignal;
      try {
        return await next(request3);
      } finally {
        cleanup === null || cleanup === undefined || cleanup();
      }
    }
  };
}

// node_modules/@azure/core-rest-pipeline/dist/esm/createPipelineFromOptions.js
function createPipelineFromOptions2(options) {
  var _a3;
  const pipeline = createEmptyPipeline2();
  if (isNodeLike2) {
    if (options.agent) {
      pipeline.addPolicy(agentPolicy2(options.agent));
    }
    if (options.tlsOptions) {
      pipeline.addPolicy(tlsPolicy2(options.tlsOptions));
    }
    pipeline.addPolicy(proxyPolicy2(options.proxyOptions));
    pipeline.addPolicy(decompressResponsePolicy2());
  }
  pipeline.addPolicy(wrapAbortSignalLikePolicy());
  pipeline.addPolicy(formDataPolicy2(), { beforePolicies: [multipartPolicyName2] });
  pipeline.addPolicy(userAgentPolicy2(options.userAgentOptions));
  pipeline.addPolicy(setClientRequestIdPolicy((_a3 = options.telemetryOptions) === null || _a3 === undefined ? undefined : _a3.clientRequestIdHeaderName));
  pipeline.addPolicy(multipartPolicy2(), { afterPhase: "Deserialize" });
  pipeline.addPolicy(defaultRetryPolicy2(options.retryOptions), { phase: "Retry" });
  pipeline.addPolicy(tracingPolicy(Object.assign(Object.assign({}, options.userAgentOptions), options.loggingOptions)), {
    afterPhase: "Retry"
  });
  if (isNodeLike2) {
    pipeline.addPolicy(redirectPolicy2(options.redirectOptions), { afterPhase: "Retry" });
  }
  pipeline.addPolicy(logPolicy2(options.loggingOptions), { afterPhase: "Sign" });
  return pipeline;
}
// node_modules/@azure/core-rest-pipeline/dist/esm/util/tokenCycler.js
var DEFAULT_CYCLER_OPTIONS = {
  forcedRefreshWindowInMs: 1000,
  retryIntervalInMs: 3000,
  refreshWindowInMs: 1000 * 60 * 2
};
async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
  async function tryGetAccessToken() {
    if (Date.now() < refreshTimeout) {
      try {
        return await getAccessToken();
      } catch (_a3) {
        return null;
      }
    } else {
      const finalToken = await getAccessToken();
      if (finalToken === null) {
        throw new Error("Failed to refresh access token.");
      }
      return finalToken;
    }
  }
  let token = await tryGetAccessToken();
  while (token === null) {
    await delay2(retryIntervalInMs);
    token = await tryGetAccessToken();
  }
  return token;
}
function createTokenCycler(credential, tokenCyclerOptions) {
  let refreshWorker = null;
  let token = null;
  let tenantId;
  const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
  const cycler = {
    get isRefreshing() {
      return refreshWorker !== null;
    },
    get shouldRefresh() {
      var _a3;
      if (cycler.isRefreshing) {
        return false;
      }
      if ((token === null || token === undefined ? undefined : token.refreshAfterTimestamp) && token.refreshAfterTimestamp < Date.now()) {
        return true;
      }
      return ((_a3 = token === null || token === undefined ? undefined : token.expiresOnTimestamp) !== null && _a3 !== undefined ? _a3 : 0) - options.refreshWindowInMs < Date.now();
    },
    get mustRefresh() {
      return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
    }
  };
  function refresh(scopes, getTokenOptions) {
    var _a3;
    if (!cycler.isRefreshing) {
      const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
      refreshWorker = beginRefresh(tryGetAccessToken, options.retryIntervalInMs, (_a3 = token === null || token === undefined ? undefined : token.expiresOnTimestamp) !== null && _a3 !== undefined ? _a3 : Date.now()).then((_token) => {
        refreshWorker = null;
        token = _token;
        tenantId = getTokenOptions.tenantId;
        return token;
      }).catch((reason) => {
        refreshWorker = null;
        token = null;
        tenantId = undefined;
        throw reason;
      });
    }
    return refreshWorker;
  }
  return async (scopes, tokenOptions) => {
    const hasClaimChallenge = Boolean(tokenOptions.claims);
    const tenantIdChanged = tenantId !== tokenOptions.tenantId;
    if (hasClaimChallenge) {
      token = null;
    }
    const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;
    if (mustRefresh) {
      return refresh(scopes, tokenOptions);
    }
    if (cycler.shouldRefresh) {
      refresh(scopes, tokenOptions);
    }
    return token;
  };
}

// node_modules/@azure/core-rest-pipeline/dist/esm/policies/bearerTokenAuthenticationPolicy.js
var bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
async function trySendRequest(request3, next) {
  try {
    return [await next(request3), undefined];
  } catch (e2) {
    if (isRestError2(e2) && e2.response) {
      return [e2.response, e2];
    } else {
      throw e2;
    }
  }
}
async function defaultAuthorizeRequest(options) {
  const { scopes, getAccessToken, request: request3 } = options;
  const getTokenOptions = {
    abortSignal: request3.abortSignal,
    tracingOptions: request3.tracingOptions,
    enableCae: true
  };
  const accessToken = await getAccessToken(scopes, getTokenOptions);
  if (accessToken) {
    options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
  }
}
function isChallengeResponse(response) {
  return response.status === 401 && response.headers.has("WWW-Authenticate");
}
async function authorizeRequestOnCaeChallenge(onChallengeOptions, caeClaims) {
  var _a3;
  const { scopes } = onChallengeOptions;
  const accessToken = await onChallengeOptions.getAccessToken(scopes, {
    enableCae: true,
    claims: caeClaims
  });
  if (!accessToken) {
    return false;
  }
  onChallengeOptions.request.headers.set("Authorization", `${(_a3 = accessToken.tokenType) !== null && _a3 !== undefined ? _a3 : "Bearer"} ${accessToken.token}`);
  return true;
}
function bearerTokenAuthenticationPolicy(options) {
  var _a3, _b2, _c2;
  const { credential, scopes, challengeCallbacks } = options;
  const logger3 = options.logger || logger2;
  const callbacks = {
    authorizeRequest: (_b2 = (_a3 = challengeCallbacks === null || challengeCallbacks === undefined ? undefined : challengeCallbacks.authorizeRequest) === null || _a3 === undefined ? undefined : _a3.bind(challengeCallbacks)) !== null && _b2 !== undefined ? _b2 : defaultAuthorizeRequest,
    authorizeRequestOnChallenge: (_c2 = challengeCallbacks === null || challengeCallbacks === undefined ? undefined : challengeCallbacks.authorizeRequestOnChallenge) === null || _c2 === undefined ? undefined : _c2.bind(challengeCallbacks)
  };
  const getAccessToken = credential ? createTokenCycler(credential) : () => Promise.resolve(null);
  return {
    name: bearerTokenAuthenticationPolicyName,
    async sendRequest(request3, next) {
      if (!request3.url.toLowerCase().startsWith("https://")) {
        throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
      }
      await callbacks.authorizeRequest({
        scopes: Array.isArray(scopes) ? scopes : [scopes],
        request: request3,
        getAccessToken,
        logger: logger3
      });
      let response;
      let error;
      let shouldSendRequest;
      [response, error] = await trySendRequest(request3, next);
      if (isChallengeResponse(response)) {
        let claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
        if (claims) {
          let parsedClaim;
          try {
            parsedClaim = atob(claims);
          } catch (e2) {
            logger3.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
            return response;
          }
          shouldSendRequest = await authorizeRequestOnCaeChallenge({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            response,
            request: request3,
            getAccessToken,
            logger: logger3
          }, parsedClaim);
          if (shouldSendRequest) {
            [response, error] = await trySendRequest(request3, next);
          }
        } else if (callbacks.authorizeRequestOnChallenge) {
          shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            request: request3,
            response,
            getAccessToken,
            logger: logger3
          });
          if (shouldSendRequest) {
            [response, error] = await trySendRequest(request3, next);
          }
          if (isChallengeResponse(response)) {
            claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
            if (claims) {
              let parsedClaim;
              try {
                parsedClaim = atob(claims);
              } catch (e2) {
                logger3.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
                return response;
              }
              shouldSendRequest = await authorizeRequestOnCaeChallenge({
                scopes: Array.isArray(scopes) ? scopes : [scopes],
                response,
                request: request3,
                getAccessToken,
                logger: logger3
              }, parsedClaim);
              if (shouldSendRequest) {
                [response, error] = await trySendRequest(request3, next);
              }
            }
          }
        }
      }
      if (error) {
        throw error;
      } else {
        return response;
      }
    }
  };
}
function parseChallenges(challenges) {
  const challengeRegex = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g;
  const paramRegex = /(\w+)="([^"]*)"/g;
  const parsedChallenges = [];
  let match;
  while ((match = challengeRegex.exec(challenges)) !== null) {
    const scheme = match[1];
    const paramsString = match[2];
    const params = {};
    let paramMatch;
    while ((paramMatch = paramRegex.exec(paramsString)) !== null) {
      params[paramMatch[1]] = paramMatch[2];
    }
    parsedChallenges.push({ scheme, params });
  }
  return parsedChallenges;
}
function getCaeChallengeClaims(challenges) {
  var _a3;
  if (!challenges) {
    return;
  }
  const parsedChallenges = parseChallenges(challenges);
  return (_a3 = parsedChallenges.find((x2) => x2.scheme === "Bearer" && x2.params.claims && x2.params.error === "insufficient_claims")) === null || _a3 === undefined ? undefined : _a3.params.claims;
}
// node_modules/@azure/core-auth/dist/esm/azureKeyCredential.js
class AzureKeyCredential {
  get key() {
    return this._key;
  }
  constructor(key) {
    if (!key) {
      throw new Error("key must be a non-empty string");
    }
    this._key = key;
  }
  update(newKey) {
    this._key = newKey;
  }
}
// node_modules/@azure/core-auth/dist/esm/keyCredential.js
function isKeyCredential(credential) {
  return isObjectWithProperties(credential, ["key"]) && typeof credential.key === "string";
}
// node_modules/@azure/core-auth/dist/esm/tokenCredential.js
function isTokenCredential(credential) {
  const castCredential = credential;
  return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === undefined || castCredential.getToken.length > 0);
}
// node_modules/@azure-rest/core-client/dist/esm/apiVersionPolicy.js
var apiVersionPolicyName2 = "ApiVersionPolicy";
function apiVersionPolicy2(options) {
  return {
    name: apiVersionPolicyName2,
    sendRequest: (req, next) => {
      const url = new URL(req.url);
      if (!url.searchParams.get("api-version") && options.apiVersion) {
        req.url = `${req.url}${Array.from(url.searchParams.keys()).length > 0 ? "&" : "?"}api-version=${options.apiVersion}`;
      }
      return next(req);
    }
  };
}

// node_modules/@azure-rest/core-client/dist/esm/keyCredentialAuthenticationPolicy.js
var keyCredentialAuthenticationPolicyName = "keyCredentialAuthenticationPolicy";
function keyCredentialAuthenticationPolicy(credential, apiKeyHeaderName) {
  return {
    name: keyCredentialAuthenticationPolicyName,
    async sendRequest(request3, next) {
      request3.headers.set(apiKeyHeaderName, credential.key);
      return next(request3);
    }
  };
}

// node_modules/@azure-rest/core-client/dist/esm/clientHelpers.js
function addCredentialPipelinePolicy(pipeline, endpoint, options = {}) {
  var _a3, _b2, _c2, _d2;
  const { credential, clientOptions } = options;
  if (!credential) {
    return;
  }
  if (isTokenCredential(credential)) {
    const tokenPolicy = bearerTokenAuthenticationPolicy({
      credential,
      scopes: (_b2 = (_a3 = clientOptions === null || clientOptions === undefined ? undefined : clientOptions.credentials) === null || _a3 === undefined ? undefined : _a3.scopes) !== null && _b2 !== undefined ? _b2 : `${endpoint}/.default`
    });
    pipeline.addPolicy(tokenPolicy);
  } else if (isKeyCredential2(credential)) {
    if (!((_c2 = clientOptions === null || clientOptions === undefined ? undefined : clientOptions.credentials) === null || _c2 === undefined ? undefined : _c2.apiKeyHeaderName)) {
      throw new Error(`Missing API Key Header Name`);
    }
    const keyPolicy = keyCredentialAuthenticationPolicy(credential, (_d2 = clientOptions === null || clientOptions === undefined ? undefined : clientOptions.credentials) === null || _d2 === undefined ? undefined : _d2.apiKeyHeaderName);
    pipeline.addPolicy(keyPolicy);
  }
}
function createDefaultPipeline2(endpoint, credential, options = {}) {
  const pipeline = createPipelineFromOptions2(options);
  pipeline.addPolicy(apiVersionPolicy2(options));
  addCredentialPipelinePolicy(pipeline, endpoint, { credential, clientOptions: options });
  return pipeline;
}
function isKeyCredential2(credential) {
  return credential.key !== undefined;
}

// node_modules/@azure-rest/core-client/dist/esm/getClient.js
function wrapRequestParameters(parameters) {
  if (parameters.onResponse) {
    return Object.assign(Object.assign({}, parameters), { onResponse(rawResponse, error) {
      var _a3;
      (_a3 = parameters.onResponse) === null || _a3 === undefined || _a3.call(parameters, rawResponse, error, error);
    } });
  }
  return parameters;
}
function getClient2(endpoint, credentialsOrPipelineOptions, clientOptions = {}) {
  let credentials;
  if (credentialsOrPipelineOptions) {
    if (isCredential(credentialsOrPipelineOptions)) {
      credentials = credentialsOrPipelineOptions;
    } else {
      clientOptions = credentialsOrPipelineOptions !== null && credentialsOrPipelineOptions !== undefined ? credentialsOrPipelineOptions : {};
    }
  }
  const pipeline = createDefaultPipeline2(endpoint, credentials, clientOptions);
  const tspClient = getClient(endpoint, Object.assign(Object.assign({}, clientOptions), { pipeline }));
  const client = (path2, ...args) => {
    return {
      get: (requestOptions = {}) => {
        return tspClient.path(path2, ...args).get(wrapRequestParameters(requestOptions));
      },
      post: (requestOptions = {}) => {
        return tspClient.path(path2, ...args).post(wrapRequestParameters(requestOptions));
      },
      put: (requestOptions = {}) => {
        return tspClient.path(path2, ...args).put(wrapRequestParameters(requestOptions));
      },
      patch: (requestOptions = {}) => {
        return tspClient.path(path2, ...args).patch(wrapRequestParameters(requestOptions));
      },
      delete: (requestOptions = {}) => {
        return tspClient.path(path2, ...args).delete(wrapRequestParameters(requestOptions));
      },
      head: (requestOptions = {}) => {
        return tspClient.path(path2, ...args).head(wrapRequestParameters(requestOptions));
      },
      options: (requestOptions = {}) => {
        return tspClient.path(path2, ...args).options(wrapRequestParameters(requestOptions));
      },
      trace: (requestOptions = {}) => {
        return tspClient.path(path2, ...args).trace(wrapRequestParameters(requestOptions));
      }
    };
  };
  return {
    path: client,
    pathUnchecked: client,
    pipeline: tspClient.pipeline
  };
}
function isCredential(param) {
  return isKeyCredential(param) || isTokenCredential(param);
}

// node_modules/@azure-rest/ai-inference/dist/esm/logger.js
var logger3 = createClientLogger2("ai-inference");

// node_modules/@azure-rest/ai-inference/dist/esm/constants.js
var SDK_VERSION3 = "1.0.0-beta.4";

// node_modules/@azure-rest/ai-inference/dist/esm/tracingHelper.js
var TracingAttributesEnum;
(function(TracingAttributesEnum2) {
  TracingAttributesEnum2["Operation_Name"] = "gen_ai.operation.name";
  TracingAttributesEnum2["Request_Model"] = "gen_ai.request.model";
  TracingAttributesEnum2["System"] = "gen_ai.system";
  TracingAttributesEnum2["Error_Type"] = "error.type";
  TracingAttributesEnum2["Server_Port"] = "server.port";
  TracingAttributesEnum2["Request_Frequency_Penalty"] = "gen_ai.request.frequency_penalty";
  TracingAttributesEnum2["Request_Max_Tokens"] = "gen_ai.request.max_tokens";
  TracingAttributesEnum2["Request_Presence_Penalty"] = "gen_ai.request.presence_penalty";
  TracingAttributesEnum2["Request_Stop_Sequences"] = "gen_ai.request.stop_sequences";
  TracingAttributesEnum2["Request_Temperature"] = "gen_ai.request.temperature";
  TracingAttributesEnum2["Request_Top_P"] = "gen_ai.request.top_p";
  TracingAttributesEnum2["Response_Finish_Reasons"] = "gen_ai.response.finish_reasons";
  TracingAttributesEnum2["Response_Id"] = "gen_ai.response.id";
  TracingAttributesEnum2["Response_Model"] = "gen_ai.response.model";
  TracingAttributesEnum2["Usage_Input_Tokens"] = "gen_ai.usage.input_tokens";
  TracingAttributesEnum2["Usage_Output_Tokens"] = "gen_ai.usage.output_tokens";
  TracingAttributesEnum2["Server_Address"] = "server.address";
})(TracingAttributesEnum || (TracingAttributesEnum = {}));
var INFERENCE_GEN_AI_SYSTEM_NAME = "az.ai.inference";
var isContentRecordingEnabled = () => envVarToBoolean("AZURE_TRACING_GEN_AI_CONTENT_RECORDING_ENABLED");
function getRequestBody2(request3) {
  return { body: JSON.parse(request3.body) };
}
function getSpanName(request3) {
  var _a3;
  const { body } = getRequestBody2(request3);
  return `chat ${(_a3 = body === null || body === undefined ? undefined : body.model) !== null && _a3 !== undefined ? _a3 : ""}`.trim();
}
function onStartTracing(span, request3, url) {
  if (!span.isRecording()) {
    return;
  }
  const urlObj = new URL(url);
  const port = Number(urlObj.port) || (urlObj.protocol === "https:" ? undefined : 80);
  if (port) {
    span.setAttribute(TracingAttributesEnum.Server_Port, port);
  }
  span.setAttribute(TracingAttributesEnum.Server_Address, urlObj.hostname);
  span.setAttribute(TracingAttributesEnum.Operation_Name, "chat");
  span.setAttribute(TracingAttributesEnum.System, "az.ai.inference");
  const { body } = getRequestBody2(request3);
  if (!body)
    return;
  span.setAttribute(TracingAttributesEnum.Request_Model, body.model);
  span.setAttribute(TracingAttributesEnum.Request_Frequency_Penalty, body.frequency_penalty);
  span.setAttribute(TracingAttributesEnum.Request_Max_Tokens, body.max_tokens);
  span.setAttribute(TracingAttributesEnum.Request_Presence_Penalty, body.presence_penalty);
  span.setAttribute(TracingAttributesEnum.Request_Stop_Sequences, body.stop);
  span.setAttribute(TracingAttributesEnum.Request_Temperature, body.temperature);
  span.setAttribute(TracingAttributesEnum.Request_Top_P, body.top_p);
  if (body.messages) {
    addRequestChatMessageEvent(span, body.messages);
  }
}
function tryProcessResponse2(span, response) {
  var _a3, _b2, _c2;
  if (!span.isRecording()) {
    return;
  }
  if (response === null || response === undefined ? undefined : response.bodyAsText) {
    const body = JSON.parse(response.bodyAsText);
    if ((_a3 = body.error) !== null && _a3 !== undefined ? _a3 : body.message) {
      span.setAttribute(TracingAttributesEnum.Error_Type, `${(_b2 = body.status) !== null && _b2 !== undefined ? _b2 : body.statusCode}`);
      span.setStatus({
        status: "error",
        error: (_c2 = body.error) !== null && _c2 !== undefined ? _c2 : body.message
      });
    }
    span.setAttribute(TracingAttributesEnum.Response_Id, body.id);
    span.setAttribute(TracingAttributesEnum.Response_Model, body.model);
    if (body.choices) {
      span.setAttribute(TracingAttributesEnum.Response_Finish_Reasons, body.choices.map((choice) => choice.finish_reason).join(","));
    }
    if (body.usage) {
      span.setAttribute(TracingAttributesEnum.Usage_Input_Tokens, body.usage.prompt_tokens);
      span.setAttribute(TracingAttributesEnum.Usage_Output_Tokens, body.usage.completion_tokens);
    }
    addResponseChatMessageEvent(span, body);
  }
}
function tryProcessError2(span, error) {
  span.setStatus({
    status: "error",
    error: isError2(error) ? error : undefined
  });
}
function addRequestChatMessageEvent(span, messages) {
  messages.forEach((message) => {
    var _a3;
    if (message.role) {
      const content = {};
      const chatMsg = message;
      if (chatMsg.content) {
        content.content = chatMsg.content;
      }
      if (!isContentRecordingEnabled()) {
        content.content = "";
      }
      const assistantMsg = message;
      if (assistantMsg.tool_calls) {
        content.tool_calls = assistantMsg.tool_calls;
        if (!isContentRecordingEnabled()) {
          const toolCalls = JSON.parse(JSON.stringify(content.tool_calls));
          toolCalls.forEach((toolCall) => {
            if (toolCall.function.arguments) {
              toolCall.function.arguments = "";
            }
            toolCall.function.name = "";
          });
          content.tool_calls = toolCalls;
        }
      }
      const toolMsg = message;
      if (toolMsg.tool_call_id) {
        content.id = toolMsg.tool_call_id;
      }
      (_a3 = span.addEvent) === null || _a3 === undefined || _a3.call(span, `gen_ai.${message.role}.message`, {
        attributes: {
          "gen_ai.system": INFERENCE_GEN_AI_SYSTEM_NAME,
          "gen_ai.event.content": JSON.stringify(content)
        }
      });
    }
  });
}
function addResponseChatMessageEvent(span, body) {
  var _a3;
  if (!span.addEvent) {
    return;
  }
  (_a3 = body === null || body === undefined ? undefined : body.choices) === null || _a3 === undefined || _a3.forEach((choice) => {
    var _a4;
    let message = {};
    if (choice.message.content) {
      message.content = choice.message.content;
    }
    if (choice.message.tool_calls) {
      message.toolCalls = choice.message.tool_calls;
    }
    if (!isContentRecordingEnabled()) {
      message = JSON.parse(JSON.stringify(message));
      message.content = "";
      if (message.toolCalls) {
        message.toolCalls.forEach((toolCall) => {
          if (toolCall.function.arguments) {
            toolCall.function.arguments = "";
          }
          toolCall.function.name = "";
        });
      }
    }
    const response = {
      finish_reason: choice.finish_reason,
      index: choice.index,
      message
    };
    const attributes = {
      "gen_ai.system": INFERENCE_GEN_AI_SYSTEM_NAME,
      "gen_ai.event.content": JSON.stringify(response)
    };
    (_a4 = span.addEvent) === null || _a4 === undefined || _a4.call(span, "gen_ai.choice", { attributes });
  });
}
function envVarToBoolean(key) {
  var _a3;
  const value = (_a3 = process.env[key]) !== null && _a3 !== undefined ? _a3 : process.env[key.toLowerCase()];
  return value !== "false" && value !== "0" && Boolean(value);
}

// node_modules/@azure-rest/ai-inference/dist/esm/tracingPolicy.js
var tracingPolicyName2 = "inferenceTracingPolicy";
function tracingPolicy2() {
  const tracingClient = createTracingClient({
    namespace: "Microsoft.CognitiveServices",
    packageName: "@azure/ai-inference-rest",
    packageVersion: SDK_VERSION3
  });
  return {
    name: tracingPolicyName2,
    async sendRequest(request3, next) {
      var _a3, _b2, _c2, _d2;
      const url = new URL(request3.url);
      if (!tracingClient || !url.href.endsWith("/chat/completions") || ((_b2 = (_a3 = getRequestBody2(request3)) === null || _a3 === undefined ? undefined : _a3.body) === null || _b2 === undefined ? undefined : _b2.stream)) {
        return next(request3);
      }
      const { span, tracingContext } = (_c2 = tryCreateSpan2(tracingClient, request3)) !== null && _c2 !== undefined ? _c2 : {};
      if (!span || !tracingContext) {
        return next(request3);
      }
      try {
        (_d2 = request3.tracingOptions) !== null && _d2 !== undefined || (request3.tracingOptions = {});
        request3.tracingOptions.tracingContext = tracingContext;
        onStartTracing(span, request3, request3.url);
        const response = await tracingClient.withContext(tracingContext, next, request3);
        tryProcessResponse2(span, response);
        return response;
      } catch (err) {
        tryProcessError2(span, err);
        throw err;
      } finally {
        span.end();
      }
    }
  };
}
function tryCreateSpan2(tracingClient, request3) {
  try {
    const { span, updatedOptions } = tracingClient.startSpan(getSpanName(request3), { tracingOptions: request3.tracingOptions }, {
      spanKind: "client"
    });
    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
  } catch (e2) {
    logger3.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e2)}`);
    return;
  }
}

// node_modules/@azure-rest/ai-inference/dist/esm/modelClient.js
function createClient(endpointParam, credentials, _a3 = {}) {
  var _b2, _c2, _d2, _e2, _f, _g, _h, _j;
  var { apiVersion = "2024-05-01-preview" } = _a3, options = __rest(_a3, ["apiVersion"]);
  const endpointUrl = (_c2 = (_b2 = options.endpoint) !== null && _b2 !== undefined ? _b2 : options.baseUrl) !== null && _c2 !== undefined ? _c2 : `${endpointParam}`;
  const userAgentInfo = `azsdk-js-ai-inference-rest/1.0.0-beta.6`;
  const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${userAgentInfo}` : `${userAgentInfo}`;
  options = Object.assign(Object.assign({}, options), { userAgentOptions: {
    userAgentPrefix
  }, loggingOptions: {
    logger: (_e2 = (_d2 = options.loggingOptions) === null || _d2 === undefined ? undefined : _d2.logger) !== null && _e2 !== undefined ? _e2 : logger3.info
  }, credentials: {
    scopes: (_g = (_f = options.credentials) === null || _f === undefined ? undefined : _f.scopes) !== null && _g !== undefined ? _g : ["https://ml.azure.com/.default"],
    apiKeyHeaderName: (_j = (_h = options.credentials) === null || _h === undefined ? undefined : _h.apiKeyHeaderName) !== null && _j !== undefined ? _j : "api-key"
  } });
  const client = getClient2(endpointUrl, credentials, options);
  client.pipeline.removePolicy({ name: "ApiVersionPolicy" });
  client.pipeline.addPolicy({
    name: "InferenceTracingPolicy",
    sendRequest: (req, next) => {
      return tracingPolicy2().sendRequest(req, next);
    }
  });
  client.pipeline.addPolicy({
    name: "ClientApiVersionPolicy",
    sendRequest: (req, next) => {
      const url = new URL(req.url);
      if (!url.searchParams.get("api-version") && apiVersion) {
        req.url = `${req.url}${Array.from(url.searchParams.keys()).length > 0 ? "&" : "?"}api-version=${apiVersion}`;
      }
      return next(req);
    }
  });
  if (isKeyCredential(credentials)) {
    client.pipeline.addPolicy({
      name: "customKeyCredentialPolicy",
      async sendRequest(request3, next) {
        request3.headers.set("Authorization", "Bearer " + credentials.key);
        return next(request3);
      }
    });
  }
  return client;
}
// node_modules/@azure-rest/ai-inference/dist/esm/isUnexpected.js
var responseMap = {
  "POST /chat/completions": ["200"],
  "GET /info": ["200"],
  "POST /embeddings": ["200"],
  "POST /images/embeddings": ["200"]
};
function isUnexpected(response) {
  const lroOriginal = response.headers["x-ms-original-url"];
  const url = new URL(lroOriginal !== null && lroOriginal !== undefined ? lroOriginal : response.request.url);
  const method = response.request.method;
  let pathDetails = responseMap[`${method} ${url.pathname}`];
  if (!pathDetails) {
    pathDetails = getParametrizedPathSuccess(method, url.pathname);
  }
  return !pathDetails.includes(response.status);
}
function getParametrizedPathSuccess(method, path2) {
  var _a3, _b2, _c2, _d2;
  const pathParts = path2.split("/");
  let matchedLen = -1, matchedValue = [];
  for (const [key, value] of Object.entries(responseMap)) {
    if (!key.startsWith(method)) {
      continue;
    }
    const candidatePath = getPathFromMapKey(key);
    const candidateParts = candidatePath.split("/");
    let found = true;
    for (let i2 = candidateParts.length - 1, j2 = pathParts.length - 1;i2 >= 1 && j2 >= 1; i2--, j2--) {
      if (((_a3 = candidateParts[i2]) === null || _a3 === undefined ? undefined : _a3.startsWith("{")) && ((_b2 = candidateParts[i2]) === null || _b2 === undefined ? undefined : _b2.indexOf("}")) !== -1) {
        const start = candidateParts[i2].indexOf("}") + 1, end = (_c2 = candidateParts[i2]) === null || _c2 === undefined ? undefined : _c2.length;
        const isMatched = new RegExp(`${(_d2 = candidateParts[i2]) === null || _d2 === undefined ? undefined : _d2.slice(start, end)}`).test(pathParts[j2] || "");
        if (!isMatched) {
          found = false;
          break;
        }
        continue;
      }
      if (candidateParts[i2] !== pathParts[j2]) {
        found = false;
        break;
      }
    }
    if (found && candidatePath.length > matchedLen) {
      matchedLen = candidatePath.length;
      matchedValue = value;
    }
  }
  return matchedValue;
}
function getPathFromMapKey(mapKey) {
  const pathStart = mapKey.indexOf("/");
  return mapKey.slice(pathStart);
}

// node_modules/@azure-rest/ai-inference/dist/esm/index.js
var esm_default = createClient;

// src/util/octokit.ts
var import_github2 = __toESM(require_github(), 1);

// node_modules/universal-user-agent/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== undefined) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@octokit/rest/node_modules/@octokit/core/node_modules/before-after-hook/lib/register.js
function register(state2, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }
  if (!options) {
    options = {};
  }
  if (Array.isArray(name)) {
    return name.reverse().reduce((callback, name2) => {
      return register.bind(null, state2, name2, callback, options);
    }, method)();
  }
  return Promise.resolve().then(() => {
    if (!state2.registry[name]) {
      return method(options);
    }
    return state2.registry[name].reduce((method2, registered) => {
      return registered.hook.bind(null, method2, options);
    }, method)();
  });
}

// node_modules/@octokit/rest/node_modules/@octokit/core/node_modules/before-after-hook/lib/add.js
function addHook(state2, kind, name, hook) {
  const orig = hook;
  if (!state2.registry[name]) {
    state2.registry[name] = [];
  }
  if (kind === "before") {
    hook = (method, options) => {
      return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
    };
  }
  if (kind === "after") {
    hook = (method, options) => {
      let result;
      return Promise.resolve().then(method.bind(null, options)).then((result_) => {
        result = result_;
        return orig(result, options);
      }).then(() => {
        return result;
      });
    };
  }
  if (kind === "error") {
    hook = (method, options) => {
      return Promise.resolve().then(method.bind(null, options)).catch((error) => {
        return orig(error, options);
      });
    };
  }
  state2.registry[name].push({
    hook,
    orig
  });
}

// node_modules/@octokit/rest/node_modules/@octokit/core/node_modules/before-after-hook/lib/remove.js
function removeHook(state2, name, method) {
  if (!state2.registry[name]) {
    return;
  }
  const index = state2.registry[name].map((registered) => {
    return registered.orig;
  }).indexOf(method);
  if (index === -1) {
    return;
  }
  state2.registry[name].splice(index, 1);
}

// node_modules/@octokit/rest/node_modules/@octokit/core/node_modules/before-after-hook/index.js
var bind = Function.bind;
var bindable = bind.bind(bind);
function bindApi(hook, state2, name) {
  const removeHookRef = bindable(removeHook, null).apply(null, name ? [state2, name] : [state2]);
  hook.api = { remove: removeHookRef };
  hook.remove = removeHookRef;
  ["before", "error", "after", "wrap"].forEach((kind) => {
    const args = name ? [state2, kind, name] : [state2, kind];
    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
  });
}
function Singular() {
  const singularHookName = Symbol("Singular");
  const singularHookState = {
    registry: {}
  };
  const singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}
function Collection() {
  const state2 = {
    registry: {}
  };
  const hook = register.bind(null, state2);
  bindApi(hook, state2);
  return hook;
}
var before_after_hook_default = { Singular, Collection };

// node_modules/@octokit/rest/node_modules/@octokit/core/node_modules/@octokit/request/node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION = "0.0.0-development";
var userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent()}`;
var DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === undefined) {
      delete obj[key];
    }
  }
  return obj;
}
function merge(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && defaults.mediaType.previews?.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url, parameters2) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters2);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters2.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters2[name])}`;
  }).join("&");
}
var urlVariableRegex = /\{[^{}}]+\}/g;
function removeNonChars(variableName) {
  return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a2, b2) => a2.concat(b2), []);
}
function omit(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined2(value) {
  return value !== undefined && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context4, operator, key, modifier) {
  var value = context4[key], result = [];
  if (isDefined2(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined2).forEach(function(value2) {
            result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function(k2) {
            if (isDefined2(value[k2])) {
              result.push(encodeValue(operator, value[k2], k2));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined2).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k2) {
            if (isDefined2(value[k2])) {
              tmp.push(encodeUnreserved(k2));
              tmp.push(encodeValue(operator, value[k2].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined2(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context4) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_2, expression, literal) {
    if (expression) {
      let operator = "";
      const values = [];
      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }
      expression.split(/,/g).forEach(function(variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues(context4, operator, tmp[1], tmp[2] || tmp[3]));
      });
      if (operator && operator !== "+") {
        var separator = ",";
        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }
        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved(literal);
    }
  });
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse5(options) {
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters2 = omit(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters2);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters2, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map((format5) => format5.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }
    if (url.endsWith("/graphql")) {
      if (options.mediaType.previews?.length) {
        const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format5 = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format5}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}
function endpointWithDefaults(defaults, route, options) {
  return parse5(merge(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge.bind(null, DEFAULTS2),
    parse: parse5
  });
}
var endpoint = withDefaults(null, DEFAULTS);

// node_modules/@octokit/rest/node_modules/@octokit/core/node_modules/@octokit/request/node_modules/fast-content-type-parse/index.js
var NullObject = function NullObject2() {
};
NullObject.prototype = Object.create(null);
var paramRE = /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu;
var quotedPairRE = /\\([\v\u0020-\u00ff])/gu;
var mediaTypeRE = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u;
var defaultContentType = { type: "", parameters: new NullObject };
Object.freeze(defaultContentType.parameters);
Object.freeze(defaultContentType);
function safeParse(header) {
  if (typeof header !== "string") {
    return defaultContentType;
  }
  let index = header.indexOf(";");
  const type3 = index !== -1 ? header.slice(0, index).trim() : header.trim();
  if (mediaTypeRE.test(type3) === false) {
    return defaultContentType;
  }
  const result = {
    type: type3.toLowerCase(),
    parameters: new NullObject
  };
  if (index === -1) {
    return result;
  }
  let key;
  let match;
  let value;
  paramRE.lastIndex = index;
  while (match = paramRE.exec(header)) {
    if (match.index !== index) {
      return defaultContentType;
    }
    index += match[0].length;
    key = match[1].toLowerCase();
    value = match[2];
    if (value[0] === '"') {
      value = value.slice(1, value.length - 1);
      quotedPairRE.test(value) && (value = value.replace(quotedPairRE, "$1"));
    }
    result.parameters[key] = value;
  }
  if (index !== header.length) {
    return defaultContentType;
  }
  return result;
}
var $safeParse = safeParse;

// node_modules/@octokit/rest/node_modules/@octokit/core/node_modules/@octokit/request-error/dist-src/index.js
class RequestError extends Error {
  name;
  status;
  request;
  response;
  constructor(message, statusCode, options) {
    super(message);
    this.name = "HttpError";
    this.status = Number.parseInt(statusCode);
    if (Number.isNaN(this.status)) {
      this.status = 0;
    }
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]")
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
}

// node_modules/@octokit/rest/node_modules/@octokit/core/node_modules/@octokit/request/dist-bundle/index.js
var VERSION2 = "10.0.3";
var defaults_default = {
  headers: {
    "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent()}`
  }
};
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
async function fetchWrapper(requestOptions) {
  const fetch = requestOptions.request?.fetch || globalThis.fetch;
  if (!fetch) {
    throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
  }
  const log2 = requestOptions.request?.log || console;
  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
  const body = isPlainObject2(requestOptions.body) || Array.isArray(requestOptions.body) ? JSON.stringify(requestOptions.body) : requestOptions.body;
  const requestHeaders = Object.fromEntries(Object.entries(requestOptions.headers).map(([name, value]) => [
    name,
    String(value)
  ]));
  let fetchResponse;
  try {
    fetchResponse = await fetch(requestOptions.url, {
      method: requestOptions.method,
      body,
      redirect: requestOptions.request?.redirect,
      headers: requestHeaders,
      signal: requestOptions.request?.signal,
      ...requestOptions.body && { duplex: "half" }
    });
  } catch (error) {
    let message = "Unknown Error";
    if (error instanceof Error) {
      if (error.name === "AbortError") {
        error.status = 500;
        throw error;
      }
      message = error.message;
      if (error.name === "TypeError" && "cause" in error) {
        if (error.cause instanceof Error) {
          message = error.cause.message;
        } else if (typeof error.cause === "string") {
          message = error.cause;
        }
      }
    }
    const requestError = new RequestError(message, 500, {
      request: requestOptions
    });
    requestError.cause = error;
    throw requestError;
  }
  const status = fetchResponse.status;
  const url = fetchResponse.url;
  const responseHeaders = {};
  for (const [key, value] of fetchResponse.headers) {
    responseHeaders[key] = value;
  }
  const octokitResponse = {
    url,
    status,
    headers: responseHeaders,
    data: ""
  };
  if ("deprecation" in responseHeaders) {
    const matches = responseHeaders.link && responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
    const deprecationLink = matches && matches.pop();
    log2.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
  }
  if (status === 204 || status === 205) {
    return octokitResponse;
  }
  if (requestOptions.method === "HEAD") {
    if (status < 400) {
      return octokitResponse;
    }
    throw new RequestError(fetchResponse.statusText, status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status === 304) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError("Not modified", status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status >= 400) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError(toErrorMessage(octokitResponse.data), status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  octokitResponse.data = parseSuccessResponseBody ? await getResponseData(fetchResponse) : fetchResponse.body;
  return octokitResponse;
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (!contentType) {
    return response.text().catch(() => "");
  }
  const mimetype = $safeParse(contentType);
  if (isJSONResponse(mimetype)) {
    let text = "";
    try {
      text = await response.text();
      return JSON.parse(text);
    } catch (err) {
      return text;
    }
  } else if (mimetype.type.startsWith("text/") || mimetype.parameters.charset?.toLowerCase() === "utf-8") {
    return response.text().catch(() => "");
  } else {
    return response.arrayBuffer().catch(() => new ArrayBuffer(0));
  }
}
function isJSONResponse(mimetype) {
  return mimetype.type === "application/json" || mimetype.type === "application/scim+json";
}
function toErrorMessage(data) {
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return "Unknown error";
  }
  if ("message" in data) {
    const suffix = "documentation_url" in data ? ` - ${data.documentation_url}` : "";
    return Array.isArray(data.errors) ? `${data.message}: ${data.errors.map((v2) => JSON.stringify(v2)).join(", ")}${suffix}` : `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters2) {
    const endpointOptions = endpoint2.merge(route, parameters2);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request22 = (route2, parameters22) => {
      return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters22)));
    };
    Object.assign(request22, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request22, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var request3 = withDefaults2(endpoint, defaults_default);

// node_modules/@octokit/rest/node_modules/@octokit/core/node_modules/@octokit/graphql/dist-bundle/index.js
var VERSION3 = "0.0.0-development";
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e2) => ` - ${e2.message}`).join(`
`);
}
var GraphqlResponseError = class extends Error {
  constructor(request22, headers, response) {
    super(_buildMessageForResponseErrors(response));
    this.request = request22;
    this.headers = headers;
    this.response = response;
    this.errors = response.errors;
    this.data = response.data;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  name = "GraphqlResponseError";
  errors;
  data;
};
var NON_VARIABLE_OPTIONS = [
  "method",
  "baseUrl",
  "url",
  "headers",
  "request",
  "query",
  "mediaType",
  "operationName"
];
var FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request22, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
        continue;
      return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query;
  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request22.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request22(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(requestOptions, headers, response.data);
    }
    return response.data.data;
  });
}
function withDefaults3(request22, newDefaults) {
  const newRequest = request22.defaults(newDefaults);
  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}
var graphql2 = withDefaults3(request3, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION3} ${getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

// node_modules/@octokit/rest/node_modules/@octokit/core/node_modules/@octokit/auth-token/dist-bundle/index.js
var b64url = "(?:[a-zA-Z0-9_-]+)";
var sep = "\\.";
var jwtRE = new RegExp(`^${b64url}${sep}${b64url}${sep}${b64url}$`);
var isJWT = jwtRE.test.bind(jwtRE);
async function auth(token) {
  const isApp = isJWT(token);
  const isInstallation = token.startsWith("v1.") || token.startsWith("ghs_");
  const isUserToServer = token.startsWith("ghu_");
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook(token, request4, route, parameters2) {
  const endpoint2 = request4.endpoint.merge(route, parameters2);
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request4(endpoint2);
}
var createTokenAuth = function createTokenAuth2(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }
  if (typeof token !== "string") {
    throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
  }
  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

// node_modules/@octokit/rest/node_modules/@octokit/core/dist-src/version.js
var VERSION4 = "7.0.2";

// node_modules/@octokit/rest/node_modules/@octokit/core/dist-src/index.js
var noop = () => {
};
var consoleWarn = console.warn.bind(console);
var consoleError = console.error.bind(console);
var userAgentTrail = `octokit-core.js/${VERSION4} ${getUserAgent()}`;

class Octokit {
  static VERSION = VERSION4;
  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};
        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }
        super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
          userAgent: `${options.userAgent} ${defaults.userAgent}`
        } : null));
      }
    };
    return OctokitWithDefaults;
  }
  static plugins = [];
  static plugin(...newPlugins) {
    const currentPlugins = this.plugins;
    const NewOctokit = class extends this {
      static plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin)));
    };
    return NewOctokit;
  }
  constructor(options = {}) {
    const hook2 = new before_after_hook_default.Collection;
    const requestDefaults = {
      baseUrl: request3.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        hook: hook2.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    };
    requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }
    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }
    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }
    this.request = request3.defaults(requestDefaults);
    this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign({
      debug: noop,
      info: noop,
      warn: consoleWarn,
      error: consoleError
    }, options.log);
    this.hook = hook2;
    if (!options.authStrategy) {
      if (!options.auth) {
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        const auth2 = createTokenAuth(options.auth);
        hook2.wrap("request", auth2.hook);
        this.auth = auth2;
      }
    } else {
      const { authStrategy, ...otherOptions } = options;
      const auth2 = authStrategy(Object.assign({
        request: this.request,
        log: this.log,
        octokit: this,
        octokitOptions: otherOptions
      }, options.auth));
      hook2.wrap("request", auth2.hook);
      this.auth = auth2;
    }
    const classConstructor = this.constructor;
    for (let i2 = 0;i2 < classConstructor.plugins.length; ++i2) {
      Object.assign(this, classConstructor.plugins[i2](this, options));
    }
  }
  request;
  graphql;
  log;
  hook;
  auth;
}

// node_modules/@octokit/plugin-request-log/dist-src/version.js
var VERSION5 = "6.0.0";

// node_modules/@octokit/plugin-request-log/dist-src/index.js
function requestLog(octokit) {
  octokit.hook.wrap("request", (request4, options) => {
    octokit.log.debug("request", options);
    const start = Date.now();
    const requestOptions = octokit.request.endpoint.parse(options);
    const path2 = requestOptions.url.replace(options.baseUrl, "");
    return request4(options).then((response) => {
      const requestId = response.headers["x-github-request-id"];
      octokit.log.info(`${requestOptions.method} ${path2} - ${response.status} with id ${requestId} in ${Date.now() - start}ms`);
      return response;
    }).catch((error) => {
      const requestId = error.response?.headers["x-github-request-id"] || "UNKNOWN";
      octokit.log.error(`${requestOptions.method} ${path2} - ${error.status} with id ${requestId} in ${Date.now() - start}ms`);
      throw error;
    });
  });
}
requestLog.VERSION = VERSION5;

// node_modules/@octokit/rest/node_modules/@octokit/plugin-paginate-rest/dist-bundle/index.js
var VERSION6 = "0.0.0-development";
function normalizePaginatedListResponse(response) {
  if (!response.data) {
    return {
      ...response,
      data: []
    };
  }
  const responseNeedsNormalization = (("total_count" in response.data) || ("total_commits" in response.data)) && !("url" in response.data);
  if (!responseNeedsNormalization)
    return response;
  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  const totalCommits = response.data.total_commits;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;
  delete response.data.total_commits;
  const namespaceKey = Object.keys(response.data)[0];
  const data = response.data[namespaceKey];
  response.data = data;
  if (typeof incompleteResults !== "undefined") {
    response.data.incomplete_results = incompleteResults;
  }
  if (typeof repositorySelection !== "undefined") {
    response.data.repository_selection = repositorySelection;
  }
  response.data.total_count = totalCount;
  response.data.total_commits = totalCommits;
  return response;
}
function iterator(octokit, route, parameters2) {
  const options = typeof route === "function" ? route.endpoint(parameters2) : octokit.request.endpoint(route, parameters2);
  const requestMethod = typeof route === "function" ? route : octokit.request;
  const method = options.method;
  const headers = options.headers;
  let url = options.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!url)
          return { done: true };
        try {
          const response = await requestMethod({ method, url, headers });
          const normalizedResponse = normalizePaginatedListResponse(response);
          url = ((normalizedResponse.headers.link || "").match(/<([^<>]+)>;\s*rel="next"/) || [])[1];
          if (!url && "total_commits" in normalizedResponse.data) {
            const parsedUrl = new URL(normalizedResponse.url);
            const params = parsedUrl.searchParams;
            const page = parseInt(params.get("page") || "1", 10);
            const per_page = parseInt(params.get("per_page") || "250", 10);
            if (page * per_page < normalizedResponse.data.total_commits) {
              params.set("page", String(page + 1));
              url = parsedUrl.toString();
            }
          }
          return { value: normalizedResponse };
        } catch (error) {
          if (error.status !== 409)
            throw error;
          url = "";
          return {
            value: {
              status: 200,
              headers: {},
              data: []
            }
          };
        }
      }
    })
  };
}
function paginate(octokit, route, parameters2, mapFn) {
  if (typeof parameters2 === "function") {
    mapFn = parameters2;
    parameters2 = undefined;
  }
  return gather(octokit, [], iterator(octokit, route, parameters2)[Symbol.asyncIterator](), mapFn);
}
function gather(octokit, results, iterator2, mapFn) {
  return iterator2.next().then((result) => {
    if (result.done) {
      return results;
    }
    let earlyExit = false;
    function done() {
      earlyExit = true;
    }
    results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
    if (earlyExit) {
      return results;
    }
    return gather(octokit, results, iterator2, mapFn);
  });
}
var composePaginateRest = Object.assign(paginate, {
  iterator
});
function paginateRest(octokit) {
  return {
    paginate: Object.assign(paginate.bind(null, octokit), {
      iterator: iterator.bind(null, octokit)
    })
  };
}
paginateRest.VERSION = VERSION6;

// node_modules/@octokit/rest/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/version.js
var VERSION7 = "16.0.0";

// node_modules/@octokit/rest/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/generated/endpoints.js
var Endpoints = {
  actions: {
    addCustomLabelsToSelfHostedRunnerForOrg: [
      "POST /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    addCustomLabelsToSelfHostedRunnerForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    addRepoAccessToSelfHostedRunnerGroupInOrg: [
      "PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    approveWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
    ],
    cancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
    ],
    createEnvironmentVariable: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/variables"
    ],
    createHostedRunnerForOrg: ["POST /orgs/{org}/actions/hosted-runners"],
    createOrUpdateEnvironmentSecret: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
    ],
    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    createOrgVariable: ["POST /orgs/{org}/actions/variables"],
    createRegistrationTokenForOrg: [
      "POST /orgs/{org}/actions/runners/registration-token"
    ],
    createRegistrationTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/registration-token"
    ],
    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
    createRemoveTokenForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/remove-token"
    ],
    createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
    createWorkflowDispatch: [
      "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
    ],
    deleteActionsCacheById: [
      "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
    ],
    deleteActionsCacheByKey: [
      "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
    ],
    deleteArtifact: [
      "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
    ],
    deleteEnvironmentSecret: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
    ],
    deleteEnvironmentVariable: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
    ],
    deleteHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
    deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
    ],
    deleteRepoVariable: [
      "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
    ],
    deleteSelfHostedRunnerFromOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}"
    ],
    deleteSelfHostedRunnerFromRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
    deleteWorkflowRunLogs: [
      "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    disableSelectedRepositoryGithubActionsOrganization: [
      "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    disableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
    ],
    downloadArtifact: [
      "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
    ],
    downloadJobLogsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
    ],
    downloadWorkflowRunAttemptLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
    ],
    downloadWorkflowRunLogs: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
    ],
    enableSelectedRepositoryGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
    ],
    enableWorkflow: [
      "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
    ],
    forceCancelWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
    ],
    generateRunnerJitconfigForOrg: [
      "POST /orgs/{org}/actions/runners/generate-jitconfig"
    ],
    generateRunnerJitconfigForRepo: [
      "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
    ],
    getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
    getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
    getActionsCacheUsageByRepoForOrg: [
      "GET /orgs/{org}/actions/cache/usage-by-repository"
    ],
    getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
    getAllowedActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/selected-actions"
    ],
    getAllowedActionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    getCustomOidcSubClaimForRepo: [
      "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    getEnvironmentPublicKey: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key"
    ],
    getEnvironmentSecret: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
    ],
    getEnvironmentVariable: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
    ],
    getGithubActionsDefaultWorkflowPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions/workflow"
    ],
    getGithubActionsDefaultWorkflowPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    getGithubActionsPermissionsOrganization: [
      "GET /orgs/{org}/actions/permissions"
    ],
    getGithubActionsPermissionsRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions"
    ],
    getHostedRunnerForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
    ],
    getHostedRunnersGithubOwnedImagesForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/images/github-owned"
    ],
    getHostedRunnersLimitsForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/limits"
    ],
    getHostedRunnersMachineSpecsForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/machine-sizes"
    ],
    getHostedRunnersPartnerImagesForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/images/partner"
    ],
    getHostedRunnersPlatformsForOrg: [
      "GET /orgs/{org}/actions/hosted-runners/platforms"
    ],
    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
    getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
    getPendingDeploymentsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    getRepoPermissions: [
      "GET /repos/{owner}/{repo}/actions/permissions",
      {},
      { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
    ],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
    getReviewsForRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
    ],
    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
    getSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
    ],
    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
    getWorkflowAccessToRepository: [
      "GET /repos/{owner}/{repo}/actions/permissions/access"
    ],
    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
    getWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
    ],
    getWorkflowRunUsage: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
    ],
    getWorkflowUsage: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
    ],
    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
    listEnvironmentSecrets: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets"
    ],
    listEnvironmentVariables: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/variables"
    ],
    listGithubHostedRunnersInGroupForOrg: [
      "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners"
    ],
    listHostedRunnersForOrg: ["GET /orgs/{org}/actions/hosted-runners"],
    listJobsForWorkflowRun: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
    ],
    listJobsForWorkflowRunAttempt: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
    ],
    listLabelsForSelfHostedRunnerForOrg: [
      "GET /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    listLabelsForSelfHostedRunnerForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
    listOrgVariables: ["GET /orgs/{org}/actions/variables"],
    listRepoOrganizationSecrets: [
      "GET /repos/{owner}/{repo}/actions/organization-secrets"
    ],
    listRepoOrganizationVariables: [
      "GET /repos/{owner}/{repo}/actions/organization-variables"
    ],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
    listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
    listRunnerApplicationsForRepo: [
      "GET /repos/{owner}/{repo}/actions/runners/downloads"
    ],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    listSelectedReposForOrgVariable: [
      "GET /orgs/{org}/actions/variables/{name}/repositories"
    ],
    listSelectedRepositoriesEnabledGithubActionsOrganization: [
      "GET /orgs/{org}/actions/permissions/repositories"
    ],
    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
    listWorkflowRunArtifacts: [
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
    ],
    listWorkflowRuns: [
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
    ],
    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
    reRunJobForWorkflowRun: [
      "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
    ],
    reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
    reRunWorkflowFailedJobs: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    removeCustomLabelFromSelfHostedRunnerForOrg: [
      "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeCustomLabelFromSelfHostedRunnerForRepo: [
      "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgVariable: [
      "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
    ],
    reviewCustomGatesForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
    ],
    reviewPendingDeploymentsForRun: [
      "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
    ],
    setAllowedActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/selected-actions"
    ],
    setAllowedActionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
    ],
    setCustomLabelsForSelfHostedRunnerForOrg: [
      "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
    ],
    setCustomLabelsForSelfHostedRunnerForRepo: [
      "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
    ],
    setCustomOidcSubClaimForRepo: [
      "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
    ],
    setGithubActionsDefaultWorkflowPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/workflow"
    ],
    setGithubActionsDefaultWorkflowPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
    ],
    setGithubActionsPermissionsOrganization: [
      "PUT /orgs/{org}/actions/permissions"
    ],
    setGithubActionsPermissionsRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgVariable: [
      "PUT /orgs/{org}/actions/variables/{name}/repositories"
    ],
    setSelectedRepositoriesEnabledGithubActionsOrganization: [
      "PUT /orgs/{org}/actions/permissions/repositories"
    ],
    setWorkflowAccessToRepository: [
      "PUT /repos/{owner}/{repo}/actions/permissions/access"
    ],
    updateEnvironmentVariable: [
      "PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
    ],
    updateHostedRunnerForOrg: [
      "PATCH /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
    ],
    updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
    updateRepoVariable: [
      "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
    ]
  },
  activity: {
    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
    deleteThreadSubscription: [
      "DELETE /notifications/threads/{thread_id}/subscription"
    ],
    getFeeds: ["GET /feeds"],
    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
    getThread: ["GET /notifications/threads/{thread_id}"],
    getThreadSubscriptionForAuthenticatedUser: [
      "GET /notifications/threads/{thread_id}/subscription"
    ],
    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
    listNotificationsForAuthenticatedUser: ["GET /notifications"],
    listOrgEventsForAuthenticatedUser: [
      "GET /users/{username}/events/orgs/{org}"
    ],
    listPublicEvents: ["GET /events"],
    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
    listPublicEventsForUser: ["GET /users/{username}/events/public"],
    listPublicOrgEvents: ["GET /orgs/{org}/events"],
    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
    listReceivedPublicEventsForUser: [
      "GET /users/{username}/received_events/public"
    ],
    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
    listRepoNotificationsForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/notifications"
    ],
    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
    listReposStarredByUser: ["GET /users/{username}/starred"],
    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
    markNotificationsAsRead: ["PUT /notifications"],
    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
    markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
    setThreadSubscription: [
      "PUT /notifications/threads/{thread_id}/subscription"
    ],
    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
  },
  apps: {
    addRepoToInstallation: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
    ],
    addRepoToInstallationForAuthenticatedUser: [
      "PUT /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    checkToken: ["POST /applications/{client_id}/token"],
    createFromManifest: ["POST /app-manifests/{code}/conversions"],
    createInstallationAccessToken: [
      "POST /app/installations/{installation_id}/access_tokens"
    ],
    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
    deleteToken: ["DELETE /applications/{client_id}/token"],
    getAuthenticated: ["GET /app"],
    getBySlug: ["GET /apps/{app_slug}"],
    getInstallation: ["GET /app/installations/{installation_id}"],
    getOrgInstallation: ["GET /orgs/{org}/installation"],
    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
    getSubscriptionPlanForAccount: [
      "GET /marketplace_listing/accounts/{account_id}"
    ],
    getSubscriptionPlanForAccountStubbed: [
      "GET /marketplace_listing/stubbed/accounts/{account_id}"
    ],
    getUserInstallation: ["GET /users/{username}/installation"],
    getWebhookConfigForApp: ["GET /app/hook/config"],
    getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
    listAccountsForPlanStubbed: [
      "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
    ],
    listInstallationReposForAuthenticatedUser: [
      "GET /user/installations/{installation_id}/repositories"
    ],
    listInstallationRequestsForAuthenticatedApp: [
      "GET /app/installation-requests"
    ],
    listInstallations: ["GET /app/installations"],
    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
    listPlans: ["GET /marketplace_listing/plans"],
    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
    listReposAccessibleToInstallation: ["GET /installation/repositories"],
    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
    listSubscriptionsForAuthenticatedUserStubbed: [
      "GET /user/marketplace_purchases/stubbed"
    ],
    listWebhookDeliveries: ["GET /app/hook/deliveries"],
    redeliverWebhookDelivery: [
      "POST /app/hook/deliveries/{delivery_id}/attempts"
    ],
    removeRepoFromInstallation: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
      {},
      { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
    ],
    removeRepoFromInstallationForAuthenticatedUser: [
      "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
    ],
    resetToken: ["PATCH /applications/{client_id}/token"],
    revokeInstallationAccessToken: ["DELETE /installation/token"],
    scopeToken: ["POST /applications/{client_id}/token/scoped"],
    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
    unsuspendInstallation: [
      "DELETE /app/installations/{installation_id}/suspended"
    ],
    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
  },
  billing: {
    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
    getGithubActionsBillingUser: [
      "GET /users/{username}/settings/billing/actions"
    ],
    getGithubBillingUsageReportOrg: [
      "GET /organizations/{org}/settings/billing/usage"
    ],
    getGithubBillingUsageReportUser: [
      "GET /users/{username}/settings/billing/usage"
    ],
    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
    getGithubPackagesBillingUser: [
      "GET /users/{username}/settings/billing/packages"
    ],
    getSharedStorageBillingOrg: [
      "GET /orgs/{org}/settings/billing/shared-storage"
    ],
    getSharedStorageBillingUser: [
      "GET /users/{username}/settings/billing/shared-storage"
    ]
  },
  campaigns: {
    createCampaign: ["POST /orgs/{org}/campaigns"],
    deleteCampaign: ["DELETE /orgs/{org}/campaigns/{campaign_number}"],
    getCampaignSummary: ["GET /orgs/{org}/campaigns/{campaign_number}"],
    listOrgCampaigns: ["GET /orgs/{org}/campaigns"],
    updateCampaign: ["PATCH /orgs/{org}/campaigns/{campaign_number}"]
  },
  checks: {
    create: ["POST /repos/{owner}/{repo}/check-runs"],
    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
    listAnnotations: [
      "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
    ],
    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
    listForSuite: [
      "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
    ],
    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
    rerequestRun: [
      "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
    ],
    rerequestSuite: [
      "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
    ],
    setSuitesPreferences: [
      "PATCH /repos/{owner}/{repo}/check-suites/preferences"
    ],
    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
  },
  codeScanning: {
    commitAutofix: [
      "POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix/commits"
    ],
    createAutofix: [
      "POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"
    ],
    createVariantAnalysis: [
      "POST /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses"
    ],
    deleteAnalysis: [
      "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
    ],
    deleteCodeqlDatabase: [
      "DELETE /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
    ],
    getAlert: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
      {},
      { renamedParameters: { alert_id: "alert_number" } }
    ],
    getAnalysis: [
      "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
    ],
    getAutofix: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"
    ],
    getCodeqlDatabase: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
    ],
    getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
    getVariantAnalysis: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}"
    ],
    getVariantAnalysisRepoTask: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}/repos/{repo_owner}/{repo_name}"
    ],
    listAlertInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
    listAlertsInstances: [
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
      {},
      { renamed: ["codeScanning", "listAlertInstances"] }
    ],
    listCodeqlDatabases: [
      "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
    ],
    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
    ],
    updateDefaultSetup: [
      "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
    ],
    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
  },
  codeSecurity: {
    attachConfiguration: [
      "POST /orgs/{org}/code-security/configurations/{configuration_id}/attach"
    ],
    attachEnterpriseConfiguration: [
      "POST /enterprises/{enterprise}/code-security/configurations/{configuration_id}/attach"
    ],
    createConfiguration: ["POST /orgs/{org}/code-security/configurations"],
    createConfigurationForEnterprise: [
      "POST /enterprises/{enterprise}/code-security/configurations"
    ],
    deleteConfiguration: [
      "DELETE /orgs/{org}/code-security/configurations/{configuration_id}"
    ],
    deleteConfigurationForEnterprise: [
      "DELETE /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
    ],
    detachConfiguration: [
      "DELETE /orgs/{org}/code-security/configurations/detach"
    ],
    getConfiguration: [
      "GET /orgs/{org}/code-security/configurations/{configuration_id}"
    ],
    getConfigurationForRepository: [
      "GET /repos/{owner}/{repo}/code-security-configuration"
    ],
    getConfigurationsForEnterprise: [
      "GET /enterprises/{enterprise}/code-security/configurations"
    ],
    getConfigurationsForOrg: ["GET /orgs/{org}/code-security/configurations"],
    getDefaultConfigurations: [
      "GET /orgs/{org}/code-security/configurations/defaults"
    ],
    getDefaultConfigurationsForEnterprise: [
      "GET /enterprises/{enterprise}/code-security/configurations/defaults"
    ],
    getRepositoriesForConfiguration: [
      "GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories"
    ],
    getRepositoriesForEnterpriseConfiguration: [
      "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories"
    ],
    getSingleConfigurationForEnterprise: [
      "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
    ],
    setConfigurationAsDefault: [
      "PUT /orgs/{org}/code-security/configurations/{configuration_id}/defaults"
    ],
    setConfigurationAsDefaultForEnterprise: [
      "PUT /enterprises/{enterprise}/code-security/configurations/{configuration_id}/defaults"
    ],
    updateConfiguration: [
      "PATCH /orgs/{org}/code-security/configurations/{configuration_id}"
    ],
    updateEnterpriseConfiguration: [
      "PATCH /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
    ]
  },
  codesOfConduct: {
    getAllCodesOfConduct: ["GET /codes_of_conduct"],
    getConductCode: ["GET /codes_of_conduct/{key}"]
  },
  codespaces: {
    addRepositoryForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    checkPermissionsForDevcontainer: [
      "GET /repos/{owner}/{repo}/codespaces/permissions_check"
    ],
    codespaceMachinesForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/machines"
    ],
    createForAuthenticatedUser: ["POST /user/codespaces"],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    createOrUpdateSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}"
    ],
    createWithPrForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
    ],
    createWithRepoForAuthenticatedUser: [
      "POST /repos/{owner}/{repo}/codespaces"
    ],
    deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
    deleteFromOrganization: [
      "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    deleteSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}"
    ],
    exportForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/exports"
    ],
    getCodespacesForUserInOrg: [
      "GET /orgs/{org}/members/{username}/codespaces"
    ],
    getExportDetailsForAuthenticatedUser: [
      "GET /user/codespaces/{codespace_name}/exports/{export_id}"
    ],
    getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
    getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
    getPublicKeyForAuthenticatedUser: [
      "GET /user/codespaces/secrets/public-key"
    ],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
    ],
    getSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}"
    ],
    listDevcontainersInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/devcontainers"
    ],
    listForAuthenticatedUser: ["GET /user/codespaces"],
    listInOrganization: [
      "GET /orgs/{org}/codespaces",
      {},
      { renamedParameters: { org_id: "org" } }
    ],
    listInRepositoryForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces"
    ],
    listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
    listRepositoriesForSecretForAuthenticatedUser: [
      "GET /user/codespaces/secrets/{secret_name}/repositories"
    ],
    listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    preFlightWithRepoForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/new"
    ],
    publishForAuthenticatedUser: [
      "POST /user/codespaces/{codespace_name}/publish"
    ],
    removeRepositoryForSecretForAuthenticatedUser: [
      "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
    ],
    repoMachinesForAuthenticatedUser: [
      "GET /repos/{owner}/{repo}/codespaces/machines"
    ],
    setRepositoriesForSecretForAuthenticatedUser: [
      "PUT /user/codespaces/secrets/{secret_name}/repositories"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
    ],
    startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
    stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
    stopInOrganization: [
      "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
    ],
    updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
  },
  copilot: {
    addCopilotSeatsForTeams: [
      "POST /orgs/{org}/copilot/billing/selected_teams"
    ],
    addCopilotSeatsForUsers: [
      "POST /orgs/{org}/copilot/billing/selected_users"
    ],
    cancelCopilotSeatAssignmentForTeams: [
      "DELETE /orgs/{org}/copilot/billing/selected_teams"
    ],
    cancelCopilotSeatAssignmentForUsers: [
      "DELETE /orgs/{org}/copilot/billing/selected_users"
    ],
    copilotMetricsForOrganization: ["GET /orgs/{org}/copilot/metrics"],
    copilotMetricsForTeam: ["GET /orgs/{org}/team/{team_slug}/copilot/metrics"],
    getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
    getCopilotSeatDetailsForUser: [
      "GET /orgs/{org}/members/{username}/copilot"
    ],
    listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
  },
  credentials: { revoke: ["POST /credentials/revoke"] },
  dependabot: {
    addSelectedRepoToOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    createOrUpdateOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
    ],
    createOrUpdateRepoSecret: [
      "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
    deleteRepoSecret: [
      "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
    getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
    getRepoPublicKey: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
    ],
    getRepoSecret: [
      "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
    ],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/dependabot/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
    listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
    listSelectedReposForOrgSecret: [
      "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    removeSelectedRepoFromOrgSecret: [
      "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
    ],
    setSelectedReposForOrgSecret: [
      "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
    ]
  },
  dependencyGraph: {
    createRepositorySnapshot: [
      "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
    ],
    diffRange: [
      "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
    ],
    exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
  },
  emojis: { get: ["GET /emojis"] },
  gists: {
    checkIsStarred: ["GET /gists/{gist_id}/star"],
    create: ["POST /gists"],
    createComment: ["POST /gists/{gist_id}/comments"],
    delete: ["DELETE /gists/{gist_id}"],
    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
    fork: ["POST /gists/{gist_id}/forks"],
    get: ["GET /gists/{gist_id}"],
    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
    getRevision: ["GET /gists/{gist_id}/{sha}"],
    list: ["GET /gists"],
    listComments: ["GET /gists/{gist_id}/comments"],
    listCommits: ["GET /gists/{gist_id}/commits"],
    listForUser: ["GET /users/{username}/gists"],
    listForks: ["GET /gists/{gist_id}/forks"],
    listPublic: ["GET /gists/public"],
    listStarred: ["GET /gists/starred"],
    star: ["PUT /gists/{gist_id}/star"],
    unstar: ["DELETE /gists/{gist_id}/star"],
    update: ["PATCH /gists/{gist_id}"],
    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
  },
  git: {
    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
  },
  gitignore: {
    getAllTemplates: ["GET /gitignore/templates"],
    getTemplate: ["GET /gitignore/templates/{name}"]
  },
  hostedCompute: {
    createNetworkConfigurationForOrg: [
      "POST /orgs/{org}/settings/network-configurations"
    ],
    deleteNetworkConfigurationFromOrg: [
      "DELETE /orgs/{org}/settings/network-configurations/{network_configuration_id}"
    ],
    getNetworkConfigurationForOrg: [
      "GET /orgs/{org}/settings/network-configurations/{network_configuration_id}"
    ],
    getNetworkSettingsForOrg: [
      "GET /orgs/{org}/settings/network-settings/{network_settings_id}"
    ],
    listNetworkConfigurationsForOrg: [
      "GET /orgs/{org}/settings/network-configurations"
    ],
    updateNetworkConfigurationForOrg: [
      "PATCH /orgs/{org}/settings/network-configurations/{network_configuration_id}"
    ]
  },
  interactions: {
    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
    getRestrictionsForYourPublicRepos: [
      "GET /user/interaction-limits",
      {},
      { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
    ],
    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
    removeRestrictionsForRepo: [
      "DELETE /repos/{owner}/{repo}/interaction-limits"
    ],
    removeRestrictionsForYourPublicRepos: [
      "DELETE /user/interaction-limits",
      {},
      { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
    ],
    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
    setRestrictionsForYourPublicRepos: [
      "PUT /user/interaction-limits",
      {},
      { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
    ]
  },
  issues: {
    addAssignees: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    addSubIssue: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/sub_issues"
    ],
    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
    checkUserCanBeAssignedToIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
    ],
    create: ["POST /repos/{owner}/{repo}/issues"],
    createComment: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
    ],
    createLabel: ["POST /repos/{owner}/{repo}/labels"],
    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
    deleteComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
    ],
    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
    deleteMilestone: [
      "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
    ],
    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
    list: ["GET /issues"],
    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
    listEventsForTimeline: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
    ],
    listForAuthenticatedUser: ["GET /user/issues"],
    listForOrg: ["GET /orgs/{org}/issues"],
    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
    listLabelsForMilestone: [
      "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
    ],
    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
    listLabelsOnIssue: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
    listSubIssues: [
      "GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues"
    ],
    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    removeAllLabels: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
    ],
    removeAssignees: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
    ],
    removeLabel: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
    ],
    removeSubIssue: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/sub_issue"
    ],
    reprioritizeSubIssue: [
      "PATCH /repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority"
    ],
    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
    updateMilestone: [
      "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
    ]
  },
  licenses: {
    get: ["GET /licenses/{license}"],
    getAllCommonlyUsed: ["GET /licenses"],
    getForRepo: ["GET /repos/{owner}/{repo}/license"]
  },
  markdown: {
    render: ["POST /markdown"],
    renderRaw: [
      "POST /markdown/raw",
      { headers: { "content-type": "text/plain; charset=utf-8" } }
    ]
  },
  meta: {
    get: ["GET /meta"],
    getAllVersions: ["GET /versions"],
    getOctocat: ["GET /octocat"],
    getZen: ["GET /zen"],
    root: ["GET /"]
  },
  migrations: {
    deleteArchiveForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/archive"
    ],
    deleteArchiveForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/archive"
    ],
    downloadArchiveForOrg: [
      "GET /orgs/{org}/migrations/{migration_id}/archive"
    ],
    getArchiveForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/archive"
    ],
    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
    listForAuthenticatedUser: ["GET /user/migrations"],
    listForOrg: ["GET /orgs/{org}/migrations"],
    listReposForAuthenticatedUser: [
      "GET /user/migrations/{migration_id}/repositories"
    ],
    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
    listReposForUser: [
      "GET /user/migrations/{migration_id}/repositories",
      {},
      { renamed: ["migrations", "listReposForAuthenticatedUser"] }
    ],
    startForAuthenticatedUser: ["POST /user/migrations"],
    startForOrg: ["POST /orgs/{org}/migrations"],
    unlockRepoForAuthenticatedUser: [
      "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
    ],
    unlockRepoForOrg: [
      "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
    ]
  },
  oidc: {
    getOidcCustomSubTemplateForOrg: [
      "GET /orgs/{org}/actions/oidc/customization/sub"
    ],
    updateOidcCustomSubTemplateForOrg: [
      "PUT /orgs/{org}/actions/oidc/customization/sub"
    ]
  },
  orgs: {
    addSecurityManagerTeam: [
      "PUT /orgs/{org}/security-managers/teams/{team_slug}",
      {},
      {
        deprecated: "octokit.rest.orgs.addSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#add-a-security-manager-team"
      }
    ],
    assignTeamToOrgRole: [
      "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    assignUserToOrgRole: [
      "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
    convertMemberToOutsideCollaborator: [
      "PUT /orgs/{org}/outside_collaborators/{username}"
    ],
    createInvitation: ["POST /orgs/{org}/invitations"],
    createIssueType: ["POST /orgs/{org}/issue-types"],
    createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
    createOrUpdateCustomPropertiesValuesForRepos: [
      "PATCH /orgs/{org}/properties/values"
    ],
    createOrUpdateCustomProperty: [
      "PUT /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    createWebhook: ["POST /orgs/{org}/hooks"],
    delete: ["DELETE /orgs/{org}"],
    deleteIssueType: ["DELETE /orgs/{org}/issue-types/{issue_type_id}"],
    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
    enableOrDisableSecurityProductOnAllOrgRepos: [
      "POST /orgs/{org}/{security_product}/{enablement}",
      {},
      {
        deprecated: "octokit.rest.orgs.enableOrDisableSecurityProductOnAllOrgRepos() is deprecated, see https://docs.github.com/rest/orgs/orgs#enable-or-disable-a-security-feature-for-an-organization"
      }
    ],
    get: ["GET /orgs/{org}"],
    getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
    getCustomProperty: [
      "GET /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
    getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
    getOrgRulesetHistory: ["GET /orgs/{org}/rulesets/{ruleset_id}/history"],
    getOrgRulesetVersion: [
      "GET /orgs/{org}/rulesets/{ruleset_id}/history/{version_id}"
    ],
    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
    getWebhookDelivery: [
      "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    list: ["GET /organizations"],
    listAppInstallations: ["GET /orgs/{org}/installations"],
    listAttestations: ["GET /orgs/{org}/attestations/{subject_digest}"],
    listBlockedUsers: ["GET /orgs/{org}/blocks"],
    listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
    listForAuthenticatedUser: ["GET /user/orgs"],
    listForUser: ["GET /users/{username}/orgs"],
    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
    listIssueTypes: ["GET /orgs/{org}/issue-types"],
    listMembers: ["GET /orgs/{org}/members"],
    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
    listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
    listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
    listOrgRoles: ["GET /orgs/{org}/organization-roles"],
    listOrganizationFineGrainedPermissions: [
      "GET /orgs/{org}/organization-fine-grained-permissions"
    ],
    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
    listPatGrantRepositories: [
      "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
    ],
    listPatGrantRequestRepositories: [
      "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
    ],
    listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
    listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
    listPendingInvitations: ["GET /orgs/{org}/invitations"],
    listPublicMembers: ["GET /orgs/{org}/public_members"],
    listSecurityManagerTeams: [
      "GET /orgs/{org}/security-managers",
      {},
      {
        deprecated: "octokit.rest.orgs.listSecurityManagerTeams() is deprecated, see https://docs.github.com/rest/orgs/security-managers#list-security-manager-teams"
      }
    ],
    listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
    listWebhooks: ["GET /orgs/{org}/hooks"],
    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeCustomProperty: [
      "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
    ],
    removeMember: ["DELETE /orgs/{org}/members/{username}"],
    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
    removeOutsideCollaborator: [
      "DELETE /orgs/{org}/outside_collaborators/{username}"
    ],
    removePublicMembershipForAuthenticatedUser: [
      "DELETE /orgs/{org}/public_members/{username}"
    ],
    removeSecurityManagerTeam: [
      "DELETE /orgs/{org}/security-managers/teams/{team_slug}",
      {},
      {
        deprecated: "octokit.rest.orgs.removeSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#remove-a-security-manager-team"
      }
    ],
    reviewPatGrantRequest: [
      "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
    ],
    reviewPatGrantRequestsInBulk: [
      "POST /orgs/{org}/personal-access-token-requests"
    ],
    revokeAllOrgRolesTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
    ],
    revokeAllOrgRolesUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}"
    ],
    revokeOrgRoleTeam: [
      "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
    ],
    revokeOrgRoleUser: [
      "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
    ],
    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
    setPublicMembershipForAuthenticatedUser: [
      "PUT /orgs/{org}/public_members/{username}"
    ],
    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
    update: ["PATCH /orgs/{org}"],
    updateIssueType: ["PUT /orgs/{org}/issue-types/{issue_type_id}"],
    updateMembershipForAuthenticatedUser: [
      "PATCH /user/memberships/orgs/{org}"
    ],
    updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
    updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
  },
  packages: {
    deletePackageForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}"
    ],
    deletePackageForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    deletePackageForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}"
    ],
    deletePackageVersionForAuthenticatedUser: [
      "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForOrg: [
      "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    deletePackageVersionForUser: [
      "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getAllPackageVersionsForAPackageOwnedByAnOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
      {},
      { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
    ],
    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions",
      {},
      {
        renamed: [
          "packages",
          "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
        ]
      }
    ],
    getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByOrg: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
    ],
    getAllPackageVersionsForPackageOwnedByUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions"
    ],
    getPackageForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}"
    ],
    getPackageForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}"
    ],
    getPackageForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}"
    ],
    getPackageVersionForAuthenticatedUser: [
      "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForOrganization: [
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    getPackageVersionForUser: [
      "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
    ],
    listDockerMigrationConflictingPackagesForAuthenticatedUser: [
      "GET /user/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForOrganization: [
      "GET /orgs/{org}/docker/conflicts"
    ],
    listDockerMigrationConflictingPackagesForUser: [
      "GET /users/{username}/docker/conflicts"
    ],
    listPackagesForAuthenticatedUser: ["GET /user/packages"],
    listPackagesForOrganization: ["GET /orgs/{org}/packages"],
    listPackagesForUser: ["GET /users/{username}/packages"],
    restorePackageForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
    ],
    restorePackageVersionForAuthenticatedUser: [
      "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForOrg: [
      "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ],
    restorePackageVersionForUser: [
      "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
    ]
  },
  privateRegistries: {
    createOrgPrivateRegistry: ["POST /orgs/{org}/private-registries"],
    deleteOrgPrivateRegistry: [
      "DELETE /orgs/{org}/private-registries/{secret_name}"
    ],
    getOrgPrivateRegistry: ["GET /orgs/{org}/private-registries/{secret_name}"],
    getOrgPublicKey: ["GET /orgs/{org}/private-registries/public-key"],
    listOrgPrivateRegistries: ["GET /orgs/{org}/private-registries"],
    updateOrgPrivateRegistry: [
      "PATCH /orgs/{org}/private-registries/{secret_name}"
    ]
  },
  pulls: {
    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    create: ["POST /repos/{owner}/{repo}/pulls"],
    createReplyForReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
    ],
    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    createReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    deletePendingReview: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    deleteReviewComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ],
    dismissReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
    ],
    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
    getReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    list: ["GET /repos/{owner}/{repo}/pulls"],
    listCommentsForReview: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
    listRequestedReviewers: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    listReviewComments: [
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
    ],
    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    removeRequestedReviewers: [
      "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    requestReviewers: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
    ],
    submitReview: [
      "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
    ],
    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
    updateBranch: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
    ],
    updateReview: [
      "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
    ],
    updateReviewComment: [
      "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
    ]
  },
  rateLimit: { get: ["GET /rate_limit"] },
  reactions: {
    createForCommitComment: [
      "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    createForIssue: [
      "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
    ],
    createForIssueComment: [
      "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    createForPullRequestReviewComment: [
      "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    createForRelease: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    createForTeamDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    createForTeamDiscussionInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ],
    deleteForCommitComment: [
      "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForIssue: [
      "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
    ],
    deleteForIssueComment: [
      "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForPullRequestComment: [
      "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
    ],
    deleteForRelease: [
      "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussion: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
    ],
    deleteForTeamDiscussionComment: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
    ],
    listForCommitComment: [
      "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
    ],
    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
    listForIssueComment: [
      "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
    ],
    listForPullRequestReviewComment: [
      "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
    ],
    listForRelease: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
    ],
    listForTeamDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
    ],
    listForTeamDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
    ]
  },
  repos: {
    acceptInvitation: [
      "PATCH /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
    ],
    acceptInvitationForAuthenticatedUser: [
      "PATCH /user/repository_invitations/{invitation_id}"
    ],
    addAppAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
    addStatusCheckContexts: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    addTeamAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    addUserAccessRestrictions: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    cancelPagesDeployment: [
      "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
    ],
    checkAutomatedSecurityFixes: [
      "GET /repos/{owner}/{repo}/automated-security-fixes"
    ],
    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
    checkPrivateVulnerabilityReporting: [
      "GET /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    checkVulnerabilityAlerts: [
      "GET /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
    compareCommitsWithBasehead: [
      "GET /repos/{owner}/{repo}/compare/{basehead}"
    ],
    createAttestation: ["POST /repos/{owner}/{repo}/attestations"],
    createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
    createCommitComment: [
      "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    createCommitSignatureProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
    createDeploymentBranchPolicy: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    createDeploymentProtectionRule: [
      "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    createDeploymentStatus: [
      "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
    createForAuthenticatedUser: ["POST /user/repos"],
    createFork: ["POST /repos/{owner}/{repo}/forks"],
    createInOrg: ["POST /orgs/{org}/repos"],
    createOrUpdateCustomPropertiesValues: [
      "PATCH /repos/{owner}/{repo}/properties/values"
    ],
    createOrUpdateEnvironment: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
    createOrgRuleset: ["POST /orgs/{org}/rulesets"],
    createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
    createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
    createRelease: ["POST /repos/{owner}/{repo}/releases"],
    createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
    createUsingTemplate: [
      "POST /repos/{template_owner}/{template_repo}/generate"
    ],
    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
    declineInvitation: [
      "DELETE /user/repository_invitations/{invitation_id}",
      {},
      { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
    ],
    declineInvitationForAuthenticatedUser: [
      "DELETE /user/repository_invitations/{invitation_id}"
    ],
    delete: ["DELETE /repos/{owner}/{repo}"],
    deleteAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    deleteAdminBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    deleteAnEnvironment: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    deleteBranchProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
    deleteCommitSignatureProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
    deleteDeployment: [
      "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
    ],
    deleteDeploymentBranchPolicy: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
    deleteInvitation: [
      "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
    deletePullRequestReviewProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
    deleteReleaseAsset: [
      "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
    disableAutomatedSecurityFixes: [
      "DELETE /repos/{owner}/{repo}/automated-security-fixes"
    ],
    disableDeploymentProtectionRule: [
      "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    disablePrivateVulnerabilityReporting: [
      "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    disableVulnerabilityAlerts: [
      "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    downloadArchive: [
      "GET /repos/{owner}/{repo}/zipball/{ref}",
      {},
      { renamed: ["repos", "downloadZipballArchive"] }
    ],
    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
    enableAutomatedSecurityFixes: [
      "PUT /repos/{owner}/{repo}/automated-security-fixes"
    ],
    enablePrivateVulnerabilityReporting: [
      "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
    ],
    enableVulnerabilityAlerts: [
      "PUT /repos/{owner}/{repo}/vulnerability-alerts"
    ],
    generateReleaseNotes: [
      "POST /repos/{owner}/{repo}/releases/generate-notes"
    ],
    get: ["GET /repos/{owner}/{repo}"],
    getAccessRestrictions: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
    ],
    getAdminBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    getAllDeploymentProtectionRules: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
    ],
    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
    getAllStatusCheckContexts: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
    ],
    getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
    getAppsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
    ],
    getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
    getBranchProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
    getCollaboratorPermissionLevel: [
      "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
    ],
    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
    getCommitSignatureProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
    ],
    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
    getCustomDeploymentProtectionRule: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
    ],
    getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
    getDeploymentBranchPolicy: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    getDeploymentStatus: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
    ],
    getEnvironment: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}"
    ],
    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
    getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
    getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
    getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
    getOrgRulesets: ["GET /orgs/{org}/rulesets"],
    getPages: ["GET /repos/{owner}/{repo}/pages"],
    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
    getPagesDeployment: [
      "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
    ],
    getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
    getPullRequestReviewProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
    getReadme: ["GET /repos/{owner}/{repo}/readme"],
    getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
    getRepoRuleSuite: [
      "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
    ],
    getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
    getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    getRepoRulesetHistory: [
      "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history"
    ],
    getRepoRulesetVersion: [
      "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}"
    ],
    getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
    getStatusChecksProtection: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    getTeamsWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
    ],
    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
    getUsersWithAccessToProtectedBranch: [
      "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
    ],
    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
    getWebhookConfigForRepo: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    getWebhookDelivery: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
    ],
    listActivities: ["GET /repos/{owner}/{repo}/activity"],
    listAttestations: [
      "GET /repos/{owner}/{repo}/attestations/{subject_digest}"
    ],
    listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
    listBranches: ["GET /repos/{owner}/{repo}/branches"],
    listBranchesForHeadCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
    ],
    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
    listCommentsForCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
    ],
    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
    listCommitStatusesForRef: [
      "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
    ],
    listCommits: ["GET /repos/{owner}/{repo}/commits"],
    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
    listCustomDeploymentRuleIntegrations: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
    ],
    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
    listDeploymentBranchPolicies: [
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
    ],
    listDeploymentStatuses: [
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
    ],
    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
    listForAuthenticatedUser: ["GET /user/repos"],
    listForOrg: ["GET /orgs/{org}/repos"],
    listForUser: ["GET /users/{username}/repos"],
    listForks: ["GET /repos/{owner}/{repo}/forks"],
    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
    listPublic: ["GET /repositories"],
    listPullRequestsAssociatedWithCommit: [
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
    ],
    listReleaseAssets: [
      "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
    ],
    listReleases: ["GET /repos/{owner}/{repo}/releases"],
    listTags: ["GET /repos/{owner}/{repo}/tags"],
    listTeams: ["GET /repos/{owner}/{repo}/teams"],
    listWebhookDeliveries: [
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
    ],
    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
    merge: ["POST /repos/{owner}/{repo}/merges"],
    mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
    redeliverWebhookDelivery: [
      "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
    ],
    removeAppAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    removeCollaborator: [
      "DELETE /repos/{owner}/{repo}/collaborators/{username}"
    ],
    removeStatusCheckContexts: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    removeStatusCheckProtection: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    removeTeamAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    removeUserAccessRestrictions: [
      "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
    setAdminBranchProtection: [
      "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
    ],
    setAppAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
      {},
      { mapToData: "apps" }
    ],
    setStatusCheckContexts: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
      {},
      { mapToData: "contexts" }
    ],
    setTeamAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
      {},
      { mapToData: "teams" }
    ],
    setUserAccessRestrictions: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
      {},
      { mapToData: "users" }
    ],
    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
    transfer: ["POST /repos/{owner}/{repo}/transfer"],
    update: ["PATCH /repos/{owner}/{repo}"],
    updateBranchProtection: [
      "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
    ],
    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
    updateDeploymentBranchPolicy: [
      "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
    ],
    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
    updateInvitation: [
      "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
    ],
    updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
    updatePullRequestReviewProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
    ],
    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
    updateReleaseAsset: [
      "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
    ],
    updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
    updateStatusCheckPotection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
      {},
      { renamed: ["repos", "updateStatusCheckProtection"] }
    ],
    updateStatusCheckProtection: [
      "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
    ],
    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
    updateWebhookConfigForRepo: [
      "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
    ],
    uploadReleaseAsset: [
      "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
      { baseUrl: "https://uploads.github.com" }
    ]
  },
  search: {
    code: ["GET /search/code"],
    commits: ["GET /search/commits"],
    issuesAndPullRequests: [
      "GET /search/issues",
      {},
      {
        deprecated: "octokit.rest.search.issuesAndPullRequests() is deprecated, see https://docs.github.com/rest/search/search#search-issues-and-pull-requests"
      }
    ],
    labels: ["GET /search/labels"],
    repos: ["GET /search/repositories"],
    topics: ["GET /search/topics"],
    users: ["GET /search/users"]
  },
  secretScanning: {
    createPushProtectionBypass: [
      "POST /repos/{owner}/{repo}/secret-scanning/push-protection-bypasses"
    ],
    getAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ],
    getScanHistory: ["GET /repos/{owner}/{repo}/secret-scanning/scan-history"],
    listAlertsForEnterprise: [
      "GET /enterprises/{enterprise}/secret-scanning/alerts"
    ],
    listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
    listLocationsForAlert: [
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
    ],
    updateAlert: [
      "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
    ]
  },
  securityAdvisories: {
    createFork: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
    ],
    createPrivateVulnerabilityReport: [
      "POST /repos/{owner}/{repo}/security-advisories/reports"
    ],
    createRepositoryAdvisory: [
      "POST /repos/{owner}/{repo}/security-advisories"
    ],
    createRepositoryAdvisoryCveRequest: [
      "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
    ],
    getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
    getRepositoryAdvisory: [
      "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ],
    listGlobalAdvisories: ["GET /advisories"],
    listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
    listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
    updateRepositoryAdvisory: [
      "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
    ]
  },
  teams: {
    addOrUpdateMembershipForUserInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    addOrUpdateRepoPermissionsInOrg: [
      "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    checkPermissionsForRepoInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    create: ["POST /orgs/{org}/teams"],
    createDiscussionCommentInOrg: [
      "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
    deleteDiscussionCommentInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    deleteDiscussionInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
    getDiscussionCommentInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    getDiscussionInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    getMembershipForUserInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    list: ["GET /orgs/{org}/teams"],
    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
    listDiscussionCommentsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
    ],
    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
    listForAuthenticatedUser: ["GET /user/teams"],
    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
    listPendingInvitationsInOrg: [
      "GET /orgs/{org}/teams/{team_slug}/invitations"
    ],
    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
    removeMembershipForUserInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
    ],
    removeRepoInOrg: [
      "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
    ],
    updateDiscussionCommentInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
    ],
    updateDiscussionInOrg: [
      "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
    ],
    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
  },
  users: {
    addEmailForAuthenticated: [
      "POST /user/emails",
      {},
      { renamed: ["users", "addEmailForAuthenticatedUser"] }
    ],
    addEmailForAuthenticatedUser: ["POST /user/emails"],
    addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
    block: ["PUT /user/blocks/{username}"],
    checkBlocked: ["GET /user/blocks/{username}"],
    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
    createGpgKeyForAuthenticated: [
      "POST /user/gpg_keys",
      {},
      { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
    ],
    createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
    createPublicSshKeyForAuthenticated: [
      "POST /user/keys",
      {},
      { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
    ],
    createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
    createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
    deleteEmailForAuthenticated: [
      "DELETE /user/emails",
      {},
      { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
    ],
    deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
    deleteGpgKeyForAuthenticated: [
      "DELETE /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
    ],
    deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
    deletePublicSshKeyForAuthenticated: [
      "DELETE /user/keys/{key_id}",
      {},
      { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
    ],
    deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
    deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
    deleteSshSigningKeyForAuthenticatedUser: [
      "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    follow: ["PUT /user/following/{username}"],
    getAuthenticated: ["GET /user"],
    getById: ["GET /user/{account_id}"],
    getByUsername: ["GET /users/{username}"],
    getContextForUser: ["GET /users/{username}/hovercard"],
    getGpgKeyForAuthenticated: [
      "GET /user/gpg_keys/{gpg_key_id}",
      {},
      { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
    ],
    getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
    getPublicSshKeyForAuthenticated: [
      "GET /user/keys/{key_id}",
      {},
      { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
    ],
    getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
    getSshSigningKeyForAuthenticatedUser: [
      "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
    ],
    list: ["GET /users"],
    listAttestations: ["GET /users/{username}/attestations/{subject_digest}"],
    listBlockedByAuthenticated: [
      "GET /user/blocks",
      {},
      { renamed: ["users", "listBlockedByAuthenticatedUser"] }
    ],
    listBlockedByAuthenticatedUser: ["GET /user/blocks"],
    listEmailsForAuthenticated: [
      "GET /user/emails",
      {},
      { renamed: ["users", "listEmailsForAuthenticatedUser"] }
    ],
    listEmailsForAuthenticatedUser: ["GET /user/emails"],
    listFollowedByAuthenticated: [
      "GET /user/following",
      {},
      { renamed: ["users", "listFollowedByAuthenticatedUser"] }
    ],
    listFollowedByAuthenticatedUser: ["GET /user/following"],
    listFollowersForAuthenticatedUser: ["GET /user/followers"],
    listFollowersForUser: ["GET /users/{username}/followers"],
    listFollowingForUser: ["GET /users/{username}/following"],
    listGpgKeysForAuthenticated: [
      "GET /user/gpg_keys",
      {},
      { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
    ],
    listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
    listPublicEmailsForAuthenticated: [
      "GET /user/public_emails",
      {},
      { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
    ],
    listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
    listPublicKeysForUser: ["GET /users/{username}/keys"],
    listPublicSshKeysForAuthenticated: [
      "GET /user/keys",
      {},
      { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
    ],
    listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
    listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
    listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
    listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
    listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
    setPrimaryEmailVisibilityForAuthenticated: [
      "PATCH /user/email/visibility",
      {},
      { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
    ],
    setPrimaryEmailVisibilityForAuthenticatedUser: [
      "PATCH /user/email/visibility"
    ],
    unblock: ["DELETE /user/blocks/{username}"],
    unfollow: ["DELETE /user/following/{username}"],
    updateAuthenticated: ["PATCH /user"]
  }
};
var endpoints_default = Endpoints;

// node_modules/@octokit/rest/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/endpoints-to-methods.js
var endpointMethodsMap = /* @__PURE__ */ new Map;
for (const [scope, endpoints] of Object.entries(endpoints_default)) {
  for (const [methodName, endpoint2] of Object.entries(endpoints)) {
    const [route, defaults, decorations] = endpoint2;
    const [method, url] = route.split(/ /);
    const endpointDefaults = Object.assign({
      method,
      url
    }, defaults);
    if (!endpointMethodsMap.has(scope)) {
      endpointMethodsMap.set(scope, /* @__PURE__ */ new Map);
    }
    endpointMethodsMap.get(scope).set(methodName, {
      scope,
      methodName,
      endpointDefaults,
      decorations
    });
  }
}
var handler = {
  has({ scope }, methodName) {
    return endpointMethodsMap.get(scope).has(methodName);
  },
  getOwnPropertyDescriptor(target, methodName) {
    return {
      value: this.get(target, methodName),
      configurable: true,
      writable: true,
      enumerable: true
    };
  },
  defineProperty(target, methodName, descriptor) {
    Object.defineProperty(target.cache, methodName, descriptor);
    return true;
  },
  deleteProperty(target, methodName) {
    delete target.cache[methodName];
    return true;
  },
  ownKeys({ scope }) {
    return [...endpointMethodsMap.get(scope).keys()];
  },
  set(target, methodName, value) {
    return target.cache[methodName] = value;
  },
  get({ octokit, scope, cache }, methodName) {
    if (cache[methodName]) {
      return cache[methodName];
    }
    const method = endpointMethodsMap.get(scope).get(methodName);
    if (!method) {
      return;
    }
    const { endpointDefaults, decorations } = method;
    if (decorations) {
      cache[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
    } else {
      cache[methodName] = octokit.request.defaults(endpointDefaults);
    }
    return cache[methodName];
  }
};
function endpointsToMethods(octokit) {
  const newMethods = {};
  for (const scope of endpointMethodsMap.keys()) {
    newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);
  }
  return newMethods;
}
function decorate(octokit, scope, methodName, defaults, decorations) {
  const requestWithDefaults = octokit.request.defaults(defaults);
  function withDecorations(...args) {
    let options = requestWithDefaults.endpoint.merge(...args);
    if (decorations.mapToData) {
      options = Object.assign({}, options, {
        data: options[decorations.mapToData],
        [decorations.mapToData]: undefined
      });
      return requestWithDefaults(options);
    }
    if (decorations.renamed) {
      const [newScope, newMethodName] = decorations.renamed;
      octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
    }
    if (decorations.deprecated) {
      octokit.log.warn(decorations.deprecated);
    }
    if (decorations.renamedParameters) {
      const options2 = requestWithDefaults.endpoint.merge(...args);
      for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
        if (name in options2) {
          octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);
          if (!(alias in options2)) {
            options2[alias] = options2[name];
          }
          delete options2[name];
        }
      }
      return requestWithDefaults(options2);
    }
    return requestWithDefaults(...args);
  }
  return Object.assign(withDecorations, requestWithDefaults);
}

// node_modules/@octokit/rest/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/index.js
function restEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    rest: api
  };
}
restEndpointMethods.VERSION = VERSION7;
function legacyRestEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    ...api,
    rest: api
  };
}
legacyRestEndpointMethods.VERSION = VERSION7;

// node_modules/@octokit/rest/dist-src/version.js
var VERSION8 = "22.0.0";

// node_modules/@octokit/rest/dist-src/index.js
var Octokit2 = Octokit.plugin(requestLog, legacyRestEndpointMethods, paginateRest).defaults({
  userAgent: `octokit-rest.js/${VERSION8}`
});

// node_modules/@octokit/auth-app/node_modules/@octokit/request/node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION9 = "0.0.0-development";
var userAgent2 = `octokit-endpoint.js/${VERSION9} ${getUserAgent()}`;
var DEFAULTS2 = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent2
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys2(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject3(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep2(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject3(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep2(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties2(obj) {
  for (const key in obj) {
    if (obj[key] === undefined) {
      delete obj[key];
    }
  }
  return obj;
}
function merge2(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys2(options.headers);
  removeUndefinedProperties2(options);
  removeUndefinedProperties2(options.headers);
  const mergedOptions = mergeDeep2(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && defaults.mediaType.previews?.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters2(url, parameters2) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters2);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters2.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters2[name])}`;
  }).join("&");
}
var urlVariableRegex2 = /\{[^{}}]+\}/g;
function removeNonChars2(variableName) {
  return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames2(url) {
  const matches = url.match(urlVariableRegex2);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars2).reduce((a2, b2) => a2.concat(b2), []);
}
function omit2(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved2(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved2(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue2(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved2(value) : encodeUnreserved2(value);
  if (key) {
    return encodeUnreserved2(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined3(value) {
  return value !== undefined && value !== null;
}
function isKeyOperator2(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues2(context4, operator, key, modifier) {
  var value = context4[key], result = [];
  if (isDefined3(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(encodeValue2(operator, value, isKeyOperator2(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined3).forEach(function(value2) {
            result.push(encodeValue2(operator, value2, isKeyOperator2(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function(k2) {
            if (isDefined3(value[k2])) {
              result.push(encodeValue2(operator, value[k2], k2));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined3).forEach(function(value2) {
            tmp.push(encodeValue2(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k2) {
            if (isDefined3(value[k2])) {
              tmp.push(encodeUnreserved2(k2));
              tmp.push(encodeValue2(operator, value[k2].toString()));
            }
          });
        }
        if (isKeyOperator2(operator)) {
          result.push(encodeUnreserved2(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined3(value)) {
        result.push(encodeUnreserved2(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved2(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl2(template) {
  return {
    expand: expand2.bind(null, template)
  };
}
function expand2(template, context4) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_2, expression, literal) {
    if (expression) {
      let operator = "";
      const values = [];
      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }
      expression.split(/,/g).forEach(function(variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues2(context4, operator, tmp[1], tmp[2] || tmp[3]));
      });
      if (operator && operator !== "+") {
        var separator = ",";
        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }
        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved2(literal);
    }
  });
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse6(options) {
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters2 = omit2(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames2(url);
  url = parseUrl2(url).expand(parameters2);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit2(parameters2, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map((format5) => format5.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }
    if (url.endsWith("/graphql")) {
      if (options.mediaType.previews?.length) {
        const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format5 = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format5}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters2(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}
function endpointWithDefaults2(defaults, route, options) {
  return parse6(merge2(defaults, route, options));
}
function withDefaults4(oldDefaults, newDefaults) {
  const DEFAULTS22 = merge2(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults2.bind(null, DEFAULTS22);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS22,
    defaults: withDefaults4.bind(null, DEFAULTS22),
    merge: merge2.bind(null, DEFAULTS22),
    parse: parse6
  });
}
var endpoint2 = withDefaults4(null, DEFAULTS2);

// node_modules/fast-content-type-parse/index.js
var NullObject3 = function NullObject4() {
};
NullObject3.prototype = Object.create(null);
var paramRE2 = /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu;
var quotedPairRE2 = /\\([\v\u0020-\u00ff])/gu;
var mediaTypeRE2 = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u;
var defaultContentType2 = { type: "", parameters: new NullObject3 };
Object.freeze(defaultContentType2.parameters);
Object.freeze(defaultContentType2);
function safeParse2(header) {
  if (typeof header !== "string") {
    return defaultContentType2;
  }
  let index = header.indexOf(";");
  const type3 = index !== -1 ? header.slice(0, index).trim() : header.trim();
  if (mediaTypeRE2.test(type3) === false) {
    return defaultContentType2;
  }
  const result = {
    type: type3.toLowerCase(),
    parameters: new NullObject3
  };
  if (index === -1) {
    return result;
  }
  let key;
  let match;
  let value;
  paramRE2.lastIndex = index;
  while (match = paramRE2.exec(header)) {
    if (match.index !== index) {
      return defaultContentType2;
    }
    index += match[0].length;
    key = match[1].toLowerCase();
    value = match[2];
    if (value[0] === '"') {
      value = value.slice(1, value.length - 1);
      quotedPairRE2.test(value) && (value = value.replace(quotedPairRE2, "$1"));
    }
    result.parameters[key] = value;
  }
  if (index !== header.length) {
    return defaultContentType2;
  }
  return result;
}
var $safeParse2 = safeParse2;

// node_modules/@octokit/auth-app/node_modules/@octokit/request-error/dist-src/index.js
class RequestError2 extends Error {
  name;
  status;
  request;
  response;
  constructor(message, statusCode, options) {
    super(message);
    this.name = "HttpError";
    this.status = Number.parseInt(statusCode);
    if (Number.isNaN(this.status)) {
      this.status = 0;
    }
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]")
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
}

// node_modules/@octokit/auth-app/node_modules/@octokit/request/dist-bundle/index.js
var VERSION10 = "0.0.0-development";
var defaults_default2 = {
  headers: {
    "user-agent": `octokit-request.js/${VERSION10} ${getUserAgent()}`
  }
};
function isPlainObject4(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
async function fetchWrapper2(requestOptions) {
  const fetch = requestOptions.request?.fetch || globalThis.fetch;
  if (!fetch) {
    throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
  }
  const log2 = requestOptions.request?.log || console;
  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
  const body = isPlainObject4(requestOptions.body) || Array.isArray(requestOptions.body) ? JSON.stringify(requestOptions.body) : requestOptions.body;
  const requestHeaders = Object.fromEntries(Object.entries(requestOptions.headers).map(([name, value]) => [
    name,
    String(value)
  ]));
  let fetchResponse;
  try {
    fetchResponse = await fetch(requestOptions.url, {
      method: requestOptions.method,
      body,
      redirect: requestOptions.request?.redirect,
      headers: requestHeaders,
      signal: requestOptions.request?.signal,
      ...requestOptions.body && { duplex: "half" }
    });
  } catch (error) {
    let message = "Unknown Error";
    if (error instanceof Error) {
      if (error.name === "AbortError") {
        error.status = 500;
        throw error;
      }
      message = error.message;
      if (error.name === "TypeError" && "cause" in error) {
        if (error.cause instanceof Error) {
          message = error.cause.message;
        } else if (typeof error.cause === "string") {
          message = error.cause;
        }
      }
    }
    const requestError = new RequestError2(message, 500, {
      request: requestOptions
    });
    requestError.cause = error;
    throw requestError;
  }
  const status = fetchResponse.status;
  const url = fetchResponse.url;
  const responseHeaders = {};
  for (const [key, value] of fetchResponse.headers) {
    responseHeaders[key] = value;
  }
  const octokitResponse = {
    url,
    status,
    headers: responseHeaders,
    data: ""
  };
  if ("deprecation" in responseHeaders) {
    const matches = responseHeaders.link && responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
    const deprecationLink = matches && matches.pop();
    log2.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
  }
  if (status === 204 || status === 205) {
    return octokitResponse;
  }
  if (requestOptions.method === "HEAD") {
    if (status < 400) {
      return octokitResponse;
    }
    throw new RequestError2(fetchResponse.statusText, status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status === 304) {
    octokitResponse.data = await getResponseData2(fetchResponse);
    throw new RequestError2("Not modified", status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status >= 400) {
    octokitResponse.data = await getResponseData2(fetchResponse);
    throw new RequestError2(toErrorMessage2(octokitResponse.data), status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  octokitResponse.data = parseSuccessResponseBody ? await getResponseData2(fetchResponse) : fetchResponse.body;
  return octokitResponse;
}
async function getResponseData2(response) {
  const contentType = response.headers.get("content-type");
  if (!contentType) {
    return response.text().catch(() => "");
  }
  const mimetype = $safeParse2(contentType);
  if (isJSONResponse2(mimetype)) {
    let text = "";
    try {
      text = await response.text();
      return JSON.parse(text);
    } catch (err) {
      return text;
    }
  } else if (mimetype.type.startsWith("text/") || mimetype.parameters.charset?.toLowerCase() === "utf-8") {
    return response.text().catch(() => "");
  } else {
    return response.arrayBuffer().catch(() => new ArrayBuffer(0));
  }
}
function isJSONResponse2(mimetype) {
  return mimetype.type === "application/json" || mimetype.type === "application/scim+json";
}
function toErrorMessage2(data) {
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return "Unknown error";
  }
  if ("message" in data) {
    const suffix = "documentation_url" in data ? ` - ${data.documentation_url}` : "";
    return Array.isArray(data.errors) ? `${data.message}: ${data.errors.map((v2) => JSON.stringify(v2)).join(", ")}${suffix}` : `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults5(oldEndpoint, newDefaults) {
  const endpoint22 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters2) {
    const endpointOptions = endpoint22.merge(route, parameters2);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper2(endpoint22.parse(endpointOptions));
    }
    const request22 = (route2, parameters22) => {
      return fetchWrapper2(endpoint22.parse(endpoint22.merge(route2, parameters22)));
    };
    Object.assign(request22, {
      endpoint: endpoint22,
      defaults: withDefaults5.bind(null, endpoint22)
    });
    return endpointOptions.request.hook(request22, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint22,
    defaults: withDefaults5.bind(null, endpoint22)
  });
}
var request4 = withDefaults5(endpoint2, defaults_default2);

// node_modules/@octokit/auth-oauth-app/node_modules/@octokit/request/node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION11 = "0.0.0-development";
var userAgent3 = `octokit-endpoint.js/${VERSION11} ${getUserAgent()}`;
var DEFAULTS3 = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent3
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys3(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject5(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep3(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject5(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep3(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties3(obj) {
  for (const key in obj) {
    if (obj[key] === undefined) {
      delete obj[key];
    }
  }
  return obj;
}
function merge3(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys3(options.headers);
  removeUndefinedProperties3(options);
  removeUndefinedProperties3(options.headers);
  const mergedOptions = mergeDeep3(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && defaults.mediaType.previews?.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters3(url, parameters2) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters2);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters2.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters2[name])}`;
  }).join("&");
}
var urlVariableRegex3 = /\{[^{}}]+\}/g;
function removeNonChars3(variableName) {
  return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames3(url) {
  const matches = url.match(urlVariableRegex3);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars3).reduce((a2, b2) => a2.concat(b2), []);
}
function omit3(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved3(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved3(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue3(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved3(value) : encodeUnreserved3(value);
  if (key) {
    return encodeUnreserved3(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined4(value) {
  return value !== undefined && value !== null;
}
function isKeyOperator3(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues3(context4, operator, key, modifier) {
  var value = context4[key], result = [];
  if (isDefined4(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(encodeValue3(operator, value, isKeyOperator3(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined4).forEach(function(value2) {
            result.push(encodeValue3(operator, value2, isKeyOperator3(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function(k2) {
            if (isDefined4(value[k2])) {
              result.push(encodeValue3(operator, value[k2], k2));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined4).forEach(function(value2) {
            tmp.push(encodeValue3(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k2) {
            if (isDefined4(value[k2])) {
              tmp.push(encodeUnreserved3(k2));
              tmp.push(encodeValue3(operator, value[k2].toString()));
            }
          });
        }
        if (isKeyOperator3(operator)) {
          result.push(encodeUnreserved3(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined4(value)) {
        result.push(encodeUnreserved3(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved3(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl3(template) {
  return {
    expand: expand3.bind(null, template)
  };
}
function expand3(template, context4) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_2, expression, literal) {
    if (expression) {
      let operator = "";
      const values = [];
      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }
      expression.split(/,/g).forEach(function(variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues3(context4, operator, tmp[1], tmp[2] || tmp[3]));
      });
      if (operator && operator !== "+") {
        var separator = ",";
        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }
        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved3(literal);
    }
  });
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse7(options) {
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters2 = omit3(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames3(url);
  url = parseUrl3(url).expand(parameters2);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit3(parameters2, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map((format5) => format5.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }
    if (url.endsWith("/graphql")) {
      if (options.mediaType.previews?.length) {
        const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format5 = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format5}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters3(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}
function endpointWithDefaults3(defaults, route, options) {
  return parse7(merge3(defaults, route, options));
}
function withDefaults6(oldDefaults, newDefaults) {
  const DEFAULTS22 = merge3(oldDefaults, newDefaults);
  const endpoint22 = endpointWithDefaults3.bind(null, DEFAULTS22);
  return Object.assign(endpoint22, {
    DEFAULTS: DEFAULTS22,
    defaults: withDefaults6.bind(null, DEFAULTS22),
    merge: merge3.bind(null, DEFAULTS22),
    parse: parse7
  });
}
var endpoint3 = withDefaults6(null, DEFAULTS3);

// node_modules/@octokit/auth-oauth-app/node_modules/@octokit/request/node_modules/@octokit/request-error/dist-src/index.js
class RequestError3 extends Error {
  name;
  status;
  request;
  response;
  constructor(message, statusCode, options) {
    super(message);
    this.name = "HttpError";
    this.status = Number.parseInt(statusCode);
    if (Number.isNaN(this.status)) {
      this.status = 0;
    }
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]")
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
}

// node_modules/@octokit/auth-oauth-app/node_modules/@octokit/request/dist-bundle/index.js
var VERSION12 = "0.0.0-development";
var defaults_default3 = {
  headers: {
    "user-agent": `octokit-request.js/${VERSION12} ${getUserAgent()}`
  }
};
function isPlainObject6(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
async function fetchWrapper3(requestOptions) {
  const fetch = requestOptions.request?.fetch || globalThis.fetch;
  if (!fetch) {
    throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
  }
  const log2 = requestOptions.request?.log || console;
  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
  const body = isPlainObject6(requestOptions.body) || Array.isArray(requestOptions.body) ? JSON.stringify(requestOptions.body) : requestOptions.body;
  const requestHeaders = Object.fromEntries(Object.entries(requestOptions.headers).map(([name, value]) => [
    name,
    String(value)
  ]));
  let fetchResponse;
  try {
    fetchResponse = await fetch(requestOptions.url, {
      method: requestOptions.method,
      body,
      redirect: requestOptions.request?.redirect,
      headers: requestHeaders,
      signal: requestOptions.request?.signal,
      ...requestOptions.body && { duplex: "half" }
    });
  } catch (error) {
    let message = "Unknown Error";
    if (error instanceof Error) {
      if (error.name === "AbortError") {
        error.status = 500;
        throw error;
      }
      message = error.message;
      if (error.name === "TypeError" && "cause" in error) {
        if (error.cause instanceof Error) {
          message = error.cause.message;
        } else if (typeof error.cause === "string") {
          message = error.cause;
        }
      }
    }
    const requestError = new RequestError3(message, 500, {
      request: requestOptions
    });
    requestError.cause = error;
    throw requestError;
  }
  const status = fetchResponse.status;
  const url = fetchResponse.url;
  const responseHeaders = {};
  for (const [key, value] of fetchResponse.headers) {
    responseHeaders[key] = value;
  }
  const octokitResponse = {
    url,
    status,
    headers: responseHeaders,
    data: ""
  };
  if ("deprecation" in responseHeaders) {
    const matches = responseHeaders.link && responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
    const deprecationLink = matches && matches.pop();
    log2.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
  }
  if (status === 204 || status === 205) {
    return octokitResponse;
  }
  if (requestOptions.method === "HEAD") {
    if (status < 400) {
      return octokitResponse;
    }
    throw new RequestError3(fetchResponse.statusText, status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status === 304) {
    octokitResponse.data = await getResponseData3(fetchResponse);
    throw new RequestError3("Not modified", status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status >= 400) {
    octokitResponse.data = await getResponseData3(fetchResponse);
    throw new RequestError3(toErrorMessage3(octokitResponse.data), status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  octokitResponse.data = parseSuccessResponseBody ? await getResponseData3(fetchResponse) : fetchResponse.body;
  return octokitResponse;
}
async function getResponseData3(response) {
  const contentType = response.headers.get("content-type");
  if (!contentType) {
    return response.text().catch(() => "");
  }
  const mimetype = $safeParse2(contentType);
  if (isJSONResponse3(mimetype)) {
    let text = "";
    try {
      text = await response.text();
      return JSON.parse(text);
    } catch (err) {
      return text;
    }
  } else if (mimetype.type.startsWith("text/") || mimetype.parameters.charset?.toLowerCase() === "utf-8") {
    return response.text().catch(() => "");
  } else {
    return response.arrayBuffer().catch(() => new ArrayBuffer(0));
  }
}
function isJSONResponse3(mimetype) {
  return mimetype.type === "application/json" || mimetype.type === "application/scim+json";
}
function toErrorMessage3(data) {
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return "Unknown error";
  }
  if ("message" in data) {
    const suffix = "documentation_url" in data ? ` - ${data.documentation_url}` : "";
    return Array.isArray(data.errors) ? `${data.message}: ${data.errors.map((v2) => JSON.stringify(v2)).join(", ")}${suffix}` : `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults7(oldEndpoint, newDefaults) {
  const endpoint22 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters2) {
    const endpointOptions = endpoint22.merge(route, parameters2);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper3(endpoint22.parse(endpointOptions));
    }
    const request22 = (route2, parameters22) => {
      return fetchWrapper3(endpoint22.parse(endpoint22.merge(route2, parameters22)));
    };
    Object.assign(request22, {
      endpoint: endpoint22,
      defaults: withDefaults7.bind(null, endpoint22)
    });
    return endpointOptions.request.hook(request22, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint22,
    defaults: withDefaults7.bind(null, endpoint22)
  });
}
var request5 = withDefaults7(endpoint3, defaults_default3);

// node_modules/@octokit/auth-oauth-user/node_modules/@octokit/request/node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION13 = "0.0.0-development";
var userAgent4 = `octokit-endpoint.js/${VERSION13} ${getUserAgent()}`;
var DEFAULTS4 = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent4
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys4(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject7(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep4(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject7(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep4(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties4(obj) {
  for (const key in obj) {
    if (obj[key] === undefined) {
      delete obj[key];
    }
  }
  return obj;
}
function merge4(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys4(options.headers);
  removeUndefinedProperties4(options);
  removeUndefinedProperties4(options.headers);
  const mergedOptions = mergeDeep4(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && defaults.mediaType.previews?.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters4(url, parameters2) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters2);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters2.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters2[name])}`;
  }).join("&");
}
var urlVariableRegex4 = /\{[^{}}]+\}/g;
function removeNonChars4(variableName) {
  return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames4(url) {
  const matches = url.match(urlVariableRegex4);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars4).reduce((a2, b2) => a2.concat(b2), []);
}
function omit4(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved4(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved4(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue4(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved4(value) : encodeUnreserved4(value);
  if (key) {
    return encodeUnreserved4(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined5(value) {
  return value !== undefined && value !== null;
}
function isKeyOperator4(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues4(context4, operator, key, modifier) {
  var value = context4[key], result = [];
  if (isDefined5(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(encodeValue4(operator, value, isKeyOperator4(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined5).forEach(function(value2) {
            result.push(encodeValue4(operator, value2, isKeyOperator4(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function(k2) {
            if (isDefined5(value[k2])) {
              result.push(encodeValue4(operator, value[k2], k2));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined5).forEach(function(value2) {
            tmp.push(encodeValue4(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k2) {
            if (isDefined5(value[k2])) {
              tmp.push(encodeUnreserved4(k2));
              tmp.push(encodeValue4(operator, value[k2].toString()));
            }
          });
        }
        if (isKeyOperator4(operator)) {
          result.push(encodeUnreserved4(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined5(value)) {
        result.push(encodeUnreserved4(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved4(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl4(template) {
  return {
    expand: expand4.bind(null, template)
  };
}
function expand4(template, context4) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_2, expression, literal) {
    if (expression) {
      let operator = "";
      const values = [];
      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }
      expression.split(/,/g).forEach(function(variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues4(context4, operator, tmp[1], tmp[2] || tmp[3]));
      });
      if (operator && operator !== "+") {
        var separator = ",";
        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }
        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved4(literal);
    }
  });
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse8(options) {
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters2 = omit4(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames4(url);
  url = parseUrl4(url).expand(parameters2);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit4(parameters2, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map((format5) => format5.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }
    if (url.endsWith("/graphql")) {
      if (options.mediaType.previews?.length) {
        const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format5 = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format5}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters4(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}
function endpointWithDefaults4(defaults, route, options) {
  return parse8(merge4(defaults, route, options));
}
function withDefaults8(oldDefaults, newDefaults) {
  const DEFAULTS22 = merge4(oldDefaults, newDefaults);
  const endpoint22 = endpointWithDefaults4.bind(null, DEFAULTS22);
  return Object.assign(endpoint22, {
    DEFAULTS: DEFAULTS22,
    defaults: withDefaults8.bind(null, DEFAULTS22),
    merge: merge4.bind(null, DEFAULTS22),
    parse: parse8
  });
}
var endpoint4 = withDefaults8(null, DEFAULTS4);

// node_modules/@octokit/auth-oauth-user/node_modules/@octokit/request/node_modules/@octokit/request-error/dist-src/index.js
class RequestError4 extends Error {
  name;
  status;
  request;
  response;
  constructor(message, statusCode, options) {
    super(message);
    this.name = "HttpError";
    this.status = Number.parseInt(statusCode);
    if (Number.isNaN(this.status)) {
      this.status = 0;
    }
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]")
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
}

// node_modules/@octokit/auth-oauth-user/node_modules/@octokit/request/dist-bundle/index.js
var VERSION14 = "0.0.0-development";
var defaults_default4 = {
  headers: {
    "user-agent": `octokit-request.js/${VERSION14} ${getUserAgent()}`
  }
};
function isPlainObject8(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
async function fetchWrapper4(requestOptions) {
  const fetch = requestOptions.request?.fetch || globalThis.fetch;
  if (!fetch) {
    throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
  }
  const log2 = requestOptions.request?.log || console;
  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
  const body = isPlainObject8(requestOptions.body) || Array.isArray(requestOptions.body) ? JSON.stringify(requestOptions.body) : requestOptions.body;
  const requestHeaders = Object.fromEntries(Object.entries(requestOptions.headers).map(([name, value]) => [
    name,
    String(value)
  ]));
  let fetchResponse;
  try {
    fetchResponse = await fetch(requestOptions.url, {
      method: requestOptions.method,
      body,
      redirect: requestOptions.request?.redirect,
      headers: requestHeaders,
      signal: requestOptions.request?.signal,
      ...requestOptions.body && { duplex: "half" }
    });
  } catch (error) {
    let message = "Unknown Error";
    if (error instanceof Error) {
      if (error.name === "AbortError") {
        error.status = 500;
        throw error;
      }
      message = error.message;
      if (error.name === "TypeError" && "cause" in error) {
        if (error.cause instanceof Error) {
          message = error.cause.message;
        } else if (typeof error.cause === "string") {
          message = error.cause;
        }
      }
    }
    const requestError = new RequestError4(message, 500, {
      request: requestOptions
    });
    requestError.cause = error;
    throw requestError;
  }
  const status = fetchResponse.status;
  const url = fetchResponse.url;
  const responseHeaders = {};
  for (const [key, value] of fetchResponse.headers) {
    responseHeaders[key] = value;
  }
  const octokitResponse = {
    url,
    status,
    headers: responseHeaders,
    data: ""
  };
  if ("deprecation" in responseHeaders) {
    const matches = responseHeaders.link && responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
    const deprecationLink = matches && matches.pop();
    log2.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
  }
  if (status === 204 || status === 205) {
    return octokitResponse;
  }
  if (requestOptions.method === "HEAD") {
    if (status < 400) {
      return octokitResponse;
    }
    throw new RequestError4(fetchResponse.statusText, status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status === 304) {
    octokitResponse.data = await getResponseData4(fetchResponse);
    throw new RequestError4("Not modified", status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status >= 400) {
    octokitResponse.data = await getResponseData4(fetchResponse);
    throw new RequestError4(toErrorMessage4(octokitResponse.data), status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  octokitResponse.data = parseSuccessResponseBody ? await getResponseData4(fetchResponse) : fetchResponse.body;
  return octokitResponse;
}
async function getResponseData4(response) {
  const contentType = response.headers.get("content-type");
  if (!contentType) {
    return response.text().catch(() => "");
  }
  const mimetype = $safeParse2(contentType);
  if (isJSONResponse4(mimetype)) {
    let text = "";
    try {
      text = await response.text();
      return JSON.parse(text);
    } catch (err) {
      return text;
    }
  } else if (mimetype.type.startsWith("text/") || mimetype.parameters.charset?.toLowerCase() === "utf-8") {
    return response.text().catch(() => "");
  } else {
    return response.arrayBuffer().catch(() => new ArrayBuffer(0));
  }
}
function isJSONResponse4(mimetype) {
  return mimetype.type === "application/json" || mimetype.type === "application/scim+json";
}
function toErrorMessage4(data) {
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return "Unknown error";
  }
  if ("message" in data) {
    const suffix = "documentation_url" in data ? ` - ${data.documentation_url}` : "";
    return Array.isArray(data.errors) ? `${data.message}: ${data.errors.map((v2) => JSON.stringify(v2)).join(", ")}${suffix}` : `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults9(oldEndpoint, newDefaults) {
  const endpoint22 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters2) {
    const endpointOptions = endpoint22.merge(route, parameters2);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper4(endpoint22.parse(endpointOptions));
    }
    const request22 = (route2, parameters22) => {
      return fetchWrapper4(endpoint22.parse(endpoint22.merge(route2, parameters22)));
    };
    Object.assign(request22, {
      endpoint: endpoint22,
      defaults: withDefaults9.bind(null, endpoint22)
    });
    return endpointOptions.request.hook(request22, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint22,
    defaults: withDefaults9.bind(null, endpoint22)
  });
}
var request6 = withDefaults9(endpoint4, defaults_default4);

// node_modules/@octokit/auth-oauth-device/node_modules/@octokit/request/node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION15 = "0.0.0-development";
var userAgent5 = `octokit-endpoint.js/${VERSION15} ${getUserAgent()}`;
var DEFAULTS5 = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent5
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys5(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject9(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep5(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject9(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep5(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties5(obj) {
  for (const key in obj) {
    if (obj[key] === undefined) {
      delete obj[key];
    }
  }
  return obj;
}
function merge5(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys5(options.headers);
  removeUndefinedProperties5(options);
  removeUndefinedProperties5(options.headers);
  const mergedOptions = mergeDeep5(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && defaults.mediaType.previews?.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters5(url, parameters2) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters2);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters2.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters2[name])}`;
  }).join("&");
}
var urlVariableRegex5 = /\{[^{}}]+\}/g;
function removeNonChars5(variableName) {
  return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames5(url) {
  const matches = url.match(urlVariableRegex5);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars5).reduce((a2, b2) => a2.concat(b2), []);
}
function omit5(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved5(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved5(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue5(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved5(value) : encodeUnreserved5(value);
  if (key) {
    return encodeUnreserved5(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined6(value) {
  return value !== undefined && value !== null;
}
function isKeyOperator5(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues5(context4, operator, key, modifier) {
  var value = context4[key], result = [];
  if (isDefined6(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(encodeValue5(operator, value, isKeyOperator5(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined6).forEach(function(value2) {
            result.push(encodeValue5(operator, value2, isKeyOperator5(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function(k2) {
            if (isDefined6(value[k2])) {
              result.push(encodeValue5(operator, value[k2], k2));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined6).forEach(function(value2) {
            tmp.push(encodeValue5(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k2) {
            if (isDefined6(value[k2])) {
              tmp.push(encodeUnreserved5(k2));
              tmp.push(encodeValue5(operator, value[k2].toString()));
            }
          });
        }
        if (isKeyOperator5(operator)) {
          result.push(encodeUnreserved5(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined6(value)) {
        result.push(encodeUnreserved5(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved5(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl5(template) {
  return {
    expand: expand5.bind(null, template)
  };
}
function expand5(template, context4) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_2, expression, literal) {
    if (expression) {
      let operator = "";
      const values = [];
      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }
      expression.split(/,/g).forEach(function(variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues5(context4, operator, tmp[1], tmp[2] || tmp[3]));
      });
      if (operator && operator !== "+") {
        var separator = ",";
        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }
        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved5(literal);
    }
  });
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse9(options) {
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters2 = omit5(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames5(url);
  url = parseUrl5(url).expand(parameters2);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit5(parameters2, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map((format5) => format5.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }
    if (url.endsWith("/graphql")) {
      if (options.mediaType.previews?.length) {
        const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format5 = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format5}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters5(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}
function endpointWithDefaults5(defaults, route, options) {
  return parse9(merge5(defaults, route, options));
}
function withDefaults10(oldDefaults, newDefaults) {
  const DEFAULTS22 = merge5(oldDefaults, newDefaults);
  const endpoint22 = endpointWithDefaults5.bind(null, DEFAULTS22);
  return Object.assign(endpoint22, {
    DEFAULTS: DEFAULTS22,
    defaults: withDefaults10.bind(null, DEFAULTS22),
    merge: merge5.bind(null, DEFAULTS22),
    parse: parse9
  });
}
var endpoint5 = withDefaults10(null, DEFAULTS5);

// node_modules/@octokit/auth-oauth-device/node_modules/@octokit/request/node_modules/@octokit/request-error/dist-src/index.js
class RequestError5 extends Error {
  name;
  status;
  request;
  response;
  constructor(message, statusCode, options) {
    super(message);
    this.name = "HttpError";
    this.status = Number.parseInt(statusCode);
    if (Number.isNaN(this.status)) {
      this.status = 0;
    }
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]")
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
}

// node_modules/@octokit/auth-oauth-device/node_modules/@octokit/request/dist-bundle/index.js
var VERSION16 = "0.0.0-development";
var defaults_default5 = {
  headers: {
    "user-agent": `octokit-request.js/${VERSION16} ${getUserAgent()}`
  }
};
function isPlainObject10(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
async function fetchWrapper5(requestOptions) {
  const fetch = requestOptions.request?.fetch || globalThis.fetch;
  if (!fetch) {
    throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
  }
  const log2 = requestOptions.request?.log || console;
  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
  const body = isPlainObject10(requestOptions.body) || Array.isArray(requestOptions.body) ? JSON.stringify(requestOptions.body) : requestOptions.body;
  const requestHeaders = Object.fromEntries(Object.entries(requestOptions.headers).map(([name, value]) => [
    name,
    String(value)
  ]));
  let fetchResponse;
  try {
    fetchResponse = await fetch(requestOptions.url, {
      method: requestOptions.method,
      body,
      redirect: requestOptions.request?.redirect,
      headers: requestHeaders,
      signal: requestOptions.request?.signal,
      ...requestOptions.body && { duplex: "half" }
    });
  } catch (error) {
    let message = "Unknown Error";
    if (error instanceof Error) {
      if (error.name === "AbortError") {
        error.status = 500;
        throw error;
      }
      message = error.message;
      if (error.name === "TypeError" && "cause" in error) {
        if (error.cause instanceof Error) {
          message = error.cause.message;
        } else if (typeof error.cause === "string") {
          message = error.cause;
        }
      }
    }
    const requestError = new RequestError5(message, 500, {
      request: requestOptions
    });
    requestError.cause = error;
    throw requestError;
  }
  const status = fetchResponse.status;
  const url = fetchResponse.url;
  const responseHeaders = {};
  for (const [key, value] of fetchResponse.headers) {
    responseHeaders[key] = value;
  }
  const octokitResponse = {
    url,
    status,
    headers: responseHeaders,
    data: ""
  };
  if ("deprecation" in responseHeaders) {
    const matches = responseHeaders.link && responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
    const deprecationLink = matches && matches.pop();
    log2.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
  }
  if (status === 204 || status === 205) {
    return octokitResponse;
  }
  if (requestOptions.method === "HEAD") {
    if (status < 400) {
      return octokitResponse;
    }
    throw new RequestError5(fetchResponse.statusText, status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status === 304) {
    octokitResponse.data = await getResponseData5(fetchResponse);
    throw new RequestError5("Not modified", status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status >= 400) {
    octokitResponse.data = await getResponseData5(fetchResponse);
    throw new RequestError5(toErrorMessage5(octokitResponse.data), status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  octokitResponse.data = parseSuccessResponseBody ? await getResponseData5(fetchResponse) : fetchResponse.body;
  return octokitResponse;
}
async function getResponseData5(response) {
  const contentType = response.headers.get("content-type");
  if (!contentType) {
    return response.text().catch(() => "");
  }
  const mimetype = $safeParse2(contentType);
  if (isJSONResponse5(mimetype)) {
    let text = "";
    try {
      text = await response.text();
      return JSON.parse(text);
    } catch (err) {
      return text;
    }
  } else if (mimetype.type.startsWith("text/") || mimetype.parameters.charset?.toLowerCase() === "utf-8") {
    return response.text().catch(() => "");
  } else {
    return response.arrayBuffer().catch(() => new ArrayBuffer(0));
  }
}
function isJSONResponse5(mimetype) {
  return mimetype.type === "application/json" || mimetype.type === "application/scim+json";
}
function toErrorMessage5(data) {
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return "Unknown error";
  }
  if ("message" in data) {
    const suffix = "documentation_url" in data ? ` - ${data.documentation_url}` : "";
    return Array.isArray(data.errors) ? `${data.message}: ${data.errors.map((v2) => JSON.stringify(v2)).join(", ")}${suffix}` : `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults11(oldEndpoint, newDefaults) {
  const endpoint22 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters2) {
    const endpointOptions = endpoint22.merge(route, parameters2);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper5(endpoint22.parse(endpointOptions));
    }
    const request22 = (route2, parameters22) => {
      return fetchWrapper5(endpoint22.parse(endpoint22.merge(route2, parameters22)));
    };
    Object.assign(request22, {
      endpoint: endpoint22,
      defaults: withDefaults11.bind(null, endpoint22)
    });
    return endpointOptions.request.hook(request22, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint22,
    defaults: withDefaults11.bind(null, endpoint22)
  });
}
var request7 = withDefaults11(endpoint5, defaults_default5);

// node_modules/@octokit/oauth-methods/node_modules/@octokit/request/node_modules/@octokit/endpoint/dist-bundle/index.js
var VERSION17 = "0.0.0-development";
var userAgent6 = `octokit-endpoint.js/${VERSION17} ${getUserAgent()}`;
var DEFAULTS6 = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent6
  },
  mediaType: {
    format: ""
  }
};
function lowercaseKeys6(object) {
  if (!object) {
    return {};
  }
  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}
function isPlainObject11(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep6(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject11(options[key])) {
      if (!(key in defaults))
        Object.assign(result, { [key]: options[key] });
      else
        result[key] = mergeDeep6(defaults[key], options[key]);
    } else {
      Object.assign(result, { [key]: options[key] });
    }
  });
  return result;
}
function removeUndefinedProperties6(obj) {
  for (const key in obj) {
    if (obj[key] === undefined) {
      delete obj[key];
    }
  }
  return obj;
}
function merge6(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? { method, url } : { url: method }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys6(options.headers);
  removeUndefinedProperties6(options);
  removeUndefinedProperties6(options.headers);
  const mergedOptions = mergeDeep6(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && defaults.mediaType.previews?.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters6(url, parameters2) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters2);
  if (names.length === 0) {
    return url;
  }
  return url + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters2.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters2[name])}`;
  }).join("&");
}
var urlVariableRegex6 = /\{[^{}}]+\}/g;
function removeNonChars6(variableName) {
  return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames6(url) {
  const matches = url.match(urlVariableRegex6);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars6).reduce((a2, b2) => a2.concat(b2), []);
}
function omit6(object, keysToOmit) {
  const result = { __proto__: null };
  for (const key of Object.keys(object)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object[key];
    }
  }
  return result;
}
function encodeReserved6(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved6(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue6(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved6(value) : encodeUnreserved6(value);
  if (key) {
    return encodeUnreserved6(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined7(value) {
  return value !== undefined && value !== null;
}
function isKeyOperator6(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues6(context4, operator, key, modifier) {
  var value = context4[key], result = [];
  if (isDefined7(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(encodeValue6(operator, value, isKeyOperator6(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined7).forEach(function(value2) {
            result.push(encodeValue6(operator, value2, isKeyOperator6(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function(k2) {
            if (isDefined7(value[k2])) {
              result.push(encodeValue6(operator, value[k2], k2));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined7).forEach(function(value2) {
            tmp.push(encodeValue6(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k2) {
            if (isDefined7(value[k2])) {
              tmp.push(encodeUnreserved6(k2));
              tmp.push(encodeValue6(operator, value[k2].toString()));
            }
          });
        }
        if (isKeyOperator6(operator)) {
          result.push(encodeUnreserved6(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined7(value)) {
        result.push(encodeUnreserved6(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved6(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl6(template) {
  return {
    expand: expand6.bind(null, template)
  };
}
function expand6(template, context4) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_2, expression, literal) {
    if (expression) {
      let operator = "";
      const values = [];
      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }
      expression.split(/,/g).forEach(function(variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues6(context4, operator, tmp[1], tmp[2] || tmp[3]));
      });
      if (operator && operator !== "+") {
        var separator = ",";
        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }
        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved6(literal);
    }
  });
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse10(options) {
  let method = options.method.toUpperCase();
  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters2 = omit6(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames6(url);
  url = parseUrl6(url).expand(parameters2);
  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit6(parameters2, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map((format5) => format5.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }
    if (url.endsWith("/graphql")) {
      if (options.mediaType.previews?.length) {
        const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format5 = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format5}`;
        }).join(",");
      }
    }
  }
  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters6(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign({ method, url, headers }, typeof body !== "undefined" ? { body } : null, options.request ? { request: options.request } : null);
}
function endpointWithDefaults6(defaults, route, options) {
  return parse10(merge6(defaults, route, options));
}
function withDefaults12(oldDefaults, newDefaults) {
  const DEFAULTS22 = merge6(oldDefaults, newDefaults);
  const endpoint22 = endpointWithDefaults6.bind(null, DEFAULTS22);
  return Object.assign(endpoint22, {
    DEFAULTS: DEFAULTS22,
    defaults: withDefaults12.bind(null, DEFAULTS22),
    merge: merge6.bind(null, DEFAULTS22),
    parse: parse10
  });
}
var endpoint6 = withDefaults12(null, DEFAULTS6);

// node_modules/@octokit/oauth-methods/node_modules/@octokit/request-error/dist-src/index.js
class RequestError6 extends Error {
  name;
  status;
  request;
  response;
  constructor(message, statusCode, options) {
    super(message);
    this.name = "HttpError";
    this.status = Number.parseInt(statusCode);
    if (Number.isNaN(this.status)) {
      this.status = 0;
    }
    if ("response" in options) {
      this.response = options.response;
    }
    const requestCopy = Object.assign({}, options.request);
    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]")
      });
    }
    requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }
}

// node_modules/@octokit/oauth-methods/node_modules/@octokit/request/dist-bundle/index.js
var VERSION18 = "0.0.0-development";
var defaults_default6 = {
  headers: {
    "user-agent": `octokit-request.js/${VERSION18} ${getUserAgent()}`
  }
};
function isPlainObject12(value) {
  if (typeof value !== "object" || value === null)
    return false;
  if (Object.prototype.toString.call(value) !== "[object Object]")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
async function fetchWrapper6(requestOptions) {
  const fetch = requestOptions.request?.fetch || globalThis.fetch;
  if (!fetch) {
    throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
  }
  const log2 = requestOptions.request?.log || console;
  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
  const body = isPlainObject12(requestOptions.body) || Array.isArray(requestOptions.body) ? JSON.stringify(requestOptions.body) : requestOptions.body;
  const requestHeaders = Object.fromEntries(Object.entries(requestOptions.headers).map(([name, value]) => [
    name,
    String(value)
  ]));
  let fetchResponse;
  try {
    fetchResponse = await fetch(requestOptions.url, {
      method: requestOptions.method,
      body,
      redirect: requestOptions.request?.redirect,
      headers: requestHeaders,
      signal: requestOptions.request?.signal,
      ...requestOptions.body && { duplex: "half" }
    });
  } catch (error) {
    let message = "Unknown Error";
    if (error instanceof Error) {
      if (error.name === "AbortError") {
        error.status = 500;
        throw error;
      }
      message = error.message;
      if (error.name === "TypeError" && "cause" in error) {
        if (error.cause instanceof Error) {
          message = error.cause.message;
        } else if (typeof error.cause === "string") {
          message = error.cause;
        }
      }
    }
    const requestError = new RequestError6(message, 500, {
      request: requestOptions
    });
    requestError.cause = error;
    throw requestError;
  }
  const status = fetchResponse.status;
  const url = fetchResponse.url;
  const responseHeaders = {};
  for (const [key, value] of fetchResponse.headers) {
    responseHeaders[key] = value;
  }
  const octokitResponse = {
    url,
    status,
    headers: responseHeaders,
    data: ""
  };
  if ("deprecation" in responseHeaders) {
    const matches = responseHeaders.link && responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
    const deprecationLink = matches && matches.pop();
    log2.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
  }
  if (status === 204 || status === 205) {
    return octokitResponse;
  }
  if (requestOptions.method === "HEAD") {
    if (status < 400) {
      return octokitResponse;
    }
    throw new RequestError6(fetchResponse.statusText, status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status === 304) {
    octokitResponse.data = await getResponseData6(fetchResponse);
    throw new RequestError6("Not modified", status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status >= 400) {
    octokitResponse.data = await getResponseData6(fetchResponse);
    throw new RequestError6(toErrorMessage6(octokitResponse.data), status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  octokitResponse.data = parseSuccessResponseBody ? await getResponseData6(fetchResponse) : fetchResponse.body;
  return octokitResponse;
}
async function getResponseData6(response) {
  const contentType = response.headers.get("content-type");
  if (!contentType) {
    return response.text().catch(() => "");
  }
  const mimetype = $safeParse2(contentType);
  if (isJSONResponse6(mimetype)) {
    let text = "";
    try {
      text = await response.text();
      return JSON.parse(text);
    } catch (err) {
      return text;
    }
  } else if (mimetype.type.startsWith("text/") || mimetype.parameters.charset?.toLowerCase() === "utf-8") {
    return response.text().catch(() => "");
  } else {
    return response.arrayBuffer().catch(() => new ArrayBuffer(0));
  }
}
function isJSONResponse6(mimetype) {
  return mimetype.type === "application/json" || mimetype.type === "application/scim+json";
}
function toErrorMessage6(data) {
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return "Unknown error";
  }
  if ("message" in data) {
    const suffix = "documentation_url" in data ? ` - ${data.documentation_url}` : "";
    return Array.isArray(data.errors) ? `${data.message}: ${data.errors.map((v2) => JSON.stringify(v2)).join(", ")}${suffix}` : `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults13(oldEndpoint, newDefaults) {
  const endpoint22 = oldEndpoint.defaults(newDefaults);
  const newApi = function(route, parameters2) {
    const endpointOptions = endpoint22.merge(route, parameters2);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper6(endpoint22.parse(endpointOptions));
    }
    const request22 = (route2, parameters22) => {
      return fetchWrapper6(endpoint22.parse(endpoint22.merge(route2, parameters22)));
    };
    Object.assign(request22, {
      endpoint: endpoint22,
      defaults: withDefaults13.bind(null, endpoint22)
    });
    return endpointOptions.request.hook(request22, endpointOptions);
  };
  return Object.assign(newApi, {
    endpoint: endpoint22,
    defaults: withDefaults13.bind(null, endpoint22)
  });
}
var request8 = withDefaults13(endpoint6, defaults_default6);

// node_modules/@octokit/oauth-methods/dist-bundle/index.js
function requestToOAuthBaseUrl(request9) {
  const endpointDefaults = request9.endpoint.DEFAULTS;
  return /^https:\/\/(api\.)?github\.com$/.test(endpointDefaults.baseUrl) ? "https://github.com" : endpointDefaults.baseUrl.replace("/api/v3", "");
}
async function oauthRequest(request9, route, parameters2) {
  const withOAuthParameters = {
    baseUrl: requestToOAuthBaseUrl(request9),
    headers: {
      accept: "application/json"
    },
    ...parameters2
  };
  const response = await request9(route, withOAuthParameters);
  if ("error" in response.data) {
    const error = new RequestError6(`${response.data.error_description} (${response.data.error}, ${response.data.error_uri})`, 400, {
      request: request9.endpoint.merge(route, withOAuthParameters)
    });
    error.response = response;
    throw error;
  }
  return response;
}
async function exchangeWebFlowCode(options) {
  const request9 = options.request || request8;
  const response = await oauthRequest(request9, "POST /login/oauth/access_token", {
    client_id: options.clientId,
    client_secret: options.clientSecret,
    code: options.code,
    redirect_uri: options.redirectUrl
  });
  const authentication = {
    clientType: options.clientType,
    clientId: options.clientId,
    clientSecret: options.clientSecret,
    token: response.data.access_token,
    scopes: response.data.scope.split(/\s+/).filter(Boolean)
  };
  if (options.clientType === "github-app") {
    if ("refresh_token" in response.data) {
      const apiTimeInMs = new Date(response.headers.date).getTime();
      authentication.refreshToken = response.data.refresh_token, authentication.expiresAt = toTimestamp(apiTimeInMs, response.data.expires_in), authentication.refreshTokenExpiresAt = toTimestamp(apiTimeInMs, response.data.refresh_token_expires_in);
    }
    delete authentication.scopes;
  }
  return { ...response, authentication };
}
function toTimestamp(apiTimeInMs, expirationInSeconds) {
  return new Date(apiTimeInMs + expirationInSeconds * 1000).toISOString();
}
async function createDeviceCode(options) {
  const request9 = options.request || request8;
  const parameters2 = {
    client_id: options.clientId
  };
  if ("scopes" in options && Array.isArray(options.scopes)) {
    parameters2.scope = options.scopes.join(" ");
  }
  return oauthRequest(request9, "POST /login/device/code", parameters2);
}
async function exchangeDeviceCode(options) {
  const request9 = options.request || request8;
  const response = await oauthRequest(request9, "POST /login/oauth/access_token", {
    client_id: options.clientId,
    device_code: options.code,
    grant_type: "urn:ietf:params:oauth:grant-type:device_code"
  });
  const authentication = {
    clientType: options.clientType,
    clientId: options.clientId,
    token: response.data.access_token,
    scopes: response.data.scope.split(/\s+/).filter(Boolean)
  };
  if ("clientSecret" in options) {
    authentication.clientSecret = options.clientSecret;
  }
  if (options.clientType === "github-app") {
    if ("refresh_token" in response.data) {
      const apiTimeInMs = new Date(response.headers.date).getTime();
      authentication.refreshToken = response.data.refresh_token, authentication.expiresAt = toTimestamp2(apiTimeInMs, response.data.expires_in), authentication.refreshTokenExpiresAt = toTimestamp2(apiTimeInMs, response.data.refresh_token_expires_in);
    }
    delete authentication.scopes;
  }
  return { ...response, authentication };
}
function toTimestamp2(apiTimeInMs, expirationInSeconds) {
  return new Date(apiTimeInMs + expirationInSeconds * 1000).toISOString();
}
async function checkToken(options) {
  const request9 = options.request || request8;
  const response = await request9("POST /applications/{client_id}/token", {
    headers: {
      authorization: `basic ${btoa(`${options.clientId}:${options.clientSecret}`)}`
    },
    client_id: options.clientId,
    access_token: options.token
  });
  const authentication = {
    clientType: options.clientType,
    clientId: options.clientId,
    clientSecret: options.clientSecret,
    token: options.token,
    scopes: response.data.scopes
  };
  if (response.data.expires_at)
    authentication.expiresAt = response.data.expires_at;
  if (options.clientType === "github-app") {
    delete authentication.scopes;
  }
  return { ...response, authentication };
}
async function refreshToken(options) {
  const request9 = options.request || request8;
  const response = await oauthRequest(request9, "POST /login/oauth/access_token", {
    client_id: options.clientId,
    client_secret: options.clientSecret,
    grant_type: "refresh_token",
    refresh_token: options.refreshToken
  });
  const apiTimeInMs = new Date(response.headers.date).getTime();
  const authentication = {
    clientType: "github-app",
    clientId: options.clientId,
    clientSecret: options.clientSecret,
    token: response.data.access_token,
    refreshToken: response.data.refresh_token,
    expiresAt: toTimestamp3(apiTimeInMs, response.data.expires_in),
    refreshTokenExpiresAt: toTimestamp3(apiTimeInMs, response.data.refresh_token_expires_in)
  };
  return { ...response, authentication };
}
function toTimestamp3(apiTimeInMs, expirationInSeconds) {
  return new Date(apiTimeInMs + expirationInSeconds * 1000).toISOString();
}
async function resetToken(options) {
  const request9 = options.request || request8;
  const auth2 = btoa(`${options.clientId}:${options.clientSecret}`);
  const response = await request9("PATCH /applications/{client_id}/token", {
    headers: {
      authorization: `basic ${auth2}`
    },
    client_id: options.clientId,
    access_token: options.token
  });
  const authentication = {
    clientType: options.clientType,
    clientId: options.clientId,
    clientSecret: options.clientSecret,
    token: response.data.token,
    scopes: response.data.scopes
  };
  if (response.data.expires_at)
    authentication.expiresAt = response.data.expires_at;
  if (options.clientType === "github-app") {
    delete authentication.scopes;
  }
  return { ...response, authentication };
}
async function deleteToken(options) {
  const request9 = options.request || request8;
  const auth2 = btoa(`${options.clientId}:${options.clientSecret}`);
  return request9("DELETE /applications/{client_id}/token", {
    headers: {
      authorization: `basic ${auth2}`
    },
    client_id: options.clientId,
    access_token: options.token
  });
}
async function deleteAuthorization(options) {
  const request9 = options.request || request8;
  const auth2 = btoa(`${options.clientId}:${options.clientSecret}`);
  return request9("DELETE /applications/{client_id}/grant", {
    headers: {
      authorization: `basic ${auth2}`
    },
    client_id: options.clientId,
    access_token: options.token
  });
}

// node_modules/@octokit/auth-oauth-device/dist-bundle/index.js
async function getOAuthAccessToken(state2, options) {
  const cachedAuthentication = getCachedAuthentication(state2, options.auth);
  if (cachedAuthentication)
    return cachedAuthentication;
  const { data: verification } = await createDeviceCode({
    clientType: state2.clientType,
    clientId: state2.clientId,
    request: options.request || state2.request,
    scopes: options.auth.scopes || state2.scopes
  });
  await state2.onVerification(verification);
  const authentication = await waitForAccessToken(options.request || state2.request, state2.clientId, state2.clientType, verification);
  state2.authentication = authentication;
  return authentication;
}
function getCachedAuthentication(state2, auth2) {
  if (auth2.refresh === true)
    return false;
  if (!state2.authentication)
    return false;
  if (state2.clientType === "github-app") {
    return state2.authentication;
  }
  const authentication = state2.authentication;
  const newScope = (("scopes" in auth2) && auth2.scopes || state2.scopes).join(" ");
  const currentScope = authentication.scopes.join(" ");
  return newScope === currentScope ? authentication : false;
}
async function wait(seconds) {
  await new Promise((resolve5) => setTimeout(resolve5, seconds * 1000));
}
async function waitForAccessToken(request9, clientId, clientType, verification) {
  try {
    const options = {
      clientId,
      request: request9,
      code: verification.device_code
    };
    const { authentication } = clientType === "oauth-app" ? await exchangeDeviceCode({
      ...options,
      clientType: "oauth-app"
    }) : await exchangeDeviceCode({
      ...options,
      clientType: "github-app"
    });
    return {
      type: "token",
      tokenType: "oauth",
      ...authentication
    };
  } catch (error) {
    if (!error.response)
      throw error;
    const errorType = error.response.data.error;
    if (errorType === "authorization_pending") {
      await wait(verification.interval);
      return waitForAccessToken(request9, clientId, clientType, verification);
    }
    if (errorType === "slow_down") {
      await wait(verification.interval + 7);
      return waitForAccessToken(request9, clientId, clientType, verification);
    }
    throw error;
  }
}
async function auth2(state2, authOptions) {
  return getOAuthAccessToken(state2, {
    auth: authOptions
  });
}
async function hook2(state2, request9, route, parameters2) {
  let endpoint7 = request9.endpoint.merge(route, parameters2);
  if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint7.url)) {
    return request9(endpoint7);
  }
  const { token } = await getOAuthAccessToken(state2, {
    request: request9,
    auth: { type: "oauth" }
  });
  endpoint7.headers.authorization = `token ${token}`;
  return request9(endpoint7);
}
var VERSION19 = "0.0.0-development";
function createOAuthDeviceAuth(options) {
  const requestWithDefaults = options.request || request7.defaults({
    headers: {
      "user-agent": `octokit-auth-oauth-device.js/${VERSION19} ${getUserAgent()}`
    }
  });
  const { request: request9 = requestWithDefaults, ...otherOptions } = options;
  const state2 = options.clientType === "github-app" ? {
    ...otherOptions,
    clientType: "github-app",
    request: request9
  } : {
    ...otherOptions,
    clientType: "oauth-app",
    request: request9,
    scopes: options.scopes || []
  };
  if (!options.clientId) {
    throw new Error('[@octokit/auth-oauth-device] "clientId" option must be set (https://github.com/octokit/auth-oauth-device.js#usage)');
  }
  if (!options.onVerification) {
    throw new Error('[@octokit/auth-oauth-device] "onVerification" option must be a function (https://github.com/octokit/auth-oauth-device.js#usage)');
  }
  return Object.assign(auth2.bind(null, state2), {
    hook: hook2.bind(null, state2)
  });
}

// node_modules/@octokit/auth-oauth-user/dist-bundle/index.js
var VERSION20 = "0.0.0-development";
async function getAuthentication(state2) {
  if ("code" in state2.strategyOptions) {
    const { authentication } = await exchangeWebFlowCode({
      clientId: state2.clientId,
      clientSecret: state2.clientSecret,
      clientType: state2.clientType,
      onTokenCreated: state2.onTokenCreated,
      ...state2.strategyOptions,
      request: state2.request
    });
    return {
      type: "token",
      tokenType: "oauth",
      ...authentication
    };
  }
  if ("onVerification" in state2.strategyOptions) {
    const deviceAuth = createOAuthDeviceAuth({
      clientType: state2.clientType,
      clientId: state2.clientId,
      onTokenCreated: state2.onTokenCreated,
      ...state2.strategyOptions,
      request: state2.request
    });
    const authentication = await deviceAuth({
      type: "oauth"
    });
    return {
      clientSecret: state2.clientSecret,
      ...authentication
    };
  }
  if ("token" in state2.strategyOptions) {
    return {
      type: "token",
      tokenType: "oauth",
      clientId: state2.clientId,
      clientSecret: state2.clientSecret,
      clientType: state2.clientType,
      onTokenCreated: state2.onTokenCreated,
      ...state2.strategyOptions
    };
  }
  throw new Error("[@octokit/auth-oauth-user] Invalid strategy options");
}
async function auth3(state2, options = {}) {
  if (!state2.authentication) {
    state2.authentication = state2.clientType === "oauth-app" ? await getAuthentication(state2) : await getAuthentication(state2);
  }
  if (state2.authentication.invalid) {
    throw new Error("[@octokit/auth-oauth-user] Token is invalid");
  }
  const currentAuthentication = state2.authentication;
  if ("expiresAt" in currentAuthentication) {
    if (options.type === "refresh" || new Date(currentAuthentication.expiresAt) < /* @__PURE__ */ new Date) {
      const { authentication } = await refreshToken({
        clientType: "github-app",
        clientId: state2.clientId,
        clientSecret: state2.clientSecret,
        refreshToken: currentAuthentication.refreshToken,
        request: state2.request
      });
      state2.authentication = {
        tokenType: "oauth",
        type: "token",
        ...authentication
      };
    }
  }
  if (options.type === "refresh") {
    if (state2.clientType === "oauth-app") {
      throw new Error("[@octokit/auth-oauth-user] OAuth Apps do not support expiring tokens");
    }
    if (!currentAuthentication.hasOwnProperty("expiresAt")) {
      throw new Error("[@octokit/auth-oauth-user] Refresh token missing");
    }
    await state2.onTokenCreated?.(state2.authentication, {
      type: options.type
    });
  }
  if (options.type === "check" || options.type === "reset") {
    const method = options.type === "check" ? checkToken : resetToken;
    try {
      const { authentication } = await method({
        clientType: state2.clientType,
        clientId: state2.clientId,
        clientSecret: state2.clientSecret,
        token: state2.authentication.token,
        request: state2.request
      });
      state2.authentication = {
        tokenType: "oauth",
        type: "token",
        ...authentication
      };
      if (options.type === "reset") {
        await state2.onTokenCreated?.(state2.authentication, {
          type: options.type
        });
      }
      return state2.authentication;
    } catch (error) {
      if (error.status === 404) {
        error.message = "[@octokit/auth-oauth-user] Token is invalid";
        state2.authentication.invalid = true;
      }
      throw error;
    }
  }
  if (options.type === "delete" || options.type === "deleteAuthorization") {
    const method = options.type === "delete" ? deleteToken : deleteAuthorization;
    try {
      await method({
        clientType: state2.clientType,
        clientId: state2.clientId,
        clientSecret: state2.clientSecret,
        token: state2.authentication.token,
        request: state2.request
      });
    } catch (error) {
      if (error.status !== 404)
        throw error;
    }
    state2.authentication.invalid = true;
    return state2.authentication;
  }
  return state2.authentication;
}
var ROUTES_REQUIRING_BASIC_AUTH = /\/applications\/[^/]+\/(token|grant)s?/;
function requiresBasicAuth(url) {
  return url && ROUTES_REQUIRING_BASIC_AUTH.test(url);
}
async function hook3(state2, request9, route, parameters2 = {}) {
  const endpoint7 = request9.endpoint.merge(route, parameters2);
  if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint7.url)) {
    return request9(endpoint7);
  }
  if (requiresBasicAuth(endpoint7.url)) {
    const credentials = btoa(`${state2.clientId}:${state2.clientSecret}`);
    endpoint7.headers.authorization = `basic ${credentials}`;
    return request9(endpoint7);
  }
  const { token } = state2.clientType === "oauth-app" ? await auth3({ ...state2, request: request9 }) : await auth3({ ...state2, request: request9 });
  endpoint7.headers.authorization = "token " + token;
  return request9(endpoint7);
}
function createOAuthUserAuth({
  clientId,
  clientSecret,
  clientType = "oauth-app",
  request: request9 = request6.defaults({
    headers: {
      "user-agent": `octokit-auth-oauth-app.js/${VERSION20} ${getUserAgent()}`
    }
  }),
  onTokenCreated,
  ...strategyOptions
}) {
  const state2 = Object.assign({
    clientType,
    clientId,
    clientSecret,
    onTokenCreated,
    strategyOptions,
    request: request9
  });
  return Object.assign(auth3.bind(null, state2), {
    hook: hook3.bind(null, state2)
  });
}
createOAuthUserAuth.VERSION = VERSION20;

// node_modules/@octokit/auth-oauth-app/dist-bundle/index.js
async function auth4(state2, authOptions) {
  if (authOptions.type === "oauth-app") {
    return {
      type: "oauth-app",
      clientId: state2.clientId,
      clientSecret: state2.clientSecret,
      clientType: state2.clientType,
      headers: {
        authorization: `basic ${btoa(`${state2.clientId}:${state2.clientSecret}`)}`
      }
    };
  }
  if ("factory" in authOptions) {
    const { type: type3, ...options } = {
      ...authOptions,
      ...state2
    };
    return authOptions.factory(options);
  }
  const common4 = {
    clientId: state2.clientId,
    clientSecret: state2.clientSecret,
    request: state2.request,
    ...authOptions
  };
  const userAuth = state2.clientType === "oauth-app" ? await createOAuthUserAuth({
    ...common4,
    clientType: state2.clientType
  }) : await createOAuthUserAuth({
    ...common4,
    clientType: state2.clientType
  });
  return userAuth();
}
async function hook4(state2, request22, route, parameters2) {
  let endpoint7 = request22.endpoint.merge(route, parameters2);
  if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint7.url)) {
    return request22(endpoint7);
  }
  if (state2.clientType === "github-app" && !requiresBasicAuth(endpoint7.url)) {
    throw new Error(`[@octokit/auth-oauth-app] GitHub Apps cannot use their client ID/secret for basic authentication for endpoints other than "/applications/{client_id}/**". "${endpoint7.method} ${endpoint7.url}" is not supported.`);
  }
  const credentials = btoa(`${state2.clientId}:${state2.clientSecret}`);
  endpoint7.headers.authorization = `basic ${credentials}`;
  try {
    return await request22(endpoint7);
  } catch (error) {
    if (error.status !== 401)
      throw error;
    error.message = `[@octokit/auth-oauth-app] "${endpoint7.method} ${endpoint7.url}" does not support clientId/clientSecret basic authentication.`;
    throw error;
  }
}
var VERSION21 = "0.0.0-development";
function createOAuthAppAuth(options) {
  const state2 = Object.assign({
    request: request5.defaults({
      headers: {
        "user-agent": `octokit-auth-oauth-app.js/${VERSION21} ${getUserAgent()}`
      }
    }),
    clientType: "oauth-app"
  }, options);
  return Object.assign(auth4.bind(null, state2), {
    hook: hook4.bind(null, state2)
  });
}

// node_modules/universal-github-app-jwt/lib/utils.js
function isPkcs1(privateKey) {
  return privateKey.includes("-----BEGIN RSA PRIVATE KEY-----");
}
function isOpenSsh(privateKey) {
  return privateKey.includes("-----BEGIN OPENSSH PRIVATE KEY-----");
}
function string2ArrayBuffer(str) {
  const buf = new ArrayBuffer(str.length);
  const bufView = new Uint8Array(buf);
  for (let i2 = 0, strLen = str.length;i2 < strLen; i2++) {
    bufView[i2] = str.charCodeAt(i2);
  }
  return buf;
}
function getDERfromPEM(pem) {
  const pemB64 = pem.trim().split(`
`).slice(1, -1).join("");
  const decoded = atob(pemB64);
  return string2ArrayBuffer(decoded);
}
function getEncodedMessage(header, payload) {
  return `${base64encodeJSON(header)}.${base64encodeJSON(payload)}`;
}
function base64encode(buffer) {
  var binary = "";
  var bytes = new Uint8Array(buffer);
  var len = bytes.byteLength;
  for (var i2 = 0;i2 < len; i2++) {
    binary += String.fromCharCode(bytes[i2]);
  }
  return fromBase64(btoa(binary));
}
function fromBase64(base64) {
  return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64encodeJSON(obj) {
  return fromBase64(btoa(JSON.stringify(obj)));
}

// node_modules/universal-github-app-jwt/lib/crypto-node.js
import { subtle } from "node:crypto";
import { createPrivateKey } from "node:crypto";
function convertPrivateKey(privateKey) {
  if (!isPkcs1(privateKey))
    return privateKey;
  return createPrivateKey(privateKey).export({
    type: "pkcs8",
    format: "pem"
  });
}

// node_modules/universal-github-app-jwt/lib/get-token.js
async function getToken({ privateKey, payload }) {
  const convertedPrivateKey = convertPrivateKey(privateKey);
  if (isPkcs1(convertedPrivateKey)) {
    throw new Error("[universal-github-app-jwt] Private Key is in PKCS#1 format, but only PKCS#8 is supported. See https://github.com/gr2m/universal-github-app-jwt#private-key-formats");
  }
  if (isOpenSsh(convertedPrivateKey)) {
    throw new Error("[universal-github-app-jwt] Private Key is in OpenSSH format, but only PKCS#8 is supported. See https://github.com/gr2m/universal-github-app-jwt#private-key-formats");
  }
  const algorithm = {
    name: "RSASSA-PKCS1-v1_5",
    hash: { name: "SHA-256" }
  };
  const header = { alg: "RS256", typ: "JWT" };
  const privateKeyDER = getDERfromPEM(convertedPrivateKey);
  const importedKey = await subtle.importKey("pkcs8", privateKeyDER, algorithm, false, ["sign"]);
  const encodedMessage = getEncodedMessage(header, payload);
  const encodedMessageArrBuf = string2ArrayBuffer(encodedMessage);
  const signatureArrBuf = await subtle.sign(algorithm.name, importedKey, encodedMessageArrBuf);
  const encodedSignature = base64encode(signatureArrBuf);
  return `${encodedMessage}.${encodedSignature}`;
}

// node_modules/universal-github-app-jwt/index.js
async function githubAppJwt({
  id,
  privateKey,
  now = Math.floor(Date.now() / 1000)
}) {
  const privateKeyWithNewlines = privateKey.replace(/\\n/g, `
`);
  const nowWithSafetyMargin = now - 30;
  const expiration = nowWithSafetyMargin + 60 * 10;
  const payload = {
    iat: nowWithSafetyMargin,
    exp: expiration,
    iss: id
  };
  const token = await getToken({
    privateKey: privateKeyWithNewlines,
    payload
  });
  return {
    appId: id,
    expiration,
    token
  };
}

// node_modules/toad-cache/dist/toad-cache.mjs
class LruObject {
  constructor(max = 1000, ttlInMsecs = 0) {
    if (isNaN(max) || max < 0) {
      throw new Error("Invalid max value");
    }
    if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
      throw new Error("Invalid ttl value");
    }
    this.first = null;
    this.items = Object.create(null);
    this.last = null;
    this.size = 0;
    this.max = max;
    this.ttl = ttlInMsecs;
  }
  bumpLru(item) {
    if (this.last === item) {
      return;
    }
    const last = this.last;
    const next = item.next;
    const prev = item.prev;
    if (this.first === item) {
      this.first = next;
    }
    item.next = null;
    item.prev = last;
    last.next = item;
    if (prev !== null) {
      prev.next = next;
    }
    if (next !== null) {
      next.prev = prev;
    }
    this.last = item;
  }
  clear() {
    this.items = Object.create(null);
    this.first = null;
    this.last = null;
    this.size = 0;
  }
  delete(key) {
    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
      const item = this.items[key];
      delete this.items[key];
      this.size--;
      if (item.prev !== null) {
        item.prev.next = item.next;
      }
      if (item.next !== null) {
        item.next.prev = item.prev;
      }
      if (this.first === item) {
        this.first = item.next;
      }
      if (this.last === item) {
        this.last = item.prev;
      }
    }
  }
  deleteMany(keys) {
    for (var i2 = 0;i2 < keys.length; i2++) {
      this.delete(keys[i2]);
    }
  }
  evict() {
    if (this.size > 0) {
      const item = this.first;
      delete this.items[item.key];
      if (--this.size === 0) {
        this.first = null;
        this.last = null;
      } else {
        this.first = item.next;
        this.first.prev = null;
      }
    }
  }
  expiresAt(key) {
    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
      return this.items[key].expiry;
    }
  }
  get(key) {
    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
      const item = this.items[key];
      if (this.ttl > 0 && item.expiry <= Date.now()) {
        this.delete(key);
        return;
      }
      this.bumpLru(item);
      return item.value;
    }
  }
  getMany(keys) {
    const result = [];
    for (var i2 = 0;i2 < keys.length; i2++) {
      result.push(this.get(keys[i2]));
    }
    return result;
  }
  keys() {
    return Object.keys(this.items);
  }
  set(key, value) {
    if (Object.prototype.hasOwnProperty.call(this.items, key)) {
      const item2 = this.items[key];
      item2.value = value;
      item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
      if (this.last !== item2) {
        this.bumpLru(item2);
      }
      return;
    }
    if (this.max > 0 && this.size === this.max) {
      this.evict();
    }
    const item = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key,
      prev: this.last,
      next: null,
      value
    };
    this.items[key] = item;
    if (++this.size === 1) {
      this.first = item;
    } else {
      this.last.next = item;
    }
    this.last = item;
  }
}

// node_modules/@octokit/auth-app/dist-node/index.js
async function getAppAuthentication({
  appId,
  privateKey,
  timeDifference
}) {
  try {
    const authOptions = {
      id: appId,
      privateKey
    };
    if (timeDifference) {
      Object.assign(authOptions, {
        now: Math.floor(Date.now() / 1000) + timeDifference
      });
    }
    const appAuthentication = await githubAppJwt(authOptions);
    return {
      type: "app",
      token: appAuthentication.token,
      appId: appAuthentication.appId,
      expiresAt: new Date(appAuthentication.expiration * 1000).toISOString()
    };
  } catch (error) {
    if (privateKey === "-----BEGIN RSA PRIVATE KEY-----") {
      throw new Error("The 'privateKey` option contains only the first line '-----BEGIN RSA PRIVATE KEY-----'. If you are setting it using a `.env` file, make sure it is set on a single line with newlines replaced by '\n'");
    } else {
      throw error;
    }
  }
}
function getCache() {
  return new LruObject(15000, 1000 * 60 * 59);
}
async function get(cache, options) {
  const cacheKey = optionsToCacheKey(options);
  const result = await cache.get(cacheKey);
  if (!result) {
    return;
  }
  const [
    token,
    createdAt,
    expiresAt,
    repositorySelection,
    permissionsString,
    singleFileName
  ] = result.split("|");
  const permissions = options.permissions || permissionsString.split(/,/).reduce((permissions2, string) => {
    if (/!$/.test(string)) {
      permissions2[string.slice(0, -1)] = "write";
    } else {
      permissions2[string] = "read";
    }
    return permissions2;
  }, {});
  return {
    token,
    createdAt,
    expiresAt,
    permissions,
    repositoryIds: options.repositoryIds,
    repositoryNames: options.repositoryNames,
    singleFileName,
    repositorySelection
  };
}
async function set(cache, options, data) {
  const key = optionsToCacheKey(options);
  const permissionsString = options.permissions ? "" : Object.keys(data.permissions).map((name) => `${name}${data.permissions[name] === "write" ? "!" : ""}`).join(",");
  const value = [
    data.token,
    data.createdAt,
    data.expiresAt,
    data.repositorySelection,
    permissionsString,
    data.singleFileName
  ].join("|");
  await cache.set(key, value);
}
function optionsToCacheKey({
  installationId,
  permissions = {},
  repositoryIds = [],
  repositoryNames = []
}) {
  const permissionsString = Object.keys(permissions).sort().map((name) => permissions[name] === "read" ? name : `${name}!`).join(",");
  const repositoryIdsString = repositoryIds.sort().join(",");
  const repositoryNamesString = repositoryNames.join(",");
  return [
    installationId,
    repositoryIdsString,
    repositoryNamesString,
    permissionsString
  ].filter(Boolean).join("|");
}
function toTokenAuthentication({
  installationId,
  token,
  createdAt,
  expiresAt,
  repositorySelection,
  permissions,
  repositoryIds,
  repositoryNames,
  singleFileName
}) {
  return Object.assign({
    type: "token",
    tokenType: "installation",
    token,
    installationId,
    permissions,
    createdAt,
    expiresAt,
    repositorySelection
  }, repositoryIds ? { repositoryIds } : null, repositoryNames ? { repositoryNames } : null, singleFileName ? { singleFileName } : null);
}
async function getInstallationAuthentication(state2, options, customRequest) {
  const installationId = Number(options.installationId || state2.installationId);
  if (!installationId) {
    throw new Error("[@octokit/auth-app] installationId option is required for installation authentication.");
  }
  if (options.factory) {
    const { type: type3, factory, oauthApp, ...factoryAuthOptions } = {
      ...state2,
      ...options
    };
    return factory(factoryAuthOptions);
  }
  const request9 = customRequest || state2.request;
  return getInstallationAuthenticationConcurrently(state2, { ...options, installationId }, request9);
}
var pendingPromises = /* @__PURE__ */ new Map;
function getInstallationAuthenticationConcurrently(state2, options, request9) {
  const cacheKey = optionsToCacheKey(options);
  if (pendingPromises.has(cacheKey)) {
    return pendingPromises.get(cacheKey);
  }
  const promise = getInstallationAuthenticationImpl(state2, options, request9).finally(() => pendingPromises.delete(cacheKey));
  pendingPromises.set(cacheKey, promise);
  return promise;
}
async function getInstallationAuthenticationImpl(state2, options, request9) {
  if (!options.refresh) {
    const result = await get(state2.cache, options);
    if (result) {
      const {
        token: token2,
        createdAt: createdAt2,
        expiresAt: expiresAt2,
        permissions: permissions2,
        repositoryIds: repositoryIds2,
        repositoryNames: repositoryNames2,
        singleFileName: singleFileName2,
        repositorySelection: repositorySelection2
      } = result;
      return toTokenAuthentication({
        installationId: options.installationId,
        token: token2,
        createdAt: createdAt2,
        expiresAt: expiresAt2,
        permissions: permissions2,
        repositorySelection: repositorySelection2,
        repositoryIds: repositoryIds2,
        repositoryNames: repositoryNames2,
        singleFileName: singleFileName2
      });
    }
  }
  const appAuthentication = await getAppAuthentication(state2);
  const payload = {
    installation_id: options.installationId,
    mediaType: {
      previews: ["machine-man"]
    },
    headers: {
      authorization: `bearer ${appAuthentication.token}`
    }
  };
  if (options.repositoryIds) {
    Object.assign(payload, { repository_ids: options.repositoryIds });
  }
  if (options.repositoryNames) {
    Object.assign(payload, {
      repositories: options.repositoryNames
    });
  }
  if (options.permissions) {
    Object.assign(payload, { permissions: options.permissions });
  }
  const {
    data: {
      token,
      expires_at: expiresAt,
      repositories,
      permissions: permissionsOptional,
      repository_selection: repositorySelectionOptional,
      single_file: singleFileName
    }
  } = await request9("POST /app/installations/{installation_id}/access_tokens", payload);
  const permissions = permissionsOptional || {};
  const repositorySelection = repositorySelectionOptional || "all";
  const repositoryIds = repositories ? repositories.map((r2) => r2.id) : undefined;
  const repositoryNames = repositories ? repositories.map((repo) => repo.name) : undefined;
  const createdAt = (/* @__PURE__ */ new Date()).toISOString();
  const cacheOptions = {
    token,
    createdAt,
    expiresAt,
    repositorySelection,
    permissions,
    repositoryIds,
    repositoryNames
  };
  if (singleFileName) {
    Object.assign(payload, { singleFileName });
  }
  await set(state2.cache, options, cacheOptions);
  const cacheData = {
    installationId: options.installationId,
    token,
    createdAt,
    expiresAt,
    repositorySelection,
    permissions,
    repositoryIds,
    repositoryNames
  };
  if (singleFileName) {
    Object.assign(cacheData, { singleFileName });
  }
  return toTokenAuthentication(cacheData);
}
async function auth5(state2, authOptions) {
  switch (authOptions.type) {
    case "app":
      return getAppAuthentication(state2);
    case "oauth-app":
      return state2.oauthApp({ type: "oauth-app" });
    case "installation":
      return getInstallationAuthentication(state2, {
        ...authOptions,
        type: "installation"
      });
    case "oauth-user":
      return state2.oauthApp(authOptions);
    default:
      throw new Error(`Invalid auth type: ${authOptions.type}`);
  }
}
var PATHS = [
  "/app",
  "/app/hook/config",
  "/app/hook/deliveries",
  "/app/hook/deliveries/{delivery_id}",
  "/app/hook/deliveries/{delivery_id}/attempts",
  "/app/installations",
  "/app/installations/{installation_id}",
  "/app/installations/{installation_id}/access_tokens",
  "/app/installations/{installation_id}/suspended",
  "/app/installation-requests",
  "/marketplace_listing/accounts/{account_id}",
  "/marketplace_listing/plan",
  "/marketplace_listing/plans",
  "/marketplace_listing/plans/{plan_id}/accounts",
  "/marketplace_listing/stubbed/accounts/{account_id}",
  "/marketplace_listing/stubbed/plan",
  "/marketplace_listing/stubbed/plans",
  "/marketplace_listing/stubbed/plans/{plan_id}/accounts",
  "/orgs/{org}/installation",
  "/repos/{owner}/{repo}/installation",
  "/users/{username}/installation"
];
function routeMatcher(paths) {
  const regexes = paths.map((p2) => p2.split("/").map((c2) => c2.startsWith("{") ? "(?:.+?)" : c2).join("/"));
  const regex = `^(?:${regexes.map((r2) => `(?:${r2})`).join("|")})$`;
  return new RegExp(regex, "i");
}
var REGEX = routeMatcher(PATHS);
function requiresAppAuth(url) {
  return !!url && REGEX.test(url.split("?")[0]);
}
var FIVE_SECONDS_IN_MS = 5 * 1000;
function isNotTimeSkewError(error) {
  return !(error.message.match(/'Expiration time' claim \('exp'\) must be a numeric value representing the future time at which the assertion expires/) || error.message.match(/'Issued at' claim \('iat'\) must be an Integer representing the time that the assertion was issued/));
}
async function hook5(state2, request9, route, parameters2) {
  const endpoint7 = request9.endpoint.merge(route, parameters2);
  const url = endpoint7.url;
  if (/\/login\/oauth\/access_token$/.test(url)) {
    return request9(endpoint7);
  }
  if (requiresAppAuth(url.replace(request9.endpoint.DEFAULTS.baseUrl, ""))) {
    const { token: token2 } = await getAppAuthentication(state2);
    endpoint7.headers.authorization = `bearer ${token2}`;
    let response;
    try {
      response = await request9(endpoint7);
    } catch (error) {
      if (isNotTimeSkewError(error)) {
        throw error;
      }
      if (typeof error.response.headers.date === "undefined") {
        throw error;
      }
      const diff = Math.floor((Date.parse(error.response.headers.date) - Date.parse((/* @__PURE__ */ new Date()).toString())) / 1000);
      state2.log.warn(error.message);
      state2.log.warn(`[@octokit/auth-app] GitHub API time and system time are different by ${diff} seconds. Retrying request with the difference accounted for.`);
      const { token: token3 } = await getAppAuthentication({
        ...state2,
        timeDifference: diff
      });
      endpoint7.headers.authorization = `bearer ${token3}`;
      return request9(endpoint7);
    }
    return response;
  }
  if (requiresBasicAuth(url)) {
    const authentication = await state2.oauthApp({ type: "oauth-app" });
    endpoint7.headers.authorization = authentication.headers.authorization;
    return request9(endpoint7);
  }
  const { token, createdAt } = await getInstallationAuthentication(state2, {}, request9.defaults({ baseUrl: endpoint7.baseUrl }));
  endpoint7.headers.authorization = `token ${token}`;
  return sendRequestWithRetries(state2, request9, endpoint7, createdAt);
}
async function sendRequestWithRetries(state2, request9, options, createdAt, retries = 0) {
  const timeSinceTokenCreationInMs = +/* @__PURE__ */ new Date - +new Date(createdAt);
  try {
    return await request9(options);
  } catch (error) {
    if (error.status !== 401) {
      throw error;
    }
    if (timeSinceTokenCreationInMs >= FIVE_SECONDS_IN_MS) {
      if (retries > 0) {
        error.message = `After ${retries} retries within ${timeSinceTokenCreationInMs / 1000}s of creating the installation access token, the response remains 401. At this point, the cause may be an authentication problem or a system outage. Please check https://www.githubstatus.com for status information`;
      }
      throw error;
    }
    ++retries;
    const awaitTime = retries * 1000;
    state2.log.warn(`[@octokit/auth-app] Retrying after 401 response to account for token replication delay (retry: ${retries}, wait: ${awaitTime / 1000}s)`);
    await new Promise((resolve5) => setTimeout(resolve5, awaitTime));
    return sendRequestWithRetries(state2, request9, options, createdAt, retries);
  }
}
var VERSION22 = "7.2.1";
function createAppAuth(options) {
  if (!options.appId) {
    throw new Error("[@octokit/auth-app] appId option is required");
  }
  if (!options.privateKey) {
    throw new Error("[@octokit/auth-app] privateKey option is required");
  }
  if ("installationId" in options && !options.installationId) {
    throw new Error("[@octokit/auth-app] installationId is set to a falsy value");
  }
  const log2 = Object.assign({
    warn: console.warn.bind(console)
  }, options.log);
  const request9 = options.request || request4.defaults({
    headers: {
      "user-agent": `octokit-auth-app.js/${VERSION22} ${getUserAgent()}`
    }
  });
  const state2 = Object.assign({
    request: request9,
    cache: getCache()
  }, options, options.installationId ? { installationId: Number(options.installationId) } : {}, {
    log: log2,
    oauthApp: createOAuthAppAuth({
      clientType: "github-app",
      clientId: options.clientId || "",
      clientSecret: options.clientSecret || "",
      request: request9
    })
  });
  return Object.assign(auth5.bind(null, state2), {
    hook: hook5.bind(null, state2)
  });
}

// node_modules/@octokit/plugin-paginate-graphql/dist-bundle/index.js
var generateMessage = (path2, cursorValue) => `The cursor at "${path2.join(",")}" did not change its value "${cursorValue}" after a page transition. Please make sure your that your query is set up correctly.`;
var MissingCursorChange = class extends Error {
  constructor(pageInfo, cursorValue) {
    super(generateMessage(pageInfo.pathInQuery, cursorValue));
    this.pageInfo = pageInfo;
    this.cursorValue = cursorValue;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  name = "MissingCursorChangeError";
};
var MissingPageInfo = class extends Error {
  constructor(response) {
    super(`No pageInfo property found in response. Please make sure to specify the pageInfo in your query. Response-Data: ${JSON.stringify(response, null, 2)}`);
    this.response = response;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  name = "MissingPageInfo";
};
var isObject2 = (value) => Object.prototype.toString.call(value) === "[object Object]";
function findPaginatedResourcePath(responseData) {
  const paginatedResourcePath = deepFindPathToProperty(responseData, "pageInfo");
  if (paginatedResourcePath.length === 0) {
    throw new MissingPageInfo(responseData);
  }
  return paginatedResourcePath;
}
var deepFindPathToProperty = (object, searchProp, path2 = []) => {
  for (const key of Object.keys(object)) {
    const currentPath = [...path2, key];
    const currentValue = object[key];
    if (isObject2(currentValue)) {
      if (currentValue.hasOwnProperty(searchProp)) {
        return currentPath;
      }
      const result = deepFindPathToProperty(currentValue, searchProp, currentPath);
      if (result.length > 0) {
        return result;
      }
    }
  }
  return [];
};
var get2 = (object, path2) => {
  return path2.reduce((current, nextProperty) => current[nextProperty], object);
};
var set2 = (object, path2, mutator) => {
  const lastProperty = path2[path2.length - 1];
  const parentPath = [...path2].slice(0, -1);
  const parent = get2(object, parentPath);
  if (typeof mutator === "function") {
    parent[lastProperty] = mutator(parent[lastProperty]);
  } else {
    parent[lastProperty] = mutator;
  }
};
var extractPageInfos = (responseData) => {
  const pageInfoPath = findPaginatedResourcePath(responseData);
  return {
    pathInQuery: pageInfoPath,
    pageInfo: get2(responseData, [...pageInfoPath, "pageInfo"])
  };
};
var isForwardSearch = (givenPageInfo) => {
  return givenPageInfo.hasOwnProperty("hasNextPage");
};
var getCursorFrom = (pageInfo) => isForwardSearch(pageInfo) ? pageInfo.endCursor : pageInfo.startCursor;
var hasAnotherPage = (pageInfo) => isForwardSearch(pageInfo) ? pageInfo.hasNextPage : pageInfo.hasPreviousPage;
var createIterator = (octokit) => {
  return (query, initialParameters = {}) => {
    let nextPageExists = true;
    let parameters2 = { ...initialParameters };
    return {
      [Symbol.asyncIterator]: () => ({
        async next() {
          if (!nextPageExists)
            return { done: true, value: {} };
          const response = await octokit.graphql(query, parameters2);
          const pageInfoContext = extractPageInfos(response);
          const nextCursorValue = getCursorFrom(pageInfoContext.pageInfo);
          nextPageExists = hasAnotherPage(pageInfoContext.pageInfo);
          if (nextPageExists && nextCursorValue === parameters2.cursor) {
            throw new MissingCursorChange(pageInfoContext, nextCursorValue);
          }
          parameters2 = {
            ...parameters2,
            cursor: nextCursorValue
          };
          return { done: false, value: response };
        }
      })
    };
  };
};
var mergeResponses = (response1, response2) => {
  if (Object.keys(response1).length === 0) {
    return Object.assign(response1, response2);
  }
  const path2 = findPaginatedResourcePath(response1);
  const nodesPath = [...path2, "nodes"];
  const newNodes = get2(response2, nodesPath);
  if (newNodes) {
    set2(response1, nodesPath, (values) => {
      return [...values, ...newNodes];
    });
  }
  const edgesPath = [...path2, "edges"];
  const newEdges = get2(response2, edgesPath);
  if (newEdges) {
    set2(response1, edgesPath, (values) => {
      return [...values, ...newEdges];
    });
  }
  const pageInfoPath = [...path2, "pageInfo"];
  set2(response1, pageInfoPath, get2(response2, pageInfoPath));
  return response1;
};
var createPaginate = (octokit) => {
  const iterator2 = createIterator(octokit);
  return async (query, initialParameters = {}) => {
    let mergedResponse = {};
    for await (const response of iterator2(query, initialParameters)) {
      mergedResponse = mergeResponses(mergedResponse, response);
    }
    return mergedResponse;
  };
};
function paginateGraphQL(octokit) {
  return {
    graphql: Object.assign(octokit.graphql, {
      paginate: Object.assign(createPaginate(octokit), {
        iterator: createIterator(octokit)
      })
    })
  };
}

// src/util/octokit.ts
var OctokitWithPlugins = Octokit2.plugin(paginateGraphQL);
var octokitInstance;
function initOctokit() {
  let instance;
  const secrets = getGitHubSecrets();
  if (secrets.kind === "pat" || secrets.kind === "default") {
    const { token } = secrets;
    instance = new OctokitWithPlugins({
      auth: token
    });
  } else if (secrets.kind === "app") {
    const { appId, privateKey } = secrets;
    instance = new OctokitWithPlugins({
      authStrategy: createAppAuth,
      auth: {
        appId,
        privateKey
      }
    });
  } else {
    throw new Error("Unknown authentication method");
  }
  return instance;
}
async function getToken2() {
  const octokit = getOctokit();
  const secrets = getGitHubSecrets();
  if (secrets.kind === "pat" || secrets.kind === "default") {
    const { token } = secrets;
    return {
      value: token,
      kind: secrets.kind
    };
  } else if (secrets.kind === "app") {
    let installationId = secrets.installationId;
    if (installationId === undefined) {
      const { data: installation } = await octokit.apps.getOrgInstallation({
        org: import_github2.context.repo.owner
      });
      installationId = installation.id;
    }
    const { data: token } = await octokit.apps.createInstallationAccessToken({
      installation_id: installationId
    });
    return { value: token.token, kind: "app" };
  }
  throw new Error("Unknown authentication method");
}
function getOctokit() {
  if (!octokitInstance) {
    octokitInstance = initOctokit();
  }
  return octokitInstance;
}

// src/3_transform/ai/cache.ts
var import_cache = __toESM(require_cache3(), 1);
import fs2 from "fs";
import path2 from "path";
var ACTIONS_CACHE_KEY = "summary-cache";
var ACTIONS_CACHE_FILE = "./cache/summary-cache.json";

class SummaryCache {
  static instance;
  static getInstance() {
    if (!SummaryCache.instance) {
      SummaryCache.instance = new SummaryCache;
    }
    return SummaryCache.instance;
  }
  cache;
  constructor() {
    this.cache = new Map;
  }
  static getPromptCacheKey(prompt, sources) {
    return JSON.stringify({
      name: prompt.name,
      prompt: prompt.messages,
      sources: sources.sort()
    });
  }
  get(prompt, sources) {
    const cacheKey = SummaryCache.getPromptCacheKey(prompt, sources);
    return this.cache.get(cacheKey);
  }
  set(prompt, sources, summary) {
    const cacheKey = SummaryCache.getPromptCacheKey(prompt, sources);
    this.cache.set(cacheKey, summary);
  }
  save() {
    const file = path2.resolve(ACTIONS_CACHE_FILE);
    const dir = path2.dirname(file);
    if (!fs2.existsSync(dir)) {
      fs2.mkdirSync(dir, { recursive: true });
    }
    console.log(`Saving summary cache to ${file}`);
    const entries = Array.from(this.cache.entries());
    const blob = JSON.stringify(entries, null, 2);
    fs2.writeFileSync(file, blob, "utf-8");
    if (process.env.GITHUB_ACTIONS === "true") {
      import_cache.saveCache([file], ACTIONS_CACHE_KEY);
    }
  }
  load() {
    const file = path2.resolve(ACTIONS_CACHE_FILE);
    if (!fs2.existsSync(file)) {
      return;
    }
    if (process.env.GITHUB_ACTIONS === "true") {
      const restored = import_cache.restoreCache([file], ACTIONS_CACHE_KEY);
      if (!restored) {
        console.warn(`No cache hit for ${file}. Using empty cache.`);
        return;
      }
    }
    console.log(`Loading summary cache from ${file}`);
    const blob = fs2.readFileSync(file, "utf-8");
    const entries = JSON.parse(blob);
    this.cache = new Map(entries);
  }
  clear() {
    this.cache.clear();
  }
  sources() {
    return Array.from(this.cache.keys()).sort();
  }
}

// src/3_transform/ai/hydration.ts
var import_lodash = __toESM(require_lodash(), 1);
function insertPlaceholders(params, placeholders) {
  params = import_lodash.cloneDeep(params);
  for (const [key, value] of Object.entries(placeholders)) {
    const placeholder = `{{\\s*${key}\\s*}}`;
    const regex = new RegExp(placeholder, "gi");
    params.messages.forEach((msg) => {
      msg.content = msg.content.replace(regex, value);
    });
  }
  return params;
}

// node_modules/@dqbd/tiktoken/tiktoken.cjs
var __dirname = "/Users/amymanny/Code/rollup-n-up-n-up/node_modules/@dqbd/tiktoken";
var wasm = require_tiktoken_bg();
var imports = {};
imports["./tiktoken_bg.js"] = wasm;
var path3 = __require("path");
var fs3 = __require("fs");
var candidates = __dirname.split(path3.sep).reduce((memo, _2, index, array) => {
  const prefix = array.slice(0, index + 1).join(path3.sep) + path3.sep;
  if (!prefix.includes("node_modules" + path3.sep)) {
    memo.unshift(path3.join(prefix, "node_modules", "tiktoken", "", "./tiktoken_bg.wasm"));
  }
  return memo;
}, []);
candidates.unshift(path3.join(__dirname, "./tiktoken_bg.wasm"));
var bytes = null;
for (const candidate of candidates) {
  try {
    bytes = fs3.readFileSync(candidate);
    break;
  } catch {
  }
}
if (bytes == null)
  throw new Error("Missing tiktoken_bg.wasm");
var wasmModule = new WebAssembly.Module(bytes);
var wasmInstance = new WebAssembly.Instance(wasmModule, imports);
wasm.__wbg_set_wasm(wasmInstance.exports);
var $get_encoding = wasm["get_encoding"];
var $encoding_for_model = wasm["encoding_for_model"];
var $Tiktoken = wasm["Tiktoken"];

// src/3_transform/ai/tokens.ts
function getEncoding(githubModelName) {
  const modelName = githubModelName.split("/").pop();
  if (!modelName) {
    return;
  }
  try {
    return $encoding_for_model(modelName);
  } catch (error) {
    console.error(`Failed to count tokens for model ${githubModelName}`, error);
  }
}
function countTokens(githubModelName, messages) {
  const encoding = getEncoding(githubModelName);
  if (!encoding)
    return;
  const totalTokens = messages.reduce((sum, msg) => {
    return sum + encoding.encode(msg.content).length;
  }, 0);
  return totalTokens;
}
function truncate(githubModelName, messages, maxTokens) {
  const encoding = getEncoding(githubModelName);
  if (!encoding)
    return;
  const userMessage = messages.find((msg) => msg.role === "user");
  if (!userMessage)
    return;
  const rest = messages.filter((msg) => msg.role !== "user");
  const usedTokens = countTokens(githubModelName, rest);
  const remainingTokens = maxTokens - usedTokens;
  const userMessageTokens = encoding.encode(userMessage.content);
  const userMessageIndex = messages.indexOf(userMessage);
  if (userMessageTokens.length > remainingTokens) {
    messages[userMessageIndex].content = new TextDecoder().decode(encoding.decode(userMessageTokens.slice(0, remainingTokens)));
  }
}

// src/3_transform/ai/summarize.ts
async function runPrompt(params) {
  const { messages, model: model2, modelParameters } = {
    messages: params.messages,
    model: params.model,
    modelParameters: params.modelParameters || {}
  };
  if (!messages.find((msg) => msg.role === "user")) {
    throw new Error("No user message found in the prompt.");
  }
  if (model2.startsWith("xai/")) {
    throw new Error("xai models are not supported");
  }
  const truncateTokens = getConfig("TRUNCATE_TOKENS");
  if (truncateTokens !== undefined) {
    truncate(model2, messages, Number(truncateTokens));
  }
  const totalTokens = countTokens(model2, messages);
  if (totalTokens !== undefined) {
    console.log("Total tokens used:", totalTokens);
  }
  const token = await getToken2();
  const endpoint7 = getModelEndpoint(token.kind);
  try {
    const client = esm_default(endpoint7, new AzureKeyCredential(token.value), {
      apiVersion: "2024-12-01-preview",
      userAgentOptions: { userAgentPrefix: "github-actions-rollup-n-up-n-up" }
    });
    const response = await client.path("/chat/completions").post({
      body: {
        ...modelParameters,
        model: model2,
        messages
      }
    });
    if (isUnexpected(response)) {
      if (response.body.error) {
        throw response.body.error;
      }
      throw new Error(`An error occurred while fetching the response (${response.status}) ${response.body}`);
    }
    const modelResponse = response.body.choices[0].message.content;
    if (!modelResponse) {
      throw new Error("No response from model.");
    } else if (modelResponse.startsWith("ERROR:")) {
      throw new Error(modelResponse);
    }
    return modelResponse;
  } catch (error) {
    throw new Error(`Unexpected Error: ${JSON.stringify(error)}`);
  }
}
async function generateSummary(params) {
  let { content, prompt } = params;
  if (typeof prompt === "string") {
    if (!prompt || prompt.trim() === "") {
      throw new Error("prompt cannot be empty.");
    }
    prompt = loadPromptFile(prompt);
  }
  if (typeof content === "string") {
    content = [{ content, source: content }];
  }
  const summaryCache = SummaryCache.getInstance();
  const cachedResponse = summaryCache.get(prompt, content.map((item) => item.source));
  if (cachedResponse) {
    console.log("Using cached response for prompt:", prompt.name);
    return cachedResponse;
  }
  const input = content.map((item) => item.content).join(`

`);
  const summary = await runPrompt(insertPlaceholders(prompt, {
    input,
    content: input,
    query: params.query || ""
  }));
  summaryCache.set(prompt, content.map((item) => item.source), summary);
  return summary;
}

// src/util/string.ts
var splitMarkdownByRegex = (markdown, regex) => {
  const sections = new Map;
  let match;
  let lastHeader = null;
  let lastIndex = 0;
  while ((match = regex.exec(markdown)) !== null) {
    if (lastHeader !== null) {
      sections.set(lastHeader, markdown.slice(lastIndex, match.index).trim());
    }
    lastHeader = toSnakeCase(match[1].trim());
    lastIndex = match.index + match[0].length;
  }
  if (lastHeader !== null) {
    sections.set(lastHeader, markdown.slice(lastIndex).trim());
  }
  return sections;
};
var splitMarkdownByHeaders = (markdown) => {
  return splitMarkdownByRegex(markdown, /^#+\s+(.*)$/gm);
};
var splitMarkdownByBoldedText = (markdown) => {
  return splitMarkdownByRegex(markdown, /\*\*(.*?)\*\*/g);
};
var stripHtml = (s2) => {
  return s2.replace(/<script[\s\S]*?<\/script>|<style[\s\S]*?<\/style>|<.*?>|<!--[\s\S]*?-->/g, "");
};
var toSnakeCase = (str) => {
  return str.replace(/[^a-zA-Z0-9\s]/g, "").trim().replace(/([a-z])([A-Z])/g, "$1_$2").replace(/\s+/g, "_").toLowerCase();
};
var title = (s2) => {
  return s2.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
};

// src/4_template/filters.ts
function accessible(markdown) {
  const colorMap = {
    "\uD83D\uDD34": "red",
    "\uD83D\uDFE5": "red",
    "\uD83D\uDFE0": "orange",
    "\uD83D\uDFE7": "orange",
    "\uD83D\uDFE1": "yellow",
    "\uD83D\uDFE8": "yellow",
    "\uD83D\uDFE2": "green",
    "\uD83D\uDFE9": "green",
    "\uD83D\uDD35": "blue",
    "\uD83D\uDFE6": "blue",
    "\uD83D\uDFE3": "purple",
    "\uD83D\uDFEA": "purple",
    "\uD83D\uDFE4": "brown",
    "": "white",
    "": "white",
    "": "black",
    "": "black"
  };
  const emojiRegex = new RegExp(Object.keys(colorMap).join("|"), "g");
  markdown = markdown.replace(emojiRegex, (emoji) => `${emoji} (${colorMap[emoji]})`);
  return markdown;
}
function stripHeaders(markdown) {
  return markdown.replace(/^(#{1,6})\s+(.*)$/gm, (match, hashes, headerText) => `**${headerText}**`).trim();
}
function stripFormatting(markdown) {
  return markdown.replace(/[#*_~`>]/g, "").replace(/!\[.*?\]\(.*?\)/g, "").replace(/\[.*?\]\(.*?\)/g, "").replace(/[-+*]\s+/g, "").replace(/[\s]+/g, " ").trim();
}
async function summarize(markdown, promptFilePath) {
  return await generateSummary({
    prompt: promptFilePath,
    content: markdown
  });
}
async function summarizeToSentence(markdown) {
  if (!markdown.trim().includes(`
`)) {
    return markdown.trim();
  }
  return await generateSummary({
    prompt: {
      model: "openai/gpt-4.1-mini",
      messages: [
        {
          role: "system",
          content: "Summarize the following content into a single sentence. Try to sacrifice as little meaning as possible."
        },
        { role: "user", content: markdown }
      ]
    },
    content: markdown
  });
}

// src/4_template/plugins/index.ts
var exports_plugins = {};
__export(exports_plugins, {
  hoist: () => hoist_default
});

// src/4_template/plugins/hoist.ts
function hoist_default() {
  return (env) => {
    env.tags.push(mark);
    env.tags.push(hoist);
  };
}
function formatMarker(val) {
  return `"__MARK_${val}"`;
}
function mark(env, code, outputVar, tokens) {
  if (!code.startsWith("mark ")) {
    return;
  }
  const markerName = code.replace(/^mark\s+/, "");
  const marker = env.compileFilters(tokens, formatMarker(markerName), env.options.autoescape);
  return `${outputVar} += ${marker};`;
}
function hoist(env, code, outputVar, tokens) {
  if (!code.startsWith("hoist ")) {
    return;
  }
  const match = code.match(/^hoist\s+([\w]+)\s*=\s*([\s\S]+)$/);
  if (!match) {
    throw new Error(`Invalid hoist tag: ${code}`);
  }
  const [, markerName, variable] = match;
  const marker = env.compileFilters(tokens, formatMarker(markerName), env.options.autoescape);
  const val = env.compileFilters(tokens, variable, env.options.autoescape);
  return `${outputVar} = ${outputVar}.replace(${marker}, ${val});`;
}

// src/util/collections.ts
class DefaultDict extends Map {
  defaultFn;
  constructor(defaultFn) {
    super();
    this.defaultFn = defaultFn;
  }
  get(key) {
    if (this.has(key)) {
      return super.get(key);
    }
    const val = this.defaultFn(key);
    this.set(key, val);
    return val;
  }
}

// src/3_transform/memory.ts
class Memory {
  static instance;
  static getInstance() {
    if (!Memory.instance) {
      Memory.instance = new Memory;
    }
    return Memory.instance;
  }
  banks;
  constructor() {
    this.banks = new DefaultDict(() => []);
  }
  remember(item, memoryBank = 0) {
    if (item.content.trim() === "") {
      return;
    }
    const bank = this.banks.get(memoryBank);
    if (bank.includes(item)) {
      return;
    }
    bank.push(item);
  }
  getBank(memoryBank = 0) {
    const bank = this.banks.get(memoryBank);
    return bank.slice();
  }
  async summarize(promptFilePath, memoryBank = 0) {
    const content = this.getBank(memoryBank);
    if (content.length === 0) {
      return "No content in memory to summarize.";
    }
    return await generateSummary({ content, prompt: promptFilePath });
  }
  async query(promptFilePath, query, memoryBank = 0) {
    const content = this.getBank(memoryBank);
    if (content.length === 0) {
      return "No content in memory to summarize.";
    }
    return await generateSummary({ content, prompt: promptFilePath, query });
  }
  headbonk(memoryBank) {
    if (memoryBank === undefined) {
      this.banks.clear();
    } else if (this.banks.has(memoryBank)) {
      this.banks.delete(memoryBank);
    }
  }
}

// src/2_pull/github/graphql/index.ts
var ISSUE_PAGE_SIZE = 50;
var NUM_ISSUE_COMMENTS = 25;
var NUM_ISSUE_LABELS = 100;
var NUM_ISSUE_ASSIGNESS = 5;

// src/2_pull/github/graphql/project.ts
var slugifyProjectFieldName = (field) => {
  return field.toLowerCase().replace(/\s+/g, "-");
};
async function listIssuesForProject(params) {
  const octokit = getOctokit();
  const query = `
    query paginate($organization: String!, $projectNumber: Int!, $cursor: String) {
      organization(login: $organization) {
        projectV2(number: $projectNumber) {
          title
          items(first: ${ISSUE_PAGE_SIZE}, after: $cursor) {
            edges {
              node {
                id
                content {
                  __typename
                  ... on Issue {
                    title
                    body
                    url
                    number
                    state
                    createdAt
                    updatedAt
                    issueType {
                      name
                    }
                    repository {
                      name
                      owner {
                        login
                      }
                      nameWithOwner
                    }
                    assignees(first: ${NUM_ISSUE_ASSIGNESS}) {
                      nodes {
                        login
                      }
                    }
                    labels(first: ${NUM_ISSUE_LABELS}) {
                      nodes {
                        name
                      }
                    }
                    comments(last: ${NUM_ISSUE_COMMENTS}) {
                      nodes {
                        author {
                          login
                        }
                        body
                        createdAt
                        url
                      }
                    }
                  }
                }
                fieldValues(first: 100) {
                  edges {
                    node {
                      __typename
                      ... on ProjectV2ItemFieldSingleSelectValue {
                        name
                        field {
                          ... on ProjectV2SingleSelectField {
                            name
                            options {
                              name
                            }
                          }
                        }
                      }
                      ... on ProjectV2ItemFieldDateValue {
                        date
                        field {
                          ... on ProjectV2Field {
                            name
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            pageInfo {
              endCursor
              hasNextPage
            }
          }
        }
      }
    }
  `;
  const response = await octokit.graphql.paginate(query, {
    organization: params.organization,
    projectNumber: params.projectNumber
  });
  const issues = response.organization.projectV2.items.edges.map((edge) => {
    const content = edge.node.content;
    if (!content || content.__typename !== "Issue") {
      return null;
    }
    return {
      title: content.title,
      body: content.body || "",
      url: content.url,
      number: content.number,
      state: content.state,
      createdAt: new Date(content.createdAt),
      updatedAt: new Date(content.updatedAt),
      type: content.issueType?.name || "Issue",
      repository: {
        name: content.repository.name,
        owner: content.repository.owner.login,
        nameWithOwner: content.repository.nameWithOwner
      },
      assignees: content.assignees.nodes.map((assignee) => assignee.login),
      labels: content.labels.nodes.map((label) => label.name),
      comments: content.comments.nodes.map((comment) => ({
        author: comment.author?.login || "Unknown",
        body: comment.body,
        createdAt: new Date(comment.createdAt),
        url: comment.url
      })),
      isSubissue: false,
      project: {
        number: params.projectNumber,
        fields: edge.node.fieldValues.edges.reduce((acc, fieldEdge) => {
          const fieldNode = fieldEdge.node;
          if (fieldNode && fieldNode.field) {
            let field;
            switch (fieldNode.__typename) {
              case "ProjectV2ItemFieldSingleSelectValue":
                field = {
                  kind: "SingleSelect",
                  value: fieldNode.name,
                  options: fieldNode.field.options.map((option) => option.name)
                };
                break;
              case "ProjectV2ItemFieldDateValue": {
                const date = fieldNode.date;
                field = {
                  kind: "Date",
                  value: date,
                  date: date ? new Date(date) : null
                };
                break;
              }
              default:
                return acc;
            }
            const fieldName = slugifyProjectFieldName(fieldNode.field.name);
            acc.set(fieldName, field);
          }
          return acc;
        }, new Map)
      }
    };
  }).filter((item) => item !== null).filter((item) => {
    return params.typeFilter === undefined || params.typeFilter.length === 0 || params.typeFilter.includes(item.type);
  });
  return {
    issues,
    title: response.organization.projectV2.title,
    url: `https://github.com/orgs/${params.organization}/projects/${params.projectNumber}`
  };
}

// src/util/date.ts
var ONE_DAY = 86400000;

// src/util/emoji.ts
var EMOJI_PRIORITY = [
  "\uD83D\uDD34",
  "\uD83D\uDFE5",
  "\uD83D\uDFE0",
  "\uD83D\uDFE7",
  "\uD83D\uDFE1",
  "\uD83D\uDFE8",
  "\uD83D\uDFE2",
  "\uD83D\uDFE9",
  "\uD83D\uDD35",
  "\uD83D\uDFE6",
  "\uD83D\uDFE3",
  "\uD83D\uDFEA",
  "\uD83D\uDFE4",
  "\uD83D\uDFEB",
  "",
  "",
  "",
  ""
];
function emojiCompare(a2, b2) {
  for (const emoji of EMOJI_PRIORITY) {
    if (a2.includes(emoji) && !b2.includes(emoji)) {
      return -1;
    }
    if (!a2.includes(emoji) && b2.includes(emoji)) {
      return 1;
    }
  }
  return;
}
function extractEmoji(text) {
  for (const emoji of EMOJI_PRIORITY) {
    if (text.includes(emoji)) {
      return emoji;
    }
  }
  return;
}

// node_modules/mimic-function/index.js
var copyProperty = (to, from, property, ignoreNonConfigurable) => {
  if (property === "length" || property === "prototype") {
    return;
  }
  if (property === "arguments" || property === "caller") {
    return;
  }
  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
    return;
  }
  Object.defineProperty(to, property, fromDescriptor);
};
var canCopyProperty = function(toDescriptor, fromDescriptor) {
  return toDescriptor === undefined || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
var changePrototype = (to, from) => {
  const fromPrototype = Object.getPrototypeOf(from);
  if (fromPrototype === Object.getPrototypeOf(to)) {
    return;
  }
  Object.setPrototypeOf(to, fromPrototype);
};
var wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
var toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
var toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
var changeToString = (to, from, name) => {
  const withName = name === "" ? "" : `with ${name.trim()}() `;
  const newToString = wrappedToString.bind(null, withName, from.toString());
  Object.defineProperty(newToString, "name", toStringName);
  const { writable, enumerable, configurable } = toStringDescriptor;
  Object.defineProperty(to, "toString", { value: newToString, writable, enumerable, configurable });
};
function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
  const { name } = to;
  for (const property of Reflect.ownKeys(from)) {
    copyProperty(to, from, property, ignoreNonConfigurable);
  }
  changePrototype(to, from);
  changeToString(to, from, name);
  return to;
}

// node_modules/memoize/distribution/index.js
var cacheStore = new WeakMap;
var cacheTimerStore = new WeakMap;
function memoize(function_, { cacheKey, cache = new Map, maxAge } = {}) {
  if (maxAge === 0) {
    return function_;
  }
  if (typeof maxAge === "number") {
    const maxSetIntervalValue = 2147483647;
    if (maxAge > maxSetIntervalValue) {
      throw new TypeError(`The \`maxAge\` option cannot exceed ${maxSetIntervalValue}.`);
    }
    if (maxAge < 0) {
      throw new TypeError("The `maxAge` option should not be a negative number.");
    }
  }
  const memoized = function(...arguments_) {
    const key = cacheKey ? cacheKey(arguments_) : arguments_[0];
    const cacheItem = cache.get(key);
    if (cacheItem) {
      return cacheItem.data;
    }
    const result = function_.apply(this, arguments_);
    const computedMaxAge = typeof maxAge === "function" ? maxAge(...arguments_) : maxAge;
    cache.set(key, {
      data: result,
      maxAge: computedMaxAge ? Date.now() + computedMaxAge : Number.POSITIVE_INFINITY
    });
    if (computedMaxAge && computedMaxAge > 0 && computedMaxAge !== Number.POSITIVE_INFINITY) {
      const timer = setTimeout(() => {
        cache.delete(key);
      }, computedMaxAge);
      timer.unref?.();
      const timers = cacheTimerStore.get(function_) ?? new Set;
      timers.add(timer);
      cacheTimerStore.set(function_, timers);
    }
    return result;
  };
  mimicFunction(memoized, function_, {
    ignoreNonConfigurable: true
  });
  cacheStore.set(memoized, cache);
  return memoized;
}

// src/2_pull/github/update.ts
function findLatestUpdates(comments, n2 = 1) {
  if (comments.length === 0) {
    return;
  }
  const updates = comments.filter((comment) => comment.isUpdate);
  if (updates.length > 0) {
    return updates.slice(0, n2);
  }
  const updateDetection = UpdateDetection.getInstance();
  for (const strategy of updateDetection.strategies) {
    switch (strategy.kind) {
      case "skip":
      case "blame":
        return;
      case "fail": {
        const issue = comments[0].issue;
        throw new Error(`No valid update found for issue ${issue.title} - ${issue.url}!`);
      }
    }
  }
  return comments.slice(0, n2);
}
function extractUpdate(comment) {
  const updateDetection = UpdateDetection.getInstance();
  for (const strategy of updateDetection.strategies) {
    const update2 = memoizedExtractUpdateWithStrategy(comment, strategy);
    if (update2 !== undefined) {
      return update2;
    }
  }
  return comment._body;
}
function extractUpdateWithStrategy(comment, strategy) {
  if (comment.isEmpty) {
    return;
  }
  if ("timeframe" in strategy) {
    const { timeframe } = strategy;
    if (timeframe && !comment.isWithinTimeframe(timeframe)) {
      return;
    }
  }
  switch (strategy.kind) {
    case "timebox": {
      return comment._body;
    }
    case "marker": {
      const { marker } = strategy;
      if (comment.hasMarker(marker)) {
        return comment._body;
      }
      break;
    }
    case "section": {
      const { section: sectionName } = strategy;
      const section = comment.section(sectionName);
      if (section !== undefined && section.trim() !== "") {
        return section;
      }
      break;
    }
  }
  return;
}
var memoizedExtractUpdateWithStrategy = memoize(extractUpdateWithStrategy, {
  cacheKey: ([comment, strategy]) => comment.url + JSON.stringify(strategy)
});

// src/2_pull/github/comment.ts
class CommentWrapper {
  memory = Memory.getInstance();
  static NULL_UPDATE = "No updates found";
  comment;
  issue;
  sections;
  boldedSections;
  constructor(issue, comment) {
    this.issue = issue;
    this.comment = comment;
    this.sections = splitMarkdownByHeaders(comment.body);
    this.boldedSections = splitMarkdownByBoldedText(comment.body);
  }
  static empty(issue) {
    return new CommentWrapper(issue, {
      author: "",
      body: CommentWrapper.NULL_UPDATE,
      createdAt: new Date(0),
      url: issue.url
    });
  }
  get header() {
    return `[${this.issue.title}](${this.url})`;
  }
  get url() {
    return this.comment.url;
  }
  get _body() {
    return stripHtml(this.comment.body).trim();
  }
  get body() {
    this.remember();
    return this._body;
  }
  get update() {
    this.remember();
    return extractUpdate(this);
  }
  get isEmpty() {
    return this.comment.body.trim() === "" || this.comment.body === CommentWrapper.NULL_UPDATE;
  }
  get isUpdate() {
    return !this.isEmpty && this.update !== undefined;
  }
  get author() {
    return this.comment.author;
  }
  get createdAt() {
    return this.comment.createdAt;
  }
  get wasPostedToday() {
    return new Date().getTime() - this.createdAt.getTime() < ONE_DAY;
  }
  get wasPostedThisWeek() {
    return new Date().getTime() - this.createdAt.getTime() < 7 * ONE_DAY;
  }
  get wasPostedThisMonth() {
    return new Date().getTime() - this.createdAt.getTime() < 31 * ONE_DAY;
  }
  get wasPostedThisYear() {
    return new Date().getTime() - this.createdAt.getTime() < 365 * ONE_DAY;
  }
  hasMarker(marker) {
    return marker.test(this.comment.body);
  }
  section(name) {
    name = toSnakeCase(name);
    const section = this.sections.get(name);
    if (section !== undefined) {
      return stripHtml(section).trim();
    }
    const boldedSection = this.boldedSections.get(name);
    if (boldedSection !== undefined) {
      return stripHtml(boldedSection).trim();
    }
    return;
  }
  isWithinTimeframe(timeframe) {
    switch (timeframe) {
      case "all-time":
        return true;
      case "today":
        return this.wasPostedToday;
      case "last-week":
        return this.wasPostedThisWeek;
      case "last-month":
        return this.wasPostedThisMonth;
      case "last-year":
        return this.wasPostedThisYear;
      default:
        throw new Error(`Invalid timeframe for comment filtering: "${timeframe}".`);
    }
  }
  emojiStatus(sections) {
    if (this.isEmpty) {
      return;
    }
    if (sections) {
      for (const sectionName of sections) {
        const section = this.section(sectionName);
        if (section) {
          const emoji = extractEmoji(section);
          if (emoji)
            return emoji;
        }
      }
    }
    return extractEmoji(this.comment.body);
  }
  get rendered() {
    return `#### Comment on ${this.issue.type}: ${this.header}

${this._body}

`;
  }
  remember() {
    this.memory.remember({ content: this.rendered, source: this.url });
  }
  render() {
    this.remember();
    return this.rendered;
  }
}

// src/2_pull/github/project-view.ts
var import_github4 = __toESM(require_github(), 1);
class ProjectView {
  params;
  filters;
  excludeFilters;
  constructor(params) {
    this.params = params;
    this.filters = new DefaultDict(() => []);
    this.excludeFilters = new DefaultDict(() => []);
    const matches = params.filterQuery.match(/(?:[^\s"]+|"[^"]*")+/g);
    if (!matches) {
      return;
    }
    matches.forEach((f2) => {
      const [key, valueStr] = f2.split(":").map((s2) => s2.trim());
      if (!key || !valueStr) {
        return;
      }
      const values = valueStr.split(",").map((v2) => {
        if (v2.startsWith('"') && v2.endsWith('"')) {
          v2 = v2.slice(1, -1);
        }
        return v2.trim();
      }).map((v2) => {
        if (v2 === "@me") {
          return import_github4.context.actor;
        }
        if (v2.startsWith("@today")) {
          const today = new Date;
          const rest = v2.split("@today-")[1]?.trim();
          let days = 0;
          if (rest) {
            if (rest.endsWith("d")) {
              days = parseInt(rest.slice(0, -1), 10);
            }
            if (rest.endsWith("w")) {
              const weeks = parseInt(rest.slice(0, -1), 10);
              days = weeks * 7;
            }
            if (rest.endsWith("m")) {
              const months = parseInt(rest.slice(0, -1), 10);
              days = months * 30;
            }
            if (rest.endsWith("y")) {
              const years = parseInt(rest.slice(0, -1), 10);
              days = years * 365;
            }
          }
          const date = new Date;
          date.setDate(today.getDate() - days);
          return date.toISOString().split("T")[0];
        }
        return v2;
      });
      if (key.startsWith("-")) {
        const eKey = key.slice(1);
        this.excludeFilters.get(eKey).push(...values);
      } else {
        this.filters.get(key).push(...values);
      }
    });
  }
  get name() {
    return this.params.name;
  }
  get number() {
    return this.params.number;
  }
  get filterQuery() {
    return this.params.filterQuery;
  }
  get customFields() {
    const defaultFields = ProjectView.defaultFields();
    return Array.from([
      ...this.filters.keys(),
      ...this.excludeFilters.keys()
    ]).filter((key) => {
      return !defaultFields.includes(key);
    });
  }
  getFilterType() {
    return this.filters.get("type");
  }
  filter(issue) {
    if (!this.checkCreated(issue.createdAt)) {
      return false;
    }
    if (!this.checkUpdated(issue.updatedAt)) {
      return false;
    }
    if (!this.checkType(issue.type)) {
      return false;
    }
    if (!this.checkRepo(issue.repoNameWithOwner)) {
      return false;
    }
    if (!this.checkAssignees(issue.assignees)) {
      return false;
    }
    for (const field of this.customFields) {
      const value = issue._projectFields.get(field);
      if (!this.checkField(field, value)) {
        return false;
      }
    }
    return true;
  }
  checkField(fieldName, field) {
    let values = [];
    if (!field) {
      values = [];
    } else if (field.kind === "SingleSelect") {
      values = field.value ? [field.value] : [];
    } else if (field.kind === "MultiSelect") {
      values = field.values ?? [];
    } else if (field.kind === "Date") {
      return this.checkDateField(fieldName, field.date);
    }
    const included = this.filters.get(fieldName);
    const excluded = this.excludeFilters.get(fieldName);
    if (values.some((value) => excluded.some((f2) => f2 === value))) {
      return false;
    }
    if (included.length === 0) {
      return true;
    }
    return values.some((value) => included.some((f2) => f2 === value));
  }
  checkDateField(field, date) {
    const filter = this.filters.get(field);
    if (!filter) {
      return true;
    } else if (date === null) {
      return false;
    }
    const dateString = date.toISOString().split("T")[0];
    for (const condition of filter) {
      if (condition.startsWith(">=")) {
        const targetDate = condition.slice(2).trim();
        if (dateString < targetDate) {
          return false;
        }
      } else if (condition.startsWith("<=")) {
        const targetDate = condition.slice(2).trim();
        if (dateString > targetDate) {
          return false;
        }
      } else if (condition.startsWith("=")) {
        const targetDate = condition.slice(1).trim();
        if (dateString !== targetDate) {
          return false;
        }
      }
    }
    return true;
  }
  checkCreated(createdAt) {
    return this.checkDateField("created", createdAt);
  }
  checkUpdated(updatedAt) {
    return this.checkDateField("updated", updatedAt);
  }
  checkType(type3) {
    return this.checkField("type", {
      kind: "SingleSelect",
      value: type3
    });
  }
  checkOpen(is) {
    return this.checkField("is", {
      kind: "SingleSelect",
      value: is
    });
  }
  checkRepo(repo) {
    return this.checkField("repo", {
      kind: "SingleSelect",
      value: repo ?? null
    });
  }
  checkAssignees(assignees) {
    return this.checkField("assignee", {
      kind: "MultiSelect",
      values: assignees
    });
  }
  static defaultFields() {
    return [
      "created",
      "updated",
      "repository",
      "assignee",
      "label",
      "is",
      "title",
      "linked-pull-requests",
      "milestone",
      "type",
      "reviewers",
      "parent-issue",
      "sub-issues-progress",
      "no",
      "has"
    ];
  }
}
async function getProjectView(params) {
  const octokit = getOctokit();
  const query = `
    query($organization: String!, $projectNumber: Int!, $projectViewNumber: Int!) {
      organization(login: $organization) {
        projectV2(number: $projectNumber) {
          view(number: $projectViewNumber) {
            name
            filter
          }
        }
      }
    }
  `;
  const response = await octokit.graphql(query, {
    organization: params.organization,
    projectNumber: params.projectNumber,
    projectViewNumber: params.projectViewNumber
  });
  return new ProjectView({
    name: response.organization.projectV2.view.name,
    number: params.projectViewNumber,
    filterQuery: response.organization.projectV2.view.filter
  });
}

// src/2_pull/github/graphql/repo.ts
async function listIssuesForRepo(params) {
  const octokit = getOctokit();
  const state2 = params.state?.trim().toUpperCase() || "OPEN";
  let states;
  switch (state2) {
    case "OPEN":
    case "CLOSED":
      states = [state2];
      break;
    case "ALL":
      states = ["OPEN", "CLOSED"];
      break;
    default:
      throw new Error(`Unknown IssueState: ${state2}. Choose OPEN, CLOSED, or ALL.`);
  }
  const query = `
    query paginate($owner: String!, $repo: String!, $states: [IssueState!], $cursor: String) {
      repositoryOwner(login: $owner) {
        repository(name: $repo) {
          issues(first: ${ISSUE_PAGE_SIZE}, states: $states, after: $cursor) {
            nodes {
              title
              body
              url
              number
              state
              createdAt
              updatedAt
              issueType {
                name
              }
              repository {
                name
                owner {
                  login
                }
                nameWithOwner
              }
              assignees(first: ${NUM_ISSUE_ASSIGNESS}) {
                nodes {
                  login
                }
              }
              labels(first: ${NUM_ISSUE_LABELS}) {
                nodes {
                  name
                }
              }
              comments(last: ${NUM_ISSUE_COMMENTS}) {
                nodes {
                  author {
                    login
                  }
                  body
                  createdAt
                  url
                }
              }
            }
            pageInfo {
              endCursor
              hasNextPage
            }
          }
        }
      }
    }
  `;
  const response = await octokit.graphql.paginate(query, {
    owner: params.owner,
    repo: params.repo,
    states
  });
  const issues = response.repositoryOwner.repository.issues.nodes.map((issue) => ({
    title: issue.title,
    body: issue.body,
    url: issue.url,
    number: issue.number,
    state: issue.state,
    createdAt: new Date(issue.createdAt),
    updatedAt: new Date(issue.updatedAt),
    type: issue.issueType?.name || "Issue",
    repository: {
      name: issue.repository.name,
      owner: issue.repository.owner.login,
      nameWithOwner: issue.repository.nameWithOwner
    },
    assignees: issue.assignees.nodes.map((assignee) => assignee.login),
    labels: issue.labels.nodes.map((label) => label.name),
    comments: issue.comments.nodes.map((comment) => ({
      author: comment.author?.login || "Unknown",
      body: comment.body,
      createdAt: new Date(comment.createdAt),
      url: comment.url
    })),
    isSubissue: false
  }));
  return {
    issues,
    title: `Issues for ${params.owner}/${params.repo}`,
    url: `https://github.com/${params.owner}/${params.repo}`
  };
}

// src/2_pull/github/graphql/subissues.ts
async function listSubissuesForIssue(params) {
  const octokit = getOctokit();
  const query = `
    query paginate($owner: String!, $repo: String!, $issueNumber: Int!, $cursor: String) {
      repositoryOwner(login: $owner) {
        repository(name: $repo) {
          issue(number: $issueNumber) {
            title
            url
            subIssues(first: ${ISSUE_PAGE_SIZE}, after: $cursor) {
              nodes {
                title
                body
                url
                number
                state
                createdAt
                updatedAt
                issueType {
                  name
                }
                repository {
                  name
                  owner {
                    login
                  }
                  nameWithOwner
                }
                assignees(first: ${NUM_ISSUE_ASSIGNESS}) {
                  nodes {
                    login
                  }
                }
                labels(first: ${NUM_ISSUE_LABELS}) {
                  nodes {
                    name
                  }
                }
                comments(last: ${NUM_ISSUE_COMMENTS}) {
                  nodes {
                    author {
                      login
                    }
                    body
                    createdAt
                    url
                  }
                }
              }
              pageInfo {
                hasNextPage
                endCursor
              }
            }
          }
        }
      }
    }
  `;
  const response = await octokit.graphql.paginate(query, params);
  const subissues = response.repositoryOwner.repository.issue.subIssues.nodes.map((subIssue) => ({
    title: subIssue.title,
    body: subIssue.body,
    url: subIssue.url,
    number: subIssue.number,
    state: subIssue.state,
    createdAt: new Date(subIssue.createdAt),
    updatedAt: new Date(subIssue.updatedAt),
    type: subIssue.issueType?.name || "Issue",
    repository: {
      name: subIssue.repository.name,
      owner: subIssue.repository.owner.login,
      nameWithOwner: subIssue.repository.nameWithOwner
    },
    assignees: subIssue.assignees.nodes.map((assignee) => assignee.login),
    labels: subIssue.labels.nodes.map((label) => label.name),
    comments: subIssue.comments.nodes.map((comment) => ({
      author: comment.author?.login || "Unknown",
      body: comment.body,
      createdAt: new Date(comment.createdAt),
      url: comment.url
    })),
    isSubissue: true
  }));
  const issueTitle = response.repositoryOwner.repository.issue.title;
  return {
    subissues,
    title: `Subissues for ${issueTitle} (#${params.issueNumber})`,
    url: response.repositoryOwner.repository.issue.url
  };
}

// src/2_pull/github/issue-list.ts
class IssueList {
  memory = Memory.getInstance();
  sourceOfTruth;
  issues;
  get length() {
    return this.issues.length;
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  [Symbol.iterator]() {
    return this.issues[Symbol.iterator]();
  }
  find(predicate) {
    return this.issues.find(predicate);
  }
  filter(predicate) {
    const filteredIssues = this.issues.filter(predicate);
    return new IssueList(filteredIssues, this.sourceOfTruth);
  }
  get header() {
    return `[${this.sourceOfTruth.title}](${this.sourceOfTruth.url})`;
  }
  get title() {
    return this.sourceOfTruth.title;
  }
  get url() {
    return this.sourceOfTruth.url;
  }
  get groupKey() {
    if (!this.sourceOfTruth.groupKey) {
      throw new Error("Don't use groupKey without a groupBy.");
    }
    return this.sourceOfTruth.groupKey;
  }
  applyViewFilter(view) {
    this.issues = this.issues.filter((issue) => view.filter(issue));
    if (view.number) {
      this.sourceOfTruth.url += `/views/${view.number}`;
    } else {
      this.sourceOfTruth.url += `?filterQuery=${encodeURIComponent(view.filterQuery)}`;
    }
    if (view.name) {
      this.sourceOfTruth.title += ` (${view.name})`;
    }
  }
  sort(fieldName, direction = "asc") {
    this.issues.sort((a2, b2) => {
      const aValue = a2.field(fieldName);
      const bValue = b2.field(fieldName);
      const comparison = emojiCompare(aValue, bValue) ?? aValue.localeCompare(bValue, undefined, { sensitivity: "base" });
      return direction === "asc" ? comparison : -comparison;
    });
    return this;
  }
  groupBy(fieldName) {
    const groups = new Map;
    for (const issue of this.issues) {
      const key = issue.field(fieldName);
      if (!groups.has(key)) {
        groups.set(key, new IssueList([], {
          title: this.sourceOfTruth.title,
          url: this.sourceOfTruth.url,
          groupKey: key || "No " + title(fieldName)
        }));
      }
      groups.get(key).issues.push(issue);
    }
    return Array.from(groups.entries()).sort(([a2], [b2]) => emojiCompare(a2, b2) ?? a2.localeCompare(b2)).map(([, group]) => group);
  }
  overallStatus(fieldName) {
    return this.issues.map((issue) => issue.field(fieldName) ?? "").sort((a2, b2) => emojiCompare(a2, b2) ?? a2.localeCompare(b2))[0];
  }
  get hasUpdates() {
    return this.issues.some((issue) => issue.hasUpdate);
  }
  get blame() {
    const issuesWithNoUpdate = this.issues.filter((issue) => !issue.hasUpdate);
    return new IssueList(issuesWithNoUpdate, {
      title: `${this.sourceOfTruth.title} - Missing Updates`,
      url: this.sourceOfTruth.url
    });
  }
  constructor(issues, sourceOfTruth) {
    this.sourceOfTruth = sourceOfTruth;
    this.issues = issues;
  }
  static async forRepo(params) {
    const response = await listIssuesForRepo(params);
    const { issues, title: title2, url } = response;
    return new IssueList(issues.map((issue) => new IssueWrapper(issue)), { title: title2, url });
  }
  static async forSubissues(params) {
    const response = await listSubissuesForIssue(params);
    const { subissues, title: title2, url } = response;
    return new IssueList(subissues.map((issue) => new IssueWrapper(issue)), { title: title2, url });
  }
  static async forProject(params) {
    const response = await listIssuesForProject(params);
    const { issues, title: title2, url } = response;
    return new IssueList(issues.map((issue) => new IssueWrapper(issue)), { title: title2, url });
  }
  static async forProjectView(params) {
    let view;
    if (params.projectViewNumber === undefined) {
      if (params.customQuery === undefined) {
        throw new Error("Either projectViewNumber or customQuery must be provided.");
      }
      view = new ProjectView({ filterQuery: params.customQuery });
    } else {
      view = await getProjectView(params);
    }
    const issueList = await this.forProject({
      organization: params.organization,
      projectNumber: params.projectNumber,
      typeFilter: view.getFilterType()
    });
    issueList.applyViewFilter(view);
    return issueList;
  }
  get rendered() {
    return `## ${this.header}

${this.issues.map((issue) => issue.rendered).join(`

`)}`;
  }
  remember() {
    this.memory.remember({ content: this.rendered, source: this.url });
  }
  render() {
    this.remember();
    return this.rendered;
  }
}

// src/2_pull/github/graphql/issue.ts
async function getIssue(params) {
  const octokit = getOctokit();
  const query = `
    query ($organization: String!, $repo: String!, $issueNumber: Int!) {
      organization(login: $organization) {
        repository(name: $repo) {
          issue(number: $issueNumber) {
            title
            body
            url
            number
            state
            createdAt
            updatedAt
            issueType {
              name
            }
            repository {
              name
              owner {
                login
              }
              nameWithOwner
            }
            assignees(first: ${NUM_ISSUE_ASSIGNESS}) {
              nodes {
                login
              }
            }
            labels(first: ${NUM_ISSUE_LABELS}) {
              nodes {
                name
              }
            }
            comments(last: ${NUM_ISSUE_COMMENTS}) {
              nodes {
                author {
                  login
                }
                body
                createdAt
                url
              }
            }
          }
        }
      }
    }
  `;
  const response = await octokit.graphql(query, {
    organization: params.owner,
    repo: params.repo,
    issueNumber: params.issueNumber
  });
  const issue = response.organization.repository.issue;
  return {
    title: issue.title,
    body: issue.body,
    url: issue.url,
    number: issue.number,
    state: issue.state,
    createdAt: new Date(issue.createdAt),
    updatedAt: new Date(issue.updatedAt),
    type: issue.issueType?.name || "Issue",
    repository: {
      name: issue.repository.name,
      owner: issue.repository.owner.login,
      nameWithOwner: issue.repository.nameWithOwner
    },
    assignees: issue.assignees.nodes.map((assignee) => assignee.login),
    labels: issue.labels.nodes.map((label) => label.name),
    comments: issue.comments.nodes.map((comment) => ({
      author: comment.author?.login || "Unknown",
      body: comment.body,
      createdAt: new Date(comment.createdAt),
      url: comment.url
    })),
    isSubissue: false
  };
}

// src/2_pull/github/issue.ts
class IssueWrapper {
  memory = Memory.getInstance();
  issue;
  constructor(issue) {
    this.issue = issue;
  }
  static async forIssue(params) {
    const issue = await getIssue(params);
    return new IssueWrapper(issue);
  }
  get header() {
    return `[${this.title}](${this.url})`;
  }
  get title() {
    return this.issue.title.trim();
  }
  get _body() {
    return this.issue.body || "";
  }
  get body() {
    this.remember();
    return this._body;
  }
  get url() {
    return this.issue.url;
  }
  get number() {
    return this.issue.number;
  }
  get isOpen() {
    return this.issue.state === "OPEN";
  }
  get createdAt() {
    return this.issue.createdAt;
  }
  get updatedAt() {
    return this.issue.updatedAt;
  }
  get type() {
    return this.issue.type;
  }
  get repo() {
    return this.issue.repository.name;
  }
  get owner() {
    return this.issue.repository.owner;
  }
  get repoNameWithOwner() {
    return this.issue.repository.nameWithOwner;
  }
  get assignees() {
    return this.issue.assignees.map((assignee) => assignee.trim());
  }
  get labels() {
    return this.issue.labels.map((label) => label.trim());
  }
  field(fieldName) {
    const insensitiveFieldName = fieldName.trim().toUpperCase().replace(/\s+/g, "").replace("_", "");
    switch (insensitiveFieldName) {
      case "TITLE":
        return this.title;
      case "URL":
        return this.url;
      case "NUMBER":
        return String(this.number);
      case "BODY":
        return this.body;
      case "TYPE":
        return this.type;
      case "REPO":
      case "REPOSITORY":
        return this.repo;
      case "ORG":
      case "ORGANIZATION":
      case "OWNER":
        return this.owner;
      case "FULLNAME":
      case "NAMEWITHOWNER":
      case "REPONAMEWITHOWNER":
        return this.repoNameWithOwner ?? "";
    }
    return this.projectFields.get(slugifyProjectFieldName(fieldName)) || "";
  }
  get projectNumber() {
    return this.issue.project?.number;
  }
  get _projectFields() {
    return this.issue.project?.fields ?? new Map;
  }
  get projectFields() {
    return new Map(Array.from(this._projectFields.entries()).map(([name, field]) => {
      switch (field.kind) {
        case "SingleSelect":
        case "Date":
          return [name, field.value ?? ""];
        case "MultiSelect":
          return [name, (field.values || []).join(", ")];
      }
    }));
  }
  status(fieldName) {
    const emojiOverride = getConfig("EMOJI_OVERRIDE");
    if (emojiOverride) {
      const update2 = this.latestUpdate;
      let emojiSections;
      if (isTrueValue(emojiOverride)) {
        emojiSections = [];
      } else {
        emojiSections = emojiOverride.split(",").map((s2) => s2.trim());
      }
      const emoji = update2.emojiStatus(emojiSections);
      if (emoji) {
        const field = this._projectFields.get(fieldName);
        if (field && field.kind === "SingleSelect") {
          for (const option of field?.options || []) {
            if (option.includes(emoji)) {
              return option;
            }
          }
        } else {
          return emoji;
        }
      }
    }
    const value = this.field(fieldName);
    if (!value) {
      return "No Status";
    }
    return value;
  }
  async subissues() {
    return IssueList.forSubissues({
      owner: this.owner,
      repo: this.repo,
      issueNumber: this.number
    });
  }
  get comments() {
    const sortCommentsByDateDesc = (a2, b2) => {
      return b2.createdAt.getTime() - a2.createdAt.getTime();
    };
    return this.issue.comments.map((comment) => new CommentWrapper(this, comment)).sort(sortCommentsByDateDesc);
  }
  get latestComment() {
    const comments = this.comments;
    if (comments.length !== 0) {
      return comments[0];
    }
    return CommentWrapper.empty(this);
  }
  latestComments(n2) {
    const comments = this.comments;
    if (comments.length !== 0) {
      return comments.slice(0, n2);
    }
    return [CommentWrapper.empty(this)];
  }
  get latestUpdate() {
    const updates = findLatestUpdates(this.comments);
    if (updates !== undefined) {
      return updates[0];
    }
    return CommentWrapper.empty(this);
  }
  latestUpdates(n2) {
    const updates = findLatestUpdates(this.comments, n2);
    if (updates !== undefined) {
      return updates;
    }
    return [CommentWrapper.empty(this)];
  }
  get hasUpdate() {
    return !this.latestUpdate.isEmpty;
  }
  get rendered() {
    const rendered = `### ${this.type}: ${this.header}

${this._body}

`;
    const update2 = this.latestUpdate;
    if (update2.isEmpty) {
      return rendered;
    }
    return `${rendered}

${update2.rendered}`;
  }
  remember() {
    this.memory.remember({ content: this.rendered, source: this.url });
  }
  render() {
    this.remember();
    return this.rendered;
  }
}

// src/2_pull/github/client.ts
class GitHubClient {
  octokit = getOctokit();
  url(url) {
    const urlParts = new URL(url);
    let match;
    if (urlParts.hostname !== "github.com") {
      throw new Error(`Unsupported hostname: ${urlParts.hostname}. Please provide a valid GitHub URL.`);
    }
    match = urlParts.pathname.match(/\/([^/]+)\/([^/]+)\/issues\/(\d+)/);
    if (match) {
      const owner = match[1];
      const repo = match[2];
      const issueNumber = parseInt(match[3], 10);
      return this.issue(owner, repo, issueNumber);
    }
    match = urlParts.pathname.match(/\/([^/]+)\/([^/]+)\/issues/);
    if (match) {
      const owner = match[1];
      const repo = match[2];
      return this.issuesForRepo(owner, repo);
    }
    match = urlParts.pathname.match(/orgs\/([^/]+)\/projects\/(\d+)(?:\/views\/(\d+))?/);
    if (match) {
      const organization = match[1];
      const projectNumber = parseInt(match[2], 10);
      const projectViewNumber = parseInt(match[3], 10) || null;
      const customQuery = urlParts.searchParams.get("filterQuery");
      if (customQuery) {
        return this.issuesForProjectQuery(organization, projectNumber, customQuery);
      }
      if (projectViewNumber) {
        return this.issuesForProjectView(organization, projectNumber, projectViewNumber);
      }
      return this.issuesForProject(organization, projectNumber);
    }
    throw new Error(`Unsupported URL: ${url}. Please provide a valid GitHub issues URL.`);
  }
  issue(owner, repo, issueNumber) {
    return IssueWrapper.forIssue({ owner, repo, issueNumber });
  }
  issuesForRepo(owner, repo) {
    return IssueList.forRepo({ owner, repo });
  }
  subissuesForIssue(owner, repo, issueNumber) {
    return IssueList.forSubissues({
      owner,
      repo,
      issueNumber
    });
  }
  issuesForProject(organization, projectNumber, typeFilter) {
    if (typeof typeFilter === "string") {
      typeFilter = [typeFilter];
    }
    return IssueList.forProject({
      organization,
      projectNumber,
      typeFilter
    });
  }
  issuesForProjectView(organization, projectNumber, projectViewNumber) {
    return IssueList.forProjectView({
      organization,
      projectNumber,
      projectViewNumber
    });
  }
  issuesForProjectQuery(organization, projectNumber, customQuery) {
    return IssueList.forProjectView({
      organization,
      projectNumber,
      customQuery
    });
  }
}

// src/4_template/debug.ts
function formatDetails(summary, dropdown) {
  return `<details><summary>${summary}</summary>

\`\`\`
${dropdown}
\`\`\`

</details>`;
}
function debugTemplate(template) {
  return formatDetails("Expand to view the full rollup-n-up-n-up template!", template.source);
}
function debugMemory(memoryBank) {
  return formatDetails("Expand to view the context passed into the inference model!", Memory.getInstance().getBank(memoryBank).map((item) => item.content).join(`

`));
}
function debugSources() {
  const sources = SummaryCache.getInstance().sources();
  const sourcesBulletList = sources.map((source) => `- ${source}`).join(`
`);
  return formatDetails("Expand to view the sources used in the inference model!", sourcesBulletList);
}

// src/4_template/render.ts
var templatesDir = path4.join(process.cwd(), "templates");
var env = mod_default({
  dataVarname: "global",
  autoDataVarname: true,
  includes: templatesDir,
  autoescape: true
});
for (const filter of Object.values(exports_filters)) {
  env.filters[filter.name] = filter;
}
for (const plugin of Object.values(exports_plugins)) {
  env.use(plugin());
}
var summaryCache = SummaryCache.getInstance();
summaryCache.load();
var github2 = new GitHubClient;
var memory = Memory.getInstance();
var today = new Date().toISOString().split("T")[0];
var globals = { github: github2, memory, today };
async function renderTemplate(templatePath) {
  const template = await env.load(templatePath);
  const result = await template({
    ...globals,
    getConfig: (config) => getConfig(config),
    debugTemplate: () => debugTemplate(template),
    debugSources: () => debugSources(),
    debugMemory: (memoryBank = 0) => debugMemory(memoryBank)
  });
  memory.headbonk();
  summaryCache.save();
  console.info(result.content);
  return result.content;
}

// src/1_trigger/action-render.ts
var template = getConfig("TEMPLATE") || "main.md.vto";
var md = await renderTemplate(template);
import_core3.setOutput("md", md);
import_core3.summary.addRaw(`
${md}`, true).write();
